
================================================================================
FILE: frontend/ios/ios/ContentView.swift
================================================================================

//
//  ContentView.swift
//  ios
//
//  Created by Hai Phan on 12/30/25.
//

import SwiftUI

struct ContentView: View {
    @State private var selectedTab: HomeTab = .home
    @State private var researchTickerSymbol: String? = nil

    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            Group {
                switch selectedTab {
                case .home:
                    HomeViewWithBinding(selectedTab: $selectedTab)
                case .updates:
                    UpdatesView(selectedTab: $selectedTab)
                case .research:
                    ResearchViewWithBinding(
                        selectedTab: $selectedTab,
                        prefilledTicker: researchTickerSymbol
                    )
                case .tracking:
                    TrackingViewWithBinding(
                        selectedTab: $selectedTab,
                        researchTickerSymbol: $researchTickerSymbol
                    )
                case .wiser:
                    WiserViewWithBinding(selectedTab: $selectedTab)
                }
            }
        }
        .preferredColorScheme(.dark)
        .onChange(of: selectedTab) { oldValue, newValue in
            // Clear the research ticker when leaving research tab
            if oldValue == .research && newValue != .research {
                researchTickerSymbol = nil
            }
        }
    }
}

// MARK: - HomeView with Binding Support
struct HomeViewWithBinding: View {
    @StateObject private var viewModel = HomeViewModel()
    @Binding var selectedTab: HomeTab
    @State private var showSearch = false
    @State private var selectedNewsArticle: NewsArticle?

    var body: some View {
        ZStack(alignment: .bottom) {
            AppColors.background
                .ignoresSafeArea()

            VStack(spacing: 0) {
                HomeHeader(
                    onProfileTapped: {},
                    onSearchTapped: {
                        showSearch = true
                    }
                )

                ScrollView(showsIndicators: false) {
                    VStack(spacing: AppSpacing.xl) {
                        MarketTickersRow(tickers: viewModel.marketTickers)
                            .padding(.top, AppSpacing.sm)

                        if let insight = viewModel.marketInsight {
                            MarketInsightsCard(insight: insight) {
                                selectedTab = .updates
                            }
                            .padding(.horizontal, AppSpacing.lg)
                        }

                        DailyBriefingSection(
                            items: viewModel.dailyBriefings,
                            onItemTapped: handleBriefingItemTapped
                        )

                        RecentResearchSection(
                            reports: viewModel.recentResearch,
                            onSeeAllTapped: { selectedTab = .research },
                            onReportTapped: { _ in },
                            onAskOrReadTapped: { _ in }
                        )

                        NewAnalysisButton {
                            selectedTab = .research
                        }

                        Spacer()
                            .frame(height: 100)
                    }
                }
                .refreshable {
                    await viewModel.refresh()
                }

                CustomTabBar(selectedTab: $selectedTab)
            }

            if viewModel.isLoading {
                LoadingOverlay()
            }
        }
        .sheet(isPresented: $showSearch) {
            SearchView()
        }
        .fullScreenCover(item: $selectedNewsArticle) { article in
            NewsDetailView(article: article)
                .preferredColorScheme(.dark)
        }
    }

    // MARK: - Action Handlers
    private func handleBriefingItemTapped(_ item: DailyBriefingItem) {
        // Convert DailyBriefingItem to NewsArticle for navigation
        selectedNewsArticle = NewsArticle(
            headline: item.title,
            summary: item.subtitle,
            source: NewsSource(name: "Market Alert", iconName: nil),
            sentiment: .neutral,
            publishedAt: item.date ?? Date(),
            thumbnailName: nil,
            relatedTickers: []
        )
    }
}

// MARK: - ResearchView with Binding Support
struct ResearchViewWithBinding: View {
    @StateObject private var viewModel: ResearchViewModel
    @Binding var selectedTab: HomeTab
    let prefilledTicker: String?
    @State private var selectedReportTicker: ReportTickerNavigation?

    init(selectedTab: Binding<HomeTab>, prefilledTicker: String? = nil) {
        self._selectedTab = selectedTab
        self.prefilledTicker = prefilledTicker
        self._viewModel = StateObject(wrappedValue: ResearchViewModel(prefilledTicker: prefilledTicker))
    }

    var body: some View {
        ZStack(alignment: .bottom) {
            AppColors.background
                .ignoresSafeArea()

            VStack(spacing: 0) {
                // Main Content
                if viewModel.selectedTab == .research {
                    researchTabContent
                } else {
                    reportsTabContent
                }

                CustomTabBar(selectedTab: $selectedTab)
            }

            if viewModel.isLoading {
                LoadingOverlay()
            }
        }
        .fullScreenCover(item: $selectedReportTicker) { nav in
            NavigationStack {
                TickerReportView(ticker: nav.ticker)
            }
            .preferredColorScheme(.dark)
        }
    }

    // MARK: - Research Tab Content
    private var researchTabContent: some View {
        ScrollView(showsIndicators: false) {
            LazyVStack(spacing: AppSpacing.xxl) {
                // Header
                ResearchHeader(
                    selectedTab: $viewModel.selectedTab,
                    onProfileTapped: handleProfileTapped
                )

                // Target Selection Section
                TargetSelectionSection(
                    searchText: $viewModel.searchText,
                    quickTickers: viewModel.quickTickers,
                    onTickerSelected: handleTickerSelected,
                    onSearchSubmit: handleSearchSubmit
                )
                .padding(.top, AppSpacing.sm)

                // Persona Selection Section
                PersonaSelectionSection(
                    personas: viewModel.personas,
                    selectedPersona: $viewModel.selectedPersona,
                    onViewAllTapped: handleViewAllPersonas
                )

                // Generate Analysis Section
                GenerateAnalysisSection(
                    cost: viewModel.analysisCost,
                    remainingCredits: viewModel.creditBalance.credits,
                    isEnabled: viewModel.canGenerateAnalysis,
                    isLoading: viewModel.isGeneratingAnalysis,
                    onGenerate: handleGenerateAnalysis
                )

                // What You'll Get Section
                WhatYouGetSection(features: viewModel.features)

                // Credits Balance Card
                CreditsBalanceCard(
                    balance: viewModel.creditBalance,
                    onAddCredits: handleAddCredits
                )
                .padding(.horizontal, AppSpacing.lg)

                // Trending Analyses Section
                TrendingAnalysesSection(
                    analyses: viewModel.trendingAnalyses,
                    onExploreTapped: handleExploreTrending,
                    onAnalysisTapped: handleTrendingAnalysisTapped
                )

                // Bottom padding for tab bar
                Spacer()
                    .frame(height: AppSpacing.xxxl)
            }
        }
        .refreshable {
            await viewModel.refresh()
        }
    }

    // MARK: - Reports Tab Content
    private var reportsTabContent: some View {
        ScrollView(showsIndicators: false) {
            LazyVStack(spacing: AppSpacing.xxl) {
                // Header
                ResearchHeader(
                    selectedTab: $viewModel.selectedTab,
                    onProfileTapped: handleProfileTapped
                )

                // Reports List Section
                ReportsListSection(
                    reports: viewModel.reports,
                    sortOption: $viewModel.reportSortOption,
                    onReportTapped: handleReportTapped,
                    onRetryTapped: handleRetryTapped
                )
                .padding(.top, AppSpacing.sm)

                // Community Insights Section
                CommunityInsightsSection(
                    insights: viewModel.communityInsights,
                    onJoinDiscussion: handleJoinDiscussion,
                    onLike: handleLikeInsight,
                    onComment: handleCommentInsight,
                    onShare: handleShareInsight
                )

                // Bottom padding for tab bar
                Spacer()
                    .frame(height: AppSpacing.xxxl)
            }
        }
        .refreshable {
            await viewModel.refresh()
        }
    }

    // MARK: - Action Handlers
    private func handleProfileTapped() {
        print("Profile tapped")
    }

    private func handleTickerSelected(_ ticker: QuickTicker) {
        viewModel.selectQuickTicker(ticker)
    }

    private func handleSearchSubmit() {
        print("Search submitted: \(viewModel.searchText)")
    }

    private func handleViewAllPersonas() {
        viewModel.viewAllPersonas()
    }

    private func handleGenerateAnalysis() {
        viewModel.generateAnalysis()
    }

    private func handleAddCredits() {
        viewModel.addMoreCredits()
    }

    private func handleExploreTrending() {
        viewModel.exploreTrending()
    }

    private func handleTrendingAnalysisTapped(_ analysis: TrendingAnalysis) {
        viewModel.selectTrendingAnalysis(analysis)
    }

    private func handleReportTapped(_ report: AnalysisReport) {
        guard report.status == .ready else {
            viewModel.openReport(report)
            return
        }
        selectedReportTicker = ReportTickerNavigation(ticker: report.ticker)
    }

    private func handleRetryTapped(_ report: AnalysisReport) {
        viewModel.retryReport(report)
    }

    private func handleJoinDiscussion() {
        viewModel.joinDiscussion()
    }

    private func handleLikeInsight(_ insight: CommunityInsight) {
        viewModel.likeInsight(insight)
    }

    private func handleCommentInsight(_ insight: CommunityInsight) {
        viewModel.commentOnInsight(insight)
    }

    private func handleShareInsight(_ insight: CommunityInsight) {
        viewModel.shareInsight(insight)
    }
}

// MARK: - TrackingView with Binding Support
struct TrackingViewWithBinding: View {
    @Binding var selectedTab: HomeTab
    @Binding var researchTickerSymbol: String?

    var body: some View {
        ZStack(alignment: .bottom) {
            AppColors.background
                .ignoresSafeArea()

            VStack(spacing: 0) {
                TrackingContentViewWithBinding(
                    selectedTab: $selectedTab,
                    researchTickerSymbol: $researchTickerSymbol
                )

                CustomTabBar(selectedTab: $selectedTab)
            }
        }
    }
}

// MARK: - WiserView with Binding Support (Learn)
struct WiserViewWithBinding: View {
    @Binding var selectedTab: HomeTab

    var body: some View {
        ZStack(alignment: .bottom) {
            AppColors.background
                .ignoresSafeArea()

            VStack(spacing: 0) {
                LearnContentView()

                CustomTabBar(selectedTab: $selectedTab)
            }
        }
    }
}

// MARK: - Placeholder View for Other Tabs
struct TabPlaceholderView: View {
    let title: String
    @Binding var selectedTab: HomeTab

    var body: some View {
        ZStack(alignment: .bottom) {
            AppColors.background
                .ignoresSafeArea()

            VStack {
                Spacer()

                VStack(spacing: AppSpacing.md) {
                    Image(systemName: "hammer.fill")
                        .font(.system(size: 48))
                        .foregroundColor(AppColors.textMuted)

                    Text(title)
                        .font(AppTypography.title)
                        .foregroundColor(AppColors.textPrimary)

                    Text("Coming Soon")
                        .font(AppTypography.body)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                CustomTabBar(selectedTab: $selectedTab)
            }
        }
    }
}

#Preview {
    ContentView()
        .environmentObject(AudioManager.shared)
}

================================================================================
FILE: frontend/ios/ios/Core/Repositories/StockRepository.swift
================================================================================

//
//  StockRepository.swift
//  ios
//
//  Repository Pattern - Data Access Layer
//
//  Repositories abstract data fetching and caching from ViewModels:
//  - ViewModels call repositories for data
//  - Repositories handle: API calls, caching, data transformation
//  - Single source of truth for data operations
//
//  Benefits:
//  - ViewModels stay focused on UI logic
//  - Easy to add caching without changing ViewModels
//  - Testable with mock repositories
//

import Foundation

// MARK: - Stock Repository Protocol

/// Protocol for stock data access
/// Allows mocking for tests and previews
@MainActor
protocol StockRepositoryProtocol {
    func searchStocks(query: String, limit: Int) async throws -> [StockSearchResult]
    func getStock(ticker: String) async throws -> StockDetail
    func getStockQuote(ticker: String) async throws -> StockQuote
    func getStockNews(ticker: String, limit: Int) async throws -> [StockNewsArticle]
}

// MARK: - Stock Repository

/// Repository for stock-related data operations
@MainActor
final class StockRepository: StockRepositoryProtocol {

    private let apiClient: APIClient
    private var cache: [String: CacheEntry] = [:]

    init(apiClient: APIClient = .shared) {
        self.apiClient = apiClient
    }

    // MARK: - Search

    func searchStocks(query: String, limit: Int = 10) async throws -> [StockSearchResult] {
        try await apiClient.request(
            endpoint: .searchStocks(query: query, limit: limit),
            responseType: [StockSearchResult].self
        )
    }

    // MARK: - Stock Detail

    func getStock(ticker: String) async throws -> StockDetail {
        let cacheKey = "stock_\(ticker)"

        // Check cache
        if let cached: StockDetail = getCached(cacheKey, maxAge: 300) {
            // Trigger background refresh if stale
            if isCacheStale(cacheKey, maxAge: 60) {
                Task {
                    try? await refreshStock(ticker)
                }
            }
            return cached
        }

        // Fetch from API
        let stock = try await apiClient.request(
            endpoint: .getStock(ticker: ticker),
            responseType: StockDetail.self
        )

        setCache(cacheKey, value: stock)
        return stock
    }

    private func refreshStock(_ ticker: String) async throws {
        let stock = try await apiClient.request(
            endpoint: .getStock(ticker: ticker),
            responseType: StockDetail.self
        )
        setCache("stock_\(ticker)", value: stock)
    }

    // MARK: - Quote

    func getStockQuote(ticker: String) async throws -> StockQuote {
        let cacheKey = "quote_\(ticker)"

        // Short cache for quotes (1 minute)
        if let cached: StockQuote = getCached(cacheKey, maxAge: 60) {
            return cached
        }

        let quote = try await apiClient.request(
            endpoint: .getStockQuote(ticker: ticker),
            responseType: StockQuote.self
        )

        setCache(cacheKey, value: quote)
        return quote
    }

    // MARK: - News

    func getStockNews(ticker: String, limit: Int = 10) async throws -> [StockNewsArticle] {
        let cacheKey = "news_\(ticker)"

        // Cache news for 5 minutes
        if let cached: [StockNewsArticle] = getCached(cacheKey, maxAge: 300) {
            return cached
        }

        let news = try await apiClient.request(
            endpoint: .getStockNews(ticker: ticker, limit: limit),
            responseType: [StockNewsArticle].self
        )

        setCache(cacheKey, value: news)
        return news
    }

    // MARK: - Cache Helpers

    private struct CacheEntry {
        let data: Any
        let timestamp: Date
    }

    private func getCached<T>(_ key: String, maxAge: TimeInterval) -> T? {
        guard let entry = cache[key],
              Date().timeIntervalSince(entry.timestamp) < maxAge,
              let value = entry.data as? T else {
            return nil
        }
        return value
    }

    private func isCacheStale(_ key: String, maxAge: TimeInterval) -> Bool {
        guard let entry = cache[key] else { return true }
        return Date().timeIntervalSince(entry.timestamp) > maxAge
    }

    private func setCache(_ key: String, value: Any) {
        cache[key] = CacheEntry(data: value, timestamp: Date())
    }

    func clearCache() {
        cache.removeAll()
    }
}

// MARK: - Stock Models (DTO)

struct StockSearchResult: Codable, Identifiable {
    var id: String { ticker }
    let ticker: String
    let companyName: String
    let exchange: String?
    let sector: String?
    let logoUrl: String?

    enum CodingKeys: String, CodingKey {
        case ticker
        case companyName = "company_name"
        case exchange, sector
        case logoUrl = "logo_url"
    }
}

struct StockDetail: Codable, Identifiable {
    var id: String { ticker }
    let ticker: String
    let companyName: String
    let exchange: String
    let sector: String?
    let industry: String?
    let description: String?
    let website: String?
    let logoUrl: String?
    let marketCap: Double?
    let price: Double?
    let change: Double?
    let changePercent: Double?
    let volume: Double?
    let avgVolume: Double?
    let high52Week: Double?
    let low52Week: Double?

    enum CodingKeys: String, CodingKey {
        case ticker
        case companyName = "company_name"
        case exchange, sector, industry, description, website
        case logoUrl = "logo_url"
        case marketCap = "market_cap"
        case price, change
        case changePercent = "change_percent"
        case volume
        case avgVolume = "avg_volume"
        case high52Week = "high_52_week"
        case low52Week = "low_52_week"
    }

    var isPositive: Bool {
        (changePercent ?? 0) >= 0
    }

    var formattedPrice: String {
        guard let price = price else { return "--" }
        return String(format: "$%.2f", price)
    }

    var formattedChange: String {
        guard let change = change else { return "--" }
        let sign = change >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", change))"
    }

    var formattedChangePercent: String {
        guard let percent = changePercent else { return "--" }
        let sign = percent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", percent))%"
    }

    var formattedMarketCap: String {
        guard let cap = marketCap else { return "--" }
        if cap >= 1_000_000_000_000 {
            return String(format: "$%.2fT", cap / 1_000_000_000_000)
        } else if cap >= 1_000_000_000 {
            return String(format: "$%.2fB", cap / 1_000_000_000)
        } else if cap >= 1_000_000 {
            return String(format: "$%.2fM", cap / 1_000_000)
        }
        return String(format: "$%.0f", cap)
    }
}

struct StockQuote: Codable {
    let ticker: String
    let price: Double
    let change: Double
    let changePercent: Double
    let open: Double?
    let high: Double?
    let low: Double?
    let previousClose: Double?
    let volume: Double?
    let timestamp: String

    enum CodingKeys: String, CodingKey {
        case ticker, price, change
        case changePercent = "change_percent"
        case open, high, low
        case previousClose = "previous_close"
        case volume, timestamp
    }
}

struct StockNewsArticle: Codable, Identifiable {
    let id: String
    let title: String
    let summary: String?
    let source: String
    let publishedAt: String
    let url: String
    let imageUrl: String?
    let sentiment: String?
    let relatedTickers: [String]?

    enum CodingKeys: String, CodingKey {
        case id, title, summary, source
        case publishedAt = "published_at"
        case url
        case imageUrl = "image_url"
        case sentiment
        case relatedTickers = "related_tickers"
    }
}

// MARK: - Mock Repository for Previews

#if DEBUG
@MainActor
final class MockStockRepository: StockRepositoryProtocol {

    func searchStocks(query: String, limit: Int) async throws -> [StockSearchResult] {
        [
            StockSearchResult(ticker: "AAPL", companyName: "Apple Inc.", exchange: "NASDAQ", sector: "Technology", logoUrl: nil),
            StockSearchResult(ticker: "MSFT", companyName: "Microsoft Corp.", exchange: "NASDAQ", sector: "Technology", logoUrl: nil)
        ]
    }

    func getStock(ticker: String) async throws -> StockDetail {
        StockDetail(
            ticker: ticker,
            companyName: "Apple Inc.",
            exchange: "NASDAQ",
            sector: "Technology",
            industry: "Consumer Electronics",
            description: "Apple Inc. designs, manufactures, and markets smartphones, personal computers...",
            website: "apple.com",
            logoUrl: nil,
            marketCap: 3_000_000_000_000,
            price: 175.50,
            change: 2.35,
            changePercent: 1.36,
            volume: 50_000_000,
            avgVolume: 55_000_000,
            high52Week: 199.62,
            low52Week: 124.17
        )
    }

    func getStockQuote(ticker: String) async throws -> StockQuote {
        StockQuote(
            ticker: ticker,
            price: 175.50,
            change: 2.35,
            changePercent: 1.36,
            open: 173.15,
            high: 176.20,
            low: 172.80,
            previousClose: 173.15,
            volume: 50_000_000,
            timestamp: ISO8601DateFormatter().string(from: Date())
        )
    }

    func getStockNews(ticker: String, limit: Int) async throws -> [StockNewsArticle] {
        [
            StockNewsArticle(
                id: "1",
                title: "Apple Reports Strong Q4 Earnings",
                summary: "Apple exceeded analyst expectations...",
                source: "Reuters",
                publishedAt: ISO8601DateFormatter().string(from: Date()),
                url: "https://example.com/news/1",
                imageUrl: nil,
                sentiment: "positive",
                relatedTickers: ["AAPL"]
            )
        ]
    }
}
#endif

================================================================================
FILE: frontend/ios/ios/Core/Services/APIClient.swift
================================================================================

//
//  APIClient.swift
//  ios
//
//  Network Layer - Connects to Python FastAPI Backend
//
//  Features:
//  - Type-safe endpoint definitions
//  - Automatic JSON encoding/decoding
//  - Auth token injection
//  - Retry with exponential backoff
//  - Request/response logging (debug mode)
//

import Foundation

// MARK: - API Client

/// Main networking client for the application.
/// Handles all HTTP communication with the FastAPI backend.
actor APIClient {

    // MARK: - Configuration

    private let baseURL: URL
    private let session: URLSession
    private let decoder: JSONDecoder
    private let encoder: JSONEncoder
    private var authToken: String?

    /// Enable debug logging
    var isDebugLoggingEnabled: Bool = false

    // MARK: - Singleton

    static let shared = APIClient()

    // MARK: - Initialization

    init(
        baseURL: URL = APIConfig.baseURL,
        session: URLSession = .shared
    ) {
        self.baseURL = baseURL
        self.session = session

        // Configure decoder for backend snake_case
        self.decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        decoder.dateDecodingStrategy = .iso8601

        // Configure encoder
        self.encoder = JSONEncoder()
        encoder.keyEncodingStrategy = .convertToSnakeCase
        encoder.dateEncodingStrategy = .iso8601

        #if DEBUG
        self.isDebugLoggingEnabled = true
        #endif
    }

    // MARK: - Auth Token

    func setAuthToken(_ token: String?) {
        self.authToken = token
    }

    // MARK: - Request Methods

    /// Make a request and decode the response
    func request<T: Decodable>(
        endpoint: APIEndpoint,
        responseType: T.Type,
        retryCount: Int = 2
    ) async throws -> T {
        let request = try buildRequest(for: endpoint)

        logRequest(request, endpoint: endpoint)

        do {
            let (data, response) = try await session.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse else {
                throw APIError.unknown(message: "Invalid response type")
            }

            logResponse(httpResponse, data: data)

            try validateResponse(httpResponse, data: data)

            return try decoder.decode(T.self, from: data)

        } catch let error as APIError {
            // Retry on server errors
            if retryCount > 0, case .serverError = error {
                try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
                return try await self.request(endpoint: endpoint, responseType: responseType, retryCount: retryCount - 1)
            }
            throw error
        } catch let error as DecodingError {
            throw APIError.decodingError(error)
        } catch {
            throw APIError.networkError(error)
        }
    }

    /// Make a request without expecting a response body
    func request(endpoint: APIEndpoint) async throws {
        let request = try buildRequest(for: endpoint)

        logRequest(request, endpoint: endpoint)

        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.unknown(message: "Invalid response type")
        }

        logResponse(httpResponse, data: data)

        try validateResponse(httpResponse, data: data)
    }

    // MARK: - Request Building

    private func buildRequest(for endpoint: APIEndpoint) throws -> URLRequest {
        var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)!
        components.path = endpoint.path

        // Add query parameters
        if let queryParams = endpoint.queryParameters, !queryParams.isEmpty {
            components.queryItems = queryParams.map { URLQueryItem(name: $0.key, value: $0.value) }
        }

        guard let url = components.url else {
            throw APIError.unknown(message: "Invalid URL")
        }

        var request = URLRequest(url: url)
        request.httpMethod = endpoint.method.rawValue
        request.timeoutInterval = endpoint.timeout

        // Headers
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        request.setValue("iOS", forHTTPHeaderField: "X-Platform")
        request.setValue(Bundle.main.appVersion, forHTTPHeaderField: "X-App-Version")

        // Auth token
        if endpoint.requiresAuth, let token = authToken {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }

        // Body
        if let body = endpoint.body {
            request.httpBody = try encoder.encode(body)
        }

        return request
    }

    // MARK: - Response Validation

    private func validateResponse(_ response: HTTPURLResponse, data: Data) throws {
        switch response.statusCode {
        case 200...299:
            return // Success

        case 401:
            throw APIError.unauthorized

        case 403:
            // Check for specific error codes
            if let errorResponse = try? decoder.decode(APIErrorResponse.self, from: data) {
                throw APIError.businessError(
                    code: errorResponse.errorCode,
                    message: errorResponse.userMessage
                )
            }
            throw APIError.forbidden

        case 404:
            throw APIError.notFound

        case 422:
            // Validation error
            if let errorResponse = try? decoder.decode(APIErrorResponse.self, from: data) {
                throw APIError.businessError(
                    code: errorResponse.errorCode,
                    message: errorResponse.userMessage
                )
            }
            throw APIError.unknown(message: "Validation failed")

        case 429:
            let retryAfter = response.value(forHTTPHeaderField: "Retry-After")
                .flatMap { Int($0) } ?? 60
            throw APIError.rateLimited(retryAfter: retryAfter)

        case 500...599:
            throw APIError.serverError(statusCode: response.statusCode)

        default:
            throw APIError.unknown(message: "HTTP \(response.statusCode)")
        }
    }

    // MARK: - Logging

    private func logRequest(_ request: URLRequest, endpoint: APIEndpoint) {
        guard isDebugLoggingEnabled else { return }

        print("ðŸŒ API Request: \(endpoint.method.rawValue) \(request.url?.absoluteString ?? "")")
        if let body = request.httpBody,
           let bodyString = String(data: body, encoding: .utf8) {
            print("   Body: \(bodyString.prefix(500))")
        }
    }

    private func logResponse(_ response: HTTPURLResponse, data: Data) {
        guard isDebugLoggingEnabled else { return }

        let emoji = (200...299).contains(response.statusCode) ? "âœ…" : "âŒ"
        print("\(emoji) API Response: \(response.statusCode)")

        if let bodyString = String(data: data, encoding: .utf8) {
            print("   Body: \(bodyString.prefix(500))")
        }
    }
}

// MARK: - API Error Response (Backend Format)

/// Matches the backend's APIError schema
struct APIErrorResponse: Sendable {
    let errorCode: String
    let message: String
    let userMessage: String
    let action: String?
    let details: [String: AnyCodable]?

    enum CodingKeys: String, CodingKey {
        case errorCode = "error_code"
        case message
        case userMessage = "user_message"
        case action
        case details
    }
}

// Explicitly nonisolated Decodable conformance
extension APIErrorResponse: Decodable {
    nonisolated init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.errorCode = try container.decode(String.self, forKey: .errorCode)
        self.message = try container.decode(String.self, forKey: .message)
        self.userMessage = try container.decode(String.self, forKey: .userMessage)
        self.action = try container.decodeIfPresent(String.self, forKey: .action)
        self.details = try container.decodeIfPresent([String: AnyCodable].self, forKey: .details)
    }
}

/// Type-erased Codable for flexible JSON
/// @unchecked Sendable because it only stores immutable value types (String, Int, Double, Bool)
struct AnyCodable: Decodable, @unchecked Sendable {
    let value: Any

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let string = try? container.decode(String.self) {
            value = string
        } else if let int = try? container.decode(Int.self) {
            value = int
        } else if let double = try? container.decode(Double.self) {
            value = double
        } else if let bool = try? container.decode(Bool.self) {
            value = bool
        } else {
            value = ""
        }
    }
}

// MARK: - Bundle Extension

extension Bundle {
    nonisolated var appVersion: String {
        infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0"
    }
}

================================================================================
FILE: frontend/ios/ios/Core/Services/APIConfig.swift
================================================================================

//
//  APIConfig.swift
//  ios
//
//  API Configuration
//
//  Handles environment-specific configuration:
//  - Base URL (dev, staging, production)
//  - Timeouts
//  - Retry policies
//

import Foundation

// MARK: - App Environment

enum AppEnvironment: Sendable {
    case development
    case staging
    case production

    nonisolated static var current: AppEnvironment {
        #if DEBUG
        return .development
        #else
        // Check for staging flag or default to production
        if ProcessInfo.processInfo.environment["STAGING"] != nil {
            return .staging
        }
        return .production
        #endif
    }
}

// MARK: - API Configuration

enum APIConfig: Sendable {

    // MARK: - Base URLs

    nonisolated static var baseURL: URL {
        switch AppEnvironment.current {
        case .development:
            // Local development server
            return URL(string: "http://localhost:8000")!
        case .staging:
            // Staging server
            return URL(string: "https://staging-api.yourapp.com")!
        case .production:
            // Production server
            return URL(string: "https://api.yourapp.com")!
        }
    }

    // MARK: - Timeouts

    /// Default request timeout (seconds)
    static let defaultTimeout: TimeInterval = 30

    /// Timeout for AI generation requests (seconds)
    static let aiGenerationTimeout: TimeInterval = 120

    /// Timeout for chat messages (seconds)
    static let chatTimeout: TimeInterval = 60

    // MARK: - Retry Policy

    /// Maximum retry attempts for failed requests
    static let maxRetryAttempts = 3

    /// Base delay between retries (seconds)
    static let retryBaseDelay: TimeInterval = 1.0

    /// Maximum delay between retries (seconds)
    static let retryMaxDelay: TimeInterval = 10.0

    // MARK: - Polling Configuration

    /// Interval for polling research status (seconds)
    nonisolated static let researchPollInterval: TimeInterval = 3.0

    /// Maximum polling duration before timeout (seconds)
    nonisolated static let researchPollTimeout: TimeInterval = 180.0 // 3 minutes

    // MARK: - Cache Configuration

    /// Default cache TTL (seconds)
    static let defaultCacheTTL: TimeInterval = 300 // 5 minutes

    /// Stock quote cache TTL (seconds)
    static let quoteCacheTTL: TimeInterval = 60 // 1 minute

    /// News feed cache TTL (seconds)
    static let newsCacheTTL: TimeInterval = 300 // 5 minutes

    // MARK: - Pagination

    /// Default page size for list endpoints
    static let defaultPageSize = 20

    /// Maximum page size allowed
    static let maxPageSize = 100
}

// MARK: - Feature Flags

enum FeatureFlags: Sendable {
    /// Enable offline mode with cached data
    nonisolated static var offlineModeEnabled: Bool {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }

    /// Enable debug logging for API calls
    nonisolated static var apiLoggingEnabled: Bool {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }

    /// Enable mock data for development
    nonisolated static var useMockData: Bool {
        #if DEBUG
        return ProcessInfo.processInfo.environment["USE_MOCK"] != nil
        #else
        return false
        #endif
    }
}

================================================================================
FILE: frontend/ios/ios/Core/Services/APIEndpoint.swift
================================================================================

//
//  APIEndpoint.swift
//  ios
//
//  Type-Safe API Endpoint Definitions
//
//  Each endpoint defines:
//  - HTTP method
//  - Path
//  - Query parameters
//  - Request body
//  - Auth requirements
//  - Timeout
//

import Foundation

// MARK: - HTTP Method

enum HTTPMethod: String, Sendable {
    case GET
    case POST
    case PUT
    case PATCH
    case DELETE
}

// MARK: - API Endpoint

/// Type-safe endpoint definitions.
/// Add new endpoints here as the app grows.
enum APIEndpoint: Sendable {

    // MARK: - Auth
    case signIn(email: String, password: String)
    case signUp(email: String, password: String, displayName: String)
    case refreshToken(refreshToken: String)
    case signOut

    // MARK: - User
    case getCurrentUser
    case getUserCredits
    case updateProfile(displayName: String?, avatarUrl: String?)

    // MARK: - Stocks
    case searchStocks(query: String, limit: Int)
    case getStock(ticker: String)
    case getStockQuote(ticker: String)
    case getStockFundamentals(ticker: String)
    case getStockNews(ticker: String, limit: Int)

    // MARK: - Watchlist
    case getWatchlist
    case addToWatchlist(stockId: String)
    case removeFromWatchlist(stockId: String)

    // MARK: - Research
    case generateResearch(stockId: String, persona: String)
    case getResearchStatus(reportId: String)
    case getResearchReport(reportId: String)
    case getMyReports(limit: Int)
    case rateReport(reportId: String, rating: Int, feedback: String?)
    case deleteReport(reportId: String)

    // MARK: - News
    case getNewsFeed(page: Int, perPage: Int)
    case getNewsArticle(articleId: String)

    // MARK: - Chat
    case createChatSession(stockId: String?)
    case sendChatMessage(sessionId: String, message: String)
    case getChatHistory(sessionId: String)

    // MARK: - Personas
    case getPersonas

    // MARK: - Path

    nonisolated var path: String {
        switch self {
        // Auth
        case .signIn:
            return "/api/v1/auth/login"
        case .signUp:
            return "/api/v1/auth/register"
        case .refreshToken:
            return "/api/v1/auth/refresh"
        case .signOut:
            return "/api/v1/auth/logout"

        // User
        case .getCurrentUser:
            return "/api/v1/users/me"
        case .getUserCredits:
            return "/api/v1/users/me/credits"
        case .updateProfile:
            return "/api/v1/users/me"

        // Stocks
        case .searchStocks:
            return "/api/v1/stocks/search"
        case .getStock(let ticker):
            return "/api/v1/stocks/\(ticker)"
        case .getStockQuote(let ticker):
            return "/api/v1/stocks/\(ticker)/quote"
        case .getStockFundamentals(let ticker):
            return "/api/v1/stocks/\(ticker)/fundamentals"
        case .getStockNews(let ticker, _):
            return "/api/v1/stocks/\(ticker)/news"

        // Watchlist
        case .getWatchlist:
            return "/api/v1/watchlist"
        case .addToWatchlist, .removeFromWatchlist:
            return "/api/v1/watchlist"

        // Research
        case .generateResearch:
            return "/api/v1/research/generate"
        case .getResearchStatus(let reportId):
            return "/api/v1/research/reports/\(reportId)/status"
        case .getResearchReport(let reportId):
            return "/api/v1/research/reports/\(reportId)"
        case .getMyReports:
            return "/api/v1/research/reports"
        case .rateReport(let reportId, _, _):
            return "/api/v1/research/reports/\(reportId)/rate"
        case .deleteReport(let reportId):
            return "/api/v1/research/reports/\(reportId)"

        // News
        case .getNewsFeed:
            return "/api/v1/news"
        case .getNewsArticle(let articleId):
            return "/api/v1/news/\(articleId)"

        // Chat
        case .createChatSession:
            return "/api/v1/chat/sessions"
        case .sendChatMessage(let sessionId, _):
            return "/api/v1/chat/sessions/\(sessionId)/messages"
        case .getChatHistory(let sessionId):
            return "/api/v1/chat/sessions/\(sessionId)"

        // Personas
        case .getPersonas:
            return "/api/v1/research/personas"
        }
    }

    // MARK: - Method

    nonisolated var method: HTTPMethod {
        switch self {
        case .signIn, .signUp, .refreshToken, .signOut,
             .addToWatchlist, .generateResearch, .rateReport,
             .createChatSession, .sendChatMessage:
            return .POST

        case .updateProfile:
            return .PATCH

        case .removeFromWatchlist, .deleteReport:
            return .DELETE

        default:
            return .GET
        }
    }

    // MARK: - Query Parameters

    nonisolated var queryParameters: [String: String]? {
        switch self {
        case .searchStocks(let query, let limit):
            return ["q": query, "limit": String(limit)]

        case .getStockNews(_, let limit):
            return ["limit": String(limit)]

        case .getMyReports(let limit):
            return ["limit": String(limit)]

        case .getNewsFeed(let page, let perPage):
            return ["page": String(page), "per_page": String(perPage)]

        default:
            return nil
        }
    }

    // MARK: - Body

    nonisolated var body: (any Encodable & Sendable)? {
        switch self {
        case .signIn(let email, let password):
            return SignInRequest(email: email, password: password)

        case .signUp(let email, let password, let displayName):
            return SignUpRequest(email: email, password: password, displayName: displayName)

        case .refreshToken(let refreshToken):
            return RefreshTokenRequest(refreshToken: refreshToken)

        case .updateProfile(let displayName, let avatarUrl):
            return UpdateProfileRequest(displayName: displayName, avatarUrl: avatarUrl)

        case .addToWatchlist(let stockId):
            return AddToWatchlistRequest(stockId: stockId)

        case .removeFromWatchlist(let stockId):
            return RemoveFromWatchlistRequest(stockId: stockId)

        case .generateResearch(let stockId, let persona):
            return GenerateResearchRequest(stockId: stockId, investorPersona: persona)

        case .rateReport(_, let rating, let feedback):
            return RateReportRequest(rating: rating, feedback: feedback)

        case .createChatSession(let stockId):
            return CreateChatSessionRequest(stockId: stockId)

        case .sendChatMessage(_, let message):
            return SendChatMessageRequest(message: message)

        default:
            return nil
        }
    }

    // MARK: - Auth Required

    nonisolated var requiresAuth: Bool {
        switch self {
        case .signIn, .signUp, .refreshToken, .getPersonas:
            return false
        default:
            return true
        }
    }

    // MARK: - Timeout

    nonisolated var timeout: TimeInterval {
        switch self {
        case .generateResearch:
            return 120 // 2 minutes for AI generation
        case .sendChatMessage:
            return 60 // 1 minute for chat
        default:
            return 30 // 30 seconds default
        }
    }
}

// MARK: - Request Bodies

nonisolated struct SignInRequest: Encodable, Sendable {
    let email: String
    let password: String
}

nonisolated struct SignUpRequest: Encodable, Sendable {
    let email: String
    let password: String
    let displayName: String
}

nonisolated struct RefreshTokenRequest: Encodable, Sendable {
    let refreshToken: String
}

nonisolated struct UpdateProfileRequest: Encodable, Sendable {
    let displayName: String?
    let avatarUrl: String?
}

nonisolated struct AddToWatchlistRequest: Encodable, Sendable {
    let stockId: String
}

nonisolated struct RemoveFromWatchlistRequest: Encodable, Sendable {
    let stockId: String
}

nonisolated struct GenerateResearchRequest: Encodable, Sendable {
    let stockId: String
    let investorPersona: String
}

nonisolated struct RateReportRequest: Encodable, Sendable {
    let rating: Int
    let feedback: String?
}

nonisolated struct CreateChatSessionRequest: Encodable, Sendable {
    let stockId: String?
}

nonisolated struct SendChatMessageRequest: Encodable, Sendable {
    let message: String
}

================================================================================
FILE: frontend/ios/ios/Core/Services/AuthService.swift
================================================================================

//
//  AuthService.swift
//  ios
//
//  Authentication Service
//
//  Handles:
//  - Sign in / Sign up
//  - Token storage (Keychain)
//  - Token refresh
//  - Sign out
//

import Foundation
import Security

// MARK: - Auth Response

struct AuthResponse: Decodable, Sendable {
    let accessToken: String
    let refreshToken: String
    let expiresIn: Int
    let tokenType: String
    let user: UserProfile

    enum CodingKeys: String, CodingKey {
        case accessToken = "access_token"
        case refreshToken = "refresh_token"
        case expiresIn = "expires_in"
        case tokenType = "token_type"
        case user
    }
}

// MARK: - Auth Service

/// Handles authentication and token management
@MainActor
final class AuthService {

    // MARK: - Properties

    private let apiClient: APIClient
    private let keychain: KeychainService

    private static let accessTokenKey = "access_token"
    private static let refreshTokenKey = "refresh_token"

    // MARK: - Initialization

    init(apiClient: APIClient, keychain: KeychainService? = nil) {
        self.apiClient = apiClient
        self.keychain = keychain ?? .shared
    }

    // MARK: - Authentication

    /// Sign in with email and password
    func signIn(email: String, password: String) async throws -> UserProfile {
        let response = try await apiClient.request(
            endpoint: .signIn(email: email, password: password),
            responseType: AuthResponse.self
        )

        // Store tokens
        saveTokens(accessToken: response.accessToken, refreshToken: response.refreshToken)

        // Update API client
        await apiClient.setAuthToken(response.accessToken)

        return response.user
    }

    /// Sign up with email and password
    func signUp(email: String, password: String, displayName: String) async throws -> UserProfile {
        let response = try await apiClient.request(
            endpoint: .signUp(email: email, password: password, displayName: displayName),
            responseType: AuthResponse.self
        )

        // Store tokens
        saveTokens(accessToken: response.accessToken, refreshToken: response.refreshToken)

        // Update API client
        await apiClient.setAuthToken(response.accessToken)

        return response.user
    }

    /// Sign out
    func signOut() async {
        // Call backend to invalidate token
        try? await apiClient.request(endpoint: .signOut)

        // Clear tokens
        clearToken()

        // Clear API client token
        await apiClient.setAuthToken(nil)
    }

    /// Refresh the access token
    func refreshToken() async throws {
        guard let refreshToken = getStoredRefreshToken() else {
            throw APIError.unauthorized
        }

        let response = try await apiClient.request(
            endpoint: .refreshToken(refreshToken: refreshToken),
            responseType: AuthResponse.self
        )

        // Store new tokens
        saveTokens(accessToken: response.accessToken, refreshToken: response.refreshToken)

        // Update API client
        await apiClient.setAuthToken(response.accessToken)
    }

    // MARK: - Token Management

    /// Get stored access token
    func getStoredToken() -> String? {
        keychain.get(Self.accessTokenKey)
    }

    /// Get stored refresh token
    func getStoredRefreshToken() -> String? {
        keychain.get(Self.refreshTokenKey)
    }

    /// Check if user has stored token
    var hasStoredToken: Bool {
        getStoredToken() != nil
    }

    /// Save tokens to keychain
    private func saveTokens(accessToken: String, refreshToken: String) {
        keychain.set(accessToken, forKey: Self.accessTokenKey)
        keychain.set(refreshToken, forKey: Self.refreshTokenKey)
    }

    /// Clear stored tokens
    func clearToken() {
        keychain.delete(Self.accessTokenKey)
        keychain.delete(Self.refreshTokenKey)
    }
}

// MARK: - Keychain Service

/// Simple Keychain wrapper for secure token storage
/// @unchecked Sendable because Keychain APIs are thread-safe
final class KeychainService: @unchecked Sendable {

    static let shared = KeychainService()

    private let service = Bundle.main.bundleIdentifier ?? "com.aivalueinvestor"

    private init() {}

    func set(_ value: String, forKey key: String) {
        guard let data = value.data(using: .utf8) else { return }

        // Delete existing item first
        delete(key)

        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: key,
            kSecValueData as String: data,
            kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly
        ]

        SecItemAdd(query as CFDictionary, nil)
    }

    func get(_ key: String) -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]

        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)

        guard status == errSecSuccess,
              let data = result as? Data,
              let string = String(data: data, encoding: .utf8) else {
            return nil
        }

        return string
    }

    func delete(_ key: String) {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: key
        ]

        SecItemDelete(query as CFDictionary)
    }

    func deleteAll() {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service
        ]

        SecItemDelete(query as CFDictionary)
    }
}

================================================================================
FILE: frontend/ios/ios/Core/Services/TaskPollingManager.swift
================================================================================

//
//  TaskPollingManager.swift
//  ios
//
//  Long-Running Task Management with Polling
//
//  Handles AI research generation and other async tasks:
//  1. Start task â†’ Get task ID
//  2. Poll for status every N seconds
//  3. Yield progress updates via AsyncStream
//  4. Complete when done or timeout
//
//  Usage:
//  ```swift
//  for await progress in pollingManager.monitorResearch(reportId: "123") {
//      switch progress {
//      case .progress(let percent, let step):
//          updateUI(percent: percent, step: step)
//      case .completed(let report):
//          showReport(report)
//      case .failed(let error):
//          handleError(error)
//      }
//  }
//  ```
//

import Foundation

// MARK: - Task Progress

/// Progress updates for long-running tasks
enum TaskProgress<T: Sendable>: Sendable {
    case started(taskId: String)
    case progress(percent: Int, step: String)
    case completed(T)
    case failed(AppError)
}

// MARK: - Research Status Response

struct ResearchStatusResponse: Sendable {
    let reportId: String
    let status: String
    let progress: Int
    let currentStep: String?
    let errorMessage: String?
    let estimatedTimeRemaining: Int?

    enum CodingKeys: String, CodingKey {
        case reportId = "report_id"
        case status, progress
        case currentStep = "current_step"
        case errorMessage = "error_message"
        case estimatedTimeRemaining = "estimated_time_remaining"
    }

    nonisolated var isCompleted: Bool { status == "completed" }
    nonisolated var isFailed: Bool { status == "failed" }
    nonisolated var isProcessing: Bool { status == "pending" || status == "processing" }
}

extension ResearchStatusResponse: Decodable {
    nonisolated init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.reportId = try container.decode(String.self, forKey: .reportId)
        self.status = try container.decode(String.self, forKey: .status)
        self.progress = try container.decode(Int.self, forKey: .progress)
        self.currentStep = try container.decodeIfPresent(String.self, forKey: .currentStep)
        self.errorMessage = try container.decodeIfPresent(String.self, forKey: .errorMessage)
        self.estimatedTimeRemaining = try container.decodeIfPresent(Int.self, forKey: .estimatedTimeRemaining)
    }
}

// MARK: - Research Generation Response

struct ResearchGenerationResponse: Sendable {
    let reportId: String
    let status: String
    let estimatedSeconds: Int?
    let pollUrl: String?

    enum CodingKeys: String, CodingKey {
        case reportId = "report_id"
        case status
        case estimatedSeconds = "estimated_seconds"
        case pollUrl = "poll_url"
    }
}

extension ResearchGenerationResponse: Decodable {
    nonisolated init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.reportId = try container.decode(String.self, forKey: .reportId)
        self.status = try container.decode(String.self, forKey: .status)
        self.estimatedSeconds = try container.decodeIfPresent(Int.self, forKey: .estimatedSeconds)
        self.pollUrl = try container.decodeIfPresent(String.self, forKey: .pollUrl)
    }
}

// MARK: - Task Polling Manager

/// Manages polling for long-running tasks like AI research generation
actor TaskPollingManager {

    private let apiClient: APIClient
    private let pollInterval: TimeInterval
    private let maxPollDuration: TimeInterval

    /// Active polling tasks (taskId -> Task)
    private var activeTasks: [String: Task<Void, Never>] = [:]

    // MARK: - Initialization

    init(
        apiClient: APIClient,
        pollInterval: TimeInterval = APIConfig.researchPollInterval,
        maxPollDuration: TimeInterval = APIConfig.researchPollTimeout
    ) {
        self.apiClient = apiClient
        self.pollInterval = pollInterval
        self.maxPollDuration = maxPollDuration
    }

    // MARK: - Research Generation

    /// Start research generation and monitor progress
    func generateAndMonitorResearch(
        stockId: String,
        persona: String
    ) -> AsyncThrowingStream<TaskProgress<ResearchReportDetail>, Error> {
        AsyncThrowingStream { continuation in
            Task {
                do {
                    // 1. Start generation
                    let response = try await apiClient.request(
                        endpoint: .generateResearch(stockId: stockId, persona: persona),
                        responseType: ResearchGenerationResponse.self
                    )

                    let reportId = response.reportId
                    continuation.yield(.started(taskId: reportId))

                    // 2. Poll for completion
                    let startTime = Date()

                    while true {
                        // Check timeout
                        if Date().timeIntervalSince(startTime) > maxPollDuration {
                            continuation.yield(.failed(.timeout))
                            continuation.finish()
                            return
                        }

                        // Wait before polling
                        try await Task.sleep(nanoseconds: UInt64(pollInterval * 1_000_000_000))

                        // Check status
                        let status = try await apiClient.request(
                            endpoint: .getResearchStatus(reportId: reportId),
                            responseType: ResearchStatusResponse.self
                        )

                        if status.isProcessing {
                            continuation.yield(.progress(
                                percent: status.progress,
                                step: status.currentStep ?? "Processing..."
                            ))
                        } else if status.isCompleted {
                            // Fetch full report
                            let report = try await apiClient.request(
                                endpoint: .getResearchReport(reportId: reportId),
                                responseType: ResearchReportDetail.self
                            )
                            continuation.yield(.completed(report))
                            continuation.finish()
                            return
                        } else if status.isFailed {
                            let errorMessage = status.errorMessage ?? "Research generation failed"
                            continuation.yield(.failed(.apiError(code: "RESEARCH_FAILED", message: errorMessage)))
                            continuation.finish()
                            return
                        }
                    }
                } catch {
                    continuation.yield(.failed(AppError.from(error)))
                    continuation.finish()
                }
            }
        }
    }

    /// Monitor an existing research report by ID
    func monitorResearch(reportId: String) -> AsyncThrowingStream<TaskProgress<ResearchReportDetail>, Error> {
        AsyncThrowingStream { continuation in
            Task {
                let startTime = Date()

                while true {
                    // Check timeout
                    if Date().timeIntervalSince(startTime) > maxPollDuration {
                        continuation.yield(.failed(.timeout))
                        continuation.finish()
                        return
                    }

                    do {
                        let status = try await apiClient.request(
                            endpoint: .getResearchStatus(reportId: reportId),
                            responseType: ResearchStatusResponse.self
                        )

                        if status.isProcessing {
                            continuation.yield(.progress(
                                percent: status.progress,
                                step: status.currentStep ?? "Processing..."
                            ))
                        } else if status.isCompleted {
                            let report = try await apiClient.request(
                                endpoint: .getResearchReport(reportId: reportId),
                                responseType: ResearchReportDetail.self
                            )
                            continuation.yield(.completed(report))
                            continuation.finish()
                            return
                        } else if status.isFailed {
                            let errorMessage = status.errorMessage ?? "Research generation failed"
                            continuation.yield(.failed(.apiError(code: "RESEARCH_FAILED", message: errorMessage)))
                            continuation.finish()
                            return
                        }

                        // Wait before next poll
                        try await Task.sleep(nanoseconds: UInt64(pollInterval * 1_000_000_000))

                    } catch {
                        continuation.yield(.failed(AppError.from(error)))
                        continuation.finish()
                        return
                    }
                }
            }
        }
    }

    // MARK: - Task Management

    /// Cancel a polling task
    func cancelTask(_ taskId: String) {
        activeTasks[taskId]?.cancel()
        activeTasks.removeValue(forKey: taskId)
    }

    /// Cancel all active polling tasks
    func cancelAllTasks() {
        for (_, task) in activeTasks {
            task.cancel()
        }
        activeTasks.removeAll()
    }

    /// Check if a task is being polled
    func isPolling(_ taskId: String) -> Bool {
        activeTasks[taskId] != nil
    }
}

// MARK: - Research Report Detail

/// Full research report from backend
struct ResearchReportDetail: Identifiable, Sendable {
    let id: String
    let userId: String
    let stockId: String
    let ticker: String
    let companyName: String
    let investorPersona: String
    let status: String

    // Report content
    let title: String?
    let executiveSummary: String?
    let investmentThesis: InvestmentThesis?
    let pros: [String]?
    let cons: [String]?
    let moatAnalysis: MoatAnalysis?
    let valuationAnalysis: ValuationAnalysis?
    let riskAssessment: RiskAssessment?
    let fullReport: String?
    let keyTakeaways: [String]?
    let actionRecommendation: String?

    // Metadata
    let generationTimeSeconds: Int?
    let tokensUsed: Int?
    let createdAt: String
    let completedAt: String?

    // User interaction
    let userRating: Int?
    let userFeedback: String?

    enum CodingKeys: String, CodingKey {
        case id
        case userId = "user_id"
        case stockId = "stock_id"
        case ticker
        case companyName = "company_name"
        case investorPersona = "investor_persona"
        case status, title
        case executiveSummary = "executive_summary"
        case investmentThesis = "investment_thesis"
        case pros, cons
        case moatAnalysis = "moat_analysis"
        case valuationAnalysis = "valuation_analysis"
        case riskAssessment = "risk_assessment"
        case fullReport = "full_report"
        case keyTakeaways = "key_takeaways"
        case actionRecommendation = "action_recommendation"
        case generationTimeSeconds = "generation_time_seconds"
        case tokensUsed = "tokens_used"
        case createdAt = "created_at"
        case completedAt = "completed_at"
        case userRating = "user_rating"
        case userFeedback = "user_feedback"
    }
}

// MARK: - Nonisolated Decodable Conformance

extension ResearchReportDetail: Decodable {
    nonisolated init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        self.id = try container.decode(String.self, forKey: .id)
        self.userId = try container.decode(String.self, forKey: .userId)
        self.stockId = try container.decode(String.self, forKey: .stockId)
        self.ticker = try container.decode(String.self, forKey: .ticker)
        self.companyName = try container.decode(String.self, forKey: .companyName)
        self.investorPersona = try container.decode(String.self, forKey: .investorPersona)
        self.status = try container.decode(String.self, forKey: .status)
        
        self.title = try container.decodeIfPresent(String.self, forKey: .title)
        self.executiveSummary = try container.decodeIfPresent(String.self, forKey: .executiveSummary)
        self.investmentThesis = try container.decodeIfPresent(InvestmentThesis.self, forKey: .investmentThesis)
        self.pros = try container.decodeIfPresent([String].self, forKey: .pros)
        self.cons = try container.decodeIfPresent([String].self, forKey: .cons)
        self.moatAnalysis = try container.decodeIfPresent(MoatAnalysis.self, forKey: .moatAnalysis)
        self.valuationAnalysis = try container.decodeIfPresent(ValuationAnalysis.self, forKey: .valuationAnalysis)
        self.riskAssessment = try container.decodeIfPresent(RiskAssessment.self, forKey: .riskAssessment)
        self.fullReport = try container.decodeIfPresent(String.self, forKey: .fullReport)
        self.keyTakeaways = try container.decodeIfPresent([String].self, forKey: .keyTakeaways)
        self.actionRecommendation = try container.decodeIfPresent(String.self, forKey: .actionRecommendation)
        
        self.generationTimeSeconds = try container.decodeIfPresent(Int.self, forKey: .generationTimeSeconds)
        self.tokensUsed = try container.decodeIfPresent(Int.self, forKey: .tokensUsed)
        self.createdAt = try container.decode(String.self, forKey: .createdAt)
        self.completedAt = try container.decodeIfPresent(String.self, forKey: .completedAt)
        
        self.userRating = try container.decodeIfPresent(Int.self, forKey: .userRating)
        self.userFeedback = try container.decodeIfPresent(String.self, forKey: .userFeedback)
    }
}

// MARK: - Report Sub-Models

struct InvestmentThesis: Sendable {
    let summary: String
    let keyDrivers: [String]
    let risks: [String]
    let timeHorizon: String
    let convictionLevel: String

    enum CodingKeys: String, CodingKey {
        case summary
        case keyDrivers = "key_drivers"
        case risks
        case timeHorizon = "time_horizon"
        case convictionLevel = "conviction_level"
    }
}

extension InvestmentThesis: Decodable {
    nonisolated init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.summary = try container.decode(String.self, forKey: .summary)
        self.keyDrivers = try container.decode([String].self, forKey: .keyDrivers)
        self.risks = try container.decode([String].self, forKey: .risks)
        self.timeHorizon = try container.decode(String.self, forKey: .timeHorizon)
        self.convictionLevel = try container.decode(String.self, forKey: .convictionLevel)
    }
}

struct MoatAnalysis: Sendable {
    let moatRating: String
    let moatSources: [String]
    let moatSustainability: String
    let competitivePosition: String
    let barriersToEntry: [String]

    enum CodingKeys: String, CodingKey {
        case moatRating = "moat_rating"
        case moatSources = "moat_sources"
        case moatSustainability = "moat_sustainability"
        case competitivePosition = "competitive_position"
        case barriersToEntry = "barriers_to_entry"
    }
}

extension MoatAnalysis: Decodable {
    nonisolated init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.moatRating = try container.decode(String.self, forKey: .moatRating)
        self.moatSources = try container.decode([String].self, forKey: .moatSources)
        self.moatSustainability = try container.decode(String.self, forKey: .moatSustainability)
        self.competitivePosition = try container.decode(String.self, forKey: .competitivePosition)
        self.barriersToEntry = try container.decode([String].self, forKey: .barriersToEntry)
    }
}

struct ValuationAnalysis: Sendable {
    let valuationRating: String
    let keyMetrics: [String: AnyCodable]
    let historicalContext: String?
    let marginOfSafety: String?

    enum CodingKeys: String, CodingKey {
        case valuationRating = "valuation_rating"
        case keyMetrics = "key_metrics"
        case historicalContext = "historical_context"
        case marginOfSafety = "margin_of_safety"
    }
}

extension ValuationAnalysis: Decodable {
    nonisolated init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.valuationRating = try container.decode(String.self, forKey: .valuationRating)
        self.keyMetrics = try container.decode([String: AnyCodable].self, forKey: .keyMetrics)
        self.historicalContext = try container.decodeIfPresent(String.self, forKey: .historicalContext)
        self.marginOfSafety = try container.decodeIfPresent(String.self, forKey: .marginOfSafety)
    }
}

struct RiskAssessment: Sendable {
    let overallRisk: String
    let businessRisks: [String]
    let financialRisks: [String]
    let marketRisks: [String]

    enum CodingKeys: String, CodingKey {
        case overallRisk = "overall_risk"
        case businessRisks = "business_risks"
        case financialRisks = "financial_risks"
        case marketRisks = "market_risks"
    }
}

extension RiskAssessment: Decodable {
    nonisolated init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.overallRisk = try container.decode(String.self, forKey: .overallRisk)
        self.businessRisks = try container.decode([String].self, forKey: .businessRisks)
        self.financialRisks = try container.decode([String].self, forKey: .financialRisks)
        self.marketRisks = try container.decode([String].self, forKey: .marketRisks)
    }
}

================================================================================
FILE: frontend/ios/ios/Core/State/AppState.swift
================================================================================

//
//  AppState.swift
//  ios
//
//  Global Application State - Single Source of Truth
//
//  Architecture Decision:
//  Using @Observable (iOS 17+) for global state instead of:
//  - EnvironmentObject: Requires @Published boilerplate
//  - Singleton: Hard to test, implicit dependencies
//  - Full DI Container: Overkill for solo developer
//
//  Benefits:
//  - Simple, no boilerplate
//  - Automatic UI updates
//  - Easy to pass via Environment
//  - Works with existing @StateObject ViewModels
//

import SwiftUI
import Combine

// MARK: - Global App State

/// Central state container for data that needs to be shared across the app.
/// Injected via `.environment()` at the app root.
///
/// Usage in Views:
/// ```swift
/// struct MyView: View {
///     @Environment(AppState.self) private var appState
///     var body: some View {
///         Text("Credits: \(appState.user.credits)")
///     }
/// }
/// ```
///
/// Usage in ViewModels:
/// ```swift
/// @MainActor
/// class MyViewModel: ObservableObject {
///     private let appState: AppState
///     init(appState: AppState) {
///         self.appState = appState
///     }
/// }
/// ```
@Observable
@MainActor
final class AppState {

    // MARK: - Sub-States

    /// Authentication state
    var auth = AuthState()

    /// Current user state (profile, credits, tier)
    var user = UserState()

    /// Watchlist and tracked stocks
    var watchlist = WatchlistState()

    /// Research reports state
    var research = ResearchState()

    // MARK: - Global UI State

    /// Network connectivity status
    var isOnline: Bool = true

    /// Global loading indicator
    var isLoading: Bool = false

    /// Global error to display
    var currentError: AppError?

    /// Toast message to display
    var toastMessage: ToastMessage?

    // MARK: - Services (Injected)

    private(set) var apiClient: APIClient!
    private(set) var authService: AuthService!

    // MARK: - Initialization

    init() {
        // Services will be set up in configure()
    }

    /// Configure services - called from App entry point
    func configure(apiClient: APIClient, authService: AuthService) {
        self.apiClient = apiClient
        self.authService = authService

        // Restore auth state from keychain
        Task {
            await restoreAuthState()
        }
    }

    // MARK: - Auth Actions

    private func restoreAuthState() async {
        guard authService.getStoredToken() != nil else {
            auth.status = .unauthenticated
            return
        }

        auth.status = .loading

        do {
            let user = try await apiClient.request(
                endpoint: .getCurrentUser,
                responseType: UserProfile.self
            )
            self.user.profile = user
            auth.status = .authenticated
        } catch {
            // Token invalid, clear it
            authService.clearToken()
            auth.status = .unauthenticated
        }
    }

    func signOut() {
        authService.clearToken()
        auth.status = .unauthenticated
        user = UserState()
        watchlist = WatchlistState()
        research = ResearchState()
    }

    // MARK: - Error Handling

    func handleError(_ error: Error) {
        let appError = AppError.from(error)

        // Handle auth errors globally
        if case .unauthorized = appError {
            signOut()
            return
        }

        currentError = appError
    }

    func clearError() {
        currentError = nil
    }

    func showToast(_ message: String, type: ToastType = .info) {
        toastMessage = ToastMessage(message: message, type: type)

        // Auto-dismiss after 3 seconds
        Task {
            try? await Task.sleep(nanoseconds: 3_000_000_000)
            if toastMessage?.message == message {
                toastMessage = nil
            }
        }
    }
}

// MARK: - Auth State

@Observable
final class AuthState {
    var status: AuthStatus = .unknown
    var accessToken: String?

    var isAuthenticated: Bool {
        status == .authenticated
    }

    var isLoading: Bool {
        status == .loading
    }
}

enum AuthStatus: Equatable {
    case unknown
    case loading
    case authenticated
    case unauthenticated
}

// MARK: - User State

@Observable
final class UserState {
    var profile: UserProfile?
    var credits: CreditInfo?
    var tier: UserTier = .free

    var displayName: String {
        profile?.displayName ?? "Guest"
    }

    var remainingCredits: Int {
        credits?.remaining ?? 0
    }

    var canGenerateResearch: Bool {
        remainingCredits > 0
    }
}

struct UserProfile: Codable, Identifiable, Sendable {
    let id: String
    let email: String
    let displayName: String?
    let avatarUrl: String?
    let tier: String
    let createdAt: String

    enum CodingKeys: String, CodingKey {
        case id, email, tier
        case displayName = "display_name"
        case avatarUrl = "avatar_url"
        case createdAt = "created_at"
    }
}

struct CreditInfo: Codable, Sendable {
    let total: Int
    let used: Int
    let remaining: Int
    let resetsAt: String?

    enum CodingKeys: String, CodingKey {
        case total, used, remaining
        case resetsAt = "resets_at"
    }
}

enum UserTier: String, Codable, Sendable {
    case free
    case pro
    case premium
}

// MARK: - Watchlist State

@Observable
final class WatchlistState {
    var stocks: [WatchlistStock] = []
    var isLoading: Bool = false

    func contains(_ ticker: String) -> Bool {
        stocks.contains { $0.ticker.uppercased() == ticker.uppercased() }
    }

    func toggle(_ stock: WatchlistStock) {
        if let index = stocks.firstIndex(where: { $0.ticker == stock.ticker }) {
            stocks.remove(at: index)
        } else {
            stocks.insert(stock, at: 0)
        }
    }
}

struct WatchlistStock: Codable, Identifiable, Equatable, Sendable {
    var id: String { ticker }
    let ticker: String
    let companyName: String
    let logoUrl: String?
    var price: Double?
    var changePercent: Double?

    enum CodingKeys: String, CodingKey {
        case ticker
        case companyName = "company_name"
        case logoUrl = "logo_url"
        case price
        case changePercent = "change_percent"
    }
}

// MARK: - Research State

@Observable
final class ResearchState {
    var reports: [ResearchReportSummary] = []
    var generatingReports: Set<String> = [] // Report IDs currently generating
    var selectedPersona: String = "buffett"

    func isGenerating(_ reportId: String) -> Bool {
        generatingReports.contains(reportId)
    }

    var hasActiveGeneration: Bool {
        !generatingReports.isEmpty
    }
}

struct ResearchReportSummary: Codable, Identifiable, Sendable {
    let id: String
    let stockId: String
    let ticker: String
    let companyName: String
    let investorPersona: String
    let status: String
    let title: String?
    let executiveSummary: String?
    let createdAt: String
    let completedAt: String?

    enum CodingKeys: String, CodingKey {
        case id
        case stockId = "stock_id"
        case ticker
        case companyName = "company_name"
        case investorPersona = "investor_persona"
        case status, title
        case executiveSummary = "executive_summary"
        case createdAt = "created_at"
        case completedAt = "completed_at"
    }

    var isCompleted: Bool { status == "completed" }
    var isFailed: Bool { status == "failed" }
    var isPending: Bool { status == "pending" || status == "processing" }
}

// MARK: - Toast Message

struct ToastMessage: Equatable, Sendable {
    let message: String
    let type: ToastType
}

enum ToastType: Sendable {
    case success
    case error
    case info
    case warning
}

// MARK: - Environment Key

extension EnvironmentValues {
    @Entry var appState: AppState = AppState()
}

================================================================================
FILE: frontend/ios/ios/Core/Utilities/AppError.swift
================================================================================

//
//  AppError.swift
//  ios
//
//  Unified Error Handling
//
//  Maps backend error codes and network errors to user-friendly messages.
//  Provides suggested actions for recovery.
//

import Foundation

// MARK: - App Error

/// Unified error type for the application.
/// Maps various error sources to user-actionable messages.
enum AppError: Error, Identifiable, Equatable, Sendable {
    // Network errors
    case noConnection
    case timeout
    case serverError(statusCode: Int)

    // Auth errors
    case unauthorized
    case tokenExpired
    case forbidden

    // Business errors
    case insufficientCredits(required: Int, available: Int)
    case notFound(resource: String)
    case validationFailed(message: String)
    case rateLimited(retryAfter: Int)

    // API errors (from backend)
    case apiError(code: String, message: String)

    // Generic
    case unknown(message: String)

    var id: String {
        switch self {
        case .noConnection: return "no_connection"
        case .timeout: return "timeout"
        case .serverError(let code): return "server_\(code)"
        case .unauthorized: return "unauthorized"
        case .tokenExpired: return "token_expired"
        case .forbidden: return "forbidden"
        case .insufficientCredits: return "insufficient_credits"
        case .notFound(let r): return "not_found_\(r)"
        case .validationFailed: return "validation"
        case .rateLimited: return "rate_limited"
        case .apiError(let code, _): return "api_\(code)"
        case .unknown: return "unknown"
        }
    }

    // MARK: - User-Friendly Messages

    var title: String {
        switch self {
        case .noConnection:
            return "No Connection"
        case .timeout:
            return "Request Timeout"
        case .serverError:
            return "Server Error"
        case .unauthorized, .tokenExpired:
            return "Session Expired"
        case .forbidden:
            return "Access Denied"
        case .insufficientCredits:
            return "Insufficient Credits"
        case .notFound:
            return "Not Found"
        case .validationFailed:
            return "Invalid Input"
        case .rateLimited:
            return "Too Many Requests"
        case .apiError:
            return "Error"
        case .unknown:
            return "Something Went Wrong"
        }
    }

    var message: String {
        switch self {
        case .noConnection:
            return "Please check your internet connection and try again."
        case .timeout:
            return "The request took too long. Please try again."
        case .serverError:
            return "We're experiencing technical difficulties. Please try again later."
        case .unauthorized, .tokenExpired:
            return "Your session has expired. Please sign in again."
        case .forbidden:
            return "You don't have permission to perform this action."
        case .insufficientCredits(let required, let available):
            return "This action requires \(required) credits, but you only have \(available). Upgrade your plan to get more."
        case .notFound(let resource):
            return "The requested \(resource) could not be found."
        case .validationFailed(let msg):
            return msg
        case .rateLimited(let seconds):
            return "Please wait \(seconds) seconds before trying again."
        case .apiError(_, let msg):
            return msg
        case .unknown(let msg):
            return msg.isEmpty ? "An unexpected error occurred. Please try again." : msg
        }
    }

    // MARK: - Suggested Actions

    var suggestedAction: ErrorAction {
        switch self {
        case .noConnection:
            return .waitForConnection
        case .timeout, .serverError:
            return .retry
        case .unauthorized, .tokenExpired:
            return .signIn
        case .forbidden:
            return .goBack
        case .insufficientCredits:
            return .upgrade
        case .notFound:
            return .goBack
        case .validationFailed:
            return .fixInput
        case .rateLimited:
            return .waitAndRetry
        case .apiError, .unknown:
            return .retry
        }
    }

    var isRetryable: Bool {
        switch self {
        case .timeout, .serverError, .rateLimited:
            return true
        default:
            return false
        }
    }

    // MARK: - Factory

    /// Create AppError from any Error
    static func from(_ error: Error) -> AppError {
        // Already an AppError
        if let appError = error as? AppError {
            return appError
        }

        // URLSession errors
        if let urlError = error as? URLError {
            switch urlError.code {
            case .notConnectedToInternet, .networkConnectionLost:
                return .noConnection
            case .timedOut:
                return .timeout
            case .cannotConnectToHost, .cannotFindHost:
                return .serverError(statusCode: 0)
            default:
                return .unknown(message: urlError.localizedDescription)
            }
        }

        // API response errors
        if let apiError = error as? APIError {
            return mapAPIError(apiError)
        }

        return .unknown(message: error.localizedDescription)
    }

    private static func mapAPIError(_ error: APIError) -> AppError {
        switch error {
        case .unauthorized:
            return .unauthorized
        case .forbidden:
            return .forbidden
        case .notFound:
            return .notFound(resource: "item")
        case .serverError(let code):
            return .serverError(statusCode: code)
        case .rateLimited(let retryAfter):
            return .rateLimited(retryAfter: retryAfter)
        case .businessError(let code, let message):
            // Map backend error codes
            if code.starts(with: "BIZ_2001") || code.starts(with: "BIZ_2002") {
                return .insufficientCredits(required: 1, available: 0)
            }
            return .apiError(code: code, message: message)
        case .decodingError:
            return .unknown(message: "Failed to process server response")
        case .networkError(let underlying):
            return .from(underlying)
        case .unknown(let message):
            return .unknown(message: message)
        }
    }
}

// MARK: - Error Action

enum ErrorAction: Sendable {
    case retry
    case waitAndRetry
    case waitForConnection
    case signIn
    case goBack
    case fixInput
    case upgrade
    case contactSupport

    var buttonTitle: String {
        switch self {
        case .retry:
            return "Try Again"
        case .waitAndRetry:
            return "Wait"
        case .waitForConnection:
            return "OK"
        case .signIn:
            return "Sign In"
        case .goBack:
            return "Go Back"
        case .fixInput:
            return "OK"
        case .upgrade:
            return "Upgrade"
        case .contactSupport:
            return "Contact Support"
        }
    }
}

// MARK: - API Error (Network Layer)

/// Low-level API errors before mapping to AppError
/// @unchecked Sendable because Error types may not conform but are used safely
enum APIError: Error, @unchecked Sendable {
    case unauthorized
    case forbidden
    case notFound
    case serverError(statusCode: Int)
    case rateLimited(retryAfter: Int)
    case businessError(code: String, message: String)
    case decodingError(Error)
    case networkError(Error)
    case unknown(message: String)
}

================================================================================
FILE: frontend/ios/ios/Core/ViewModels/BaseViewModel.swift
================================================================================

//
//  BaseViewModel.swift
//  ios
//
//  Base ViewModel Protocol and Helpers
//
//  This provides common patterns for ViewModels:
//  - Loading state management
//  - Error handling
//  - AppState access
//  - Async task management
//
//  Two options for adoption:
//  1. Protocol conformance (recommended for existing code)
//  2. Class inheritance (for new ViewModels)
//

import Foundation
import Combine
import SwiftUI

// MARK: - ViewModel Protocol

/// Protocol that all ViewModels should conform to for consistency.
/// Provides a standard interface for loading, error, and refresh handling.
@MainActor
protocol ViewModelProtocol: ObservableObject {
    /// Whether the ViewModel is currently loading data
    var isLoading: Bool { get set }

    /// Current error message (nil if no error)
    var errorMessage: String? { get set }

    /// Load initial data
    func loadData()

    /// Refresh data (for pull-to-refresh)
    func refresh() async
}

// MARK: - Base ViewModel Class (Optional Inheritance)

/// Base class for ViewModels that need AppState access.
///
/// Usage:
/// ```swift
/// class MyViewModel: BaseViewModel {
///     @Published var items: [Item] = []
///
///     override func loadData() {
///         performTask {
///             self.items = try await self.apiClient.request(...)
///         }
///     }
/// }
/// ```
@MainActor
class BaseViewModel: ObservableObject {

    // MARK: - Published Properties

    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published private(set) var loadingTasks: Set<String> = []

    // MARK: - Dependencies

    /// Reference to global app state
    weak var appState: AppState?

    /// API client for network requests
    var apiClient: APIClient {
        appState?.apiClient ?? APIClient.shared
    }

    // MARK: - Task Management

    /// Currently running tasks (for cancellation)
    private var tasks: [String: Task<Void, Never>] = [:]

    // MARK: - Initialization

    init(appState: AppState? = nil) {
        self.appState = appState
    }

    // MARK: - Loading State

    /// Check if any task is currently loading
    var hasActiveTask: Bool {
        !loadingTasks.isEmpty
    }

    /// Start a named loading task
    func startLoading(_ taskName: String = "default") {
        loadingTasks.insert(taskName)
        isLoading = true
    }

    /// Complete a named loading task
    func stopLoading(_ taskName: String = "default") {
        loadingTasks.remove(taskName)
        isLoading = !loadingTasks.isEmpty
    }

    // MARK: - Error Handling

    /// Set error message and optionally report to AppState
    func setError(_ error: Error, reportGlobally: Bool = false) {
        let appError = AppError.from(error)
        errorMessage = appError.message

        if reportGlobally {
            appState?.handleError(error)
        }
    }

    /// Clear error message
    func clearError() {
        errorMessage = nil
    }

    // MARK: - Async Task Helpers

    /// Perform an async task with automatic loading state and error handling.
    ///
    /// - Parameters:
    ///   - taskName: Unique name for this task (for tracking multiple concurrent tasks)
    ///   - showLoading: Whether to show loading indicator
    ///   - reportError: Whether to set errorMessage on failure
    ///   - operation: The async operation to perform
    func performTask(
        _ taskName: String = "default",
        showLoading: Bool = true,
        reportError: Bool = true,
        operation: @escaping () async throws -> Void
    ) {
        // Cancel existing task with same name
        tasks[taskName]?.cancel()

        tasks[taskName] = Task {
            if showLoading {
                startLoading(taskName)
            }

            clearError()

            do {
                try await operation()
            } catch is CancellationError {
                // Task was cancelled, ignore
            } catch {
                if reportError {
                    setError(error)
                }
            }

            if showLoading {
                stopLoading(taskName)
            }

            tasks.removeValue(forKey: taskName)
        }
    }

    /// Perform a task that returns a value
    func performTask<T>(
        _ taskName: String = "default",
        showLoading: Bool = true,
        reportError: Bool = true,
        operation: @escaping () async throws -> T
    ) async -> T? {
        if showLoading {
            startLoading(taskName)
        }

        clearError()

        defer {
            if showLoading {
                stopLoading(taskName)
            }
        }

        do {
            return try await operation()
        } catch is CancellationError {
            return nil
        } catch {
            if reportError {
                setError(error)
            }
            return nil
        }
    }

    /// Cancel a specific task
    func cancelTask(_ taskName: String) {
        tasks[taskName]?.cancel()
        tasks.removeValue(forKey: taskName)
        stopLoading(taskName)
    }

    /// Cancel all tasks
    func cancelAllTasks() {
        for (name, task) in tasks {
            task.cancel()
            stopLoading(name)
        }
        tasks.removeAll()
    }

    // MARK: - Override Points

    /// Override to load initial data
    func loadData() {
        // Override in subclass
    }

    /// Override for pull-to-refresh
    func refresh() async {
        // Default implementation reloads data
        loadData()
    }

    // MARK: - Cleanup

    deinit {
        // Cancel all tasks when ViewModel is deallocated
        for task in tasks.values {
            task.cancel()
        }
    }
}

// MARK: - View Extensions

/// View modifier for attaching a ViewModel to a View
struct ViewModelModifier<VM: ObservableObject>: ViewModifier {
    @StateObject var viewModel: VM

    func body(content: Content) -> some View {
        content
            .environmentObject(viewModel)
    }
}

extension View {
    /// Attach a ViewModel to a View
    func viewModel<VM: ObservableObject>(_ viewModel: @autoclosure @escaping () -> VM) -> some View {
        modifier(ViewModelModifier(viewModel: viewModel()))
    }
}

// MARK: - Loading State Helpers

/// Represents a loadable resource with loading/success/error states
enum LoadingState<T> {
    case idle
    case loading
    case success(T)
    case failure(AppError)

    var isLoading: Bool {
        if case .loading = self { return true }
        return false
    }

    var value: T? {
        if case .success(let value) = self { return value }
        return nil
    }

    var error: AppError? {
        if case .failure(let error) = self { return error }
        return nil
    }
}

// MARK: - Refreshable Protocol

/// Protocol for ViewModels that support refresh
@MainActor
protocol Refreshable {
    func refresh() async
}

================================================================================
FILE: frontend/ios/ios/Models/AudioPlayerModels.swift
================================================================================

//
//  AudioPlayerModels.swift
//  ios
//
//  Data models for the Global Audio Player system
//

import Foundation
import SwiftUI

// MARK: - Audio Episode
/// Represents a playable audio episode (Money Moves story, Book chapter, etc.)
struct AudioEpisode: Identifiable, Equatable {
    let id: String
    let title: String
    let subtitle: String
    let artworkGradientColors: [String]
    let artworkIcon: String
    let duration: TimeInterval
    let category: AudioCategory
    let authorName: String
    let sourceId: String // Original article/book ID for navigation

    var formattedDuration: String {
        let minutes = Int(duration) / 60
        let seconds = Int(duration) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }

    var artworkColors: [Color] {
        artworkGradientColors.map { Color(hex: $0) }
    }

    static func == (lhs: AudioEpisode, rhs: AudioEpisode) -> Bool {
        lhs.id == rhs.id
    }
}

// MARK: - Audio Category
enum AudioCategory: String, CaseIterable {
    case moneyMoves = "Money Moves"
    case books = "Books"
    case dailyBrief = "Daily Brief"
    case podcast = "Podcast"

    var icon: String {
        switch self {
        case .moneyMoves: return "chart.line.uptrend.xyaxis"
        case .books: return "book.fill"
        case .dailyBrief: return "newspaper.fill"
        case .podcast: return "mic.fill"
        }
    }

    var accentColor: Color {
        switch self {
        case .moneyMoves: return AppColors.primaryBlue
        case .books: return Color(hex: "A855F7")
        case .dailyBrief: return AppColors.alertOrange
        case .podcast: return AppColors.bullish
        }
    }
}

// MARK: - Playback State
enum PlaybackState: Equatable {
    case idle
    case loading
    case playing
    case paused
    case error(String)

    var isActive: Bool {
        switch self {
        case .playing, .paused, .loading:
            return true
        default:
            return false
        }
    }
}

// MARK: - Playback Speed
enum PlaybackSpeed: Double, CaseIterable, Identifiable {
    case slow = 0.5
    case normal = 1.0
    case faster = 1.25
    case fast = 1.5
    case veryFast = 1.75
    case double = 2.0

    var id: Double { rawValue }

    var label: String {
        switch self {
        case .slow: return "0.5x"
        case .normal: return "1x"
        case .faster: return "1.25x"
        case .fast: return "1.5x"
        case .veryFast: return "1.75x"
        case .double: return "2x"
        }
    }
}

// MARK: - Sleep Timer Option
enum SleepTimerOption: Int, CaseIterable, Identifiable {
    case off = 0
    case fiveMinutes = 5
    case tenMinutes = 10
    case fifteenMinutes = 15
    case thirtyMinutes = 30
    case oneHour = 60
    case endOfEpisode = -1

    var id: Int { rawValue }

    var label: String {
        switch self {
        case .off: return "Off"
        case .fiveMinutes: return "5 minutes"
        case .tenMinutes: return "10 minutes"
        case .fifteenMinutes: return "15 minutes"
        case .thirtyMinutes: return "30 minutes"
        case .oneHour: return "1 hour"
        case .endOfEpisode: return "End of episode"
        }
    }
}

// MARK: - Audio Queue Item
struct AudioQueueItem: Identifiable {
    let id = UUID()
    let episode: AudioEpisode
    var isCurrentlyPlaying: Bool = false
}

// MARK: - Sample Data
extension AudioEpisode {
    static let sampleMoneyMoves = AudioEpisode(
        id: "mm-digital-finance-001",
        title: "The Future of Digital Finance",
        subtitle: "Exploring fintech innovation and banking transformation",
        artworkGradientColors: ["1E3A5F", "0D1B2A", "1B263B"],
        artworkIcon: "chart.line.uptrend.xyaxis",
        duration: 1080, // 18 minutes
        category: .moneyMoves,
        authorName: "The Alpha",
        sourceId: "article-digital-finance-001"
    )

    static let sampleFTX = AudioEpisode(
        id: "mm-ftx-collapse-001",
        title: "The FTX Collapse",
        subtitle: "Crypto's biggest fraud unraveled",
        artworkGradientColors: ["DC2626", "991B1B", "7F1D1D"],
        artworkIcon: "exclamationmark.triangle.fill",
        duration: 1080, // 18 minutes
        category: .moneyMoves,
        authorName: "The Alpha",
        sourceId: "article-ftx-001"
    )

    static let sampleBook = AudioEpisode(
        id: "book-intelligent-investor-ch1",
        title: "The Intelligent Investor - Chapter 1",
        subtitle: "Investment vs. Speculation",
        artworkGradientColors: ["059669", "047857", "064E3B"],
        artworkIcon: "book.fill",
        duration: 2700, // 45 minutes
        category: .books,
        authorName: "Benjamin Graham",
        sourceId: "book-intelligent-investor"
    )

    static let sampleDailyBrief = AudioEpisode(
        id: "daily-brief-jan-30",
        title: "Morning Market Brief",
        subtitle: "January 30, 2026 - Key market movers",
        artworkGradientColors: ["F97316", "EA580C", "C2410C"],
        artworkIcon: "newspaper.fill",
        duration: 420, // 7 minutes
        category: .dailyBrief,
        authorName: "AI Value Investor",
        sourceId: "brief-jan-30-2026"
    )
}

================================================================================
FILE: frontend/ios/ios/Models/BookCoreDetailModels.swift
================================================================================

//
//  BookCoreDetailModels.swift
//  ios
//
//  Data models for the Book Core Detail View content
//  Represents detailed content for each core chapter
//

import Foundation
import SwiftUI

// MARK: - Core Chapter Content
/// Full content model for a core chapter detail view
struct CoreChapterContent: Identifiable {
    let id = UUID()
    let chapterNumber: Int
    let chapterTitle: String
    let bookTitle: String
    let bookAuthor: String
    let sections: [CoreChapterSection]
    let audioDurationSeconds: Int
    let currentProgress: Double // 0.0 - 1.0

    var formattedDuration: String {
        let minutes = audioDurationSeconds / 60
        return "\(minutes) min"
    }

    var formattedChapterLabel: String {
        "Core \(chapterNumber)"
    }
}

// MARK: - Core Chapter Section
/// Represents a section within a core chapter
struct CoreChapterSection: Identifiable {
    let id = UUID()
    let type: CoreSectionType
    let title: String?
    let content: CoreSectionContent
}

// MARK: - Core Section Type
enum CoreSectionType: String {
    case heading          // Main section heading
    case paragraph        // Regular text paragraph
    case quote            // Highlighted quote
    case assetList        // List of asset categories
    case actionPlan       // Action steps section
    case bulletPoints     // Bulleted list
    case callout          // Highlighted callout box
}

// MARK: - Core Section Content
/// Union type for different section content
enum CoreSectionContent {
    case text(String)
    case richText(AttributedString)
    case quote(QuoteContent)
    case assetList([AssetCategory])
    case actionPlan([ActionStep])
    case bulletPoints([BulletPoint])
    case callout(CalloutContent)
}

// MARK: - Quote Content
struct QuoteContent: Identifiable {
    let id = UUID()
    let text: String
    let author: String
    let source: String?
}

// MARK: - Asset Category
struct AssetCategory: Identifiable {
    let id = UUID()
    let icon: String
    let iconColor: String
    let title: String
    let description: String
}

// MARK: - Action Step
struct ActionStep: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let isCompleted: Bool
}

// MARK: - Bullet Point
struct BulletPoint: Identifiable {
    let id = UUID()
    let text: String
    let isHighlighted: Bool
}

// MARK: - Callout Content
struct CalloutContent: Identifiable {
    let id = UUID()
    let title: String
    let text: String
    let style: CoreCalloutStyle
}

enum CoreCalloutStyle {
    case info
    case warning
    case success
    case insight

    var backgroundColor: Color {
        switch self {
        case .info: return Color(hex: "3B82F6").opacity(0.15)
        case .warning: return Color(hex: "F59E0B").opacity(0.15)
        case .success: return Color(hex: "22C55E").opacity(0.15)
        case .insight: return Color(hex: "A855F7").opacity(0.15)
        }
    }

    var iconColor: Color {
        switch self {
        case .info: return Color(hex: "3B82F6")
        case .warning: return Color(hex: "F59E0B")
        case .success: return Color(hex: "22C55E")
        case .insight: return Color(hex: "A855F7")
        }
    }

    var iconName: String {
        switch self {
        case .info: return "info.circle.fill"
        case .warning: return "exclamationmark.triangle.fill"
        case .success: return "checkmark.circle.fill"
        case .insight: return "lightbulb.fill"
        }
    }
}

// MARK: - Audio Transition State
/// Represents the state for chapter audio transitions
struct ChapterAudioTransition {
    let fromChapter: Int
    let toChapter: Int
    let pauseDurationSeconds: Int
    let transitionMessage: String

    static func createTransition(from: Int, to: Int) -> ChapterAudioTransition {
        ChapterAudioTransition(
            fromChapter: from,
            toChapter: to,
            pauseDurationSeconds: 10,
            transitionMessage: "Think about those action steps for a moment... Now, let's move to Core \(to)."
        )
    }
}

// MARK: - Sample Data Extensions
extension CoreChapterContent {
    /// Sample data for "Mastering the Financial Scorecard" - Chapter 2 of Rich Dad Poor Dad
    static let sampleFinancialScorecard = CoreChapterContent(
        chapterNumber: 2,
        chapterTitle: "Mastering the Financial Scorecard",
        bookTitle: "Rich Dad Poor Dad",
        bookAuthor: "Robert T. Kiyosaki",
        sections: [
            // Section 1: The Illusion of Wealth
            CoreChapterSection(
                type: .heading,
                title: nil,
                content: .text("The Illusion of Wealth")
            ),
            CoreChapterSection(
                type: .paragraph,
                title: nil,
                content: .text("Here is the secret that keeps the middle class exhausted: You are looking at the wrong scoreboard. Most professionals believe that a high salary equals wealth. It doesn't. You can earn $250,000 a year and still be technically insolvent if your monthly burn rate matches your income. The friction isn't your paycheck; it's your financial literacy. You have been trained to read words, but you haven't been trained to read numbers. Consequently, you spend your life building someone else's business (your boss's), buying someone else's investments (the bank's), and paying someone else's bills (the government's).")
            ),

            // Quote Section
            CoreChapterSection(
                type: .quote,
                title: nil,
                content: .quote(QuoteContent(
                    text: "\"The rich don't work for money. They make money work for them. Assets generate income whether you're working or notâ€”that's the key to financial freedom.\"",
                    author: "Robert Kiyosaki",
                    source: "Rich Dad Poor Dad"
                ))
            ),

            // Section 2: The Tale of Two Columns
            CoreChapterSection(
                type: .heading,
                title: nil,
                content: .text("The Tale of Two Columns")
            ),
            CoreChapterSection(
                type: .paragraph,
                title: nil,
                content: .text("The author illustrates this with a simple, brutal truth that shattered the worldview of a young couple. They celebrate a pay raise by buying their \"dream home.\" They proudly list this house under the \"Asset\" column of their financial statement. But the author's mentor, the \"Rich Dad,\" draws a simple diagram to prove them wrong. He defines an asset not by accounting tradition, but by the direction of cash flow. An asset puts money in your pocket. A liability takes money out. Because that house requires a mortgage, property taxes, insurance, and maintenance, cash is flowing out. Therefore, the house is a liability.")
            ),
            CoreChapterSection(
                type: .paragraph,
                title: nil,
                content: .text("The \"Rich Dad\" explains that the poor work for money to pay expenses; the middle class buys liabilities they think are assets (like houses and cars); but the rich focus entirely on the Asset Columnâ€”acquiring things that generate cash while they sleep.")
            ),

            // Asset Categories Section
            CoreChapterSection(
                type: .assetList,
                title: "True Assets",
                content: .assetList([
                    AssetCategory(
                        icon: "building.2.fill",
                        iconColor: "F59E0B",
                        title: "Real Estate",
                        description: "Tangible, proven track record, generates rental income, tax benefits, but requires significant capital and management."
                    ),
                    AssetCategory(
                        icon: "bitcoinsign.circle.fill",
                        iconColor: "F7931A",
                        title: "Cryptocurrency",
                        description: "Highly liquid, 24/7 markets, potential for high returns, but volatile and requires technical knowledge and risk management."
                    ),
                    AssetCategory(
                        icon: "laptopcomputer",
                        iconColor: "8B5CF6",
                        title: "Digital Assets",
                        description: "Online businesses, SaaS products, digital courses, and content libraries generate passive income with minimal overhead. Scalable and location-independent."
                    )
                ])
            ),

            // Section 3: The New Mask
            CoreChapterSection(
                type: .heading,
                title: nil,
                content: .text("The New Mask")
            ),
            CoreChapterSection(
                type: .paragraph,
                title: nil,
                content: .text("Now, the \"Liability Trap\" is even more sophisticated. It's no longer just a house; it's digital. It is the crypto \"investment\" that has zero utility and generates no yieldâ€”that is speculation, not an asset. It is the five different AI software subscriptions you pay for monthly but don't use to generate income.")
            ),
            CoreChapterSection(
                type: .paragraph,
                title: nil,
                content: .text("In the modern era, true assets have evolved. An asset might be a high-yield DeFi staking protocol, a dividend-paying ETF, or a piece of code you wrote once that sells itself repeatedly. Conversely, \"Buy Now, Pay Later\" schemes for consumer goods are the modern shackles. The principle remains: if you have to work to keep it, it's a job. If you have to pay to keep it, it's a liability. If it pays you to keep it, it's an asset.")
            ),

            // Section 4: The Action Plan
            CoreChapterSection(
                type: .heading,
                title: nil,
                content: .text("The Action Plan")
            ),
            CoreChapterSection(
                type: .actionPlan,
                title: nil,
                content: .actionPlan([
                    ActionStep(
                        title: "The Ruthless Audit",
                        description: "Tonight, draw a T-chart. List everything you own. If it requires money to maintain and yields zero cash flow (your car, your house, your unused tech), move it to the Liability column immediately. Stop lying to yourself.",
                        isCompleted: false
                    ),
                    ActionStep(
                        title: "The Replacement Ratio",
                        description: "For every new liability you want (e.g., a new phone), you must first buy an asset that covers the monthly cost of that liability. Do not buy the toy until the asset buys it for you.",
                        isCompleted: false
                    )
                ])
            )
        ],
        audioDurationSeconds: 1080,
        currentProgress: 0.0
    )

    /// Sample data for "De-Programming the Employee Mindset" - Chapter 1
    static let sampleEmployeeMindset = CoreChapterContent(
        chapterNumber: 1,
        chapterTitle: "De-Programming the \"Employee\" Mindset",
        bookTitle: "Rich Dad Poor Dad",
        bookAuthor: "Robert T. Kiyosaki",
        sections: [
            CoreChapterSection(
                type: .heading,
                title: nil,
                content: .text("The Rat Race")
            ),
            CoreChapterSection(
                type: .paragraph,
                title: nil,
                content: .text("Most people are trapped in a cycle they don't even see. Wake up, go to work, pay bills, repeat. The fear of not having enough money drives them to work harder, but the greed for more possessions keeps them spending everything they earn. This is the Rat Raceâ€”running faster and faster on a wheel that goes nowhere.")
            ),
            CoreChapterSection(
                type: .quote,
                title: nil,
                content: .quote(QuoteContent(
                    text: "\"The fear of being different prevents most people from seeking new ways to solve their problems.\"",
                    author: "Robert Kiyosaki",
                    source: "Rich Dad Poor Dad"
                ))
            ),
            CoreChapterSection(
                type: .heading,
                title: nil,
                content: .text("Two Fathers, Two Philosophies")
            ),
            CoreChapterSection(
                type: .paragraph,
                title: nil,
                content: .text("Robert's biological fatherâ€”his \"Poor Dad\"â€”was highly educated, had a PhD, and held prestigious positions in education. He believed in working hard, getting good grades, and finding a secure job with benefits. His \"Rich Dad\"â€”his best friend's fatherâ€”never finished eighth grade but became one of the wealthiest men in Hawaii.")
            ),
            CoreChapterSection(
                type: .bulletPoints,
                title: "The Two Mindsets",
                content: .bulletPoints([
                    BulletPoint(text: "Poor Dad: \"I can't afford it\" - A statement that shuts down thinking", isHighlighted: false),
                    BulletPoint(text: "Rich Dad: \"How can I afford it?\" - A question that opens possibilities", isHighlighted: true),
                    BulletPoint(text: "Poor Dad: \"Study hard so you can find a good company to work for\"", isHighlighted: false),
                    BulletPoint(text: "Rich Dad: \"Study hard so you can find a good company to buy\"", isHighlighted: true)
                ])
            ),
            CoreChapterSection(
                type: .actionPlan,
                title: nil,
                content: .actionPlan([
                    ActionStep(
                        title: "Question Your Beliefs",
                        description: "Write down three financial beliefs you inherited from your parents. For each one, ask: \"Is this serving me, or limiting me?\"",
                        isCompleted: false
                    ),
                    ActionStep(
                        title: "Change Your Language",
                        description: "For the next week, whenever you think \"I can't afford it,\" replace it with \"How can I afford it?\" Notice how this shifts your thinking from defeat to creativity.",
                        isCompleted: false
                    )
                ])
            )
        ],
        audioDurationSeconds: 900,
        currentProgress: 1.0
    )
}

extension AssetCategory {
    static let sampleCategories: [AssetCategory] = [
        AssetCategory(
            icon: "building.2.fill",
            iconColor: "F59E0B",
            title: "Real Estate",
            description: "Tangible, proven track record, generates rental income, tax benefits, but requires significant capital and management."
        ),
        AssetCategory(
            icon: "bitcoinsign.circle.fill",
            iconColor: "F7931A",
            title: "Cryptocurrency",
            description: "Highly liquid, 24/7 markets, potential for high returns, but volatile and requires technical knowledge and risk management."
        ),
        AssetCategory(
            icon: "laptopcomputer",
            iconColor: "8B5CF6",
            title: "Digital Assets",
            description: "Online businesses, SaaS products, digital courses, and content libraries generate passive income with minimal overhead. Scalable and location-independent."
        )
    ]
}

================================================================================
FILE: frontend/ios/ios/Models/ChatConversationModels.swift
================================================================================

//
//  ChatConversationModels.swift
//  ios
//
//  Data models for rich chat conversation content
//

import Foundation
import SwiftUI

// MARK: - Chat Message Role
enum ChatMessageRole {
    case user
    case assistant
}

// MARK: - Rich Content Type
enum RichContentType {
    case text(String)
    case sentimentAnalysis(SentimentAnalysis)
    case stockPerformance(StockPerformance)
    case riskFactors(RiskFactorsData)
    case tip(TipData)
    case bulletPoints([ChatBulletPoint])
}

// MARK: - Rich Chat Message
struct RichChatMessage: Identifiable {
    let id = UUID()
    let role: ChatMessageRole
    let content: [RichContentType]
    let timestamp: Date

    var formattedTime: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a"
        return formatter.string(from: timestamp)
    }
}

// MARK: - Sentiment Analysis
struct SentimentAnalysis: Identifiable {
    let id = UUID()
    let overallSentiment: SentimentType
    let percentage: Int
    let bulletPoints: [ChatBulletPoint]
    let dataUpdatedText: String

    enum SentimentType: String {
        case bullish = "Bullish"
        case bearish = "Bearish"
        case neutral = "Neutral"

        var color: Color {
            switch self {
            case .bullish: return AppColors.bullish
            case .bearish: return AppColors.bearish
            case .neutral: return AppColors.neutral
            }
        }
    }
}

// MARK: - Chat Bullet Point
struct ChatBulletPoint: Identifiable {
    let id = UUID()
    let text: String
    let indicatorType: IndicatorType

    enum IndicatorType {
        case success  // Green checkmark
        case warning  // Yellow/amber triangle
        case info     // Blue info circle

        var color: Color {
            switch self {
            case .success: return AppColors.bullish
            case .warning: return AppColors.neutral
            case .info: return AppColors.primaryBlue
            }
        }

        var iconName: String {
            switch self {
            case .success: return "checkmark.circle.fill"
            case .warning: return "exclamationmark.triangle.fill"
            case .info: return "info.circle.fill"
            }
        }
    }
}

// MARK: - Stock Performance
struct StockPerformance: Identifiable {
    let id = UUID()
    let currentPrice: Double
    let changePercent: Double
    let period: String
    let dayHigh: Double
    let dayLow: Double
    let volume: String
    let avgVolume: String
    let chartData: [Double]
    let followUpQuestion: String?

    var isPositive: Bool {
        changePercent >= 0
    }

    var formattedPrice: String {
        String(format: "$%.2f", currentPrice)
    }

    var formattedChange: String {
        let sign = changePercent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", changePercent))%"
    }

    var formattedDayHigh: String {
        String(format: "$%.2f", dayHigh)
    }

    var formattedDayLow: String {
        String(format: "$%.2f", dayLow)
    }
}

// MARK: - Risk Factor
struct RiskFactor: Identifiable {
    let id = UUID()
    let iconName: String
    let iconColor: Color
    let title: String
    let description: String
    let impactLevel: ImpactLevel

    enum ImpactLevel: String {
        case high = "High Impact"
        case medium = "Medium Impact"
        case variable = "Variable Impact"

        var color: Color {
            switch self {
            case .high: return AppColors.bearish
            case .medium: return AppColors.neutral
            case .variable: return AppColors.primaryBlue
            }
        }
    }
}

// MARK: - Risk Factors Data
struct RiskFactorsData: Identifiable {
    let id = UUID()
    let introText: String
    let factors: [RiskFactor]
}

// MARK: - Tip Data
struct TipData: Identifiable {
    let id = UUID()
    let title: String
    let content: String
}

// MARK: - Page Indicator
struct PageIndicatorData {
    let currentPage: Int
    let totalPages: Int
}

// MARK: - Sample Data
extension RichChatMessage {
    static let sampleConversation: [RichChatMessage] = [
        // User asks about Tesla
        RichChatMessage(
            role: .user,
            content: [.text("What's the current sentiment around Tesla stock?")],
            timestamp: Calendar.current.date(byAdding: .minute, value: -7, to: Date())!
        ),

        // AI responds with sentiment analysis
        RichChatMessage(
            role: .assistant,
            content: [
                .text("Based on the latest market data and social sentiment analysis, here's what I found about Tesla (TSLA):"),
                .sentimentAnalysis(SentimentAnalysis(
                    overallSentiment: .bullish,
                    percentage: 68,
                    bulletPoints: [
                        ChatBulletPoint(text: "Strong delivery numbers exceeded expectations in Q4", indicatorType: .success),
                        ChatBulletPoint(text: "Cybertruck production ramping up successfully", indicatorType: .success),
                        ChatBulletPoint(text: "Competition intensifying in EV market", indicatorType: .warning),
                        ChatBulletPoint(text: "Analyst price targets range from $180-$350", indicatorType: .info)
                    ],
                    dataUpdatedText: "Data updated 5 minutes ago"
                ))
            ],
            timestamp: Calendar.current.date(byAdding: .minute, value: -6, to: Date())!
        ),

        // User asks about performance
        RichChatMessage(
            role: .user,
            content: [.text("How's Tesla's stock performance?")],
            timestamp: Calendar.current.date(byAdding: .minute, value: -5, to: Date())!
        ),

        // AI responds with stock performance
        RichChatMessage(
            role: .assistant,
            content: [
                .text("Here's Tesla's stock performance over the past month:"),
                .stockPerformance(StockPerformance(
                    currentPrice: 242.84,
                    changePercent: 8.7,
                    period: "1 Month",
                    dayHigh: 245.12,
                    dayLow: 238.45,
                    volume: "124.5M",
                    avgVolume: "98.2M",
                    chartData: [220, 225, 218, 230, 235, 228, 240, 238, 245, 242],
                    followUpQuestion: "Would you like me to analyze any specific timeframe or technical indicators?"
                ))
            ],
            timestamp: Calendar.current.date(byAdding: .minute, value: -4, to: Date())!
        ),

        // User asks about risks
        RichChatMessage(
            role: .user,
            content: [.text("What are the key risks to consider?")],
            timestamp: Calendar.current.date(byAdding: .minute, value: -2, to: Date())!
        ),

        // AI responds with risk factors
        RichChatMessage(
            role: .assistant,
            content: [
                .text("Here are the major risk factors for Tesla investors to monitor:"),
                .riskFactors(RiskFactorsData(
                    introText: "",
                    factors: [
                        RiskFactor(
                            iconName: "exclamationmark.triangle.fill",
                            iconColor: AppColors.bearish,
                            title: "Market Competition",
                            description: "Traditional automakers and new EV startups intensifying competition globally",
                            impactLevel: .high
                        ),
                        RiskFactor(
                            iconName: "doc.text.fill",
                            iconColor: AppColors.neutral,
                            title: "Regulatory Changes",
                            description: "Potential changes in EV subsidies and environmental regulations",
                            impactLevel: .medium
                        ),
                        RiskFactor(
                            iconName: "shippingbox.fill",
                            iconColor: AppColors.neutral,
                            title: "Supply Chain Constraints",
                            description: "Battery materials and semiconductor availability concerns",
                            impactLevel: .medium
                        ),
                        RiskFactor(
                            iconName: "dollarsign.circle.fill",
                            iconColor: AppColors.primaryBlue,
                            title: "Valuation Concerns",
                            description: "High P/E ratio compared to traditional automakers",
                            impactLevel: .variable
                        )
                    ]
                )),
                .tip(TipData(
                    title: "RISK MITIGATION TIP",
                    content: "Consider diversifying your portfolio and maintaining a long-term investment horizon to weather short-term volatility."
                ))
            ],
            timestamp: Calendar.current.date(byAdding: .minute, value: 0, to: Date())!
        )
    ]
}

================================================================================
FILE: frontend/ios/ios/Models/ChatModels.swift
================================================================================

//
//  ChatModels.swift
//  ios
//
//  Data models for the Chat tab in Learn/Wiser section
//

import Foundation
import SwiftUI

// MARK: - Suggestion Chip Type
enum SuggestionChipType {
    case question
    case hashtag
    case ticker

    var textColor: Color {
        switch self {
        case .question: return AppColors.primaryBlue
        case .hashtag: return AppColors.neutral
        case .ticker: return AppColors.bullish
        }
    }

    var backgroundColor: Color {
        switch self {
        case .question: return AppColors.primaryBlue.opacity(0.15)
        case .hashtag: return AppColors.neutral.opacity(0.15)
        case .ticker: return AppColors.bullish.opacity(0.15)
        }
    }

    var borderColor: Color {
        switch self {
        case .question: return AppColors.primaryBlue.opacity(0.3)
        case .hashtag: return AppColors.neutral.opacity(0.3)
        case .ticker: return AppColors.bullish.opacity(0.3)
        }
    }
}

// MARK: - Suggestion Chip
struct SuggestionChip: Identifiable {
    let id = UUID()
    let text: String
    let type: SuggestionChipType

    static func inferType(from text: String) -> SuggestionChipType {
        if text.contains("#") && text.contains("?") {
            return .question
        } else if text.hasPrefix("#") {
            return .hashtag
        } else if text.contains("?") {
            return .question
        } else if text.contains("$") || text.uppercased() == text {
            return .ticker
        }
        return .question
    }
}

// MARK: - Chat Message
struct ChatMessage: Identifiable {
    let id = UUID()
    let content: String
    let isFromUser: Bool
    let timestamp: Date
    let citations: [ChatCitation]?

    init(content: String, isFromUser: Bool, timestamp: Date = Date(), citations: [ChatCitation]? = nil) {
        self.content = content
        self.isFromUser = isFromUser
        self.timestamp = timestamp
        self.citations = citations
    }
}

// MARK: - Chat Citation
struct ChatCitation: Identifiable {
    let id = UUID()
    let source: String
    let title: String
    let url: String?
}

// MARK: - Chat Session
struct ChatSession: Identifiable {
    let id = UUID()
    let title: String
    let previewMessage: String
    let lastMessageAt: Date
    let messageCount: Int

    var timeAgo: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: lastMessageAt, relativeTo: Date())
    }
}

// MARK: - Chat Input Attachment Type
enum ChatAttachmentType: String, CaseIterable {
    case voice = "Voice"
    case image = "Image"

    var iconName: String {
        switch self {
        case .voice: return "mic.fill"
        case .image: return "photo.fill"
        }
    }
}

// MARK: - Chat History Item Type
enum ChatHistoryItemType: String, CaseIterable {
    case book = "BOOK"
    case concept = "CONCEPT"
    case stock = "STOCK"
    case normal = "NORMAL"
    case journey = "JOURNEY"
    case report = "REPORT"

    var displayName: String {
        rawValue
    }

    var textColor: Color {
        switch self {
        case .book: return Color(hex: "22C55E") // Green
        case .concept: return Color(hex: "3B82F6") // Blue
        case .stock: return Color(hex: "22C55E") // Green
        case .normal: return AppColors.textSecondary
        case .journey: return Color(hex: "F59E0B") // Amber
        case .report: return Color(hex: "EF4444") // Red
        }
    }
}

// MARK: - Chat History Item
struct ChatHistoryItem: Identifiable {
    let id = UUID()
    let type: ChatHistoryItemType
    let title: String
    let preview: String
    let timestamp: Date
    let isSaved: Bool

    var timeAgo: String {
        let calendar = Calendar.current
        let now = Date()

        if calendar.isDateInToday(timestamp) {
            let formatter = RelativeDateTimeFormatter()
            formatter.unitsStyle = .abbreviated
            return formatter.localizedString(for: timestamp, relativeTo: now)
        } else if calendar.isDateInYesterday(timestamp) {
            return "1d ago"
        } else {
            let formatter = DateFormatter()
            formatter.dateFormat = "MM/dd/yyyy"
            return formatter.string(from: timestamp)
        }
    }
}

// MARK: - Chat History Section
enum ChatHistorySection: String, CaseIterable {
    case today = "TODAY"
    case yesterday = "YESTERDAY"
    case older = "OLDER"
}

// MARK: - Chat History Grouped
struct ChatHistoryGroup: Identifiable {
    let id = UUID()
    let section: ChatHistorySection
    let items: [ChatHistoryItem]
}

// MARK: - Sample Data
extension SuggestionChip {
    static let sampleData: [SuggestionChip] = [
        SuggestionChip(text: "Should I buy #AAPL?", type: .question),
        SuggestionChip(text: "#Tech Stocks", type: .hashtag),
        SuggestionChip(text: "#Crypto", type: .hashtag),
        SuggestionChip(text: "What does this chart mean?", type: .question),
        SuggestionChip(text: "Why #TSLA moved?", type: .ticker)
    ]
}

extension ChatSession {
    static let sampleData: [ChatSession] = [
        ChatSession(
            title: "Apple Stock Analysis",
            previewMessage: "Based on the current P/E ratio and market conditions...",
            lastMessageAt: Calendar.current.date(byAdding: .hour, value: -2, to: Date())!,
            messageCount: 5
        ),
        ChatSession(
            title: "Understanding P/E Ratios",
            previewMessage: "The P/E ratio is calculated by dividing...",
            lastMessageAt: Calendar.current.date(byAdding: .day, value: -1, to: Date())!,
            messageCount: 8
        ),
        ChatSession(
            title: "Crypto Market Overview",
            previewMessage: "The cryptocurrency market has been volatile...",
            lastMessageAt: Calendar.current.date(byAdding: .day, value: -3, to: Date())!,
            messageCount: 12
        )
    ]
}

extension ChatHistoryItem {
    // Today items
    static let todayItems: [ChatHistoryItem] = [
        ChatHistoryItem(
            type: .book,
            title: "The Psychology of Money",
            preview: "Discussing key insights from Morgan Housel's book about wealth, greed, and...",
            timestamp: Calendar.current.date(byAdding: .hour, value: -2, to: Date())!,
            isSaved: false
        ),
        ChatHistoryItem(
            type: .concept,
            title: "Compound Interest Explained",
            preview: "Understanding the power of compound interest and how it can exponentially gro...",
            timestamp: Calendar.current.date(byAdding: .hour, value: -4, to: Date())!,
            isSaved: false
        ),
        ChatHistoryItem(
            type: .stock,
            title: "AAPL Stock Analysis",
            preview: "Current price: $182.45 (+2.3%) â€¢ Market cap: $2.85T â€¢ P/E ratio: 29.4 â€¢ Analyzin...",
            timestamp: Calendar.current.date(byAdding: .hour, value: -5, to: Date())!,
            isSaved: false
        )
    ]

    // Yesterday items
    static let yesterdayItems: [ChatHistoryItem] = [
        ChatHistoryItem(
            type: .normal,
            title: "What is a report?",
            preview: "Comprehensive analysis of market trends, sector performance, and economic...",
            timestamp: Calendar.current.date(byAdding: .day, value: -1, to: Date())!,
            isSaved: false
        ),
        ChatHistoryItem(
            type: .journey,
            title: "My Investment Journey",
            preview: "Planning a 10-year investment strategy from beginner to advanced portfolio...",
            timestamp: Calendar.current.date(byAdding: .day, value: -1, to: Date())!,
            isSaved: false
        ),
        ChatHistoryItem(
            type: .normal,
            title: "What is Rich Dad Poor Dad book?",
            preview: "Exploring Robert Kiyosaki's principles on financial education and building wealth...",
            timestamp: Calendar.current.date(byAdding: .day, value: -1, to: Date())!,
            isSaved: false
        ),
        ChatHistoryItem(
            type: .normal,
            title: "TSLA Review",
            preview: "Current price: $248.92 (-1.2%) â€¢ Market cap: $789B â€¢ Analyzing Tesla's recent...",
            timestamp: Calendar.current.date(byAdding: .day, value: -1, to: Date())!,
            isSaved: false
        )
    ]

    // Older items
    static let olderItems: [ChatHistoryItem] = [
        ChatHistoryItem(
            type: .stock,
            title: "AMZN E-commerce Dominance",
            preview: "Current price: $151.23 (+0.9%) â€¢ AWS cloud services and retail expansion...",
            timestamp: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 20))!,
            isSaved: false
        ),
        ChatHistoryItem(
            type: .report,
            title: "Global Economic Outlook",
            preview: "Comprehensive analysis of GDP growth, inflation trends, and monetary policy...",
            timestamp: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 18))!,
            isSaved: true
        ),
        ChatHistoryItem(
            type: .book,
            title: "The Millionaire Next Door",
            preview: "Research-based insights on wealth accumulation habits and the frugal...",
            timestamp: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 18))!,
            isSaved: false
        ),
        ChatHistoryItem(
            type: .journey,
            title: "Debt Elimination Strategy",
            preview: "Systematic approach to becoming debt-free using snowball and avalanche...",
            timestamp: Calendar.current.date(from: DateComponents(year: 2025, month: 11, day: 25))!,
            isSaved: true
        ),
        ChatHistoryItem(
            type: .normal,
            title: "Risk-Adjusted Returns",
            preview: "Understanding Sharpe ratio, beta, and alpha for evaluating investment...",
            timestamp: Calendar.current.date(from: DateComponents(year: 2025, month: 11, day: 23))!,
            isSaved: false
        )
    ]

    static let sampleGroups: [ChatHistoryGroup] = [
        ChatHistoryGroup(section: .today, items: todayItems),
        ChatHistoryGroup(section: .yesterday, items: yesterdayItems),
        ChatHistoryGroup(section: .older, items: olderItems)
    ]
}

================================================================================
FILE: frontend/ios/ios/Models/GrowthModels.swift
================================================================================

//
//  GrowthModels.swift
//  ios
//
//  Data models for the Growth Section in the Financial tab
//

import Foundation
import SwiftUI

// MARK: - Growth Metric Type
enum GrowthMetricType: String, CaseIterable, Identifiable {
    case eps = "EPS"
    case revenue = "Revenue"
    case netIncome = "Net Income"
    case operatingProfit = "Operating Profit"
    case freeCashFlow = "Free Cash Flow"

    var id: String { rawValue }

    var description: String {
        switch self {
        case .eps:
            return "Earnings Per Share measures the company's profit allocated to each outstanding share of common stock."
        case .revenue:
            return "Total income generated from sales of goods or services before any expenses are deducted."
        case .netIncome:
            return "The company's total profit after all expenses, taxes, and costs have been subtracted from revenue."
        case .operatingProfit:
            return "Profit from core business operations, excluding interest and taxes."
        case .freeCashFlow:
            return "Cash generated by operations minus capital expenditures. Shows actual cash available to shareholders."
        }
    }
}

// MARK: - Growth Period Type
enum GrowthPeriodType: String, CaseIterable, Identifiable {
    case annual = "Annual"
    case quarterly = "Quarterly"

    var id: String { rawValue }
}

// MARK: - Growth Data Point
struct GrowthDataPoint: Identifiable, Equatable, Hashable {
    let id = UUID()
    let period: String              // e.g., "2020", "2021" or "Q1 '24"
    let value: Double               // Absolute value (e.g., 100B)
    let yoyChangePercent: Double    // Year-over-Year change percentage
    let sectorAverageYoY: Double    // Sector average YoY for comparison
    
    static func == (lhs: GrowthDataPoint, rhs: GrowthDataPoint) -> Bool {
        lhs.period == rhs.period
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(period)
    }

    var isPositiveYoY: Bool {
        yoyChangePercent >= 0
    }

    var formattedYoY: String {
        String(format: "%.2f%%", yoyChangePercent)
    }

    var yoyColor: Color {
        yoyChangePercent >= 0 ? AppColors.bullish : AppColors.bearish
    }

    var formattedValue: String {
        formatLargeNumber(value)
    }

    private func formatLargeNumber(_ number: Double) -> String {
        let absNumber = abs(number)
        if absNumber >= 1_000_000_000_000 {
            return String(format: "%.1fT", number / 1_000_000_000_000)
        } else if absNumber >= 1_000_000_000 {
            return String(format: "%.1fB", number / 1_000_000_000)
        } else if absNumber >= 1_000_000 {
            return String(format: "%.1fM", number / 1_000_000)
        } else if absNumber >= 1_000 {
            return String(format: "%.1fK", number / 1_000)
        }
        return String(format: "%.2f", number)
    }
}

// MARK: - Growth Chart Data
struct GrowthChartData {
    let metricType: GrowthMetricType
    let periodType: GrowthPeriodType
    let dataPoints: [GrowthDataPoint]

    var maxValue: Double {
        dataPoints.map { $0.value }.max() ?? 0
    }

    var minValue: Double {
        min(dataPoints.map { $0.value }.min() ?? 0, 0)
    }

    var averageYoY: Double {
        guard !dataPoints.isEmpty else { return 0 }
        return dataPoints.map { $0.yoyChangePercent }.reduce(0, +) / Double(dataPoints.count)
    }

    var formattedAverageYoY: String {
        let sign = averageYoY >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", averageYoY))%"
    }
}

// MARK: - Growth Section Data
struct GrowthSectionData {
    let epsAnnual: [GrowthDataPoint]
    let epsQuarterly: [GrowthDataPoint]
    let revenueAnnual: [GrowthDataPoint]
    let revenueQuarterly: [GrowthDataPoint]
    let netIncomeAnnual: [GrowthDataPoint]
    let netIncomeQuarterly: [GrowthDataPoint]
    let operatingProfitAnnual: [GrowthDataPoint]
    let operatingProfitQuarterly: [GrowthDataPoint]
    let freeCashFlowAnnual: [GrowthDataPoint]
    let freeCashFlowQuarterly: [GrowthDataPoint]

    func dataPoints(for metric: GrowthMetricType, period: GrowthPeriodType) -> [GrowthDataPoint] {
        switch (metric, period) {
        case (.eps, .annual): return epsAnnual
        case (.eps, .quarterly): return epsQuarterly
        case (.revenue, .annual): return revenueAnnual
        case (.revenue, .quarterly): return revenueQuarterly
        case (.netIncome, .annual): return netIncomeAnnual
        case (.netIncome, .quarterly): return netIncomeQuarterly
        case (.operatingProfit, .annual): return operatingProfitAnnual
        case (.operatingProfit, .quarterly): return operatingProfitQuarterly
        case (.freeCashFlow, .annual): return freeCashFlowAnnual
        case (.freeCashFlow, .quarterly): return freeCashFlowQuarterly
        }
    }

    func chartData(for metric: GrowthMetricType, period: GrowthPeriodType) -> GrowthChartData {
        GrowthChartData(
            metricType: metric,
            periodType: period,
            dataPoints: dataPoints(for: metric, period: period)
        )
    }
}

// MARK: - Sample Data
extension GrowthSectionData {
    static let sampleData = GrowthSectionData(
        epsAnnual: [
            GrowthDataPoint(period: "2021", value: 5.61, yoyChangePercent: 71.04, sectorAverageYoY: 35.2),
            GrowthDataPoint(period: "2022", value: 6.11, yoyChangePercent: 8.91, sectorAverageYoY: 5.8),
            GrowthDataPoint(period: "2023", value: 6.13, yoyChangePercent: 0.33, sectorAverageYoY: -2.1),
            GrowthDataPoint(period: "2024", value: 6.75, yoyChangePercent: 10.11, sectorAverageYoY: 7.5),
            GrowthDataPoint(period: "2025", value: 7.35, yoyChangePercent: 8.89, sectorAverageYoY: 6.2)
        ],
        epsQuarterly: [
            GrowthDataPoint(period: "Q1'21", value: 1.40, yoyChangePercent: 54.29, sectorAverageYoY: 28.5),
            GrowthDataPoint(period: "Q2'21", value: 1.30, yoyChangePercent: 93.28, sectorAverageYoY: 42.3),
            GrowthDataPoint(period: "Q3'21", value: 1.24, yoyChangePercent: 70.24, sectorAverageYoY: 35.8),
            GrowthDataPoint(period: "Q4'21", value: 2.10, yoyChangePercent: 62.03, sectorAverageYoY: 31.5),
            GrowthDataPoint(period: "Q1'22", value: 1.52, yoyChangePercent: 8.57, sectorAverageYoY: 5.2),
            GrowthDataPoint(period: "Q2'22", value: 1.20, yoyChangePercent: -7.69, sectorAverageYoY: -3.5),
            GrowthDataPoint(period: "Q3'22", value: 1.29, yoyChangePercent: 4.03, sectorAverageYoY: 2.1),
            GrowthDataPoint(period: "Q4'22", value: 1.88, yoyChangePercent: -10.48, sectorAverageYoY: -8.2),
            GrowthDataPoint(period: "Q1'23", value: 1.52, yoyChangePercent: 0.00, sectorAverageYoY: -1.8),
            GrowthDataPoint(period: "Q2'23", value: 1.26, yoyChangePercent: 5.00, sectorAverageYoY: 0.5),
            GrowthDataPoint(period: "Q3'23", value: 1.46, yoyChangePercent: 13.18, sectorAverageYoY: 10.2),
            GrowthDataPoint(period: "Q4'23", value: 2.02, yoyChangePercent: 7.45, sectorAverageYoY: -8.5),
            GrowthDataPoint(period: "Q1'24", value: 1.53, yoyChangePercent: 0.66, sectorAverageYoY: 3.2),
            GrowthDataPoint(period: "Q2'24", value: 1.40, yoyChangePercent: 11.11, sectorAverageYoY: 8.5),
            GrowthDataPoint(period: "Q3'24", value: 1.64, yoyChangePercent: 12.33, sectorAverageYoY: 9.1),
            GrowthDataPoint(period: "Q4'24", value: 2.18, yoyChangePercent: 7.92, sectorAverageYoY: 5.8),
            GrowthDataPoint(period: "Q1'25", value: 1.68, yoyChangePercent: 9.80, sectorAverageYoY: 7.2),
            GrowthDataPoint(period: "Q2'25", value: 1.52, yoyChangePercent: 8.57, sectorAverageYoY: 6.5),
            GrowthDataPoint(period: "Q3'25", value: 1.78, yoyChangePercent: 8.54, sectorAverageYoY: 6.8),
            GrowthDataPoint(period: "Q4'25", value: 2.37, yoyChangePercent: 8.72, sectorAverageYoY: 6.3)
        ],
        revenueAnnual: [
            GrowthDataPoint(period: "2021", value: 365_817_000_000, yoyChangePercent: 33.26, sectorAverageYoY: 22.5),
            GrowthDataPoint(period: "2022", value: 394_328_000_000, yoyChangePercent: 7.79, sectorAverageYoY: 12.3),
            GrowthDataPoint(period: "2023", value: 383_285_000_000, yoyChangePercent: -2.80, sectorAverageYoY: 15.8),
            GrowthDataPoint(period: "2024", value: 391_035_000_000, yoyChangePercent: 2.02, sectorAverageYoY: -8.2),
            GrowthDataPoint(period: "2025", value: 412_500_000_000, yoyChangePercent: 5.49, sectorAverageYoY: 4.5)
        ],
        revenueQuarterly: [
            GrowthDataPoint(period: "Q1'21", value: 89_584_000_000, yoyChangePercent: 53.68, sectorAverageYoY: 35.2),
            GrowthDataPoint(period: "Q2'21", value: 81_434_000_000, yoyChangePercent: 36.42, sectorAverageYoY: 25.8),
            GrowthDataPoint(period: "Q3'21", value: 83_360_000_000, yoyChangePercent: 28.85, sectorAverageYoY: 22.5),
            GrowthDataPoint(period: "Q4'21", value: 123_945_000_000, yoyChangePercent: 11.25, sectorAverageYoY: 15.3),
            GrowthDataPoint(period: "Q1'22", value: 97_278_000_000, yoyChangePercent: 8.59, sectorAverageYoY: 12.5),
            GrowthDataPoint(period: "Q2'22", value: 82_959_000_000, yoyChangePercent: 1.87, sectorAverageYoY: 8.8),
            GrowthDataPoint(period: "Q3'22", value: 90_146_000_000, yoyChangePercent: 8.14, sectorAverageYoY: 10.2),
            GrowthDataPoint(period: "Q4'22", value: 117_154_000_000, yoyChangePercent: -5.49, sectorAverageYoY: -2.5),
            GrowthDataPoint(period: "Q1'23", value: 94_836_000_000, yoyChangePercent: -2.51, sectorAverageYoY: -1.5),
            GrowthDataPoint(period: "Q2'23", value: 81_797_000_000, yoyChangePercent: -1.40, sectorAverageYoY: 0.8),
            GrowthDataPoint(period: "Q3'23", value: 89_498_000_000, yoyChangePercent: -0.72, sectorAverageYoY: 1.2),
            GrowthDataPoint(period: "Q4'23", value: 119_575_000_000, yoyChangePercent: 2.07, sectorAverageYoY: 3.5),
            GrowthDataPoint(period: "Q1'24", value: 90_753_000_000, yoyChangePercent: -4.31, sectorAverageYoY: 3.2),
            GrowthDataPoint(period: "Q2'24", value: 85_778_000_000, yoyChangePercent: 4.87, sectorAverageYoY: 4.5),
            GrowthDataPoint(period: "Q3'24", value: 94_930_000_000, yoyChangePercent: 6.07, sectorAverageYoY: -0.8),
            GrowthDataPoint(period: "Q4'24", value: 124_300_000_000, yoyChangePercent: 3.95, sectorAverageYoY: 4.2),
            GrowthDataPoint(period: "Q1'25", value: 95_900_000_000, yoyChangePercent: 5.67, sectorAverageYoY: 5.2),
            GrowthDataPoint(period: "Q2'25", value: 89_200_000_000, yoyChangePercent: 3.99, sectorAverageYoY: 4.8),
            GrowthDataPoint(period: "Q3'25", value: 98_500_000_000, yoyChangePercent: 3.76, sectorAverageYoY: 5.1),
            GrowthDataPoint(period: "Q4'25", value: 128_900_000_000, yoyChangePercent: 3.70, sectorAverageYoY: 4.5)
        ],
        netIncomeAnnual: [
            GrowthDataPoint(period: "2021", value: 94_680_000_000, yoyChangePercent: 64.92, sectorAverageYoY: 45.3),
            GrowthDataPoint(period: "2022", value: 99_803_000_000, yoyChangePercent: 5.41, sectorAverageYoY: 3.8),
            GrowthDataPoint(period: "2023", value: 96_995_000_000, yoyChangePercent: -2.81, sectorAverageYoY: -4.2),
            GrowthDataPoint(period: "2024", value: 106_426_000_000, yoyChangePercent: 9.72, sectorAverageYoY: 6.5),
            GrowthDataPoint(period: "2025", value: 115_000_000_000, yoyChangePercent: 8.06, sectorAverageYoY: 7.2)
        ],
        netIncomeQuarterly: [
            GrowthDataPoint(period: "Q1'21", value: 23_630_000_000, yoyChangePercent: 110.00, sectorAverageYoY: 65.3),
            GrowthDataPoint(period: "Q2'21", value: 21_744_000_000, yoyChangePercent: 93.21, sectorAverageYoY: 55.8),
            GrowthDataPoint(period: "Q3'21", value: 20_551_000_000, yoyChangePercent: 62.35, sectorAverageYoY: 42.5),
            GrowthDataPoint(period: "Q4'21", value: 34_630_000_000, yoyChangePercent: 20.35, sectorAverageYoY: 18.2),
            GrowthDataPoint(period: "Q1'22", value: 25_010_000_000, yoyChangePercent: 5.84, sectorAverageYoY: 4.2),
            GrowthDataPoint(period: "Q2'22", value: 19_442_000_000, yoyChangePercent: -10.59, sectorAverageYoY: -8.5),
            GrowthDataPoint(period: "Q3'22", value: 20_721_000_000, yoyChangePercent: 0.83, sectorAverageYoY: 1.2),
            GrowthDataPoint(period: "Q4'22", value: 29_998_000_000, yoyChangePercent: -13.38, sectorAverageYoY: -11.2),
            GrowthDataPoint(period: "Q1'23", value: 24_160_000_000, yoyChangePercent: -3.40, sectorAverageYoY: -2.5),
            GrowthDataPoint(period: "Q2'23", value: 19_881_000_000, yoyChangePercent: 2.26, sectorAverageYoY: -1.2),
            GrowthDataPoint(period: "Q3'23", value: 22_956_000_000, yoyChangePercent: 10.79, sectorAverageYoY: 8.5),
            GrowthDataPoint(period: "Q4'23", value: 33_916_000_000, yoyChangePercent: 13.06, sectorAverageYoY: -9.8),
            GrowthDataPoint(period: "Q1'24", value: 23_636_000_000, yoyChangePercent: -2.17, sectorAverageYoY: 3.2),
            GrowthDataPoint(period: "Q2'24", value: 21_448_000_000, yoyChangePercent: 7.88, sectorAverageYoY: 5.5),
            GrowthDataPoint(period: "Q3'24", value: 25_012_000_000, yoyChangePercent: 8.96, sectorAverageYoY: 8.9),
            GrowthDataPoint(period: "Q4'24", value: 36_330_000_000, yoyChangePercent: 7.12, sectorAverageYoY: 5.8),
            GrowthDataPoint(period: "Q1'25", value: 25_850_000_000, yoyChangePercent: 9.36, sectorAverageYoY: 7.5),
            GrowthDataPoint(period: "Q2'25", value: 23_450_000_000, yoyChangePercent: 9.33, sectorAverageYoY: 7.8),
            GrowthDataPoint(period: "Q3'25", value: 27_200_000_000, yoyChangePercent: 8.75, sectorAverageYoY: 7.2),
            GrowthDataPoint(period: "Q4'25", value: 38_500_000_000, yoyChangePercent: 5.97, sectorAverageYoY: 6.5)
        ],
        operatingProfitAnnual: [
            GrowthDataPoint(period: "2021", value: 108_949_000_000, yoyChangePercent: 64.35, sectorAverageYoY: 42.1),
            GrowthDataPoint(period: "2022", value: 119_437_000_000, yoyChangePercent: 9.63, sectorAverageYoY: 6.5),
            GrowthDataPoint(period: "2023", value: 114_301_000_000, yoyChangePercent: -4.30, sectorAverageYoY: -5.2),
            GrowthDataPoint(period: "2024", value: 124_000_000_000, yoyChangePercent: 8.49, sectorAverageYoY: 7.8),
            GrowthDataPoint(period: "2025", value: 132_500_000_000, yoyChangePercent: 6.85, sectorAverageYoY: 5.5)
        ],
        operatingProfitQuarterly: [
            GrowthDataPoint(period: "Q1'21", value: 27_500_000_000, yoyChangePercent: 120.50, sectorAverageYoY: 72.3),
            GrowthDataPoint(period: "Q2'21", value: 24_126_000_000, yoyChangePercent: 96.35, sectorAverageYoY: 58.5),
            GrowthDataPoint(period: "Q3'21", value: 24_082_000_000, yoyChangePercent: 62.15, sectorAverageYoY: 45.2),
            GrowthDataPoint(period: "Q4'21", value: 41_525_000_000, yoyChangePercent: 20.18, sectorAverageYoY: 16.8),
            GrowthDataPoint(period: "Q1'22", value: 30_288_000_000, yoyChangePercent: 10.13, sectorAverageYoY: 8.2),
            GrowthDataPoint(period: "Q2'22", value: 23_076_000_000, yoyChangePercent: -4.36, sectorAverageYoY: -2.5),
            GrowthDataPoint(period: "Q3'22", value: 25_000_000_000, yoyChangePercent: 3.81, sectorAverageYoY: 2.1),
            GrowthDataPoint(period: "Q4'22", value: 36_016_000_000, yoyChangePercent: -13.27, sectorAverageYoY: -10.8),
            GrowthDataPoint(period: "Q1'23", value: 28_318_000_000, yoyChangePercent: -6.50, sectorAverageYoY: -4.2),
            GrowthDataPoint(period: "Q2'23", value: 22_997_000_000, yoyChangePercent: -0.34, sectorAverageYoY: -2.1),
            GrowthDataPoint(period: "Q3'23", value: 26_969_000_000, yoyChangePercent: 7.88, sectorAverageYoY: 6.8),
            GrowthDataPoint(period: "Q4'23", value: 39_895_000_000, yoyChangePercent: 10.77, sectorAverageYoY: -7.5),
            GrowthDataPoint(period: "Q1'24", value: 27_900_000_000, yoyChangePercent: -1.48, sectorAverageYoY: 4.2),
            GrowthDataPoint(period: "Q2'24", value: 25_350_000_000, yoyChangePercent: 10.23, sectorAverageYoY: 6.1),
            GrowthDataPoint(period: "Q3'24", value: 29_600_000_000, yoyChangePercent: 9.75, sectorAverageYoY: 7.8),
            GrowthDataPoint(period: "Q4'24", value: 41_150_000_000, yoyChangePercent: 3.15, sectorAverageYoY: 5.2),
            GrowthDataPoint(period: "Q1'25", value: 30_500_000_000, yoyChangePercent: 9.32, sectorAverageYoY: 7.2),
            GrowthDataPoint(period: "Q2'25", value: 27_800_000_000, yoyChangePercent: 9.66, sectorAverageYoY: 7.5),
            GrowthDataPoint(period: "Q3'25", value: 32_100_000_000, yoyChangePercent: 8.45, sectorAverageYoY: 6.8),
            GrowthDataPoint(period: "Q4'25", value: 42_100_000_000, yoyChangePercent: 2.31, sectorAverageYoY: 5.5)
        ],
        freeCashFlowAnnual: [
            GrowthDataPoint(period: "2021", value: 92_953_000_000, yoyChangePercent: 26.70, sectorAverageYoY: 22.3),
            GrowthDataPoint(period: "2022", value: 111_443_000_000, yoyChangePercent: 19.89, sectorAverageYoY: 15.8),
            GrowthDataPoint(period: "2023", value: 99_584_000_000, yoyChangePercent: -10.64, sectorAverageYoY: -8.2),
            GrowthDataPoint(period: "2024", value: 107_500_000_000, yoyChangePercent: 7.95, sectorAverageYoY: 6.5),
            GrowthDataPoint(period: "2025", value: 115_800_000_000, yoyChangePercent: 7.72, sectorAverageYoY: 6.2)
        ],
        freeCashFlowQuarterly: [
            GrowthDataPoint(period: "Q1'21", value: 21_235_000_000, yoyChangePercent: 68.50, sectorAverageYoY: 45.3),
            GrowthDataPoint(period: "Q2'21", value: 21_035_000_000, yoyChangePercent: 52.85, sectorAverageYoY: 38.2),
            GrowthDataPoint(period: "Q3'21", value: 20_841_000_000, yoyChangePercent: 28.90, sectorAverageYoY: 25.5),
            GrowthDataPoint(period: "Q4'21", value: 28_360_000_000, yoyChangePercent: 9.85, sectorAverageYoY: 12.3),
            GrowthDataPoint(period: "Q1'22", value: 28_755_000_000, yoyChangePercent: 35.42, sectorAverageYoY: 28.5),
            GrowthDataPoint(period: "Q2'22", value: 22_839_000_000, yoyChangePercent: 8.58, sectorAverageYoY: 12.2),
            GrowthDataPoint(period: "Q3'22", value: 24_088_000_000, yoyChangePercent: 15.58, sectorAverageYoY: 18.5),
            GrowthDataPoint(period: "Q4'22", value: 34_005_000_000, yoyChangePercent: 19.91, sectorAverageYoY: 15.8),
            GrowthDataPoint(period: "Q1'23", value: 22_185_000_000, yoyChangePercent: -22.84, sectorAverageYoY: -18.2),
            GrowthDataPoint(period: "Q2'23", value: 21_152_000_000, yoyChangePercent: -7.39, sectorAverageYoY: -5.5),
            GrowthDataPoint(period: "Q3'23", value: 23_632_000_000, yoyChangePercent: -1.89, sectorAverageYoY: 4.2),
            GrowthDataPoint(period: "Q4'23", value: 32_415_000_000, yoyChangePercent: -4.67, sectorAverageYoY: -10.8),
            GrowthDataPoint(period: "Q1'24", value: 24_160_000_000, yoyChangePercent: 8.90, sectorAverageYoY: 6.5),
            GrowthDataPoint(period: "Q2'24", value: 22_310_000_000, yoyChangePercent: 5.47, sectorAverageYoY: 4.2),
            GrowthDataPoint(period: "Q3'24", value: 26_540_000_000, yoyChangePercent: 12.31, sectorAverageYoY: 9.8),
            GrowthDataPoint(period: "Q4'24", value: 34_490_000_000, yoyChangePercent: 6.40, sectorAverageYoY: 6.1),
            GrowthDataPoint(period: "Q1'25", value: 26_200_000_000, yoyChangePercent: 8.44, sectorAverageYoY: 7.2),
            GrowthDataPoint(period: "Q2'25", value: 24_500_000_000, yoyChangePercent: 9.81, sectorAverageYoY: 7.5),
            GrowthDataPoint(period: "Q3'25", value: 28_900_000_000, yoyChangePercent: 8.89, sectorAverageYoY: 7.8),
            GrowthDataPoint(period: "Q4'25", value: 36_200_000_000, yoyChangePercent: 4.96, sectorAverageYoY: 6.3)
        ]
    )
}

// MARK: - Growth Info Item (for educational content)
struct GrowthInfoItem: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let icon: String
    let example: String?

    init(title: String, description: String, icon: String, example: String? = nil) {
        self.title = title
        self.description = description
        self.icon = icon
        self.example = example
    }
}

extension GrowthInfoItem {
    static let valueInvestingTips: [GrowthInfoItem] = [
        GrowthInfoItem(
            title: "Consistent Growth",
            description: "Look for companies with steady, predictable growth rates rather than volatile or erratic patterns. Warren Buffett prefers 'wonderful companies at fair prices.'",
            icon: "chart.line.uptrend.xyaxis",
            example: "A company growing revenue 8-12% annually for 5+ years is more reliable than one with 50% one year and -20% the next."
        ),
        GrowthInfoItem(
            title: "Compare to Sector",
            description: "The sector average line shows how the company performs relative to peers. Outperforming the sector consistently indicates competitive advantages.",
            icon: "chart.bar.fill",
            example: "If sector grows 5% but company grows 10%, it's gaining market share."
        ),
        GrowthInfoItem(
            title: "Revenue Quality",
            description: "Sustainable revenue growth comes from increasing sales volume or pricing power, not one-time events. Check if growth is organic or from acquisitions.",
            icon: "dollarsign.circle.fill",
            example: "Recurring subscription revenue is more valuable than one-time product sales."
        ),
        GrowthInfoItem(
            title: "EPS vs Revenue",
            description: "EPS growing faster than revenue suggests improving margins and operational efficiency. The opposite may indicate rising costs eating into profits.",
            icon: "arrow.up.right.circle.fill",
            example: "Revenue +5% with EPS +15% = excellent cost management."
        ),
        GrowthInfoItem(
            title: "Free Cash Flow",
            description: "FCF growth is crucial - it shows actual cash generation after all capital needs. Companies can manipulate earnings but not cash flow easily.",
            icon: "banknote.fill",
            example: "Positive FCF growth means the company can fund dividends, buybacks, or expansion without debt."
        ),
        GrowthInfoItem(
            title: "Year-over-Year (YoY)",
            description: "YoY comparison removes seasonality effects and shows true growth trajectory. Multiple positive YoY quarters indicate momentum.",
            icon: "calendar",
            example: "Comparing Q4 2024 to Q4 2023 is more meaningful than Q4 to Q3."
        )
    ]
}

================================================================================
FILE: frontend/ios/ios/Models/HealthCheckModels.swift
================================================================================

//
//  HealthCheckModels.swift
//  ios
//
//  Data models for the Health Check financial metrics card
//

import Foundation
import SwiftUI

// MARK: - Health Check Overall Rating

enum HealthCheckRating: String, CaseIterable {
    case excellent = "Excellent"
    case good = "Good"
    case mix = "Mix"
    case caution = "Caution"
    case poor = "Poor"

    var color: Color {
        switch self {
        case .excellent:
            return AppColors.bullish
        case .good:
            return Color(hex: "4ADE80")
        case .mix:
            return AppColors.neutral
        case .caution:
            return AppColors.alertOrange
        case .poor:
            return AppColors.bearish
        }
    }

    var iconName: String {
        switch self {
        case .excellent, .good:
            return "checkmark.circle.fill"
        case .mix:
            return "checkmark.circle.fill"
        case .caution:
            return "exclamationmark.triangle.fill"
        case .poor:
            return "xmark.circle.fill"
        }
    }
}

// MARK: - Health Check Metric Type

enum HealthCheckMetricType: String, CaseIterable, Identifiable {
    case debtToEquity = "Debt-to-Equity"
    case peRatio = "P/E Ratio"
    case returnOnEquity = "Return on Equity"
    case currentRatio = "Current Ratio"

    var id: String { rawValue }

    var subtitle: String {
        switch self {
        case .debtToEquity:
            return "Lower is better"
        case .peRatio:
            return "Valuation metric"
        case .returnOnEquity:
            return "Profitability"
        case .currentRatio:
            return "Liquidity"
        }
    }

    var leftLabel: String {
        switch self {
        case .debtToEquity:
            return "Healthy"
        case .peRatio:
            return "Cheap"
        case .returnOnEquity:
            return "Poor"
        case .currentRatio:
            return "Low"
        }
    }

    var rightLabel: String {
        switch self {
        case .debtToEquity:
            return "Risky"
        case .peRatio:
            return "Expensive"
        case .returnOnEquity:
            return "Great"
        case .currentRatio:
            return "High"
        }
    }

    /// Description for value investors
    var valueInvestorDescription: String {
        switch self {
        case .debtToEquity:
            return "Measures a company's financial leverage. Value investors prefer lower ratios as they indicate less reliance on debt financing and lower bankruptcy risk."
        case .peRatio:
            return "Price-to-Earnings ratio shows how much investors pay per dollar of earnings. Lower P/E relative to sector may indicate undervaluation - a key value investing signal."
        case .returnOnEquity:
            return "Measures profitability relative to shareholder equity. Higher ROE indicates efficient use of capital, but compare to sector average for context."
        case .currentRatio:
            return "Measures ability to pay short-term obligations. A ratio above 1.0 indicates good liquidity. Value investors look for financial stability."
        }
    }
}

// MARK: - Health Check Metric Status

enum HealthCheckMetricStatus {
    case positive  // Green - good metric
    case neutral   // Yellow - average/mixed
    case negative  // Red - concerning

    var primaryColor: Color {
        switch self {
        case .positive:
            return AppColors.bullish
        case .neutral:
            return AppColors.neutral
        case .negative:
            return AppColors.bearish
        }
    }
}

// MARK: - Health Check Metric Data

struct HealthCheckMetric: Identifiable {
    let id = UUID()
    let type: HealthCheckMetricType
    let value: Double
    let comparisonValue: Double?  // Sector average or benchmark
    let percentDifference: Double?  // % difference from sector
    let gaugePosition: Double  // 0.0 to 1.0 position on gauge
    let status: HealthCheckMetricStatus
    let insightText: String
    let highlightedValue: String?  // e.g., "43% lower" or "15% discount"
    let highlightedLabel: String?  // e.g., "debt" or "discount"

    var formattedValue: String {
        switch type {
        case .debtToEquity:
            return String(format: "%.2f", value)
        case .peRatio:
            return String(format: "%.1f", value)
        case .returnOnEquity:
            return String(format: "%.1f%%", value)
        case .currentRatio:
            return String(format: "%.2f", value)
        }
    }

    var formattedComparison: String? {
        guard let comparison = comparisonValue else { return nil }
        
        switch type {
        case .debtToEquity, .currentRatio:
            return "vs \(String(format: "%.2f", comparison))"
        case .peRatio, .returnOnEquity:
            return "vs \(String(format: "%.1f", comparison))"
        }
    }

    var valueColor: Color {
        colorAtPosition(gaugePosition, for: type)
    }
    
    /// Calculate the color at a specific position on the gauge gradient
    private func colorAtPosition(_ position: Double, for metricType: HealthCheckMetricType) -> Color {
        let clampedPosition = min(max(position, 0.0), 1.0)
        
        let gradientColors: [Color]
        switch metricType {
        case .debtToEquity, .peRatio:
            // Lower is better: green -> lime -> yellow -> orange -> red
            gradientColors = [
                AppColors.bullish,
                Color(hex: "84CC16"),
                AppColors.neutral,
                AppColors.alertOrange,
                AppColors.bearish
            ]
        case .returnOnEquity, .currentRatio:
            // Higher is better: red -> orange -> yellow -> lime -> green
            gradientColors = [
                AppColors.bearish,
                AppColors.alertOrange,
                AppColors.neutral,
                Color(hex: "84CC16"),
                AppColors.bullish
            ]
        }
        
        // Map position to color index (0.0 -> first color, 1.0 -> last color)
        let colorCount = gradientColors.count
        let scaledPosition = clampedPosition * Double(colorCount - 1)
        let lowerIndex = Int(floor(scaledPosition))
        let upperIndex = min(lowerIndex + 1, colorCount - 1)
        let fraction = scaledPosition - Double(lowerIndex)
        
        // For simplicity, return the closest color (no interpolation)
        if fraction < 0.5 {
            return gradientColors[lowerIndex]
        } else {
            return gradientColors[upperIndex]
        }
    }
}

// MARK: - Health Check Section Data

struct HealthCheckSectionData {
    let overallRating: HealthCheckRating
    let passedCount: Int
    let totalCount: Int
    let metrics: [HealthCheckMetric]

    var ratingBadgeText: String {
        "[\(passedCount)/\(totalCount)] \(overallRating.rawValue)"
    }
}

// MARK: - Sample Data

extension HealthCheckSectionData {
    static let sampleData = HealthCheckSectionData(
        overallRating: .mix,
        passedCount: 2,
        totalCount: 4,
        metrics: [
            HealthCheckMetric(
                type: .debtToEquity,
                value: 0.68,
                comparisonValue: 1.19,
                percentDifference: -43,
                gaugePosition: 0.25,
                status: .positive,
                insightText: "Strong balance sheet with conservative leverage.",
                highlightedValue: "43%",
                highlightedLabel: "lower debt than sector average."
            ),
            HealthCheckMetric(
                type: .peRatio,
                value: 24.3,
                comparisonValue: 28.5,
                percentDifference: -15,
                gaugePosition: 0.42,
                status: .positive,
                insightText: "to the Tech sector average. Fair value opportunity.",
                highlightedValue: "15%",
                highlightedLabel: "Trading at a discount"
            ),
            HealthCheckMetric(
                type: .returnOnEquity,
                value: 12.8,
                comparisonValue: 28.5,
                percentDifference: -22,
                gaugePosition: 0.35,
                status: .negative,
                insightText: "ROE than peers. Low capital efficiency with improving trend.",
                highlightedValue: "22%",
                highlightedLabel: "below"
            ),
            HealthCheckMetric(
                type: .currentRatio,
                value: 1.82,
                comparisonValue: 1.5,
                percentDifference: 21,
                gaugePosition: 0.68,
                status: .positive,
                insightText: "sector average, normal short-term liquidity position.",
                highlightedValue: "21%",
                highlightedLabel: "above"
            )
        ]
    )

    static let sampleApple = HealthCheckSectionData(
        overallRating: .good,
        passedCount: 3,
        totalCount: 4,
        metrics: [
            HealthCheckMetric(
                type: .debtToEquity,
                value: 1.87,
                comparisonValue: 0.95,
                percentDifference: 97,
                gaugePosition: 0.65,
                status: .neutral,
                insightText: "Moderate leverage compared to tech sector average.",
                highlightedValue: "97%",
                highlightedLabel: "higher debt than sector average."
            ),
            HealthCheckMetric(
                type: .peRatio,
                value: 35.15,
                comparisonValue: 27.04,
                percentDifference: 30,
                gaugePosition: 0.72,
                status: .neutral,
                insightText: "to sector average. Premium valuation for quality.",
                highlightedValue: "30%",
                highlightedLabel: "Trading at premium"
            ),
            HealthCheckMetric(
                type: .returnOnEquity,
                value: 147.2,
                comparisonValue: 25.0,
                percentDifference: 489,
                gaugePosition: 0.95,
                status: .positive,
                insightText: "ROE than peers. Exceptional capital efficiency.",
                highlightedValue: "5.9x",
                highlightedLabel: "higher"
            ),
            HealthCheckMetric(
                type: .currentRatio,
                value: 0.99,
                comparisonValue: 1.5,
                percentDifference: -34,
                gaugePosition: 0.35,
                status: .negative,
                insightText: "sector average. Tight but manageable liquidity.",
                highlightedValue: "34%",
                highlightedLabel: "below"
            )
        ]
    )
}

================================================================================
FILE: frontend/ios/ios/Models/HoldersModels.swift
================================================================================

//
//  HoldersModels.swift
//  ios
//
//  Data models for the Holders tab in Ticker Detail
//  Includes shareholder breakdown and smart money flow data
//

import Foundation
import SwiftUI

// MARK: - Shareholder Breakdown

/// Represents the ownership distribution of a company
struct ShareholderBreakdown: Identifiable {
    let id = UUID()
    let insidersPercent: Double
    let institutionsPercent: Double
    let publicOtherPercent: Double

    /// Top 10 institutional holders data (legacy)
    let topHolders: [InstitutionalHolder]

    /// Top 10 owners data (institutions and insiders)
    let top10Owners: Top10OwnersData

    // Computed property for validation
    var totalPercent: Double {
        insidersPercent + institutionsPercent + publicOtherPercent
    }

    // Formatted strings
    var formattedInsiders: String {
        String(format: "%.0f%%", insidersPercent)
    }

    var formattedInstitutions: String {
        String(format: "%.0f%%", institutionsPercent)
    }

    var formattedPublicOther: String {
        String(format: "%.0f%%", publicOtherPercent)
    }
}

/// Individual institutional holder
struct InstitutionalHolder: Identifiable {
    let id = UUID()
    let name: String
    let sharesHeld: Double
    let percentOwnership: Double
    let changePercent: Double?

    var formattedShares: String {
        if sharesHeld >= 1_000_000_000 {
            return String(format: "%.2fB", sharesHeld / 1_000_000_000)
        } else if sharesHeld >= 1_000_000 {
            return String(format: "%.2fM", sharesHeld / 1_000_000)
        }
        return String(format: "%.0f", sharesHeld)
    }

    var formattedPercent: String {
        String(format: "%.2f%%", percentOwnership)
    }

    var formattedChange: String? {
        guard let change = changePercent else { return nil }
        let sign = change >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", change))%"
    }

    var changeColor: Color {
        guard let change = changePercent else { return AppColors.textSecondary }
        return change >= 0 ? AppColors.bullish : AppColors.bearish
    }
}

// MARK: - Smart Money Tab Types

enum SmartMoneyTab: String, CaseIterable {
    case insider = "Insider"
    case hedgeFunds = "Hedge Funds"
    case congress = "Congress"
}

// MARK: - Stock Price Data Point

/// Stock price data for a specific month (for comparison with smart money activity)
struct StockPriceDataPoint: Identifiable {
    let id = UUID()
    let month: String
    let price: Double  // Closing price for the month

    var formattedPrice: String {
        String(format: "$%.2f", price)
    }
}

// MARK: - Smart Money Flow Data

/// Monthly smart money flow data point
struct SmartMoneyFlowDataPoint: Identifiable {
    let id = UUID()
    let month: String
    let buyVolume: Double   // In millions
    let sellVolume: Double  // In millions

    var netFlow: Double {
        buyVolume - sellVolume
    }

    var isPositiveNet: Bool {
        netFlow >= 0
    }

    var formattedNetFlow: String {
        let sign = netFlow >= 0 ? "+" : ""
        if abs(netFlow) >= 1000 {
            return "\(sign)\(String(format: "%.1f", netFlow / 1000))B"
        }
        return "\(sign)\(String(format: "%.1f", netFlow))M"
    }
}

/// Summary of smart money activity
struct SmartMoneyFlowSummary {
    let totalNetFlow: Double  // Total net in millions
    let isPositive: Bool
    let periodDescription: String  // e.g., "12-Month"

    var formattedNetFlow: String {
        let sign = totalNetFlow >= 0 ? "+" : ""
        if abs(totalNetFlow) >= 1000 {
            return "\(sign)$\(String(format: "%.2f", abs(totalNetFlow) / 1000))B"
        }
        return "\(sign)$\(String(format: "%.2f", abs(totalNetFlow)))M"
    }

    var flowColor: Color {
        isPositive ? AppColors.bullish : AppColors.bearish
    }

    var flowIcon: String {
        isPositive ? "arrow.up" : "arrow.down"
    }
}

/// Complete smart money data for a specific tab (Insider/Hedge Funds/Congress)
struct SmartMoneyData: Identifiable {
    let id = UUID()
    let tab: SmartMoneyTab
    let priceData: [StockPriceDataPoint]  // Stock price for comparison
    let flowData: [SmartMoneyFlowDataPoint]
    let summary: SmartMoneyFlowSummary
}

// MARK: - Combined Holders Data

struct HoldersData {
    let shareholderBreakdown: ShareholderBreakdown
    let insiderData: SmartMoneyData
    let hedgeFundsData: SmartMoneyData
    let congressData: SmartMoneyData
    let recentActivities: RecentActivitiesData

    func smartMoneyData(for tab: SmartMoneyTab) -> SmartMoneyData {
        switch tab {
        case .insider:
            return insiderData
        case .hedgeFunds:
            return hedgeFundsData
        case .congress:
            return congressData
        }
    }
}

// MARK: - Sample Data

extension ShareholderBreakdown {
    static let sampleData = ShareholderBreakdown(
        insidersPercent: 12,
        institutionsPercent: 55,
        publicOtherPercent: 33,
        topHolders: InstitutionalHolder.sampleData,
        top10Owners: Top10OwnersData.sampleData
    )
}

extension InstitutionalHolder {
    static let sampleData: [InstitutionalHolder] = [
        InstitutionalHolder(name: "The Vanguard Group", sharesHeld: 1_340_000_000, percentOwnership: 8.61, changePercent: 0.3),
        InstitutionalHolder(name: "BlackRock Inc.", sharesHeld: 1_080_000_000, percentOwnership: 6.94, changePercent: -0.2),
        InstitutionalHolder(name: "Berkshire Hathaway", sharesHeld: 905_000_000, percentOwnership: 5.82, changePercent: 0.0),
        InstitutionalHolder(name: "State Street Corp", sharesHeld: 625_000_000, percentOwnership: 4.02, changePercent: 0.5),
        InstitutionalHolder(name: "FMR LLC", sharesHeld: 420_000_000, percentOwnership: 2.70, changePercent: -0.8),
        InstitutionalHolder(name: "Geode Capital Management", sharesHeld: 310_000_000, percentOwnership: 1.99, changePercent: 0.1),
        InstitutionalHolder(name: "Morgan Stanley", sharesHeld: 285_000_000, percentOwnership: 1.83, changePercent: 1.2),
        InstitutionalHolder(name: "Northern Trust Corp", sharesHeld: 245_000_000, percentOwnership: 1.57, changePercent: -0.3),
        InstitutionalHolder(name: "Bank of America Corp", sharesHeld: 198_000_000, percentOwnership: 1.27, changePercent: 0.4),
        InstitutionalHolder(name: "JP Morgan Chase", sharesHeld: 175_000_000, percentOwnership: 1.12, changePercent: 0.6)
    ]
}

extension StockPriceDataPoint {
    /// Sample stock price data (AAPL-like prices for 12 months)
    static let sampleData: [StockPriceDataPoint] = [
        StockPriceDataPoint(month: "02/2025", price: 155.30),
        StockPriceDataPoint(month: "03/2025", price: 158.20),
        StockPriceDataPoint(month: "04/2025", price: 162.40),
        StockPriceDataPoint(month: "05/2025", price: 165.10),
        StockPriceDataPoint(month: "06/2025", price: 168.50),
        StockPriceDataPoint(month: "07/2025", price: 170.80),
        StockPriceDataPoint(month: "08/2025", price: 171.20),
        StockPriceDataPoint(month: "09/2025", price: 168.90),
        StockPriceDataPoint(month: "10/2025", price: 165.80),
        StockPriceDataPoint(month: "11/2025", price: 170.50),
        StockPriceDataPoint(month: "12/2025", price: 175.20),
        StockPriceDataPoint(month: "01/2026", price: 178.42)
    ]
}

extension SmartMoneyFlowDataPoint {
    static let insiderSampleData: [SmartMoneyFlowDataPoint] = [
        SmartMoneyFlowDataPoint(month: "02/2025", buyVolume: 10.2, sellVolume: 6.5),
        SmartMoneyFlowDataPoint(month: "03/2025", buyVolume: 7.8, sellVolume: 9.2),
        SmartMoneyFlowDataPoint(month: "04/2025", buyVolume: 8.5, sellVolume: 12.3),
        SmartMoneyFlowDataPoint(month: "05/2025", buyVolume: 11.2, sellVolume: 5.8),
        SmartMoneyFlowDataPoint(month: "06/2025", buyVolume: 12.5, sellVolume: 8.2),
        SmartMoneyFlowDataPoint(month: "07/2025", buyVolume: 6.9, sellVolume: 10.5),
        SmartMoneyFlowDataPoint(month: "08/2025", buyVolume: 8.3, sellVolume: 11.1),
        SmartMoneyFlowDataPoint(month: "09/2025", buyVolume: 9.5, sellVolume: 7.2),
        SmartMoneyFlowDataPoint(month: "10/2025", buyVolume: 14.7, sellVolume: 7.5),
        SmartMoneyFlowDataPoint(month: "11/2025", buyVolume: 10.8, sellVolume: 8.9),
        SmartMoneyFlowDataPoint(month: "12/2025", buyVolume: 13.2, sellVolume: 6.1),
        SmartMoneyFlowDataPoint(month: "01/2026", buyVolume: 16.2, sellVolume: 7.9)
    ]

    static let hedgeFundsSampleData: [SmartMoneyFlowDataPoint] = [
        SmartMoneyFlowDataPoint(month: "02/2025", buyVolume: 42.1, sellVolume: 35.2),
        SmartMoneyFlowDataPoint(month: "03/2025", buyVolume: 38.5, sellVolume: 42.1),
        SmartMoneyFlowDataPoint(month: "04/2025", buyVolume: 35.2, sellVolume: 48.3),
        SmartMoneyFlowDataPoint(month: "05/2025", buyVolume: 48.9, sellVolume: 32.5),
        SmartMoneyFlowDataPoint(month: "06/2025", buyVolume: 45.2, sellVolume: 38.5),
        SmartMoneyFlowDataPoint(month: "07/2025", buyVolume: 39.8, sellVolume: 45.2),
        SmartMoneyFlowDataPoint(month: "08/2025", buyVolume: 52.1, sellVolume: 41.3),
        SmartMoneyFlowDataPoint(month: "09/2025", buyVolume: 44.5, sellVolume: 38.9),
        SmartMoneyFlowDataPoint(month: "10/2025", buyVolume: 38.9, sellVolume: 55.2),
        SmartMoneyFlowDataPoint(month: "11/2025", buyVolume: 51.2, sellVolume: 36.8),
        SmartMoneyFlowDataPoint(month: "12/2025", buyVolume: 48.5, sellVolume: 33.2),
        SmartMoneyFlowDataPoint(month: "01/2026", buyVolume: 55.8, sellVolume: 31.2)
    ]

    static let congressSampleData: [SmartMoneyFlowDataPoint] = [
        SmartMoneyFlowDataPoint(month: "02/2025", buyVolume: 1.8, sellVolume: 1.2),
        SmartMoneyFlowDataPoint(month: "03/2025", buyVolume: 2.1, sellVolume: 1.8),
        SmartMoneyFlowDataPoint(month: "04/2025", buyVolume: 2.5, sellVolume: 3.1),
        SmartMoneyFlowDataPoint(month: "05/2025", buyVolume: 3.2, sellVolume: 1.5),
        SmartMoneyFlowDataPoint(month: "06/2025", buyVolume: 2.1, sellVolume: 1.5),
        SmartMoneyFlowDataPoint(month: "07/2025", buyVolume: 1.5, sellVolume: 2.8),
        SmartMoneyFlowDataPoint(month: "08/2025", buyVolume: 3.2, sellVolume: 0.8),
        SmartMoneyFlowDataPoint(month: "09/2025", buyVolume: 2.8, sellVolume: 1.9),
        SmartMoneyFlowDataPoint(month: "10/2025", buyVolume: 1.8, sellVolume: 2.9),
        SmartMoneyFlowDataPoint(month: "11/2025", buyVolume: 3.5, sellVolume: 1.2),
        SmartMoneyFlowDataPoint(month: "12/2025", buyVolume: 2.9, sellVolume: 2.1),
        SmartMoneyFlowDataPoint(month: "01/2026", buyVolume: 3.9, sellVolume: 1.4)
    ]
}

extension SmartMoneyData {
    static let insiderSampleData = SmartMoneyData(
        tab: .insider,
        priceData: StockPriceDataPoint.sampleData,
        flowData: SmartMoneyFlowDataPoint.insiderSampleData,
        summary: SmartMoneyFlowSummary(
            totalNetFlow: 8.27,
            isPositive: true,
            periodDescription: "12-Month"
        )
    )

    static let hedgeFundsSampleData = SmartMoneyData(
        tab: .hedgeFunds,
        priceData: StockPriceDataPoint.sampleData,
        flowData: SmartMoneyFlowDataPoint.hedgeFundsSampleData,
        summary: SmartMoneyFlowSummary(
            totalNetFlow: 57.7,
            isPositive: true,
            periodDescription: "12-Month"
        )
    )

    static let congressSampleData = SmartMoneyData(
        tab: .congress,
        priceData: StockPriceDataPoint.sampleData,
        flowData: SmartMoneyFlowDataPoint.congressSampleData,
        summary: SmartMoneyFlowSummary(
            totalNetFlow: 7.4,
            isPositive: true,
            periodDescription: "12-Month"
        )
    )
}

extension HoldersData {
    static let sampleData = HoldersData(
        shareholderBreakdown: ShareholderBreakdown.sampleData,
        insiderData: SmartMoneyData.insiderSampleData,
        hedgeFundsData: SmartMoneyData.hedgeFundsSampleData,
        congressData: SmartMoneyData.congressSampleData,
        recentActivities: RecentActivitiesData.sampleData
    )
}

// MARK: - Holders Colors

/// Centralized colors for the Holders tab
struct HoldersColors {
    // Shareholder breakdown colors
    static let insiders = Color(hex: "F59E0B")       // Orange/Amber
    static let institutions = AppColors.primaryBlue  // Blue
    static let publicOther = Color(hex: "6B7280")    // Gray

    // Smart money flow colors
    static let buyVolume = AppColors.bullish         // Green
    static let sellVolume = AppColors.bearish        // Red
    static let flowLine = AppColors.primaryBlue      // Blue for cumulative flow line
}

// MARK: - Top 10 Owner Tab

enum Top10OwnerTab: String, CaseIterable {
    case institutions = "Institutions"
    case insiders = "Insiders"
}

// MARK: - Top Institution Owner

/// Represents a top institutional owner
struct TopInstitution: Identifiable {
    let id = UUID()
    let rank: Int
    let name: String
    let category: String  // e.g., "Asset Management", "Investment Banking"
    let valueInBillions: Double
    let percentOwnership: Double

    var formattedValue: String {
        if valueInBillions >= 1 {
            return String(format: "$%.1fB", valueInBillions)
        } else {
            return String(format: "$%.0fM", valueInBillions * 1000)
        }
    }

    var formattedPercent: String {
        String(format: "%.1f%%", percentOwnership)
    }
}

// MARK: - Top Insider Owner

/// Represents a top insider owner
struct TopInsider: Identifiable {
    let id = UUID()
    let rank: Int
    let name: String
    let title: String  // e.g., "CEO", "CFO", "Director"
    let valueInMillions: Double
    let percentOwnership: Double

    var formattedValue: String {
        if valueInMillions >= 1000 {
            return String(format: "$%.1fB", valueInMillions / 1000)
        } else {
            return String(format: "$%.1fM", valueInMillions)
        }
    }

    var formattedPercent: String {
        String(format: "%.2f%%", percentOwnership)
    }
}

// MARK: - Top 10 Owners Data

struct Top10OwnersData {
    let institutions: [TopInstitution]
    let insiders: [TopInsider]
}

// MARK: - Top 10 Sample Data

extension TopInstitution {
    static let sampleData: [TopInstitution] = [
        TopInstitution(rank: 1, name: "Vanguard Group Inc", category: "Asset Management", valueInBillions: 14.5, percentOwnership: 5.2),
        TopInstitution(rank: 2, name: "BlackRock Fund Advisors", category: "Investment Management", valueInBillions: 12.8, percentOwnership: 4.6),
        TopInstitution(rank: 3, name: "State Street Corporation", category: "Financial Services", valueInBillions: 9.2, percentOwnership: 3.3),
        TopInstitution(rank: 4, name: "Fidelity Management", category: "Mutual Funds", valueInBillions: 8.7, percentOwnership: 3.1),
        TopInstitution(rank: 5, name: "Geode Capital Management", category: "Investment Advisor", valueInBillions: 6.4, percentOwnership: 2.3),
        TopInstitution(rank: 6, name: "Northern Trust Corporation", category: "Wealth Management", valueInBillions: 5.9, percentOwnership: 2.1),
        TopInstitution(rank: 7, name: "Morgan Stanley", category: "Investment Banking", valueInBillions: 5.1, percentOwnership: 1.8),
        TopInstitution(rank: 8, name: "JPMorgan Chase & Co", category: "Commercial Banking", valueInBillions: 4.7, percentOwnership: 1.7),
        TopInstitution(rank: 9, name: "Bank of America Corporation", category: "Financial Services", valueInBillions: 4.3, percentOwnership: 1.5),
        TopInstitution(rank: 10, name: "Goldman Sachs Group Inc", category: "Investment Banking", valueInBillions: 3.8, percentOwnership: 1.4)
    ]
}

extension TopInsider {
    static let sampleData: [TopInsider] = [
        TopInsider(rank: 1, name: "Tim Cook", title: "Chief Executive Officer", valueInMillions: 1850.5, percentOwnership: 0.66),
        TopInsider(rank: 2, name: "Arthur D. Levinson", title: "Chairman of the Board", valueInMillions: 892.3, percentOwnership: 0.32),
        TopInsider(rank: 3, name: "Jeff Williams", title: "Chief Operating Officer", valueInMillions: 645.8, percentOwnership: 0.23),
        TopInsider(rank: 4, name: "Luca Maestri", title: "Chief Financial Officer", valueInMillions: 421.2, percentOwnership: 0.15),
        TopInsider(rank: 5, name: "Katherine Adams", title: "General Counsel & SVP", valueInMillions: 312.5, percentOwnership: 0.11),
        TopInsider(rank: 6, name: "Deirdre O'Brien", title: "SVP Retail + People", valueInMillions: 285.4, percentOwnership: 0.10),
        TopInsider(rank: 7, name: "Craig Federighi", title: "SVP Software Engineering", valueInMillions: 268.9, percentOwnership: 0.10),
        TopInsider(rank: 8, name: "John Ternus", title: "SVP Hardware Engineering", valueInMillions: 245.1, percentOwnership: 0.09),
        TopInsider(rank: 9, name: "Greg Joswiak", title: "SVP Worldwide Marketing", valueInMillions: 198.7, percentOwnership: 0.07),
        TopInsider(rank: 10, name: "James A. Bell", title: "Independent Director", valueInMillions: 156.2, percentOwnership: 0.06)
    ]
}

extension Top10OwnersData {
    static let sampleData = Top10OwnersData(
        institutions: TopInstitution.sampleData,
        insiders: TopInsider.sampleData
    )
}

// MARK: - Recent Activities Tab

enum RecentActivitiesTab: String, CaseIterable {
    case institutions = "Institutions"
    case insiders = "Insiders"
}

// MARK: - Recent Activities Sort Option

enum RecentActivitiesSortOption: String, CaseIterable {
    case byValue = "By Value ($)"
    case byDate = "By Date"
}

// MARK: - Institutional Activity

/// Represents a recent institutional trading activity
struct InstitutionalActivity: Identifiable {
    let id = UUID()
    let institutionName: String
    let category: String  // e.g., "Asset Management", "Investment Banking"
    let date: Date
    let changeInMillions: Double  // Positive = bought, Negative = sold
    let changePercent: Double
    let totalHeldInBillions: Double

    var isPositive: Bool {
        changeInMillions >= 0
    }

    var formattedChange: String {
        let sign = changeInMillions >= 0 ? "+" : "-"
        if abs(changeInMillions) >= 1000 {
            return "\(sign)$\(String(format: "%.2f", abs(changeInMillions) / 1000))B"
        }
        return "\(sign)$\(String(format: "%.2f", abs(changeInMillions)))M"
    }

    var formattedChangePercent: String {
        let sign = changePercent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", changePercent))%"
    }

    var formattedTotalHeld: String {
        if totalHeldInBillions >= 1 {
            return "Held: $\(String(format: "%.1f", totalHeldInBillions))B"
        }
        return "Held: $\(String(format: "%.0f", totalHeldInBillions * 1000))M"
    }

    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MM/dd/yyyy"
        return formatter.string(from: date)
    }

    var changeColor: Color {
        isPositive ? AppColors.bullish : AppColors.bearish
    }
}

// MARK: - Recent Activities Flow Summary

/// Summary of recent institutional flow
struct RecentActivitiesFlowSummary {
    let periodDescription: String  // e.g., "Oct - Dec 2025"
    let quarterDescription: String  // e.g., "Q4"
    let inFlowInBillions: Double
    let outFlowInBillions: Double

    var netFlowInMillions: Double {
        (inFlowInBillions - outFlowInBillions) * 1000
    }

    var isNetPositive: Bool {
        netFlowInMillions >= 0
    }

    var formattedInFlow: String {
        String(format: "$%.1fB", inFlowInBillions)
    }

    var formattedOutFlow: String {
        String(format: "$%.1fB", outFlowInBillions)
    }

    var formattedNetFlow: String {
        let sign = netFlowInMillions >= 0 ? "+ " : "- "
        if abs(netFlowInMillions) >= 1000 {
            return "\(sign)$\(String(format: "%.2f", abs(netFlowInMillions) / 1000))B"
        }
        return "\(sign)$\(String(format: "%.0f", abs(netFlowInMillions)))M"
    }

    var netFlowColor: Color {
        isNetPositive ? AppColors.bullish : AppColors.bearish
    }

    /// Percentage of in flow vs total flow for the bar visualization
    var inFlowPercent: Double {
        let total = inFlowInBillions + outFlowInBillions
        guard total > 0 else { return 0.5 }
        return inFlowInBillions / total
    }
}

// MARK: - Recent Activities Data

struct RecentActivitiesData {
    let institutionalFlowSummary: RecentActivitiesFlowSummary
    let institutionalActivities: [InstitutionalActivity]
    let insiderActivities: InsiderActivitiesData

    func sortedInstitutionalActivities(by option: RecentActivitiesSortOption) -> [InstitutionalActivity] {
        switch option {
        case .byValue:
            return institutionalActivities.sorted { abs($0.changeInMillions) > abs($1.changeInMillions) }
        case .byDate:
            return institutionalActivities.sorted { $0.date > $1.date }
        }
    }
}

// MARK: - Recent Activities Sample Data

extension RecentActivitiesFlowSummary {
    static let sampleData = RecentActivitiesFlowSummary(
        periodDescription: "Oct - Dec 2025",
        quarterDescription: "Q4",
        inFlowInBillions: 2.1,
        outFlowInBillions: 1.8
    )
}

extension InstitutionalActivity {
    static func createDate(_ month: Int, _ day: Int, _ year: Int) -> Date {
        var components = DateComponents()
        components.month = month
        components.day = day
        components.year = year
        return Calendar.current.date(from: components) ?? Date()
    }

    static let sampleData: [InstitutionalActivity] = [
        InstitutionalActivity(
            institutionName: "Vanguard Group Inc",
            category: "Asset Management",
            date: createDate(12, 30, 2025),
            changeInMillions: 49.43,
            changePercent: 0.34,
            totalHeldInBillions: 14.5
        ),
        InstitutionalActivity(
            institutionName: "BlackRock Fund Advisors",
            category: "Investment Management",
            date: createDate(11, 14, 2025),
            changeInMillions: 15.90,
            changePercent: 0.54,
            totalHeldInBillions: 11.5
        ),
        InstitutionalActivity(
            institutionName: "State Street Corporation",
            category: "Financial Services",
            date: createDate(12, 20, 2025),
            changeInMillions: -10.40,
            changePercent: -0.24,
            totalHeldInBillions: 5.0
        ),
        InstitutionalActivity(
            institutionName: "Fidelity Management",
            category: "Mutual Funds",
            date: createDate(12, 10, 2025),
            changeInMillions: 9.30,
            changePercent: 0.21,
            totalHeldInBillions: 4.8
        ),
        InstitutionalActivity(
            institutionName: "Morgan Stanley",
            category: "Financial Services",
            date: createDate(12, 20, 2025),
            changeInMillions: 7.30,
            changePercent: 0.18,
            totalHeldInBillions: 4.5
        ),
        InstitutionalActivity(
            institutionName: "JPMorgan Chase & Co",
            category: "Commercial Banking",
            date: createDate(10, 25, 2025),
            changeInMillions: -4.40,
            changePercent: -0.34,
            totalHeldInBillions: 3.4
        ),
        InstitutionalActivity(
            institutionName: "Goldman Sachs Group",
            category: "Investment Banking",
            date: createDate(11, 28, 2025),
            changeInMillions: 12.80,
            changePercent: 0.42,
            totalHeldInBillions: 3.2
        ),
        InstitutionalActivity(
            institutionName: "Northern Trust Corp",
            category: "Wealth Management",
            date: createDate(12, 5, 2025),
            changeInMillions: -8.50,
            changePercent: -0.28,
            totalHeldInBillions: 2.8
        )
    ]
}

extension RecentActivitiesData {
    static let sampleData = RecentActivitiesData(
        institutionalFlowSummary: RecentActivitiesFlowSummary.sampleData,
        institutionalActivities: InstitutionalActivity.sampleData,
        insiderActivities: InsiderActivitiesData.sampleData
    )
}

// MARK: - Insider Activity Transaction Type

/// Type of insider transaction with informative classification
enum InsiderTransactionType: String, CaseIterable {
    case informativeBuy = "Informative Buy"
    case informativeSell = "Informative Sell"
    case uninformativeBuy = "Uninformative Buy"
    case uninformativeSell = "Uninformative Sell"

    var isBuy: Bool {
        self == .informativeBuy || self == .uninformativeBuy
    }

    var isInformative: Bool {
        self == .informativeBuy || self == .informativeSell
    }

    var color: Color {
        switch self {
        case .informativeBuy:
            return AppColors.bullish
        case .informativeSell:
            return AppColors.bearish
        case .uninformativeBuy, .uninformativeSell:
            return AppColors.textSecondary
        }
    }

    var valueColor: Color {
        isBuy ? AppColors.bullish : AppColors.bearish
    }
}

// MARK: - Insider Activity Filter Option

enum InsiderActivityFilterOption: String, CaseIterable {
    case all = "All"
    case informative = "Informative"
}

// MARK: - Insider Activity

/// Represents a recent insider trading activity
struct InsiderActivity: Identifiable {
    let id = UUID()
    let name: String  // e.g., "Tim Cook"
    let title: String  // e.g., "CEO"
    let date: Date
    let changeInMillions: Double  // Positive = bought, Negative = sold
    let transactionType: InsiderTransactionType
    let priceAtTransaction: Double

    var isPositive: Bool {
        changeInMillions >= 0
    }

    var formattedChange: String {
        let sign = changeInMillions >= 0 ? "+" : "-"
        if abs(changeInMillions) >= 1000 {
            return "\(sign)$\(String(format: "%.2f", abs(changeInMillions) / 1000))B"
        }
        return "\(sign)$\(String(format: "%.2f", abs(changeInMillions)))M"
    }

    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MM/dd/yyyy"
        return formatter.string(from: date)
    }

    var formattedPrice: String {
        if priceAtTransaction > 0 {
            return String(format: "$%.2f", priceAtTransaction)
        }
        return "$0"
    }

    var changeColor: Color {
        isPositive ? AppColors.bullish : AppColors.bearish
    }
}

// MARK: - Insider Activity Summary

/// Summary of insider trading activity (Informative Buys vs Sells)
struct InsiderActivitySummary {
    let periodDescription: String  // e.g., "Last 12 Months"
    let informativeBuysInMillions: Double
    let informativeSellsInMillions: Double
    let numBuyers: Int
    let numSellers: Int

    var netInformativeFlowInMillions: Double {
        informativeBuysInMillions - informativeSellsInMillions
    }

    var isNetPositive: Bool {
        netInformativeFlowInMillions >= 0
    }

    var formattedBuys: String {
        if informativeBuysInMillions >= 1000 {
            return String(format: "$%.2fB", informativeBuysInMillions / 1000)
        }
        return String(format: "$%.2fM", informativeBuysInMillions)
    }

    var formattedSells: String {
        if informativeSellsInMillions >= 1000 {
            return String(format: "$%.2fB", informativeSellsInMillions / 1000)
        }
        return String(format: "$%.2fM", informativeSellsInMillions)
    }

    var formattedNetFlow: String {
        let sign = netInformativeFlowInMillions >= 0 ? "+ " : "- "
        if abs(netInformativeFlowInMillions) >= 1000 {
            return "\(sign)$\(String(format: "%.2f", abs(netInformativeFlowInMillions) / 1000))B"
        }
        return "\(sign)$\(String(format: "%.2f", abs(netInformativeFlowInMillions)))M"
    }

    var netFlowColor: Color {
        isNetPositive ? AppColors.bullish : AppColors.bearish
    }

    var buyersLabel: String {
        "\(numBuyers) Buyer\(numBuyers == 1 ? "" : "s")"
    }

    var sellersLabel: String {
        "\(numSellers) Seller\(numSellers == 1 ? "" : "s")"
    }
}

// MARK: - Insider Activities Data

struct InsiderActivitiesData {
    let summary: InsiderActivitySummary
    let activities: [InsiderActivity]

    func filteredActivities(by filter: InsiderActivityFilterOption) -> [InsiderActivity] {
        switch filter {
        case .all:
            return activities
        case .informative:
            return activities.filter { $0.transactionType.isInformative }
        }
    }

    func sortedActivities(by option: RecentActivitiesSortOption, filter: InsiderActivityFilterOption) -> [InsiderActivity] {
        let filtered = filteredActivities(by: filter)
        switch option {
        case .byValue:
            return filtered.sorted { abs($0.changeInMillions) > abs($1.changeInMillions) }
        case .byDate:
            return filtered.sorted { $0.date > $1.date }
        }
    }
}

// MARK: - Insider Activities Sample Data

extension InsiderActivitySummary {
    static let sampleData = InsiderActivitySummary(
        periodDescription: "Last 12 Months",
        informativeBuysInMillions: 11.34,
        informativeSellsInMillions: 2.7,
        numBuyers: 2,
        numSellers: 4
    )
}

extension InsiderActivity {
    static let sampleData: [InsiderActivity] = [
        InsiderActivity(
            name: "Tim Cook",
            title: "CEO",
            date: InstitutionalActivity.createDate(12, 30, 2025),
            changeInMillions: 3.43,
            transactionType: .informativeBuy,
            priceAtTransaction: 160.50
        ),
        InsiderActivity(
            name: "Luca Maestri",
            title: "President & CFO",
            date: InstitutionalActivity.createDate(12, 20, 2025),
            changeInMillions: 1.90,
            transactionType: .informativeBuy,
            priceAtTransaction: 161.50
        ),
        InsiderActivity(
            name: "Monica Lozano",
            title: "Director",
            date: InstitutionalActivity.createDate(12, 19, 2025),
            changeInMillions: 5.40,
            transactionType: .uninformativeBuy,
            priceAtTransaction: 0
        ),
        InsiderActivity(
            name: "Jeff Williams",
            title: "COO",
            date: InstitutionalActivity.createDate(12, 19, 2025),
            changeInMillions: -1.30,
            transactionType: .uninformativeSell,
            priceAtTransaction: 160.90
        ),
        InsiderActivity(
            name: "Oscar Munoz",
            title: "Director",
            date: InstitutionalActivity.createDate(12, 19, 2025),
            changeInMillions: -1.47,
            transactionType: .informativeSell,
            priceAtTransaction: 150.54
        ),
        InsiderActivity(
            name: "Craig Federighi",
            title: "SVP Software Engineering",
            date: InstitutionalActivity.createDate(12, 15, 2025),
            changeInMillions: -0.85,
            transactionType: .uninformativeSell,
            priceAtTransaction: 158.20
        ),
        InsiderActivity(
            name: "Katherine Adams",
            title: "General Counsel",
            date: InstitutionalActivity.createDate(12, 10, 2025),
            changeInMillions: 2.15,
            transactionType: .informativeBuy,
            priceAtTransaction: 155.80
        ),
        InsiderActivity(
            name: "Deirdre O'Brien",
            title: "SVP Retail + People",
            date: InstitutionalActivity.createDate(12, 5, 2025),
            changeInMillions: -0.92,
            transactionType: .informativeSell,
            priceAtTransaction: 152.30
        )
    ]
}

extension InsiderActivitiesData {
    static let sampleData = InsiderActivitiesData(
        summary: InsiderActivitySummary.sampleData,
        activities: InsiderActivity.sampleData
    )
}

================================================================================
FILE: frontend/ios/ios/Models/HomeModels.swift
================================================================================

//
//  HomeModels.swift
//  ios
//
//  Data models for the Home screen
//

import Foundation

// MARK: - Market Ticker
struct MarketTicker: Identifiable {
    let id = UUID()
    let name: String
    let price: Double
    let changePercent: Double
    let sparklineData: [Double]

    var isPositive: Bool {
        changePercent >= 0
    }

    var formattedPrice: String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = 2
        formatter.maximumFractionDigits = 2
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: price)) ?? String(format: "%.2f", price)
    }

    var formattedChange: String {
        let sign = changePercent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", changePercent))%"
    }
}

// MARK: - Market Sentiment
enum MarketSentiment: String {
    case bullish = "Bullish"
    case bearish = "Bearish"
    case neutral = "Neutral"
}

// MARK: - Market Insight
struct MarketInsight: Identifiable {
    let id = UUID()
    let headline: String
    let bulletPoints: [String]
    let sentiment: MarketSentiment
    let updatedAt: Date

    var timeAgo: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .full
        return formatter.localizedString(for: updatedAt, relativeTo: Date())
    }
}

// MARK: - Alert Type
enum AlertType: String {
    case whalesAlert = "whales_alert"
    case earningsAlert = "earnings_alert"
    case whalesFollowing = "whales_following"
    case wiserTrending = "wiser_trending"

    var iconName: String {
        switch self {
        case .whalesAlert: return "icon_whale"
        case .earningsAlert: return "icon_earnings"
        case .whalesFollowing: return "icon_whale_following"
        case .wiserTrending: return "icon_wiser"
        }
    }

    var systemIconName: String {
        switch self {
        case .whalesAlert: return "bell.fill"
        case .earningsAlert: return "chart.line.uptrend.xyaxis"
        case .whalesFollowing: return "bell.fill"
        case .wiserTrending: return "lightbulb.fill"
        }
    }
}

// MARK: - Daily Briefing Item
struct DailyBriefingItem: Identifiable {
    let id = UUID()
    let type: AlertType
    let title: String
    let subtitle: String
    let date: Date?
    let badgeText: String?

    var hasDateBadge: Bool {
        date != nil && badgeText != nil
    }
}

// MARK: - Investor Persona
enum InvestorPersona: String, CaseIterable {
    case warrenBuffett = "Warren Buffett"
    case peterLynch = "Peter Lynch"
    case cathieWood = "Cathie Wood"
    case charleMunger = "Charlie Munger"
    case benjaminGraham = "Benjamin Graham"

    var displayName: String {
        rawValue
    }

    var badgeColor: String {
        switch self {
        case .warrenBuffett: return "4F46E5"
        case .peterLynch: return "059669"
        case .cathieWood: return "DC2626"
        case .charleMunger: return "7C3AED"
        case .benjaminGraham: return "EA580C"
        }
    }
}

// MARK: - Research Report
struct ResearchReport: Identifiable {
    let id = UUID()
    let stockTicker: String
    let stockName: String
    let companyLogoName: String
    let persona: InvestorPersona
    let headline: String
    let summary: String
    let rating: Double
    let targetPrice: Double
    let createdAt: Date
    let gradientColors: [String]

    var formattedRating: String {
        String(format: "%.1f/5", rating)
    }

    var formattedTargetPrice: String {
        "$\(Int(targetPrice))"
    }

    var timeAgo: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: createdAt, relativeTo: Date())
    }
}

// MARK: - Tab Item
enum HomeTab: String, CaseIterable {
    case home = "Home"
    case updates = "Updates"
    case research = "Research"
    case tracking = "Tracking"
    case wiser = "Wiser"

    var iconName: String {
        switch self {
        case .home: return "icon_home"
        case .updates: return "icon_updates"
        case .research: return "icon_research"
        case .tracking: return "icon_tracking"
        case .wiser: return "icon_wiser"
        }
    }

    var systemIconName: String {
        switch self {
        case .home: return "house.fill"
        case .updates: return "chart.bar.doc.horizontal"
        case .research: return "magnifyingglass"
        case .tracking: return "star.fill"
        case .wiser: return "lightbulb.fill"
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Models/InvestorPathModels.swift
================================================================================

//
//  InvestorJourneyModels.swift
//  ios
//
//  Data models for The Investor Journey screen
//

import Foundation
import SwiftUI

// MARK: - Lesson Status
enum LessonStatus: String, CaseIterable {
    case completed = "Completed"
    case upNext = "Up Next"
    case notStarted = "Not Started"

    var color: Color {
        switch self {
        case .completed: return AppColors.bullish
        case .upNext: return AppColors.primaryBlue
        case .notStarted: return AppColors.textMuted
        }
    }

    var backgroundColor: Color {
        switch self {
        case .completed: return AppColors.bullish.opacity(0.15)
        case .upNext: return AppColors.primaryBlue.opacity(0.15)
        case .notStarted: return Color.clear
        }
    }
}

// MARK: - Lesson Category
enum LessonCategory {
    case standard
    case crypto

    var badgeText: String? {
        switch self {
        case .crypto: return "Crypto"
        case .standard: return nil
        }
    }

    var badgeColor: Color {
        return Color(hex: "F59E0B")
    }
}

// MARK: - Lesson
struct Lesson: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let durationMinutes: Int
    let status: LessonStatus
    let category: LessonCategory

    var formattedDuration: String {
        "\(durationMinutes) min"
    }

    init(
        title: String,
        description: String,
        durationMinutes: Int,
        status: LessonStatus = .notStarted,
        category: LessonCategory = .standard
    ) {
        self.title = title
        self.description = description
        self.durationMinutes = durationMinutes
        self.status = status
        self.category = category
    }
}

// MARK: - Journey Level
enum JourneyLevel: Int, CaseIterable {
    case foundation = 1
    case analysis = 2
    case strategies = 3
    case mastery = 4

    var title: String {
        switch self {
        case .foundation: return "Foundation"
        case .analysis: return "Analysis"
        case .strategies: return "Strategies"
        case .mastery: return "Mastery"
        }
    }

    var tagline: String {
        switch self {
        case .foundation: return "Your financial fortress starts here"
        case .analysis: return "The rules Wall Street plays by"
        case .strategies: return "The playbooks that built empires"
        case .mastery: return "Think like legendary investors"
        }
    }

    var iconName: String {
        switch self {
        case .foundation: return "ðŸŒ±"
        case .analysis: return "ðŸ“Š"
        case .strategies: return "âš¡"
        case .mastery: return "ðŸ‘‘"
        }
    }

    var color: Color {
        switch self {
        case .foundation: return AppColors.bullish
        case .analysis: return AppColors.primaryBlue
        case .strategies: return AppColors.alertPurple
        case .mastery: return AppColors.neutral
        }
    }
}

// MARK: - Level Progress
struct LevelProgress: Identifiable {
    let id = UUID()
    let level: JourneyLevel
    let lessons: [Lesson]

    var completedCount: Int {
        lessons.filter { $0.status == .completed }.count
    }

    var totalCount: Int {
        lessons.count
    }

    var progress: Double {
        guard totalCount > 0 else { return 0 }
        return Double(completedCount) / Double(totalCount)
    }

    var formattedProgress: String {
        "\(completedCount)/\(totalCount)"
    }

    var isUnlocked: Bool {
        // Level is unlocked if it's Foundation, or previous level has some progress
        level == .foundation || completedCount > 0
    }

    var firstIncompleteLessonId: UUID? {
        lessons.first(where: { $0.status != .completed })?.id
    }
}

// MARK: - Investor Journey Data
struct InvestorJourneyData {
    let levels: [LevelProgress]
    let totalLessonsCompleted: Int
    let totalLessons: Int

    var overallProgress: Double {
        guard totalLessons > 0 else { return 0 }
        return Double(totalLessonsCompleted) / Double(totalLessons)
    }

    var formattedOverallProgress: String {
        "\(totalLessonsCompleted)/\(totalLessons) Lessons Completed"
    }
}

// MARK: - Study Schedule
struct StudySchedule {
    var dailyReminderEnabled: Bool
    var morningSessionTime: Date
    var reviewTime: Date

    var formattedMorningTime: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a"
        return formatter.string(from: morningSessionTime)
    }

    var formattedReviewTime: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a"
        return formatter.string(from: reviewTime)
    }
}

// MARK: - Investor Quote
struct InvestorQuote {
    let text: String
    let author: String
}

// MARK: - Sample Data
extension InvestorJourneyData {
    static let sampleData: InvestorJourneyData = {
        let foundationLessons = [
            Lesson(
                title: "Compound Interest",
                description: "Discover why Einstein called it the eighth wonder of the world.",
                durationMinutes: 3,
                status: .completed
            ),
            Lesson(
                title: "Stock vs. Business",
                description: "Learn to think like an owner, not a trader. The fundamental shift.",
                durationMinutes: 4,
                status: .upNext
            ),
            Lesson(
                title: "Mr. Market",
                description: "How the market works. Meet the bipolar partner who offers to buy or sell every day.",
                durationMinutes: 5,
                status: .notStarted
            ),
            Lesson(
                title: "Risk and Reward are Linked",
                description: "Two sides of the same coin. Understanding how they trade off is the first step to smarter investing.",
                durationMinutes: 4,
                status: .notStarted
            ),
            Lesson(
                title: "Bitcoin: Digital Gold?",
                description: "Understanding the \"Store of Value\" thesis. Why scarcity (21 million coins) matters in a world of printing money.",
                durationMinutes: 4,
                status: .notStarted,
                category: .crypto
            ),
            Lesson(
                title: "ETFs 101",
                description: "What is an ETF? How to invest in ETFs.",
                durationMinutes: 3,
                status: .notStarted
            ),
            Lesson(
                title: "The Inflation Thief",
                description: "How your money loses value while sitting still, and what to do.",
                durationMinutes: 3,
                status: .notStarted
            )
        ]

        let analysisLessons = [
            Lesson(
                title: "Key Statistics",
                description: "The numbers that matter most when evaluating any company.",
                durationMinutes: 5,
                status: .notStarted
            ),
            Lesson(
                title: "The Income Statement",
                description: "Reading the story of profitability and growth over time.",
                durationMinutes: 8,
                status: .notStarted
            ),
            Lesson(
                title: "The Balance Sheet",
                description: "Understanding assets, liabilities, and what the company owns.",
                durationMinutes: 6,
                status: .notStarted
            ),
            Lesson(
                title: "Cash Flow is King",
                description: "Why cash is king and profits can lie. Follow the money.",
                durationMinutes: 5,
                status: .notStarted
            ),
            Lesson(
                title: "Economic Moats",
                description: "Identifying the competitive advantages that protect great businesses.",
                durationMinutes: 4,
                status: .notStarted
            ),
            Lesson(
                title: "Tokenomics 101",
                description: "The \"Central Bank\" of a crypto project. Who holds the tokens? Are they printing more tomorrow (inflation)?",
                durationMinutes: 4,
                status: .notStarted,
                category: .crypto
            ),
            Lesson(
                title: "Red Flags",
                description: "Warning signs: Insider selling, frequent accounting changes, or missed earnings.",
                durationMinutes: 4,
                status: .notStarted
            )
        ]

        let strategiesLessons = [
            Lesson(
                title: "The Buffett Way",
                description: "Value investing principles from the Oracle of Omaha himself.",
                durationMinutes: 7,
                status: .notStarted
            ),
            Lesson(
                title: "The Lynch Way",
                description: "Invest in what you know. Peter Lynch's common sense approach.",
                durationMinutes: 6,
                status: .notStarted
            ),
            Lesson(
                title: "The Cathie Wood Way",
                description: "Disruptive innovation investing and exponential growth thinking.",
                durationMinutes: 5,
                status: .notStarted
            ),
            Lesson(
                title: "Whale Watching",
                description: "Following institutional investors and learning from their moves.",
                durationMinutes: 4,
                status: .notStarted
            ),
            Lesson(
                title: "Portfolio Gardening",
                description: "Cultivating your investments: when to water, prune, or uproot. The myth of diversification.",
                durationMinutes: 5,
                status: .notStarted
            ),
            Lesson(
                title: "The Power of Discipline",
                description: "Keeps your strategy on track and turns plans into profits.",
                durationMinutes: 5,
                status: .notStarted
            ),
            Lesson(
                title: "Common Investing Mistakes",
                description: "Even smart investors make mistakes. Learning the common ones helps you avoid costly decisions before they happen.",
                durationMinutes: 5,
                status: .notStarted
            )
        ]

        let masteryLessons = [
            Lesson(
                title: "The FOMO Cycle",
                description: "Recognizing and breaking free from emotion-driven investing patterns.",
                durationMinutes: 6,
                status: .notStarted
            ),
            Lesson(
                title: "Second-Order Thinking",
                description: "Everyone asks \"What happens next?\" Masters ask \"And then what?\"",
                durationMinutes: 4,
                status: .notStarted
            ),
            Lesson(
                title: "Risk vs. Uncertainty",
                description: "Understanding the crucial difference and managing both effectively.",
                durationMinutes: 5,
                status: .notStarted
            ),
            Lesson(
                title: "The Art of Selling",
                description: "When and how to exit positions without emotion clouding judgment.",
                durationMinutes: 4,
                status: .notStarted
            ),
            Lesson(
                title: "Inversion Thinking",
                description: "Charlie Munger's secret weapon: solving problems backwards.",
                durationMinutes: 5,
                status: .notStarted
            ),
            Lesson(
                title: "AI and Beyond",
                description: "AI is changing how trades are made and investments are chosen, redefining the future of the markets.",
                durationMinutes: 5,
                status: .notStarted
            )
        ]

        let levels = [
            LevelProgress(level: .foundation, lessons: foundationLessons),
            LevelProgress(level: .analysis, lessons: analysisLessons),
            LevelProgress(level: .strategies, lessons: strategiesLessons),
            LevelProgress(level: .mastery, lessons: masteryLessons)
        ]

        let totalCompleted = levels.reduce(0) { $0 + $1.completedCount }
        let totalLessons = levels.reduce(0) { $0 + $1.totalCount }

        return InvestorJourneyData(
            levels: levels,
            totalLessonsCompleted: totalCompleted,
            totalLessons: totalLessons
        )
    }()
}

extension StudySchedule {
    static let defaultSchedule: StudySchedule = {
        let calendar = Calendar.current
        var morningComponents = DateComponents()
        morningComponents.hour = 9
        morningComponents.minute = 0
        let morningTime = calendar.date(from: morningComponents) ?? Date()

        var eveningComponents = DateComponents()
        eveningComponents.hour = 20
        eveningComponents.minute = 0
        let eveningTime = calendar.date(from: eveningComponents) ?? Date()

        return StudySchedule(
            dailyReminderEnabled: true,
            morningSessionTime: morningTime,
            reviewTime: eveningTime
        )
    }()
}

extension InvestorQuote {
    static let buffettQuote = InvestorQuote(
        text: "The stock market is a device for transferring money from the impatient to the patient.",
        author: "Warren Buffett"
    )
}

// MARK: - Lesson Topic Card Models

/// Represents a text segment that can be highlighted in a different color
struct HighlightedTextSegment: Identifiable {
    let id = UUID()
    let text: String
    let isHighlighted: Bool

    init(_ text: String, highlighted: Bool = false) {
        self.text = text
        self.isHighlighted = highlighted
    }
}

/// Type of content card in a lesson story
enum LessonCardType {
    case title       // First card with big title and subtitle
    case content     // Middle cards with image and text
    case completion  // Final card with checkmark and CTA
}

/// Represents a single card/page in a lesson story
struct LessonTopicCard: Identifiable {
    let id = UUID()
    let cardType: LessonCardType

    // Title card properties
    var title: String?
    var subtitleSegments: [HighlightedTextSegment]?

    // Content card properties
    var imageName: String?  // Optional image asset name
    var contentSegments: [HighlightedTextSegment]?

    // Completion card properties
    var completionTitle: String?
    var completionSubtitle: String?
    var ctaButtonTitle: String?
    var ctaDestination: LessonCTADestination?

    // Common properties
    var audioText: String?  // Text for AI voice to read
}

/// Destination for the CTA button on completion card
enum LessonCTADestination {
    case analyzeStock
    case viewPortfolio
    case readArticle(String)
    case watchVideo(String)
    case practiceQuiz
    case custom(String)

    var defaultTitle: String {
        switch self {
        case .analyzeStock: return "Analyze a Stock"
        case .viewPortfolio: return "View Portfolio"
        case .readArticle: return "Read Article"
        case .watchVideo: return "Watch Video"
        case .practiceQuiz: return "Take Quiz"
        case .custom(let title): return title
        }
    }
}

/// Full lesson story content
struct LessonStoryContent: Identifiable {
    let id = UUID()
    let lessonLabel: String      // e.g., "LESSON 1: THE BUFFETT WAY"
    let lessonNumber: Int
    let totalLessonsInLevel: Int
    let estimatedMinutes: Int
    let cards: [LessonTopicCard]

    var totalCards: Int { cards.count }
}

// MARK: - Lesson Topic Card Builders

extension LessonTopicCard {
    /// Create a title card
    static func titleCard(
        title: String,
        subtitle: [HighlightedTextSegment],
        audioText: String? = nil
    ) -> LessonTopicCard {
        LessonTopicCard(
            cardType: .title,
            title: title,
            subtitleSegments: subtitle,
            audioText: audioText
        )
    }

    /// Create a content card with optional image
    static func contentCard(
        imageName: String? = nil,
        content: [HighlightedTextSegment],
        audioText: String? = nil
    ) -> LessonTopicCard {
        LessonTopicCard(
            cardType: .content,
            imageName: imageName,
            contentSegments: content,
            audioText: audioText
        )
    }

    /// Create a completion card
    static func completionCard(
        title: String = "You're ready.",
        subtitle: String = "You've learned the core idea. Practice with a real stock to reinforce it.",
        ctaTitle: String? = nil,
        ctaDestination: LessonCTADestination = .analyzeStock
    ) -> LessonTopicCard {
        LessonTopicCard(
            cardType: .completion,
            completionTitle: title,
            completionSubtitle: subtitle,
            ctaButtonTitle: ctaTitle ?? ctaDestination.defaultTitle,
            ctaDestination: ctaDestination
        )
    }
}

// MARK: - Sample Lesson Story Data

extension LessonStoryContent {
    /// Sample "The Buffett Way" lesson content
    static let buffettWaySample = LessonStoryContent(
        lessonLabel: "LESSON 1: THE BUFFETT WAY",
        lessonNumber: 1,
        totalLessonsInLevel: 7,
        estimatedMinutes: 2,
        cards: [
            // Card 1: Title
            .titleCard(
                title: "Buying Dollar Bills for 50 Cents",
                subtitle: [
                    .init("Why Warren Buffett never pays retail price.")
                ],
                audioText: "Why Warren Buffett never pays retail price."
            ),

            // Card 2: Content about price vs value
            .contentCard(
                imageName: nil, // Placeholder for image
                content: [
                    .init("Price is what the market asks. Value is what the business is worth. The gap between them is where investing opportunities are found.")
                ],
                audioText: "Price is what the market asks. Value is what the business is worth. The gap between them is where investing opportunities are found."
            ),

            // Card 3: Content about emotion vs fundamentals
            .contentCard(
                imageName: nil, // Placeholder for image
                content: [
                    .init("Price changes with emotion. Value is anchored in fundamentals. Knowing the difference helps you invest, not speculate.")
                ],
                audioText: "Price changes with emotion. Value is anchored in fundamentals. Knowing the difference helps you invest, not speculate."
            ),

            // Card 4: Completion
            .completionCard(
                title: "You're ready.",
                subtitle: "You've learned the core idea. Practice with a real stock to reinforce it.",
                ctaDestination: .analyzeStock
            )
        ]
    )
}

================================================================================
FILE: frontend/ios/ios/Models/LearnModels.swift
================================================================================

//
//  LearnModels.swift
//  ios
//
//  Data models for the Learn (Wiser) screen
//

import Foundation
import SwiftUI

// MARK: - Learn Tab
enum LearnTab: String, CaseIterable {
    case learn = "Learn"
    case chat = "Chat"
}

// MARK: - Investor Level
enum InvestorLevel: String, CaseIterable {
    case foundation = "Foundation"
    case analyst = "Analyst"
    case strategist = "Strategist"
    case master = "Master"

    var iconName: String {
        switch self {
        case .foundation: return "graduationcap.fill"
        case .analyst: return "chart.bar.fill"
        case .strategist: return "bolt.fill"
        case .master: return "crown.fill"
        }
    }

    var color: Color {
        switch self {
        case .foundation: return Color(hex: "22C55E")
        case .analyst: return Color(hex: "3B82F6")
        case .strategist: return Color(hex: "A855F7")
        case .master: return Color(hex: "F59E0B")
        }
    }

    var index: Int {
        switch self {
        case .foundation: return 0
        case .analyst: return 1
        case .strategist: return 2
        case .master: return 3
        }
    }
}

// MARK: - Journey Track
struct JourneyTrack: Identifiable {
    let id = UUID()
    let level: InvestorLevel
    let completedCount: Int
    let totalCount: Int
    let items: [JourneyItem]

    var progress: Double {
        guard totalCount > 0 else { return 0 }
        return Double(completedCount) / Double(totalCount)
    }

    var progressPercentage: Int {
        Int(progress * 100)
    }

    var formattedProgress: String {
        "\(completedCount) of \(totalCount) completed"
    }
}

// MARK: - Journey Item
struct JourneyItem: Identifiable {
    let id = UUID()
    let title: String
    let isCompleted: Bool
    let isActive: Bool
    let stepNumber: Int
}

// MARK: - Next Lesson
struct NextLesson: Identifiable {
    let id = UUID()
    let journeyNumber: Int
    let journeyTitle: String
    let lessonTitle: String
    let lessonDescription: String
    let estimatedMinutes: Int
    let chapterCount: Int
}

// MARK: - Money Move Category
enum MoneyMoveCategory: String, CaseIterable {
    case blueprints = "The Blueprints"
    case valueTraps = "Value Traps"
    case battles = "Battles"
    
    var tagline: String {
        switch self {
        case .blueprints: return "How the winners won."
        case .valueTraps: return "Failures, frauds, and lessons learned."
        case .battles: return "Comparative analysis of giants."
        }
    }
    
    var iconName: String {
        switch self {
        case .blueprints: return "trophy.fill"
        case .valueTraps: return "flame.fill"
        case .battles: return "bolt.horizontal.fill"
        }
    }
    
    var iconBackgroundColor: Color {
        switch self {
        case .blueprints: return Color(hex: "22C55E") // Green - success
        case .valueTraps: return Color(hex: "EF4444") // Red - warning
        case .battles: return Color(hex: "8B5CF6") // Purple - strategic
        }
    }
}

// MARK: - Money Move
struct MoneyMove: Identifiable {
    let id = UUID()
    let title: String
    let subtitle: String
    let category: MoneyMoveCategory
    let estimatedMinutes: Int
    let learnerCount: String
    let isBookmarked: Bool
    
    var iconName: String {
        category.iconName
    }
    
    var iconBackgroundColor: Color {
        category.iconBackgroundColor
    }
}

// MARK: - Education Book
struct EducationBook: Identifiable {
    let id = UUID()
    let title: String
    let author: String
    let description: String
    let coverImageName: String
    let pageCount: Int
    let publishedYear: Int
    let rating: Double
    let isMostRead: Bool

    var formattedRating: String {
        String(format: "%.1f", rating)
    }

    var formattedPages: String {
        "\(pageCount) pages"
    }

    var formattedPublished: String {
        "Published \(publishedYear)"
    }
}

// MARK: - Book Level
enum BookLevel: String, CaseIterable {
    case starter = "Starter"
    case intermediate = "Intermediate"
    case advanced = "Advanced"

    var color: Color {
        switch self {
        case .starter: return Color(hex: "06B6D4") // Cyan
        case .intermediate: return Color(hex: "8B5CF6") // Purple
        case .advanced: return Color(hex: "F59E0B") // Amber
        }
    }
}

// MARK: - Book Category Tag
enum BookCategoryTag: String, CaseIterable {
    case mindset = "Mindset"
    case finance = "Finance"
    case strategy = "Strategy"
    case analysis = "Analysis"
    case psychology = "Psychology"
    case investing = "Investing"
    case economics = "Economics"
    case business = "Business"
}

// MARK: - Book Author
struct BookAuthor: Identifiable {
    let id = UUID()
    let name: String
    let title: String
    let bio: String
    let avatarGradientColors: [String]
}

// MARK: - Key Highlight
struct BookKeyHighlight: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let iconName: String
    let iconColor: String
}

// MARK: - Core Chapter
struct BookCoreChapter: Identifiable {
    let id = UUID()
    let number: Int
    let title: String
    let description: String

    /// Returns the detailed content for this chapter if available
    /// This links to the full CoreChapterContent for the detail view
    func getDetailContent(for book: LibraryBook) -> CoreChapterContent? {
        // Map chapter numbers to their detailed content
        // In a real app, this would fetch from a database or API
        switch (book.curriculumOrder, number) {
        case (1, 1): return .sampleEmployeeMindset
        case (1, 2): return .sampleFinancialScorecard
        default: return createGenericContent(for: book)
        }
    }

    /// Creates generic content for chapters without detailed content
    private func createGenericContent(for book: LibraryBook) -> CoreChapterContent {
        CoreChapterContent(
            chapterNumber: number,
            chapterTitle: title,
            bookTitle: book.title,
            bookAuthor: book.author,
            sections: [
                CoreChapterSection(
                    type: .heading,
                    title: nil,
                    content: .text("Overview")
                ),
                CoreChapterSection(
                    type: .paragraph,
                    title: nil,
                    content: .text(description)
                ),
                CoreChapterSection(
                    type: .callout,
                    title: nil,
                    content: .callout(CalloutContent(
                        title: "Coming Soon",
                        text: "Detailed content for this chapter is being developed. Check back soon for the full learning experience.",
                        style: .info
                    ))
                )
            ],
            audioDurationSeconds: 600,
            currentProgress: 0.0
        )
    }
}

// MARK: - Book Discussion/Review
struct BookDiscussion: Identifiable {
    let id = UUID()
    let authorName: String
    let authorAvatarGradient: [String]
    let rating: Int // 1-5 stars
    let content: String
    let postedDate: Date

    var formattedDate: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .full
        return formatter.localizedString(for: postedDate, relativeTo: Date())
    }
}

// MARK: - Library Book (For Book Library/Curriculum View)
struct LibraryBook: Identifiable {
    let id = UUID()
    let title: String
    let author: String
    let description: String
    let pageCount: Int
    let publishedYear: Int
    let rating: Double
    let curriculumOrder: Int
    let isMastered: Bool
    let keyIdeasCount: Int
    let coverGradientStart: String
    let coverGradientEnd: String

    // Detail view properties
    let level: BookLevel
    let chapterCount: Int
    let categoryTags: [BookCategoryTag]
    let whyThisBook: String
    let authorDetail: BookAuthor
    let audioDurationSeconds: Int
    let readTimeMinutes: Int
    let viewCount: String
    let lastUpdated: Date

    // Core tab content
    let keyHighlights: [BookKeyHighlight]
    let coreChapters: [BookCoreChapter]
    let discussions: [BookDiscussion]

    // User progress - which chapter the user is currently on (1-indexed)
    let currentChapter: Int

    var formattedRating: String {
        String(format: "%.1f", rating)
    }

    var formattedPages: String {
        "\(pageCount) pages"
    }

    var formattedPublished: String {
        "Published \(publishedYear)"
    }

    var formattedKeyIdeas: String {
        "\(keyIdeasCount) Key Ideas"
    }

    var formattedChapters: String {
        "\(chapterCount) Cores"
    }

    var formattedAudioDuration: String {
        let minutes = audioDurationSeconds / 60
        let seconds = audioDurationSeconds % 60
        return String(format: "%d:%02d", minutes, seconds)
    }

    var formattedReadTime: String {
        "\(readTimeMinutes) min"
    }

    var formattedViewCount: String {
        viewCount
    }

    var formattedLastUpdated: String {
        let calendar = Calendar.current
        let year = calendar.component(.year, from: lastUpdated)
        return "Updated \(year)"
    }

    /// Convert to AudioEpisode for playback
    var audioEpisode: AudioEpisode {
        AudioEpisode(
            id: "book-\(id.uuidString)",
            title: title,
            subtitle: "by \(author)",
            artworkGradientColors: [coverGradientStart, coverGradientEnd],
            artworkIcon: "book.fill",
            duration: TimeInterval(audioDurationSeconds),
            category: .books,
            authorName: author,
            sourceId: id.uuidString
        )
    }
}

// MARK: - Community Discussion
struct CommunityDiscussion: Identifiable {
    let id = UUID()
    let authorName: String
    let authorAvatarName: String
    let content: String
    let postedAt: Date
    let replyCount: Int
    let likeCount: Int

    var timeAgo: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: postedAt, relativeTo: Date())
    }

    var formattedReplies: String {
        "\(replyCount) replies"
    }

    var formattedLikes: String {
        "\(likeCount)"
    }
}



// MARK: - Sample Data Extensions
extension JourneyTrack {
    static let sampleBeginner = JourneyTrack(
        level: .foundation,
        completedCount: 1,
        totalCount: 7,
        items: [
            JourneyItem(title: "Compound Interest", isCompleted: true, isActive: false, stepNumber: 1),
            JourneyItem(title: "Stock vs. Business", isCompleted: false, isActive: true, stepNumber: 2),
            JourneyItem(title: "Mr. Market", isCompleted: false, isActive: false, stepNumber: 3),
            JourneyItem(title: "Risk and Reward are Linked", isCompleted: false, isActive: false, stepNumber: 4)
        ]
    )
}

extension NextLesson {
    static let sampleData = NextLesson(
        journeyNumber: 2,
        journeyTitle: "Analyst",
        lessonTitle: "How the System Works",
        lessonDescription: "Understanding market mechanics, analysis financial report and more.",
        estimatedMinutes: 18,
        chapterCount: 7
    )
}

extension MoneyMove {
    static let sampleData: [MoneyMove] = [
        // Mix of categories for visual variety
        MoneyMove(
            title: "How Amazon Built Its Moat",
            subtitle: "The strategy behind unstoppable dominance.",
            category: .blueprints,
            estimatedMinutes: 12,
            learnerCount: "2.1k",
            isBookmarked: false
        ),
        MoneyMove(
            title: "The Fall of Enron",
            subtitle: "Red flags every investor should know.",
            category: .valueTraps,
            estimatedMinutes: 15,
            learnerCount: "1.5k",
            isBookmarked: false
        ),
        MoneyMove(
            title: "Netflix vs. Disney+",
            subtitle: "The streaming wars breakdown.",
            category: .battles,
            estimatedMinutes: 14,
            learnerCount: "2.3k",
            isBookmarked: false
        ),
        MoneyMove(
            title: "Warren Buffett's Early Days",
            subtitle: "The moves that built a fortune.",
            category: .blueprints,
            estimatedMinutes: 10,
            learnerCount: "1.8k",
            isBookmarked: false
        ),
        MoneyMove(
            title: "Tesla vs. Traditional Auto",
            subtitle: "Innovation meets industry giants.",
            category: .battles,
            estimatedMinutes: 13,
            learnerCount: "1.9k",
            isBookmarked: false
        ),
        MoneyMove(
            title: "WeWork's Unraveling",
            subtitle: "When valuations don't match reality.",
            category: .valueTraps,
            estimatedMinutes: 11,
            learnerCount: "1.3k",
            isBookmarked: false
        )
    ]
}

extension EducationBook {
    static let sampleData: [EducationBook] = [
        EducationBook(
            title: "The Intelligent Investor",
            author: "Benjamin Graham",
            description: "The Bible of Value Investing. Warren Buffett's #1 recommended book.",
            coverImageName: "book_intelligent_investor",
            pageCount: 623,
            publishedYear: 1949,
            rating: 4.8,
            isMostRead: true
        ),
        EducationBook(
            title: "One Up On Wall Street",
            author: "Peter Lynch",
            description: "How to use what you already know to make money in the market.",
            coverImageName: "book_one_up_wall_street",
            pageCount: 304,
            publishedYear: 1989,
            rating: 4.5,
            isMostRead: false
        ),
        EducationBook(
            title: "Common Stocks and Uncommon Profits",
            author: "Philip Fisher",
            description: "The growth investing masterpiece that influenced Warren Buffett.",
            coverImageName: "book_common_stocks",
            pageCount: 271,
            publishedYear: 1958,
            rating: 4.7,
            isMostRead: false
        )
    ]
}

extension CommunityDiscussion {
    static let sampleData: [CommunityDiscussion] = [
        CommunityDiscussion(
            authorName: "Sarah Chen",
            authorAvatarName: "avatar_sarah",
            content: "Just finished reading about economic moats. Can someone explain how to identify them in tech companies?",
            postedAt: Calendar.current.date(byAdding: .hour, value: -2, to: Date())!,
            replyCount: 24,
            likeCount: 156
        ),
        CommunityDiscussion(
            authorName: "Marcus Johnson",
            authorAvatarName: "avatar_marcus",
            content: "My portfolio is down 15% this month. Should I hold or sell? Looking for advice from experienced investors.",
            postedAt: Calendar.current.date(byAdding: .hour, value: -5, to: Date())!,
            replyCount: 89,
            likeCount: 203
        )
    ]
}

extension LibraryBook {
    // Sample discussions used across books
    private static let sampleDiscussions: [BookDiscussion] = [
        BookDiscussion(
            authorName: "Michael Chen",
            authorAvatarGradient: ["3B82F6", "1E40AF"],
            rating: 5,
            content: "This book completely changed my perspective on money and wealth. The lessons about assets vs liabilities are eye-opening. Highly recommend for anyone wanting to improve their financial literacy!",
            postedDate: Calendar.current.date(byAdding: .day, value: -2, to: Date())!
        ),
        BookDiscussion(
            authorName: "Sarah Johnson",
            authorAvatarGradient: ["EC4899", "BE185D"],
            rating: 5,
            content: "A must-read for everyone! The storytelling approach makes complex financial concepts easy to understand. I've already started applying these principles to my own finances.",
            postedDate: Calendar.current.date(byAdding: .day, value: -5, to: Date())!
        ),
        BookDiscussion(
            authorName: "David Park",
            authorAvatarGradient: ["22C55E", "15803D"],
            rating: 4,
            content: "Great foundational book for beginners. Some concepts are a bit simplified, but that's what makes it accessible. Perfect starting point for your investment journey.",
            postedDate: Calendar.current.date(byAdding: .day, value: -7, to: Date())!
        )
    ]

    static let sampleData: [LibraryBook] = [
        // Book 1 - Rich Dad Poor Dad - MASTERED
        LibraryBook(
            title: "Rich Dad Poor Dad",
            author: "Robert T. Kiyosaki",
            description: "What the rich teach their kids about money that the poor and middle class do not.",
            pageCount: 336,
            publishedYear: 1997,
            rating: 4.7,
            curriculumOrder: 1,
            isMastered: true,
            keyIdeasCount: 12,
            coverGradientStart: "7C3AED",
            coverGradientEnd: "4C1D95",
            level: .starter,
            chapterCount: 7,
            categoryTags: [.mindset, .finance],
            whyThisBook: "Rich Dad Poor Dad is Robert Kiyosaki's best-selling book about the difference in mindset between the poor, middle class, and rich. It advocates the importance of financial literacy, financial independence and building wealth through investing in assets.\n\nThe book is largely based on Kiyosaki's upbringing and education in Hawaii. It highlights the different attitudes toward money, work, and life between his biological father and the father of his best friend.",
            authorDetail: BookAuthor(
                name: "Robert T. Kiyosaki",
                title: "Entrepreneur, Investor & Author",
                bio: "Robert Kiyosaki is an American businessman and author. He founded the Rich Dad Company which provides personal finance and business education through books and videos.",
                avatarGradientColors: ["3B82F6", "1E40AF"]
            ),
            audioDurationSeconds: 1080,
            readTimeMinutes: 18,
            viewCount: "4.2M",
            lastUpdated: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 27))!,
            keyHighlights: [
                BookKeyHighlight(title: "Assets vs. Liabilities", description: "The rich acquire assets. The poor and middle class acquire liabilities that they think are assets.", iconName: "chart.pie.fill", iconColor: "22C55E"),
                BookKeyHighlight(title: "Financial Education", description: "Schools don't teach financial literacy. You must educate yourself about money and investing.", iconName: "book.fill", iconColor: "3B82F6"),
                BookKeyHighlight(title: "Work to Learn", description: "Don't work for money. Work to learn skills that will help you become financially independent.", iconName: "lightbulb.fill", iconColor: "F59E0B"),
                BookKeyHighlight(title: "Take Risks", description: "Playing it safe is actually the riskiest thing you can do. Learn to manage risk and take calculated chances.", iconName: "bolt.fill", iconColor: "8B5CF6")
            ],
            coreChapters: [
                BookCoreChapter(number: 1, title: "De-Programming the \"Employee\" Mindset", description: "Stop trading time for money by breaking the psychological cycle of fear and greed that keeps 90% of people trapped in the Rat Race."),
                BookCoreChapter(number: 2, title: "Mastering the Financial Scorecard", description: "Wealth isn't about how much you make, but how much you keepâ€”learn to read the \"report card\" of adulthood by strictly distinguishing assets from liabilities."),
                BookCoreChapter(number: 3, title: "The Corporate Shield Strategy", description: "Utilize the \"secret weapon\" of the wealthy to legally minimize tax exposure and protect your assets before the government gets paid."),
                BookCoreChapter(number: 4, title: "The Opportunity Hunter", description: "Train your brain to see deals where others see chaos; financial intelligence is simply having more options than the average person."),
                BookCoreChapter(number: 5, title: "Trading Security for Skills", description: "View your job as a paid internship where you acquire the \"Triangle of Skills\"â€”sales, marketing, and communicationâ€”rather than a safety net."),
                BookCoreChapter(number: 6, title: "Conquering the Inner Saboteur", description: "Identify and neutralize the emotional barriers that kill investment deals even when the numbers make sense."),
                BookCoreChapter(number: 7, title: "The \"First 3 Steps\" Launchpad", description: "A tactical checklist to move from \"analysis paralysis\" to your first asset acquisition within 90 days.")
            ],
            discussions: sampleDiscussions,
            currentChapter: 2
        ),

        // Book 2 - The Intelligent Investor - MASTERED
        LibraryBook(
            title: "The Intelligent Investor",
            author: "Benjamin Graham",
            description: "The definitive book on value investing. Warren Buffett calls it 'the best book on investing ever written.'",
            pageCount: 623,
            publishedYear: 1949,
            rating: 4.8,
            curriculumOrder: 2,
            isMastered: true,
            keyIdeasCount: 18,
            coverGradientStart: "1E3A5F",
            coverGradientEnd: "0F1F35",
            level: .intermediate,
            chapterCount: 20,
            categoryTags: [.investing, .analysis, .strategy],
            whyThisBook: "The Intelligent Investor is widely considered the bible of value investing. Benjamin Graham's timeless wisdom on how to think about investing has guided generations of the world's most successful investors.\n\nThe book teaches the concept of 'Mr. Market,' margin of safety, and the distinction between investing and speculation. Warren Buffett credits this book for shaping his investment philosophy.",
            authorDetail: BookAuthor(
                name: "Benjamin Graham",
                title: "Father of Value Investing",
                bio: "Benjamin Graham was an influential economist, professor, and professional investor. Known as the 'father of value investing,' he mentored Warren Buffett and developed fundamental analysis techniques still used today.",
                avatarGradientColors: ["1E3A5F", "0F1F35"]
            ),
            audioDurationSeconds: 2700,
            readTimeMinutes: 45,
            viewCount: "8.1M",
            lastUpdated: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 20))!,
            keyHighlights: [
                BookKeyHighlight(title: "Mr. Market", description: "Think of the market as a moody partner who offers to buy or sell shares daily at different prices.", iconName: "person.fill.questionmark", iconColor: "3B82F6"),
                BookKeyHighlight(title: "Margin of Safety", description: "Always buy at a significant discount to intrinsic value to protect against errors and bad luck.", iconName: "shield.fill", iconColor: "22C55E"),
                BookKeyHighlight(title: "Investor vs Speculator", description: "An investor analyzes fundamentals; a speculator bets on price movements.", iconName: "chart.bar.fill", iconColor: "F59E0B"),
                BookKeyHighlight(title: "Defensive Investing", description: "Build a diversified portfolio that doesn't require constant attention.", iconName: "lock.shield.fill", iconColor: "8B5CF6")
            ],
            coreChapters: [
                BookCoreChapter(number: 1, title: "Investment versus Speculation", description: "Defining what it means to be a true investor rather than a gambler."),
                BookCoreChapter(number: 2, title: "The Investor and Inflation", description: "How to protect your portfolio against the erosion of purchasing power."),
                BookCoreChapter(number: 3, title: "A Century of Stock Market History", description: "Lessons from 100 years of market performance."),
                BookCoreChapter(number: 4, title: "General Portfolio Policy", description: "The defensive investor's approach to asset allocation."),
                BookCoreChapter(number: 5, title: "The Defensive Investor and Common Stocks", description: "Criteria for selecting quality stocks for conservative portfolios."),
                BookCoreChapter(number: 6, title: "The Enterprising Investor", description: "Strategies for more active investors seeking higher returns.")
            ],
            discussions: sampleDiscussions,
            currentChapter: 6
        ),

        // Book 3 - The Psychology of Money
        LibraryBook(
            title: "The Psychology of Money",
            author: "Morgan Housel",
            description: "Timeless lessons on wealth, greed, and happiness. Understanding how emotions drive financial decisions.",
            pageCount: 256,
            publishedYear: 2020,
            rating: 4.9,
            curriculumOrder: 3,
            isMastered: false,
            keyIdeasCount: 15,
            coverGradientStart: "059669",
            coverGradientEnd: "064E3B",
            level: .starter,
            chapterCount: 20,
            categoryTags: [.psychology, .mindset, .finance],
            whyThisBook: "Morgan Housel explores the strange ways people think about money and teaches you how to make better sense of one of life's most important topics.\n\nThrough 19 short stories, the book demonstrates that financial success is not about what you know technically but how you behave. It's about soft skills that are often overlooked in financial education.",
            authorDetail: BookAuthor(
                name: "Morgan Housel",
                title: "Partner at Collaborative Fund",
                bio: "Morgan Housel is a partner at Collaborative Fund and a former columnist at The Motley Fool and The Wall Street Journal. He is a two-time winner of the Best in Business Award from the Society of American Business Editors.",
                avatarGradientColors: ["059669", "047857"]
            ),
            audioDurationSeconds: 1560,
            readTimeMinutes: 26,
            viewCount: "5.7M",
            lastUpdated: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 15))!,
            keyHighlights: [
                BookKeyHighlight(title: "Compounding", description: "The most powerful force in finance. Small gains over long periods create enormous wealth.", iconName: "arrow.up.right", iconColor: "22C55E"),
                BookKeyHighlight(title: "Room for Error", description: "Plan for things going wrong. Survival is the cornerstone of wealth building.", iconName: "exclamationmark.shield.fill", iconColor: "F59E0B"),
                BookKeyHighlight(title: "Wealth is Hidden", description: "True wealth is what you don't seeâ€”money not spent on visible luxuries.", iconName: "eye.slash.fill", iconColor: "8B5CF6"),
                BookKeyHighlight(title: "Reasonable > Rational", description: "Being reasonable is more sustainable than being coldly rational with money.", iconName: "heart.fill", iconColor: "EC4899")
            ],
            coreChapters: [
                BookCoreChapter(number: 1, title: "No One's Crazy", description: "Everyone has unique experiences that shape their financial behavior."),
                BookCoreChapter(number: 2, title: "Luck & Risk", description: "Nothing is as good or bad as it seems; outcomes involve luck."),
                BookCoreChapter(number: 3, title: "Never Enough", description: "The hardest financial skill is getting the goalpost to stop moving."),
                BookCoreChapter(number: 4, title: "Confounding Compounding", description: "The counterintuitive math behind exponential growth."),
                BookCoreChapter(number: 5, title: "Getting Wealthy vs. Staying Wealthy", description: "Making money requires risk; keeping it requires humility."),
                BookCoreChapter(number: 6, title: "Tails, You Win", description: "A few outlier events drive the majority of outcomes.")
            ],
            discussions: sampleDiscussions,
            currentChapter: 1
        ),

        // Book 4 - One Up On Wall Street
        LibraryBook(
            title: "One Up On Wall Street",
            author: "Peter Lynch",
            description: "How to use what you already know to make money in the market from the legendary Fidelity fund manager.",
            pageCount: 304,
            publishedYear: 1989,
            rating: 4.5,
            curriculumOrder: 4,
            isMastered: false,
            keyIdeasCount: 14,
            coverGradientStart: "2D4A3E",
            coverGradientEnd: "1A2D25",
            level: .intermediate,
            chapterCount: 18,
            categoryTags: [.investing, .strategy, .analysis],
            whyThisBook: "Peter Lynch ran the Magellan Fund at Fidelity, achieving an average annual return of 29.2% over 13 years. In this book, he shares his investment approach of finding 'tenbaggers' - stocks that increase tenfold in value.\n\nLynch teaches investors to use their everyday experiences to find investment opportunities, categorizing stocks into six types to help identify the best opportunities.",
            authorDetail: BookAuthor(
                name: "Peter Lynch",
                title: "Legendary Fidelity Fund Manager",
                bio: "Peter Lynch is a legendary American investor, known for achieving an average annual return of 29.2% as manager of the Magellan Fund at Fidelity Investments, making it the best-performing mutual fund in the world.",
                avatarGradientColors: ["2D4A3E", "1A2D25"]
            ),
            audioDurationSeconds: 1680,
            readTimeMinutes: 28,
            viewCount: "3.2M",
            lastUpdated: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 10))!,
            keyHighlights: [
                BookKeyHighlight(title: "Invest in What You Know", description: "Your personal experiences give you an edge over Wall Street analysts.", iconName: "lightbulb.fill", iconColor: "F59E0B"),
                BookKeyHighlight(title: "Tenbaggers", description: "Look for stocks with the potential to increase 10x in value.", iconName: "arrow.up.circle.fill", iconColor: "22C55E"),
                BookKeyHighlight(title: "Six Stock Categories", description: "Classify stocks as slow growers, stalwarts, fast growers, cyclicals, turnarounds, or asset plays.", iconName: "square.grid.2x2.fill", iconColor: "3B82F6"),
                BookKeyHighlight(title: "Do Your Homework", description: "Research the company's story, financials, and competitive position.", iconName: "doc.text.magnifyingglass", iconColor: "8B5CF6")
            ],
            coreChapters: [
                BookCoreChapter(number: 1, title: "The Making of a Stockpicker", description: "Lynch's journey to becoming a legendary investor."),
                BookCoreChapter(number: 2, title: "The Wall Street Oxymorons", description: "Why individual investors can beat the professionals."),
                BookCoreChapter(number: 3, title: "Is This Gambling, or What?", description: "Distinguishing investing from speculation."),
                BookCoreChapter(number: 4, title: "Passing the Mirror Test", description: "Knowing yourself before investing."),
                BookCoreChapter(number: 5, title: "Is This a Good Market?", description: "Why market timing doesn't work."),
                BookCoreChapter(number: 6, title: "Stalking the Tenbagger", description: "Finding stocks with multi-bagger potential.")
            ],
            discussions: sampleDiscussions,
            currentChapter: 1
        ),

        // Book 5 - Common Stocks and Uncommon Profits
        LibraryBook(
            title: "Common Stocks and Uncommon Profits",
            author: "Philip Fisher",
            description: "The growth investing masterpiece that influenced Warren Buffett's investment philosophy.",
            pageCount: 271,
            publishedYear: 1958,
            rating: 4.7,
            curriculumOrder: 5,
            isMastered: false,
            keyIdeasCount: 16,
            coverGradientStart: "4A1E1E",
            coverGradientEnd: "2D1212",
            level: .intermediate,
            chapterCount: 14,
            categoryTags: [.investing, .strategy, .analysis],
            whyThisBook: "Philip Fisher pioneered growth investing and developed the 'scuttlebutt' method of research. This book presents Fisher's 15 points to look for in a common stock.\n\nWarren Buffett describes himself as '85% Graham and 15% Fisher,' highlighting the profound impact this book had on his transition from pure value investing to quality-focused investing.",
            authorDetail: BookAuthor(
                name: "Philip Fisher",
                title: "Pioneer of Growth Investing",
                bio: "Philip Fisher was an American stock investor known for his investment philosophy, detailed in his book 'Common Stocks and Uncommon Profits.' He pioneered the growth investing strategy and influenced Warren Buffett.",
                avatarGradientColors: ["4A1E1E", "2D1212"]
            ),
            audioDurationSeconds: 1440,
            readTimeMinutes: 24,
            viewCount: "2.1M",
            lastUpdated: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 5))!,
            keyHighlights: [
                BookKeyHighlight(title: "Scuttlebutt Method", description: "Research by talking to customers, suppliers, competitors, and employees.", iconName: "bubble.left.and.bubble.right.fill", iconColor: "3B82F6"),
                BookKeyHighlight(title: "15 Points", description: "A checklist of qualities to evaluate before investing in a company.", iconName: "checklist", iconColor: "22C55E"),
                BookKeyHighlight(title: "Hold for Long Term", description: "Buy great companies and hold them for years or decades.", iconName: "clock.fill", iconColor: "F59E0B"),
                BookKeyHighlight(title: "Management Quality", description: "The caliber of management is crucial to long-term success.", iconName: "person.3.fill", iconColor: "8B5CF6")
            ],
            coreChapters: [
                BookCoreChapter(number: 1, title: "Clues from the Past", description: "How historical performance indicates future potential."),
                BookCoreChapter(number: 2, title: "What 'Scuttlebutt' Can Do", description: "The power of on-the-ground research."),
                BookCoreChapter(number: 3, title: "What to Buy: The Fifteen Points", description: "Fisher's famous checklist for stock selection."),
                BookCoreChapter(number: 4, title: "What to Buy: Applying This to Your Own Needs", description: "Customizing the approach to your situation."),
                BookCoreChapter(number: 5, title: "When to Buy", description: "Timing your purchases for maximum value."),
                BookCoreChapter(number: 6, title: "When to Sell", description: "The rare circumstances that justify selling.")
            ],
            discussions: sampleDiscussions,
            currentChapter: 1
        ),

        // Book 6 - The Little Book of Common Sense Investing
        LibraryBook(
            title: "The Little Book of Common Sense Investing",
            author: "John C. Bogle",
            description: "The only way to guarantee your fair share of stock market returns. The case for index funds.",
            pageCount: 304,
            publishedYear: 2007,
            rating: 4.6,
            curriculumOrder: 6,
            isMastered: false,
            keyIdeasCount: 10,
            coverGradientStart: "1E40AF",
            coverGradientEnd: "1E3A8A",
            level: .starter,
            chapterCount: 20,
            categoryTags: [.investing, .strategy],
            whyThisBook: "John Bogle, founder of Vanguard, revolutionized investing by creating the first index fund. This book makes the case for passive investing and demonstrates why most active managers fail to beat the market.\n\nThe book teaches the importance of low costs, broad diversification, and staying the course through market volatility.",
            authorDetail: BookAuthor(
                name: "John C. Bogle",
                title: "Founder of Vanguard Group",
                bio: "John Clifton Bogle was the founder and chief executive of The Vanguard Group. He is credited with creating the first index fund and was a driving force behind the growth of passive investing.",
                avatarGradientColors: ["1E40AF", "1E3A8A"]
            ),
            audioDurationSeconds: 1320,
            readTimeMinutes: 22,
            viewCount: "2.8M",
            lastUpdated: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 28))!,
            keyHighlights: [
                BookKeyHighlight(title: "Index Funds Win", description: "Most active managers underperform the market over time.", iconName: "chart.line.uptrend.xyaxis", iconColor: "22C55E"),
                BookKeyHighlight(title: "Costs Matter", description: "Every dollar paid in fees is a dollar less in returns.", iconName: "dollarsign.circle.fill", iconColor: "F59E0B"),
                BookKeyHighlight(title: "Stay the Course", description: "Time in the market beats timing the market.", iconName: "clock.arrow.circlepath", iconColor: "3B82F6"),
                BookKeyHighlight(title: "Simple is Best", description: "A total market index fund is all most investors need.", iconName: "sparkles", iconColor: "8B5CF6")
            ],
            coreChapters: [
                BookCoreChapter(number: 1, title: "A Parable", description: "The Gotrocks family learns about the cost of financial intermediaries."),
                BookCoreChapter(number: 2, title: "Rational Exuberance", description: "Understanding long-term stock market returns."),
                BookCoreChapter(number: 3, title: "Cast Your Lot with Business", description: "Why owning businesses beats speculating."),
                BookCoreChapter(number: 4, title: "How Most Investors Turn a Winner's Game into a Loser's Game", description: "The mathematics of active management failure."),
                BookCoreChapter(number: 5, title: "The Grand Illusion", description: "Why past performance doesn't predict future results."),
                BookCoreChapter(number: 6, title: "Taxes Are Costs, Too", description: "The hidden drag of tax inefficiency.")
            ],
            discussions: sampleDiscussions,
            currentChapter: 1
        ),

        // Book 7 - A Random Walk Down Wall Street
        LibraryBook(
            title: "A Random Walk Down Wall Street",
            author: "Burton Malkiel",
            description: "The time-tested strategy for successful investing. Understanding market efficiency.",
            pageCount: 432,
            publishedYear: 1973,
            rating: 4.4,
            curriculumOrder: 7,
            isMastered: false,
            keyIdeasCount: 13,
            coverGradientStart: "7C2D12",
            coverGradientEnd: "451A03",
            level: .intermediate,
            chapterCount: 15,
            categoryTags: [.economics, .investing, .analysis],
            whyThisBook: "Burton Malkiel's classic introduces the efficient market hypothesis and challenges the notion that expert stock pickers can consistently beat the market.\n\nThe book covers both fundamental and technical analysis, exploring their limitations, and makes the case for a diversified, low-cost investment strategy.",
            authorDetail: BookAuthor(
                name: "Burton Malkiel",
                title: "Professor at Princeton University",
                bio: "Burton Gordon Malkiel is an American economist and writer, most known for his classic finance book A Random Walk Down Wall Street. He is a proponent of the efficient market hypothesis.",
                avatarGradientColors: ["7C2D12", "451A03"]
            ),
            audioDurationSeconds: 1920,
            readTimeMinutes: 32,
            viewCount: "1.9M",
            lastUpdated: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 20))!,
            keyHighlights: [
                BookKeyHighlight(title: "Efficient Markets", description: "Stock prices reflect all available information, making consistent outperformance difficult.", iconName: "equal.circle.fill", iconColor: "3B82F6"),
                BookKeyHighlight(title: "Random Walk", description: "Short-term price movements are unpredictable and follow a random pattern.", iconName: "shuffle", iconColor: "F59E0B"),
                BookKeyHighlight(title: "Diversification", description: "Don't put all your eggs in one basket; spread risk across assets.", iconName: "square.grid.3x3.fill", iconColor: "22C55E"),
                BookKeyHighlight(title: "Buy and Hold", description: "Time in the market beats timing the market.", iconName: "hand.raised.fill", iconColor: "8B5CF6")
            ],
            coreChapters: [
                BookCoreChapter(number: 1, title: "Firm Foundations and Castles in the Air", description: "Two theories of how markets work."),
                BookCoreChapter(number: 2, title: "The Madness of Crowds", description: "Historical bubbles and manias."),
                BookCoreChapter(number: 3, title: "Stock Valuation from the Sixties", description: "How valuation methods evolved."),
                BookCoreChapter(number: 4, title: "The Biggest Bubble of All", description: "Lessons from the internet bubble."),
                BookCoreChapter(number: 5, title: "Technical and Fundamental Analysis", description: "Examining the two main approaches to picking stocks."),
                BookCoreChapter(number: 6, title: "A New Walking Shoe", description: "Modern portfolio theory explained.")
            ],
            discussions: sampleDiscussions,
            currentChapter: 1
        ),

        // Book 8 - The Essays of Warren Buffett
        LibraryBook(
            title: "The Essays of Warren Buffett",
            author: "Warren Buffett & Lawrence Cunningham",
            description: "Lessons for corporate America. Wisdom from the Oracle of Omaha's annual letters.",
            pageCount: 368,
            publishedYear: 1997,
            rating: 4.8,
            curriculumOrder: 8,
            isMastered: false,
            keyIdeasCount: 20,
            coverGradientStart: "B45309",
            coverGradientEnd: "78350F",
            level: .advanced,
            chapterCount: 8,
            categoryTags: [.investing, .business, .strategy],
            whyThisBook: "This collection compiles Warren Buffett's annual shareholder letters into a coherent philosophy of investing and business management.\n\nThe essays cover corporate governance, finance, investing, and common stock, providing direct insight into the mind of the world's most successful investor.",
            authorDetail: BookAuthor(
                name: "Warren Buffett",
                title: "Chairman & CEO, Berkshire Hathaway",
                bio: "Warren Edward Buffett is an American business magnate, investor, and philanthropist. Known as the 'Oracle of Omaha,' he is one of the most successful investors in history and consistently ranks among the world's wealthiest people.",
                avatarGradientColors: ["B45309", "78350F"]
            ),
            audioDurationSeconds: 2100,
            readTimeMinutes: 35,
            viewCount: "4.5M",
            lastUpdated: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 15))!,
            keyHighlights: [
                BookKeyHighlight(title: "Circle of Competence", description: "Stay within areas you truly understand.", iconName: "circle.dashed", iconColor: "3B82F6"),
                BookKeyHighlight(title: "Economic Moats", description: "Invest in businesses with durable competitive advantages.", iconName: "shield.checkered", iconColor: "22C55E"),
                BookKeyHighlight(title: "Owner Earnings", description: "Focus on cash flow available to shareholders after maintenance capex.", iconName: "banknote.fill", iconColor: "F59E0B"),
                BookKeyHighlight(title: "Long-term Focus", description: "Our favorite holding period is forever.", iconName: "infinity", iconColor: "8B5CF6")
            ],
            coreChapters: [
                BookCoreChapter(number: 1, title: "Corporate Governance", description: "How boards and managers should serve shareholders."),
                BookCoreChapter(number: 2, title: "Corporate Finance and Investing", description: "Capital allocation and investment philosophy."),
                BookCoreChapter(number: 3, title: "Alternatives to Common Stock", description: "Fixed-income securities and other investments."),
                BookCoreChapter(number: 4, title: "Common Stock", description: "How to value and select individual stocks."),
                BookCoreChapter(number: 5, title: "Mergers and Acquisitions", description: "When acquisitions create or destroy value."),
                BookCoreChapter(number: 6, title: "Accounting and Valuation", description: "Understanding financial statements deeply.")
            ],
            discussions: sampleDiscussions,
            currentChapter: 1
        ),

        // Book 9 - Security Analysis
        LibraryBook(
            title: "Security Analysis",
            author: "Benjamin Graham & David Dodd",
            description: "The classic 1934 edition. The foundation of modern value investing analysis.",
            pageCount: 725,
            publishedYear: 1934,
            rating: 4.6,
            curriculumOrder: 9,
            isMastered: false,
            keyIdeasCount: 22,
            coverGradientStart: "374151",
            coverGradientEnd: "1F2937",
            level: .advanced,
            chapterCount: 52,
            categoryTags: [.analysis, .investing, .finance],
            whyThisBook: "The foundational text of value investing, Security Analysis established the discipline of professional financial analysis during the Great Depression.\n\nThis comprehensive guide covers bond analysis, preferred stock analysis, and common stock analysis with timeless principles that remain relevant today.",
            authorDetail: BookAuthor(
                name: "Benjamin Graham & David Dodd",
                title: "Founders of Value Investing",
                bio: "Benjamin Graham and David Dodd were professors at Columbia Business School who together wrote Security Analysis, establishing the intellectual foundation for what would later be called value investing.",
                avatarGradientColors: ["374151", "1F2937"]
            ),
            audioDurationSeconds: 3600,
            readTimeMinutes: 60,
            viewCount: "1.5M",
            lastUpdated: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 10))!,
            keyHighlights: [
                BookKeyHighlight(title: "Intrinsic Value", description: "Every security has a value based on its underlying fundamentals.", iconName: "dollarsign.square.fill", iconColor: "22C55E"),
                BookKeyHighlight(title: "Margin of Safety", description: "The difference between price and value protects against loss.", iconName: "shield.fill", iconColor: "3B82F6"),
                BookKeyHighlight(title: "Financial Statement Analysis", description: "Deep dive into balance sheets, income statements, and cash flows.", iconName: "doc.text.fill", iconColor: "F59E0B"),
                BookKeyHighlight(title: "Bond Analysis", description: "Evaluating fixed income securities for safety and yield.", iconName: "percent", iconColor: "8B5CF6")
            ],
            coreChapters: [
                BookCoreChapter(number: 1, title: "The Scope and Limits of Security Analysis", description: "Defining what analysis can and cannot do."),
                BookCoreChapter(number: 2, title: "Fundamental Elements in the Problem of Analysis", description: "Core concepts underlying all security analysis."),
                BookCoreChapter(number: 3, title: "Sources of Information", description: "Where to find reliable data for analysis."),
                BookCoreChapter(number: 4, title: "Distinctions Between Investment and Speculation", description: "A clear framework for classifying activities."),
                BookCoreChapter(number: 5, title: "Classification of Securities", description: "Understanding different types of financial instruments."),
                BookCoreChapter(number: 6, title: "The Selection of Fixed-Value Investments", description: "Criteria for choosing bonds and preferred stocks.")
            ],
            discussions: sampleDiscussions,
            currentChapter: 1
        ),

        // Book 10 - The Most Important Thing
        LibraryBook(
            title: "The Most Important Thing",
            author: "Howard Marks",
            description: "Uncommon sense for the thoughtful investor. Legendary Oaktree Capital insights.",
            pageCount: 200,
            publishedYear: 2011,
            rating: 4.7,
            curriculumOrder: 10,
            isMastered: false,
            keyIdeasCount: 17,
            coverGradientStart: "581C87",
            coverGradientEnd: "3B0764",
            level: .advanced,
            chapterCount: 20,
            categoryTags: [.investing, .psychology, .strategy],
            whyThisBook: "Howard Marks distills 40 years of investment wisdom into the essential principles that separate successful investors from the rest.\n\nThe book covers second-level thinking, understanding market cycles, managing risk, and the importance of contrarian thinking in achieving superior returns.",
            authorDetail: BookAuthor(
                name: "Howard Marks",
                title: "Co-Chairman, Oaktree Capital",
                bio: "Howard Stanley Marks is an American investor and writer. He is the co-founder and co-chairman of Oaktree Capital Management, the largest investor in distressed securities worldwide.",
                avatarGradientColors: ["581C87", "3B0764"]
            ),
            audioDurationSeconds: 1200,
            readTimeMinutes: 20,
            viewCount: "2.3M",
            lastUpdated: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 5))!,
            keyHighlights: [
                BookKeyHighlight(title: "Second-Level Thinking", description: "Go beyond the obvious to find insights others miss.", iconName: "brain.head.profile", iconColor: "8B5CF6"),
                BookKeyHighlight(title: "Understanding Risk", description: "Risk means more things can happen than will happen.", iconName: "exclamationmark.triangle.fill", iconColor: "F59E0B"),
                BookKeyHighlight(title: "Market Cycles", description: "Markets swing between euphoria and despair; position accordingly.", iconName: "waveform.path", iconColor: "3B82F6"),
                BookKeyHighlight(title: "Contrarian Thinking", description: "The best opportunities come from disagreeing with consensus.", iconName: "arrow.left.arrow.right", iconColor: "22C55E")
            ],
            coreChapters: [
                BookCoreChapter(number: 1, title: "Second-Level Thinking", description: "The foundation of superior returns."),
                BookCoreChapter(number: 2, title: "Understanding Market Efficiency", description: "What efficient markets mean for investors."),
                BookCoreChapter(number: 3, title: "Value", description: "The relationship between price and intrinsic value."),
                BookCoreChapter(number: 4, title: "The Relationship Between Price and Value", description: "Why buying below value is essential."),
                BookCoreChapter(number: 5, title: "Understanding Risk", description: "Redefining risk beyond volatility."),
                BookCoreChapter(number: 6, title: "Recognizing Risk", description: "When risk is highest and lowest.")
            ],
            discussions: sampleDiscussions,
            currentChapter: 1
        )
    ]
}

================================================================================
FILE: frontend/ios/ios/Models/MoneyMoveArticleModels.swift
================================================================================

//
//  MoneyMoveArticleModels.swift
//  ios
//
//  Data models for Money Move Article Detail View
//

import Foundation
import SwiftUI

// MARK: - Money Move Article (Full Detail)
struct MoneyMoveArticle: Identifiable {
    let id = UUID()
    let title: String
    let subtitle: String
    let category: MoneyMoveCategory
    let author: ArticleAuthor
    let publishedAt: Date
    let readTimeMinutes: Int
    let viewCount: String
    let commentCount: Int
    let isBookmarked: Bool
    let hasAudioVersion: Bool

    // Hero section
    let heroGradientColors: [String]
    let tagLabel: String?
    let isFeatured: Bool // Indicates if this is a featured article

    // Content sections
    let keyHighlights: [ArticleHighlight]
    let sections: [ArticleSection]
    let statistics: [ArticleStatistic]

    // Engagement
    let comments: [ArticleComment]
    let relatedArticles: [RelatedArticle]

    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM dd, yyyy"
        return formatter.string(from: publishedAt)
    }

    var formattedReadTime: String {
        "\(readTimeMinutes) min read"
    }
}

// MARK: - Article Author
struct ArticleAuthor: Identifiable {
    let id = UUID()
    let name: String
    let avatarName: String?
    let title: String
    let isVerified: Bool
    let followerCount: String

    var avatarInitials: String {
        let components = name.components(separatedBy: " ")
        let initials = components.compactMap { $0.first }.prefix(2)
        return String(initials).uppercased()
    }
}

// MARK: - Article Highlight (Key Points)
struct ArticleHighlight: Identifiable {
    let id = UUID()
    let icon: String
    let title: String
    let description: String
}

// MARK: - Article Section
struct ArticleSection: Identifiable {
    let id = UUID()
    let title: String
    let icon: String?
    let content: [ArticleSectionContent]
    let hasGlowEffect: Bool

    init(title: String, icon: String? = nil, content: [ArticleSectionContent], hasGlowEffect: Bool = false) {
        self.title = title
        self.icon = icon
        self.content = content
        self.hasGlowEffect = hasGlowEffect
    }
}

// MARK: - Article Section Content Types
enum ArticleSectionContent: Identifiable {
    case paragraph(String)
    case bulletList([String])
    case subheading(String)
    case quote(text: String, attribution: String?)
    case callout(icon: String, text: String, style: CalloutStyle)
    case chart(ChartData)

    var id: String {
        switch self {
        case .paragraph(let text): return "p-\(text.prefix(20))"
        case .bulletList(let items): return "bl-\(items.first ?? "")"
        case .subheading(let text): return "sh-\(text)"
        case .quote(let text, _): return "q-\(text.prefix(20))"
        case .callout(_, let text, _): return "c-\(text.prefix(20))"
        case .chart(let data): return "chart-\(data.title)"
        }
    }
}

// MARK: - Callout Style
enum CalloutStyle {
    case info
    case warning
    case success
    case highlight

    var backgroundColor: Color {
        switch self {
        case .info: return Color(hex: "3B82F6").opacity(0.05)
        case .warning: return Color(hex: "F59E0B").opacity(0.05)
        case .success: return Color(hex: "22C55E").opacity(0.05)
        case .highlight: return Color(hex: "A855F7").opacity(0.05)
        }
    }

    var borderColor: Color {
        switch self {
        case .info: return Color(hex: "3B82F6").opacity(0.3)
        case .warning: return Color(hex: "F59E0B").opacity(0.3)
        case .success: return Color(hex: "22C55E").opacity(0.3)
        case .highlight: return Color(hex: "A855F7").opacity(0.3)
        }
    }
}

// MARK: - Chart Data
struct ChartData: Identifiable {
    let id = UUID()
    let title: String
    let type: ChartType
    let dataPoints: [ChartDataPoint]
}

enum ChartType {
    case line
    case bar
    case area
}

struct ChartDataPoint: Identifiable {
    let id = UUID()
    let label: String
    let value: Double
    let color: Color?

    init(label: String, value: Double, color: Color? = nil) {
        self.label = label
        self.value = value
        self.color = color
    }
}

// MARK: - Article Statistic
struct ArticleStatistic: Identifiable {
    let id = UUID()
    let value: String
    let label: String
    let trend: StatisticTrend?
    let trendValue: String?

    init(value: String, label: String, trend: StatisticTrend? = nil, trendValue: String? = nil) {
        self.value = value
        self.label = label
        self.trend = trend
        self.trendValue = trendValue
    }
}

enum StatisticTrend {
    case up
    case down
    case neutral

    var color: Color {
        switch self {
        case .up: return AppColors.bullish
        case .down: return AppColors.bearish
        case .neutral: return AppColors.neutral
        }
    }

    var icon: String {
        switch self {
        case .up: return "arrow.up"
        case .down: return "arrow.down"
        case .neutral: return "minus"
        }
    }
}

// MARK: - Article Comment
struct ArticleComment: Identifiable {
    let id = UUID()
    let authorName: String
    let authorAvatar: String?
    let content: String
    let postedAt: Date
    let likeCount: Int
    let replyCount: Int
    let isVerified: Bool

    var timeAgo: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: postedAt, relativeTo: Date())
    }

    var avatarInitials: String {
        let components = authorName.components(separatedBy: " ")
        let initials = components.compactMap { $0.first }.prefix(2)
        return String(initials).uppercased()
    }
}

// MARK: - Related Article
struct RelatedArticle: Identifiable {
    let id = UUID()
    let title: String
    let subtitle: String
    let category: MoneyMoveCategory
    let readTimeMinutes: Int
    let viewCount: String
    let gradientColors: [String]
}

// MARK: - Article Action Type
enum ArticleActionType {
    case mobilePost
    case instantAccess
    case listen
    case share
    case team

    var icon: String {
        switch self {
        case .mobilePost: return "iphone"
        case .instantAccess: return "bolt.fill"
        case .listen: return "headphones"
        case .share: return "square.and.arrow.up"
        case .team: return "person.2.fill"
        }
    }

    var label: String {
        switch self {
        case .mobilePost: return "Mobile Post"
        case .instantAccess: return "Instant Access"
        case .listen: return "Listen"
        case .share: return "Share"
        case .team: return "Usho Team"
        }
    }
}

// MARK: - Sample Data
extension MoneyMoveArticle {
    static let sampleDigitalFinance = MoneyMoveArticle(
        title: "The Future of Digital Finance",
        subtitle: "Exploring the intersection of fintech innovation, cryptocurrency adoption, and traditional banking transformation.",
        category: .blueprints,
        author: ArticleAuthor(
            name: "The Alpha",
            avatarName: nil,
            title: "Investment Research",
            isVerified: true,
            followerCount: "45.2k"
        ),
        publishedAt: Calendar.current.date(byAdding: .day, value: -3, to: Date())!,
        readTimeMinutes: 18,
        viewCount: "4.2M",
        commentCount: 124,
        isBookmarked: false,
        hasAudioVersion: true,
        heroGradientColors: ["1E3A5F", "0D1B2A", "1B263B"],
        tagLabel: "MUST READ",
        isFeatured: false,
        keyHighlights: [
            ArticleHighlight(
                icon: "building.columns.fill",
                title: "The Alpha",
                description: "As technology becomes ubiquitous, decentralized finance (DeFi) is reshaping how we invest."
            ),
            ArticleHighlight(
                icon: "chart.line.uptrend.xyaxis",
                title: "Key Trends",
                description: "The pace of banking innovation has never been faster. This conversation isn't about tomorrow's shift."
            ),
            ArticleHighlight(
                icon: "shield.checkered",
                title: "Risk Factors",
                description: "Despite strong prospects, regulatory challenges and market volatility remain key concerns."
            )
        ],
        sections: [
            ArticleSection(
                title: "The Rise of Decentralized Finance",
                icon: "chart.bar.fill",
                content: [
                    .paragraph("Decentralized finance, or DeFi, represents a fundamental shift in how financial services are delivered. By removing intermediaries through blockchain technology and smart contracts, DeFi platforms are offering users direct access to financial instruments that were once the exclusive domain of institutions."),
                    .paragraph("The implications are profound. Users can now access loans, trade assets, and earn yields on their digital assets without needing to seek permission or provide extensive documentation."),
                    .callout(
                        icon: "lightbulb.fill",
                        text: "DeFi protocols have processed over $180B in total value locked, representing a 340% increase from last year.",
                        style: .highlight
                    ),
                    .bulletList([
                        "Permissionless lending and borrowing",
                        "Automated market makers (AMMs)",
                        "Yield farming and liquidity mining",
                        "Cross-chain interoperability"
                    ])
                ],
                hasGlowEffect: true
            ),
            ArticleSection(
                title: "Artificial Intelligence in Banking",
                icon: "cpu.fill",
                content: [
                    .paragraph("Traditional banks are not standing still. The integration of artificial intelligence and machine learning has revolutionized everything from fraud detection to customer service. AI-powered chatbots now handle over 70% of customer inquiries, while advanced algorithms identify suspicious transactions in milliseconds."),
                    .subheading("Enhanced Security"),
                    .paragraph("Biometric authentication, combined with behavioral analysis, has reduced fraud rates by 45% across major financial institutions. Banks are investing heavily in zero-trust security architectures."),
                    .subheading("Personalized Experiences"),
                    .paragraph("Machine learning models analyze spending patterns to provide personalized financial advice, automatically categorize transactions, and predict future expenses with remarkable accuracy.")
                ]
            ),
            ArticleSection(
                title: "Embedded Finance and Super Apps",
                icon: "apps.iphone",
                content: [
                    .paragraph("The boundaries between financial services and other digital experiences are dissolving. Embedded finance allows non-financial companies to offer banking, lending, and payment services seamlessly within their platforms."),
                    .quote(
                        text: "The future of finance isn't about going to the bankâ€”it's about banking coming to you, wherever you are.",
                        attribution: "Industry Analyst"
                    ),
                    .paragraph("Super apps like WeChat in China have already demonstrated the power of consolidating multiple services. Western markets are now seeing similar evolution, with ride-sharing apps offering banking, e-commerce platforms providing credit, and social media enabling peer-to-peer payments.")
                ]
            ),
            ArticleSection(
                title: "Navigating the New Financial Frontier",
                icon: "map.fill",
                content: [
                    .paragraph("The transformation of finance through technology is not a distant future speculationâ€”it's happening now. From the way we pay for groceries to how global corporations manage treasury operations, every aspect of our financial lives is being reimagined."),
                    .callout(
                        icon: "exclamationmark.triangle.fill",
                        text: "Investors should remain vigilant. While opportunities abound, the regulatory landscape is still evolving, and not all innovations will survive.",
                        style: .warning
                    ),
                    .paragraph("The journey ahead promises to be transformativeâ€”reshaping not just how we manage money, but how we think about value, ownership, and economic participation in an increasingly connected world.")
                ]
            )
        ],
        statistics: [
            ArticleStatistic(value: "$180B", label: "Total Value Locked", trend: .up, trendValue: "340%"),
            ArticleStatistic(value: "4.2M", label: "Daily Active Users", trend: .up, trendValue: "127%"),
            ArticleStatistic(value: "2,400+", label: "DeFi Protocols", trend: .up, trendValue: "89%")
        ],
        comments: [
            ArticleComment(
                authorName: "Alex Johnson",
                authorAvatar: nil,
                content: "Excellent breakdown of the current DeFi landscape! The data on portfolio fragility suggests wealth creation through early adoption needs more critical analysis.",
                postedAt: Calendar.current.date(byAdding: .hour, value: -5, to: Date())!,
                likeCount: 47,
                replyCount: 8,
                isVerified: false
            ),
            ArticleComment(
                authorName: "Maya Patel",
                authorAvatar: nil,
                content: "As a traditional banker transitioning to fintech, this article perfectly captures the challenges and opportunities we face. The embedded finance section was particularly insightful.",
                postedAt: Calendar.current.date(byAdding: .hour, value: -12, to: Date())!,
                likeCount: 32,
                replyCount: 3,
                isVerified: true
            )
        ],
        relatedArticles: [
            RelatedArticle(
                title: "The FTX Collapse",
                subtitle: "What the failure of crypto's top exchange tells us about the future.",
                category: .valueTraps,
                readTimeMinutes: 14,
                viewCount: "2.8M",
                gradientColors: ["DC2626", "991B1B"]
            ),
            RelatedArticle(
                title: "How Amazon Built Its Moat",
                subtitle: "The strategy behind unstoppable dominance.",
                category: .blueprints,
                readTimeMinutes: 12,
                viewCount: "3.1M",
                gradientColors: ["059669", "047857"]
            ),
            RelatedArticle(
                title: "How AI Is Revolutionizing Stock Market Analysis",
                subtitle: "From pattern recognition to predictive analytics.",
                category: .blueprints,
                readTimeMinutes: 16,
                viewCount: "1.9M",
                gradientColors: ["7C3AED", "5B21B6"]
            )
        ]
    )
    
    /// Featured version of the digital finance article with orange gradient for hero card
    static let featuredDigitalFinance = MoneyMoveArticle(
        title: "The Future of Digital Finance",
        subtitle: "Exploring the intersection of fintech innovation, cryptocurrency adoption, and traditional banking transformation.",
        category: .blueprints,
        author: ArticleAuthor(
            name: "The Alpha",
            avatarName: nil,
            title: "Investment Research",
            isVerified: true,
            followerCount: "45.2k"
        ),
        publishedAt: Calendar.current.date(byAdding: .day, value: -3, to: Date())!,
        readTimeMinutes: 18,
        viewCount: "4.2M",
        commentCount: 124,
        isBookmarked: false,
        hasAudioVersion: true,
        heroGradientColors: ["EA580C", "C2410C", "9A3412"], // Orange gradient for featured articles
        tagLabel: "MUST READ",
        isFeatured: true, // Mark as featured to show "FEATURED DEEP DIVE" instead of category
        keyHighlights: [
            ArticleHighlight(
                icon: "building.columns.fill",
                title: "The Alpha",
                description: "As technology becomes ubiquitous, decentralized finance (DeFi) is reshaping how we invest."
            ),
            ArticleHighlight(
                icon: "chart.line.uptrend.xyaxis",
                title: "Key Trends",
                description: "The pace of banking innovation has never been faster. This conversation isn't about tomorrow's shift."
            ),
            ArticleHighlight(
                icon: "shield.checkered",
                title: "Risk Factors",
                description: "Despite strong prospects, regulatory challenges and market volatility remain key concerns."
            )
        ],
        sections: [
            ArticleSection(
                title: "The Rise of Decentralized Finance",
                icon: "chart.bar.fill",
                content: [
                    .paragraph("Decentralized finance, or DeFi, represents a fundamental shift in how financial services are delivered. By removing intermediaries through blockchain technology and smart contracts, DeFi platforms are offering users direct access to financial instruments that were once the exclusive domain of institutions."),
                    .paragraph("The implications are profound. Users can now access loans, trade assets, and earn yields on their digital assets without needing to seek permission or provide extensive documentation."),
                    .callout(
                        icon: "lightbulb.fill",
                        text: "DeFi protocols have processed over $180B in total value locked, representing a 340% increase from last year.",
                        style: .highlight
                    ),
                    .bulletList([
                        "Permissionless lending and borrowing",
                        "Automated market makers (AMMs)",
                        "Yield farming and liquidity mining",
                        "Cross-chain interoperability"
                    ])
                ],
                hasGlowEffect: true
            ),
            ArticleSection(
                title: "Artificial Intelligence in Banking",
                icon: "cpu.fill",
                content: [
                    .paragraph("Traditional banks are not standing still. The integration of artificial intelligence and machine learning has revolutionized everything from fraud detection to customer service. AI-powered chatbots now handle over 70% of customer inquiries, while advanced algorithms identify suspicious transactions in milliseconds."),
                    .subheading("Enhanced Security"),
                    .paragraph("Biometric authentication, combined with behavioral analysis, has reduced fraud rates by 45% across major financial institutions. Banks are investing heavily in zero-trust security architectures."),
                    .subheading("Personalized Experiences"),
                    .paragraph("Machine learning models analyze spending patterns to provide personalized financial advice, automatically categorize transactions, and predict future expenses with remarkable accuracy.")
                ]
            ),
            ArticleSection(
                title: "Embedded Finance and Super Apps",
                icon: "apps.iphone",
                content: [
                    .paragraph("The boundaries between financial services and other digital experiences are dissolving. Embedded finance allows non-financial companies to offer banking, lending, and payment services seamlessly within their platforms."),
                    .quote(
                        text: "The future of finance isn't about going to the bankâ€”it's about banking coming to you, wherever you are.",
                        attribution: "Industry Analyst"
                    ),
                    .paragraph("Super apps like WeChat in China have already demonstrated the power of consolidating multiple services. Western markets are now seeing similar evolution, with ride-sharing apps offering banking, e-commerce platforms providing credit, and social media enabling peer-to-peer payments.")
                ]
            ),
            ArticleSection(
                title: "Navigating the New Financial Frontier",
                icon: "map.fill",
                content: [
                    .paragraph("The transformation of finance through technology is not a distant future speculationâ€”it's happening now. From the way we pay for groceries to how global corporations manage treasury operations, every aspect of our financial lives is being reimagined."),
                    .callout(
                        icon: "exclamationmark.triangle.fill",
                        text: "Investors should remain vigilant. While opportunities abound, the regulatory landscape is still evolving, and not all innovations will survive.",
                        style: .warning
                    ),
                    .paragraph("The journey ahead promises to be transformativeâ€”reshaping not just how we manage money, but how we think about value, ownership, and economic participation in an increasingly connected world.")
                ]
            )
        ],
        statistics: [
            ArticleStatistic(value: "$180B", label: "Total Value Locked", trend: .up, trendValue: "340%"),
            ArticleStatistic(value: "4.2M", label: "Daily Active Users", trend: .up, trendValue: "127%"),
            ArticleStatistic(value: "2,400+", label: "DeFi Protocols", trend: .up, trendValue: "89%")
        ],
        comments: [
            ArticleComment(
                authorName: "Alex Johnson",
                authorAvatar: nil,
                content: "Excellent breakdown of the current DeFi landscape! The data on portfolio fragility suggests wealth creation through early adoption needs more critical analysis.",
                postedAt: Calendar.current.date(byAdding: .hour, value: -5, to: Date())!,
                likeCount: 47,
                replyCount: 8,
                isVerified: false
            ),
            ArticleComment(
                authorName: "Maya Patel",
                authorAvatar: nil,
                content: "As a traditional banker transitioning to fintech, this article perfectly captures the challenges and opportunities we face. The embedded finance section was particularly insightful.",
                postedAt: Calendar.current.date(byAdding: .hour, value: -12, to: Date())!,
                likeCount: 32,
                replyCount: 3,
                isVerified: true
            )
        ],
        relatedArticles: [
            RelatedArticle(
                title: "The FTX Collapse",
                subtitle: "What the failure of crypto's top exchange tells us about the future.",
                category: .valueTraps,
                readTimeMinutes: 14,
                viewCount: "2.8M",
                gradientColors: ["DC2626", "991B1B"]
            ),
            RelatedArticle(
                title: "How Amazon Built Its Moat",
                subtitle: "The strategy behind unstoppable dominance.",
                category: .blueprints,
                readTimeMinutes: 12,
                viewCount: "3.1M",
                gradientColors: ["059669", "047857"]
            ),
            RelatedArticle(
                title: "How AI Is Revolutionizing Stock Market Analysis",
                subtitle: "From pattern recognition to predictive analytics.",
                category: .blueprints,
                readTimeMinutes: 16,
                viewCount: "1.9M",
                gradientColors: ["7C3AED", "5B21B6"]
            )
        ]
    )
}

================================================================================
FILE: frontend/ios/ios/Models/NewsDetailModels.swift
================================================================================

//
//  NewsDetailModels.swift
//  ios
//
//  Data models for the News Detail screen
//

import Foundation

// MARK: - Key Takeaway
struct KeyTakeaway: Identifiable {
    let id = UUID()
    let index: Int
    let text: String
}

// MARK: - News Article Detail
struct NewsArticleDetail: Identifiable {
    let id = UUID()
    let headline: String
    let source: NewsSource
    let sentiment: NewsSentiment
    let publishedAt: Date
    let readTimeMinutes: Int
    let heroImageName: String?
    let relatedTickers: [String]
    let keyTakeaways: [KeyTakeaway]
    let articleURL: URL?

    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return formatter.string(from: publishedAt)
    }

    var formattedReadTime: String {
        "\(readTimeMinutes) min read"
    }

    // Convert from NewsArticle
    init(from article: NewsArticle, keyTakeaways: [KeyTakeaway], heroImageName: String? = nil, readTimeMinutes: Int = 4, articleURL: URL? = nil) {
        self.headline = article.headline
        self.source = article.source
        self.sentiment = article.sentiment
        self.publishedAt = article.publishedAt
        self.readTimeMinutes = readTimeMinutes
        self.heroImageName = heroImageName ?? article.thumbnailName
        self.relatedTickers = article.relatedTickers
        self.keyTakeaways = keyTakeaways
        self.articleURL = articleURL
    }

    init(headline: String, source: NewsSource, sentiment: NewsSentiment, publishedAt: Date, readTimeMinutes: Int, heroImageName: String?, relatedTickers: [String], keyTakeaways: [KeyTakeaway], articleURL: URL?) {
        self.headline = headline
        self.source = source
        self.sentiment = sentiment
        self.publishedAt = publishedAt
        self.readTimeMinutes = readTimeMinutes
        self.heroImageName = heroImageName
        self.relatedTickers = relatedTickers
        self.keyTakeaways = keyTakeaways
        self.articleURL = articleURL
    }
}

// MARK: - News Source Extension
extension NewsSource {
    // Source brand colors
    var brandColor: String {
        switch name.lowercased() {
        case "cnbc": return "6366F1"   // Indigo/purple
        case "reuters": return "FF6600"  // Orange
        case "bloomberg": return "2800D7" // Purple
        case "wsj", "wall street journal": return "000000" // Black
        case "zacks": return "0066CC" // Blue
        case "marketwatch": return "00AC4E" // Green
        default: return "3B82F6" // Default blue
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Models/ProfitPowerModels.swift
================================================================================

//
//  ProfitPowerModels.swift
//  ios
//
//  Data models for the Profit Power Section in the Financial tab
//  Displays margin metrics over time with sector comparison
//

import Foundation
import SwiftUI

// MARK: - Profit Power Period Type

enum ProfitPowerPeriodType: String, CaseIterable, Identifiable {
    case annual = "Annual"
    case quarterly = "Quarterly"

    var id: String { rawValue }
}

// MARK: - Profit Margin Type

enum ProfitMarginType: String, CaseIterable, Identifiable {
    case grossMargin = "Gross Margin"
    case operatingMargin = "Operating Margin"
    case fcfMargin = "FCF Margin"
    case netMargin = "Net Margin"
    case sectorAverage = "Sector Average Net Margin"

    var id: String { rawValue }

    var shortName: String {
        switch self {
        case .grossMargin: return "Gross Margin"
        case .operatingMargin: return "Operating Margin"
        case .fcfMargin: return "FCF Margin"
        case .netMargin: return "Net Margin"
        case .sectorAverage: return "Sector Average\nNet Margin"
        }
    }

    var color: Color {
        switch self {
        case .grossMargin: return AppColors.profitGrossMargin
        case .operatingMargin: return AppColors.profitOperatingMargin
        case .fcfMargin: return AppColors.profitFCFMargin
        case .netMargin: return AppColors.profitNetMargin
        case .sectorAverage: return AppColors.profitSectorAverage
        }
    }

    var isDashed: Bool {
        self == .sectorAverage
    }

    var description: String {
        switch self {
        case .grossMargin:
            return "Revenue minus cost of goods sold, divided by revenue. Shows pricing power and production efficiency."
        case .operatingMargin:
            return "Operating income divided by revenue. Measures operational efficiency before interest and taxes."
        case .fcfMargin:
            return "Free cash flow divided by revenue. Indicates how much cash the business generates relative to sales."
        case .netMargin:
            return "Net income divided by revenue. The bottom line profitability after all expenses."
        case .sectorAverage:
            return "Average net margin of peer companies in the same sector for comparison."
        }
    }
}

// MARK: - Profit Power Data Point

struct ProfitPowerDataPoint: Identifiable {
    let id = UUID()
    let period: String              // e.g., "2020", "2021" or "Q1 '24"
    let grossMargin: Double         // Percentage (e.g., 45.5 for 45.5%)
    let operatingMargin: Double     // Percentage
    let fcfMargin: Double           // Percentage
    let netMargin: Double           // Percentage
    let sectorAverageNetMargin: Double  // Percentage

    /// Returns margin value for a specific margin type
    func margin(for type: ProfitMarginType) -> Double {
        switch type {
        case .grossMargin: return grossMargin
        case .operatingMargin: return operatingMargin
        case .fcfMargin: return fcfMargin
        case .netMargin: return netMargin
        case .sectorAverage: return sectorAverageNetMargin
        }
    }
}

// MARK: - Profit Power Section Data

struct ProfitPowerSectionData {
    let annualData: [ProfitPowerDataPoint]
    let quarterlyData: [ProfitPowerDataPoint]

    func dataPoints(for period: ProfitPowerPeriodType) -> [ProfitPowerDataPoint] {
        switch period {
        case .annual: return annualData
        case .quarterly: return quarterlyData
        }
    }

    /// Get all margin values for chart scaling
    var allMarginValues: [Double] {
        let annual = annualData.flatMap { [
            $0.grossMargin, $0.operatingMargin, $0.fcfMargin,
            $0.netMargin, $0.sectorAverageNetMargin
        ] }
        let quarterly = quarterlyData.flatMap { [
            $0.grossMargin, $0.operatingMargin, $0.fcfMargin,
            $0.netMargin, $0.sectorAverageNetMargin
        ] }
        return annual + quarterly
    }

    var maxMargin: Double {
        (allMarginValues.max() ?? 50) * 1.1
    }

    var minMargin: Double {
        min(allMarginValues.min() ?? 0, 0)
    }
}

// MARK: - Sample Data

extension ProfitPowerSectionData {
    static let sampleData = ProfitPowerSectionData(
        annualData: [
            ProfitPowerDataPoint(
                period: "2020",
                grossMargin: 38.2,
                operatingMargin: 6.5,
                fcfMargin: 5.2,
                netMargin: 9.8,
                sectorAverageNetMargin: 8.5
            ),
            ProfitPowerDataPoint(
                period: "2021",
                grossMargin: 38.5,
                operatingMargin: 8.2,
                fcfMargin: 4.8,
                netMargin: 12.5,
                sectorAverageNetMargin: 9.2
            ),
            ProfitPowerDataPoint(
                period: "2022",
                grossMargin: 45.0,
                operatingMargin: 14.8,
                fcfMargin: 11.5,
                netMargin: 21.2,
                sectorAverageNetMargin: 22.5
            ),
            ProfitPowerDataPoint(
                period: "2023",
                grossMargin: 48.2,
                operatingMargin: 18.5,
                fcfMargin: 11.2,
                netMargin: 21.5,
                sectorAverageNetMargin: 20.8
            ),
            ProfitPowerDataPoint(
                period: "2024",
                grossMargin: 49.5,
                operatingMargin: 14.5,
                fcfMargin: 11.8,
                netMargin: 20.8,
                sectorAverageNetMargin: 21.2
            ),
            ProfitPowerDataPoint(
                period: "2025",
                grossMargin: 52.0,
                operatingMargin: 16.2,
                fcfMargin: 12.5,
                netMargin: 22.0,
                sectorAverageNetMargin: 21.0
            )
        ],
        quarterlyData: [
            ProfitPowerDataPoint(
                period: "Q1 '24",
                grossMargin: 48.8,
                operatingMargin: 15.2,
                fcfMargin: 10.5,
                netMargin: 20.2,
                sectorAverageNetMargin: 19.8
            ),
            ProfitPowerDataPoint(
                period: "Q2 '24",
                grossMargin: 49.2,
                operatingMargin: 14.8,
                fcfMargin: 11.8,
                netMargin: 21.0,
                sectorAverageNetMargin: 20.5
            ),
            ProfitPowerDataPoint(
                period: "Q3 '24",
                grossMargin: 50.1,
                operatingMargin: 13.5,
                fcfMargin: 12.2,
                netMargin: 20.5,
                sectorAverageNetMargin: 21.2
            ),
            ProfitPowerDataPoint(
                period: "Q4 '24",
                grossMargin: 51.5,
                operatingMargin: 14.2,
                fcfMargin: 13.0,
                netMargin: 21.8,
                sectorAverageNetMargin: 21.5
            ),
            ProfitPowerDataPoint(
                period: "Q1 '25",
                grossMargin: 52.2,
                operatingMargin: 15.5,
                fcfMargin: 12.8,
                netMargin: 22.2,
                sectorAverageNetMargin: 20.8
            ),
            ProfitPowerDataPoint(
                period: "Q2 '25",
                grossMargin: 52.8,
                operatingMargin: 16.8,
                fcfMargin: 13.2,
                netMargin: 22.5,
                sectorAverageNetMargin: 21.0
            )
        ]
    )
}

// MARK: - Profit Power Info Item

struct ProfitPowerInfoItem: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let icon: String
    let example: String?

    init(title: String, description: String, icon: String, example: String? = nil) {
        self.title = title
        self.description = description
        self.icon = icon
        self.example = example
    }
}

extension ProfitPowerInfoItem {
    static let valueInvestingTips: [ProfitPowerInfoItem] = [
        ProfitPowerInfoItem(
            title: "Gross Margin Stability",
            description: "A stable or expanding gross margin indicates pricing power and competitive moat. Declining gross margins may signal increasing competition or rising input costs.",
            icon: "chart.line.uptrend.xyaxis",
            example: "Apple's gross margin consistently above 38% demonstrates strong brand pricing power."
        ),
        ProfitPowerInfoItem(
            title: "Operating Leverage",
            description: "When operating margin grows faster than gross margin, it shows the company is achieving scale. Fixed costs are being spread over more revenue.",
            icon: "scalemass.fill",
            example: "Operating margin expanding from 10% to 15% while revenue doubles indicates excellent operating leverage."
        ),
        ProfitPowerInfoItem(
            title: "Free Cash Flow Quality",
            description: "FCF margin shows how much actual cash the business generates. Companies can manipulate earnings but not cash. Higher is better.",
            icon: "banknote.fill",
            example: "A company with 15% net margin but only 5% FCF margin may have aggressive accounting."
        ),
        ProfitPowerInfoItem(
            title: "Net Margin Trends",
            description: "The bottom line. Compare to sector average - consistently above sector suggests competitive advantages worth paying for.",
            icon: "arrow.up.right.circle.fill",
            example: "Net margin 5% above sector average for 5+ years indicates a durable moat."
        ),
        ProfitPowerInfoItem(
            title: "Margin Compression Warning",
            description: "When all margins decline together, it's a red flag. Could indicate new competition, market saturation, or loss of pricing power.",
            icon: "exclamationmark.triangle.fill",
            example: "If gross margin drops while competitors maintain theirs, investigate the cause."
        ),
        ProfitPowerInfoItem(
            title: "Sector Comparison",
            description: "The dashed line shows sector average. Persistent outperformance justifies premium valuation; persistent underperformance warrants caution.",
            icon: "chart.bar.xaxis",
            example: "Operating 3% above sector average over a full business cycle shows genuine excellence."
        )
    ]
}

================================================================================
FILE: frontend/ios/ios/Models/ResearchModels.swift
================================================================================

//
//  ResearchModels.swift
//  ios
//
//  Data models for the Research screen
//

import Foundation
import SwiftUI

// MARK: - Research Tab
enum ResearchTab: String, CaseIterable {
    case research = "Research"
    case reports = "Reports"
}

// MARK: - Quick Ticker
struct QuickTicker: Identifiable, Equatable {
    let id = UUID()
    let symbol: String

    static let defaults: [QuickTicker] = [
        QuickTicker(symbol: "AAPL"),
        QuickTicker(symbol: "TSLA"),
        QuickTicker(symbol: "NVDA"),
        QuickTicker(symbol: "BTC")
    ]
}

// MARK: - Analysis Persona
enum AnalysisPersona: String, CaseIterable, Identifiable {
    case warrenBuffett = "Warren Buffett"
    case cathieWood = "Cathie Wood"
    case peterLynch = "Peter Lynch"
    case rayDalio = "Ray Dalio"
    case satoshiNakamoto = "Satoshi Nakamoto"

    var id: String { rawValue }

    var tagline: String {
        switch self {
        case .warrenBuffett: return "Safe, Long-term Value"
        case .cathieWood: return "Disruptive Innovation"
        case .peterLynch: return "Growth at Value"
        case .rayDalio: return "Risk Parity"
        case .satoshiNakamoto: return "Decentralized Sound Money"
        }
    }

    var iconName: String {
        switch self {
        case .warrenBuffett: return "icon_persona_buffett"
        case .cathieWood: return "icon_persona_wood"
        case .peterLynch: return "icon_persona_lynch"
        case .rayDalio: return "icon_persona_dalio"
        case .satoshiNakamoto: return "icon_persona_satoshi"
        }
    }

    var systemIconName: String {
        switch self {
        case .warrenBuffett: return "building.columns.fill"
        case .cathieWood: return "bolt.fill"
        case .peterLynch: return "chart.line.uptrend.xyaxis"
        case .rayDalio: return "circle.fill"
        case .satoshiNakamoto: return "bitcoinsign.circle.fill"
        }
    }

    var accentColor: Color {
        switch self {
        case .warrenBuffett: return Color(hex: "3B82F6") // Blue
        case .cathieWood: return Color(hex: "A855F7")    // Purple
        case .peterLynch: return Color(hex: "06B6D4")    // Cyan
        case .rayDalio: return Color(hex: "F97316")      // Orange
        case .satoshiNakamoto: return Color(hex: "F97316") // Orange
        }
    }

    var description: String {
        switch self {
        case .warrenBuffett:
            return "Focuses on fundamental value, strong moats, consistent earnings, and long-term competitive advantages. Ideal for conservative investors."
        case .cathieWood:
            return "Emphasizes disruptive innovation, emerging technologies, and high-growth potential companies that could reshape industries."
        case .peterLynch:
            return "Looks for growth at a reasonable price (GARP), with focus on companies you understand and can spot in everyday life."
        case .rayDalio:
            return "Applies risk parity principles, diversification across asset classes, and systematic macro-economic analysis."
        case .satoshiNakamoto:
            return "Focuses on decentralized assets, sound money principles, and blockchain-native investments with long-term store of value potential."
        }
    }
}

// MARK: - Analysis Feature
struct AnalysisFeature: Identifiable {
    let id = UUID()
    let title: String
    let subtitle: String
    let iconName: String
    let systemIconName: String
    let iconColor: Color

    static let allFeatures: [AnalysisFeature] = [
        AnalysisFeature(
            title: "Financial Deep Dive",
            subtitle: "Year historical analysis, ratios, and trend forecasting",
            iconName: "icon_feature_financial",
            systemIconName: "chart.pie.fill",
            iconColor: Color(hex: "22C55E")
        ),
        AnalysisFeature(
            title: "Competitive Position",
            subtitle: "Market share analysis and moat assessment",
            iconName: "icon_feature_competitive",
            systemIconName: "building.2.fill",
            iconColor: Color(hex: "3B82F6")
        ),
        AnalysisFeature(
            title: "AI-Powered Insights",
            subtitle: "Pattern recognition, anomaly detection and beyond!",
            iconName: "icon_feature_ai",
            systemIconName: "sparkles",
            iconColor: Color(hex: "F97316")
        ),
        AnalysisFeature(
            title: "Risk Assessment",
            subtitle: "Comprehensive risk factors and mitigation strategies",
            iconName: "icon_feature_risk",
            systemIconName: "exclamationmark.triangle.fill",
            iconColor: Color(hex: "EF4444")
        ),
        AnalysisFeature(
            title: "Insiders and Whales",
            subtitle: "Track big moves, new opens, increase or decrease their positions",
            iconName: "icon_feature_whales",
            systemIconName: "person.2.fill",
            iconColor: Color(hex: "06B6D4")
        )
    ]
}

// MARK: - Credit Balance
struct CreditBalance {
    let credits: Int
    let renewalDate: Date

    var formattedRenewalDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return "Renews \(formatter.string(from: renewalDate))"
    }

    static let mock = CreditBalance(
        credits: 47,
        renewalDate: Calendar.current.date(from: DateComponents(year: 2025, month: 1, day: 1)) ?? Date()
    )
}

// MARK: - Trending Analysis
struct TrendingAnalysis: Identifiable {
    let id = UUID()
    let title: String
    let companiesCount: Int
    let interestPercent: Int
    let iconName: String
    let systemIconName: String
    let iconBackgroundColor: Color

    var formattedCompaniesCount: String {
        "\(companiesCount) companies analyzed this month"
    }

    var formattedInterest: String {
        "+\(interestPercent)% interest"
    }

    static let mockTrending: [TrendingAnalysis] = [
        TrendingAnalysis(
            title: "AI & Machine Learning Stocks",
            companiesCount: 12,
            interestPercent: 127,
            iconName: "icon_trending_ai",
            systemIconName: "brain.head.profile",
            iconBackgroundColor: Color(hex: "3B82F6")
        ),
        TrendingAnalysis(
            title: "Clean Energy Sector",
            companiesCount: 8,
            interestPercent: 89,
            iconName: "icon_trending_energy",
            systemIconName: "bolt.fill",
            iconBackgroundColor: Color(hex: "22C55E")
        ),
        TrendingAnalysis(
            title: "Cryptocurrency & Blockchain",
            companiesCount: 15,
            interestPercent: 203,
            iconName: "icon_trending_crypto",
            systemIconName: "bitcoinsign.circle.fill",
            iconBackgroundColor: Color(hex: "F97316")
        )
    ]
}

// MARK: - Analysis Cost
struct AnalysisCost {
    let credits: Int

    static let standard = AnalysisCost(credits: 5)
}

// MARK: - Report Status
enum ReportStatus: String {
    case processing = "Processing"
    case failed = "Failed"
    case ready = "Ready"

    var color: Color {
        switch self {
        case .processing: return Color(hex: "3B82F6")  // Blue
        case .failed: return Color(hex: "EF4444")       // Red
        case .ready: return Color(hex: "22C55E")        // Green
        }
    }

    var backgroundColor: Color {
        switch self {
        case .processing: return Color(hex: "3B82F6").opacity(0.2)
        case .failed: return Color(hex: "EF4444").opacity(0.2)
        case .ready: return Color(hex: "22C55E").opacity(0.2)
        }
    }
}

// MARK: - Analysis Report
struct AnalysisReport: Identifiable {
    let id = UUID()
    let companyName: String
    let ticker: String
    let industry: String
    let persona: AnalysisPersona
    let status: ReportStatus
    let progress: Double? // 0.0 to 1.0, only for processing
    let rating: Double?   // 0-100, only for ready
    let ratingLabel: String? // e.g. "Strong Quality Business", only for ready
    let date: Date
    let isRefunded: Bool

    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return formatter.string(from: date)
    }

    var tickerAndIndustry: String {
        "\(ticker) â€¢ \(industry)"
    }

    var progressPercent: Int {
        Int((progress ?? 0) * 100)
    }

    static let mockReports: [AnalysisReport] = [
        AnalysisReport(
            companyName: "Oracle Corporation",
            ticker: "ORCL",
            industry: "Enterprise Software",
            persona: .warrenBuffett,
            status: .ready,
            progress: nil,
            rating: 82,
            ratingLabel: "Strong Quality Business",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 2, day: 7)) ?? Date(),
            isRefunded: false
        ),
        AnalysisReport(
            companyName: "Tesla Inc.",
            ticker: "TSLA",
            industry: "Automotive",
            persona: .cathieWood,
            status: .processing,
            progress: 0.67,
            rating: nil,
            ratingLabel: nil,
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 2, day: 20)) ?? Date(),
            isRefunded: false
        ),
        AnalysisReport(
            companyName: "Meta Platforms",
            ticker: "META",
            industry: "Social Media",
            persona: .rayDalio,
            status: .failed,
            progress: nil,
            rating: nil,
            ratingLabel: nil,
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 2, day: 19)) ?? Date(),
            isRefunded: true
        ),
        AnalysisReport(
            companyName: "Apple Inc.",
            ticker: "AAPL",
            industry: "Technology",
            persona: .warrenBuffett,
            status: .ready,
            progress: nil,
            rating: 90,
            ratingLabel: "Excellent Quality Business",
            date: Calendar.current.date(from: DateComponents(year: 2024, month: 12, day: 24)) ?? Date(),
            isRefunded: false
        ),
        AnalysisReport(
            companyName: "NVIDIA Corp.",
            ticker: "NVDA",
            industry: "Semiconductors",
            persona: .peterLynch,
            status: .ready,
            progress: nil,
            rating: 95,
            ratingLabel: "Excellent Quality Business",
            date: Calendar.current.date(from: DateComponents(year: 2024, month: 12, day: 23)) ?? Date(),
            isRefunded: false
        )
    ]
}

// MARK: - Community Insight
struct CommunityInsight: Identifiable {
    let id = UUID()
    let userName: String
    let userAvatarName: String
    let postedAt: Date
    let comment: String
    let likesCount: Int
    let commentsCount: Int

    var timeAgo: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: postedAt, relativeTo: Date())
    }

    static let mockInsights: [CommunityInsight] = [
        CommunityInsight(
            userName: "David Martinez",
            userAvatarName: "avatar_david",
            postedAt: Date().addingTimeInterval(-7200), // 2h ago
            comment: "Just completed a Buffett-style analysis on $AAPL. The moat is stronger than ever with the services ecosystem. Highly recommend!",
            likesCount: 24,
            commentsCount: 8
        ),
        CommunityInsight(
            userName: "Sarah Johnson",
            userAvatarName: "avatar_sarah",
            postedAt: Date().addingTimeInterval(-18000), // 5h ago
            comment: "The Cathie Wood persona nailed the $NVDA analysis. AI infrastructure thesis is spot on. Worth every credit!",
            likesCount: 41,
            commentsCount: 15
        )
    ]
}

// MARK: - Report Sort Option
enum ReportSortOption: String, CaseIterable {
    case dateNewest = "Newest First"
    case dateOldest = "Oldest First"
    case ratingHigh = "Highest Rated"
    case ratingLow = "Lowest Rated"
}

================================================================================
FILE: frontend/ios/ios/Models/RevenueBreakdownModels.swift
================================================================================

//
//  RevenueBreakdownModels.swift
//  ios
//
//  Data models for the "How [TICKER] Makes Money" section in the Financial tab
//

import Foundation
import SwiftUI

// MARK: - Revenue Source
struct RevenueSource: Identifiable {
    let id = UUID()
    let name: String
    let value: Double
    let color: Color

    var percentage: Double {
        0 // Will be calculated in context of total revenue
    }

    func percentage(of total: Double) -> Double {
        guard total > 0 else { return 0 }
        return (value / total) * 100
    }

    var formattedValue: String {
        formatLargeNumber(value)
    }

    func formattedPercentage(of total: Double) -> String {
        String(format: "%.0f%%", percentage(of: total))
    }

    private func formatLargeNumber(_ number: Double) -> String {
        let absNumber = abs(number)
        if absNumber >= 1_000_000_000_000 {
            return String(format: "%.1fT", number / 1_000_000_000_000)
        } else if absNumber >= 1_000_000_000 {
            return String(format: "%.2fB", number / 1_000_000_000)
        } else if absNumber >= 1_000_000 {
            return String(format: "%.1fM", number / 1_000_000)
        } else if absNumber >= 1_000 {
            return String(format: "%.1fK", number / 1_000)
        }
        return String(format: "%.0f", number)
    }
}

// MARK: - Cost Item
struct CostItem: Identifiable {
    let id = UUID()
    let name: String
    let value: Double
    let color: Color

    func percentage(of total: Double) -> Double {
        guard total > 0 else { return 0 }
        return (abs(value) / total) * 100
    }

    var formattedValue: String {
        formatLargeNumber(value)
    }

    func formattedPercentage(of total: Double) -> String {
        String(format: "%.0f%%", percentage(of: total))
    }

    private func formatLargeNumber(_ number: Double) -> String {
        let absNumber = abs(number)
        if absNumber >= 1_000_000_000_000 {
            return String(format: "%.1fT", number / 1_000_000_000_000)
        } else if absNumber >= 1_000_000_000 {
            return String(format: "%.0fB", number / 1_000_000_000)
        } else if absNumber >= 1_000_000 {
            return String(format: "%.1fM", number / 1_000_000)
        } else if absNumber >= 1_000 {
            return String(format: "%.1fK", number / 1_000)
        }
        return String(format: "%.0f", number)
    }
}

// MARK: - Revenue Breakdown Data
struct RevenueBreakdownData {
    let tickerSymbol: String
    let revenueSources: [RevenueSource]
    let costOfSales: Double
    let operatingExpense: Double
    let tax: Double

    // MARK: - Computed Properties

    var totalRevenue: Double {
        revenueSources.reduce(0) { $0 + $1.value }
    }

    var totalCosts: Double {
        costOfSales + operatingExpense + tax
    }

    var netProfit: Double {
        totalRevenue - totalCosts
    }

    var isProfit: Bool {
        netProfit >= 0
    }

    var netProfitLabel: String {
        isProfit ? "Net Profit" : "Net Loss"
    }

    var netProfitColor: Color {
        isProfit ? AppColors.bullish : Color(hex: "8B0000") // Dark red for loss
    }

    // Cost items for display
    var costItems: [CostItem] {
        [
            CostItem(name: "Cost of Sales", value: costOfSales, color: Color(hex: "EF4444")),
            CostItem(name: "Op. Expense", value: operatingExpense, color: Color(hex: "F87171")),
            CostItem(name: "Tax", value: tax, color: Color(hex: "FCA5A5"))
        ]
    }

    // Net profit/loss as a cost item (for legend)
    var netProfitItem: CostItem {
        CostItem(
            name: netProfitLabel,
            value: netProfit,
            color: netProfitColor
        )
    }

    // Formatted values
    var formattedTotalRevenue: String {
        formatLargeNumber(totalRevenue)
    }

    var formattedNetProfit: String {
        let prefix = isProfit ? "" : "-"
        return prefix + formatLargeNumber(abs(netProfit))
    }

    func netProfitPercentage() -> Double {
        guard totalRevenue > 0 else { return 0 }
        return (abs(netProfit) / totalRevenue) * 100
    }

    // MARK: - Chart Calculations

    /// Maximum value for chart scaling - uses larger of revenue or total costs
    var chartMaxValue: Double {
        max(totalRevenue, totalCosts) * 1.1
    }

    /// Whether costs exceed revenue (company is loss-making)
    var costsExceedRevenue: Bool {
        totalCosts > totalRevenue
    }

    /// Revenue as percentage of chart max (for break-even line positioning)
    var revenuePercentageOfMax: Double {
        guard chartMaxValue > 0 else { return 0 }
        return totalRevenue / chartMaxValue
    }

    /// Calculate cumulative position for waterfall chart
    func waterfallPosition(for index: Int) -> (start: Double, end: Double) {
        var currentPosition = totalRevenue

        for i in 0..<index {
            currentPosition -= costItems[i].value
        }

        let start = currentPosition
        let end = currentPosition - costItems[index].value

        return (start, end)
    }

    // MARK: - Private Helpers

    private func formatLargeNumber(_ number: Double) -> String {
        let absNumber = abs(number)
        if absNumber >= 1_000_000_000_000 {
            return String(format: "%.1fT", number / 1_000_000_000_000)
        } else if absNumber >= 1_000_000_000 {
            return String(format: "%.0fB", number / 1_000_000_000)
        } else if absNumber >= 1_000_000 {
            return String(format: "%.1fM", number / 1_000_000)
        } else if absNumber >= 1_000 {
            return String(format: "%.1fK", number / 1_000)
        }
        return String(format: "%.0f", number)
    }
}

// MARK: - Revenue Source Colors
extension RevenueSource {
    static let iPhoneColor = Color(hex: "3B82F6")      // Blue
    static let servicesColor = Color(hex: "A855F7")    // Purple
    static let macColor = Color(hex: "F97316")         // Orange
    static let iPadColor = Color(hex: "06B6D4")        // Cyan
    static let otherColor = Color(hex: "9CA3AF")       // Gray
    static let wearablesColor = Color(hex: "22C55E")   // Green
}

// MARK: - Sample Data
extension RevenueBreakdownData {
    // Apple - Profitable company
    static let sampleApple = RevenueBreakdownData(
        tickerSymbol: "AAPL",
        revenueSources: [
            RevenueSource(name: "iPhone", value: 205_500_000_000, color: RevenueSource.iPhoneColor),
            RevenueSource(name: "Services", value: 73_100_000_000, color: RevenueSource.servicesColor),
            RevenueSource(name: "Mac", value: 32_200_000_000, color: RevenueSource.macColor),
            RevenueSource(name: "iPad", value: 25_100_000_000, color: RevenueSource.iPadColor),
            RevenueSource(name: "Other", value: 20_450_000_000, color: RevenueSource.otherColor)
        ],
        costOfSales: 192_000_000_000,
        operatingExpense: 91_000_000_000,
        tax: 5_000_000_000
    )

    // Example of a company with net loss
    static let sampleLossCompany = RevenueBreakdownData(
        tickerSymbol: "RIVN",
        revenueSources: [
            RevenueSource(name: "Vehicles", value: 4_400_000_000, color: RevenueSource.iPhoneColor),
            RevenueSource(name: "Services", value: 300_000_000, color: RevenueSource.servicesColor),
            RevenueSource(name: "Other", value: 100_000_000, color: RevenueSource.otherColor)
        ],
        costOfSales: 6_500_000_000,
        operatingExpense: 3_200_000_000,
        tax: 50_000_000
    )

    // Microsoft
    static let sampleMicrosoft = RevenueBreakdownData(
        tickerSymbol: "MSFT",
        revenueSources: [
            RevenueSource(name: "Cloud", value: 110_000_000_000, color: RevenueSource.iPhoneColor),
            RevenueSource(name: "Office", value: 48_000_000_000, color: RevenueSource.servicesColor),
            RevenueSource(name: "Windows", value: 22_000_000_000, color: RevenueSource.macColor),
            RevenueSource(name: "Gaming", value: 16_000_000_000, color: RevenueSource.iPadColor),
            RevenueSource(name: "LinkedIn", value: 15_000_000_000, color: RevenueSource.wearablesColor),
            RevenueSource(name: "Other", value: 14_000_000_000, color: RevenueSource.otherColor)
        ],
        costOfSales: 72_000_000_000,
        operatingExpense: 63_000_000_000,
        tax: 16_000_000_000
    )
}

// MARK: - Info Items for Educational Content
struct RevenueBreakdownInfoItem: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let icon: String
}

extension RevenueBreakdownInfoItem {
    static let educationalContent: [RevenueBreakdownInfoItem] = [
        RevenueBreakdownInfoItem(
            title: "Revenue Diversification",
            description: "Companies with multiple revenue streams are generally more stable. A single dominant source (>70%) can indicate concentration risk.",
            icon: "chart.pie.fill"
        ),
        RevenueBreakdownInfoItem(
            title: "Gross Margin",
            description: "Revenue minus Cost of Sales shows gross profit. Higher margins indicate pricing power or operational efficiency.",
            icon: "arrow.up.right.circle.fill"
        ),
        RevenueBreakdownInfoItem(
            title: "Operating Expenses",
            description: "Includes R&D, sales, marketing, and administrative costs. Watch for expenses growing faster than revenue.",
            icon: "building.2.fill"
        ),
        RevenueBreakdownInfoItem(
            title: "Net Profit Margin",
            description: "Net profit as a percentage of revenue. Compare to industry peers - tech companies often have 15-25% margins.",
            icon: "percent"
        ),
        RevenueBreakdownInfoItem(
            title: "Revenue Quality",
            description: "Recurring revenue (subscriptions, services) is more valuable than one-time sales. Look for growing services segments.",
            icon: "repeat.circle.fill"
        )
    ]
}

================================================================================
FILE: frontend/ios/ios/Models/RevenueEngineModels.swift
================================================================================

//
//  RevenueEngineModels.swift
//  ios
//
//  Data models for The Revenue Engine deep dive section
//  Shows revenue segment breakdown with automatic role assignment and growth formatting
//

import Foundation
import SwiftUI

// MARK: - Revenue Segment Role

enum RevenueSegmentRole: String {
    case risingSegment = "Rising Segment"
    case headwind = "Headwind"
    case coreBusiness = "Core Business"
    case diversified = "Diversified"

    var color: Color {
        switch self {
        case .risingSegment:
            return AppColors.bullish
        case .headwind:
            return AppColors.bearish
        case .coreBusiness:
            return AppColors.primaryBlue
        case .diversified:
            return AppColors.textSecondary
        }
    }

    var backgroundColor: Color {
        color.opacity(0.15)
    }

    var borderColor: Color {
        return AppColors.textSecondary
    }

    var iconName: String {
        switch self {
        case .risingSegment:
            return "arrow.up.right.circle.fill"
        case .headwind:
            return "arrow.down.right.circle.fill"
        case .coreBusiness:
            return "star.circle.fill"
        case .diversified:
            return "circle.grid.2x2.fill"
        }
    }
}

// MARK: - Revenue Segment

struct RevenueSegment: Identifiable {
    let id = UUID()
    let name: String
    let currentRevenue: Double      // in millions or billions (consistent unit)
    let previousRevenue: Double     // in millions or billions (consistent unit)
    let totalRevenue: Double        // total company revenue for percentage calculation

    // MARK: - Computed Properties

    /// Growth rate as decimal (e.g., 0.80 = 80% growth)
    var growth: Double {
        guard previousRevenue > 0 else { return 0 }
        return (currentRevenue - previousRevenue) / previousRevenue
    }

    /// Revenue as percentage of total
    var revenuePercentage: Double {
        guard totalRevenue > 0 else { return 0 }
        return (currentRevenue / totalRevenue) * 100
    }

    /// Formatted revenue string (e.g., "$12.5B")
    var formattedRevenue: String {
        if currentRevenue >= 1000 {
            return String(format: "$%.1fB", currentRevenue / 1000)
        } else {
            return String(format: "$%.0fM", currentRevenue)
        }
    }

    /// Formatted percentage string (e.g., "25%")
    var formattedPercentage: String {
        String(format: "%.0f%%", revenuePercentage)
    }

    /// Auto-formatted growth text based on growth rate
    /// Examples: "Hyper-growth (+80% YoY)", "Stable (+2% YoY)", "Declining (-15% YoY)"
    var formattedGrowth: String {
        let percentage = growth * 100
        let sign = growth >= 0 ? "+" : ""
        let percentString = String(format: "%@%.0f%%", sign, percentage)

        if growth >= 0.40 {
            return "Hyper-growth (\(percentString) YoY)"
        } else if growth >= 0.15 {
            return "Strong growth (\(percentString) YoY)"
        } else if growth >= 0.05 {
            return "Growing (\(percentString) YoY)"
        } else if growth >= -0.05 {
            return "Stable (\(percentString) YoY)"
        } else if growth >= -0.20 {
            return "Declining (\(percentString) YoY)"
        } else {
            return "Sharp decline (\(percentString) YoY)"
        }
    }

    /// Growth trend color
    var growthColor: Color {
        if growth >= 0.05 {
            return AppColors.bullish
        } else if growth >= -0.05 {
            return AppColors.textSecondary
        } else {
            return AppColors.bearish
        }
    }
}

// MARK: - Revenue Engine Data

struct ReportRevenueEngineData {
    let segments: [RevenueSegment]
    let totalRevenue: Double
    let revenueUnit: String         // "Millions" or "Billions"
    let period: String              // e.g., "FY 2024"
    let analysisNote: String?       // Optional AI insight

    // MARK: - Role Assignment Logic

    /// Automatically assigns roles to segments based on their characteristics
    func roleForSegment(_ segment: RevenueSegment) -> RevenueSegmentRole {
        guard !segments.isEmpty else { return .diversified }

        // Find segment with highest growth
        let maxGrowth = segments.map { $0.growth }.max() ?? 0
        let minGrowth = segments.map { $0.growth }.min() ?? 0
        let maxRevenue = segments.map { $0.currentRevenue }.max() ?? 0

        // Rule 1: Rising Segment - highest growth (and growth > 10%)
        if segment.growth == maxGrowth && segment.growth > 0.10 {
            return .risingSegment
        }

        // Rule 2: Headwind - most negative growth (and growth < -5%)
        if segment.growth == minGrowth && segment.growth < -0.05 {
            return .headwind
        }

        // Rule 3: Core Business - largest revenue
        if segment.currentRevenue == maxRevenue {
            return .coreBusiness
        }

        // Rule 4: Diversified - everything else
        return .diversified
    }

    /// Total revenue formatted
    var formattedTotalRevenue: String {
        if totalRevenue >= 1000 {
            return String(format: "$%.1fB", totalRevenue / 1000)
        } else {
            return String(format: "$%.0fM", totalRevenue)
        }
    }
}

// MARK: - Sample Data

extension ReportRevenueEngineData {
    /// Sample data demonstrating all 4 role types
    static let sampleOracle = ReportRevenueEngineData(
        segments: [
            // Core Business: Largest revenue
            RevenueSegment(
                name: "Cloud Services & License Support",
                currentRevenue: 38_500,    // $38.5B
                previousRevenue: 37_200,   // $37.2B
                totalRevenue: 53_000
            ),
            // Rising Segment: Highest growth
            RevenueSegment(
                name: "Cloud Infrastructure (IaaS)",
                currentRevenue: 8_500,     // $8.5B
                previousRevenue: 4_700,    // $4.7B (80% growth!)
                totalRevenue: 53_000
            ),
            // Headwind: Declining
            RevenueSegment(
                name: "License Revenue",
                currentRevenue: 3_200,     // $3.2B
                previousRevenue: 4_100,    // $4.1B (-22% decline)
                totalRevenue: 53_000
            ),
            // Diversified: Everything else
            RevenueSegment(
                name: "Hardware & Other",
                currentRevenue: 2_800,     // $2.8B
                previousRevenue: 2_700,    // $2.7B (4% growth - diversified)
                totalRevenue: 53_000
            )
        ],
        totalRevenue: 53_000,  // $53B total
        revenueUnit: "Millions",
        period: "FY 2024",
        analysisNote: "Oracle's revenue engine is transforming: cloud infrastructure is exploding at 80% YoY while legacy license revenue shrinks. The core support business remains stable and massive, generating $38.5B in recurring revenue."
    )
}

================================================================================
FILE: frontend/ios/ios/Models/SearchModels.swift
================================================================================

//
//  SearchModels.swift
//  ios
//
//  Data models for the Search screen
//

import Foundation
import SwiftUI

// MARK: - Search Result Type
enum SearchResultType: String, CaseIterable {
    case stock = "Stock"
    case person = "Person"
    case etf = "ETF"
    case crypto = "Crypto"

    var iconName: String {
        switch self {
        case .stock: return "chart.line.uptrend.xyaxis"
        case .person: return "person.fill"
        case .etf: return "chart.pie.fill"
        case .crypto: return "bitcoinsign.circle.fill"
        }
    }
}

// MARK: - Search Result Item
struct SearchResultItem: Identifiable {
    let id = UUID()
    let type: SearchResultType
    let ticker: String?
    let name: String
    let subtitle: String
    let imageName: String?
    let isFollowable: Bool
    let isFollowing: Bool

    var displayTicker: String? {
        ticker
    }

    var hasProfileImage: Bool {
        type == .person
    }
}

// MARK: - Search Query Suggestion
struct SearchQuerySuggestion: Identifiable {
    let id = UUID()
    let text: String
    let iconName: String?

    var hasIcon: Bool {
        iconName != nil
    }
}

// MARK: - Search News Item
struct SearchNewsItem: Identifiable {
    let id = UUID()
    let source: String
    let timeAgo: String
    let headline: String
    let summary: String
    let imageName: String
    let readMoreAction: String

    var formattedMeta: String {
        "\(source)  \(timeAgo)"
    }
}

// MARK: - Search Book Item
struct SearchBookItem: Identifiable {
    let id = UUID()
    let title: String
    let author: String
    let description: String
    let coverImageName: String
    let pageCount: Int
    let publishedYear: Int
    let rating: Double

    var formattedRating: String {
        String(format: "%.1f", rating)
    }

    var formattedPages: String {
        "\(pageCount) pages"
    }

    var formattedPublished: String {
        "Published \(publishedYear)"
    }
}

// MARK: - Sample Data Extensions
extension SearchQuerySuggestion {
    static let sampleData: [SearchQuerySuggestion] = [
        SearchQuerySuggestion(text: "What is P/E ratio?", iconName: nil),
        SearchQuerySuggestion(text: "Best tech stocks", iconName: nil),
        SearchQuerySuggestion(text: "Market trends", iconName: nil),
        SearchQuerySuggestion(text: "Why APPLE moved today?", iconName: nil)
    ]
}

extension SearchResultItem {
    static let sampleData: [SearchResultItem] = [
        SearchResultItem(
            type: .stock,
            ticker: "AAPL",
            name: "Apple Inc.",
            subtitle: "Technology",
            imageName: nil,
            isFollowable: false,
            isFollowing: false
        ),
        SearchResultItem(
            type: .stock,
            ticker: "TSLA",
            name: "Tesla Inc.",
            subtitle: "Automotive",
            imageName: nil,
            isFollowable: false,
            isFollowing: false
        ),
        SearchResultItem(
            type: .person,
            ticker: nil,
            name: "Nancy Pelosi",
            subtitle: "U.S. Representative",
            imageName: "avatar_nancy_pelosi",
            isFollowable: true,
            isFollowing: false
        ),
        SearchResultItem(
            type: .stock,
            ticker: "MSFT",
            name: "Microsoft Corp.",
            subtitle: "Technology",
            imageName: nil,
            isFollowable: false,
            isFollowing: false
        ),
        SearchResultItem(
            type: .person,
            ticker: nil,
            name: "Michael Burry",
            subtitle: "Scion Asset Management",
            imageName: "avatar_michael_burry",
            isFollowable: true,
            isFollowing: false
        )
    ]
}

extension SearchNewsItem {
    static let sampleData: [SearchNewsItem] = [
        SearchNewsItem(
            source: "TechCrunch",
            timeAgo: "8 hours ago",
            headline: "Fed Signals Potential Rate Cuts in 2024",
            summary: "Federal Reserve hints at monetary policy shifts that could impact market dynamics...",
            imageName: "news_fed_rates",
            readMoreAction: "Read More"
        ),
        SearchNewsItem(
            source: "CNBC",
            timeAgo: "8 hours ago",
            headline: "Apple Announces Revolutionary AI Features Coming to iPhone 16 Pro",
            summary: "Tech giant unveils groundbreaking artificial intelligence capabilities that could reshape the smartphone industry and boost stock performance...",
            imageName: "news_apple_ai",
            readMoreAction: "Read More"
        ),
        SearchNewsItem(
            source: "Reuters",
            timeAgo: "10 hours ago",
            headline: "Bitcoin Reaches New All-Time High Above $68K",
            summary: "Cryptocurrency markets rally as institutional adoption continues to grow worldwide...",
            imageName: "news_bitcoin",
            readMoreAction: "Read More"
        )
    ]
}

extension SearchBookItem {
    static let sampleData: [SearchBookItem] = [
        SearchBookItem(
            title: "The Intelligent Investor",
            author: "Benjamin Graham",
            description: "The Bible of Value Investing. Warren Buffett's #1 recommended book.",
            coverImageName: "book_intelligent_investor",
            pageCount: 623,
            publishedYear: 1949,
            rating: 4.9
        ),
        SearchBookItem(
            title: "One Up On Wall Street",
            author: "Peter Lynch",
            description: "How to use what you already know to make money in the market.",
            coverImageName: "book_one_up_wall_street",
            pageCount: 304,
            publishedYear: 1989,
            rating: 4.8
        )
    ]
}

================================================================================
FILE: frontend/ios/ios/Models/SignalOfConfidenceModels.swift
================================================================================

//
//  SignalOfConfidenceModels.swift
//  ios
//
//  Data models for the Signal of Confidence Section in the Financial tab
//  Displays dividends, buybacks, and shares outstanding over time
//

import Foundation
import SwiftUI

// MARK: - Signal of Confidence View Type

enum SignalOfConfidenceViewType: String, CaseIterable, Identifiable {
    case yield = "Yield (%)"
    case capital = "Capital ($)"

    var id: String { rawValue }
}

// MARK: - Signal of Confidence Metric Type

enum SignalOfConfidenceMetricType: String, CaseIterable, Identifiable {
    case dividends = "Dividends"
    case buybacks = "Buybacks"
    case sharesOutstanding = "Shares Outstanding"

    var id: String { rawValue }

    var color: Color {
        switch self {
        case .dividends: return AppColors.confidenceDividends
        case .buybacks: return AppColors.confidenceBuybacks
        case .sharesOutstanding: return AppColors.confidenceSharesOutstanding
        }
    }

    var isLine: Bool {
        self == .sharesOutstanding
    }

    var description: String {
        switch self {
        case .dividends:
            return "Cash payments made to shareholders, typically quarterly. A consistent or growing dividend signals financial stability and management confidence."
        case .buybacks:
            return "When a company repurchases its own shares, reducing shares outstanding. This returns cash to shareholders and can boost earnings per share."
        case .sharesOutstanding:
            return "Total number of shares held by all shareholders. Decreasing share count from buybacks is generally positive; increasing count from dilution is concerning."
        }
    }
}

// MARK: - Signal of Confidence Data Point

struct SignalOfConfidenceDataPoint: Identifiable {
    let id = UUID()
    let period: String                    // e.g., "Q2 '24", "Q3 '24"
    let dividendYield: Double             // Percentage (e.g., 1.3 for 1.3%)
    let buybackYield: Double              // Percentage
    let dividendAmount: Double            // Dollar amount in millions
    let buybackAmount: Double             // Dollar amount in millions
    let sharesOutstanding: Double         // In millions (e.g., 150 for 150M)

    /// Total shareholder yield (dividend + buyback)
    var totalYield: Double {
        dividendYield + buybackYield
    }

    /// Total capital returned in millions
    var totalCapitalReturned: Double {
        dividendAmount + buybackAmount
    }
}

// MARK: - Signal of Confidence Summary

struct SignalOfConfidenceSummary {
    let totalYield: Double                // Total shareholder yield percentage
    let dividendYield: Double             // Dividend portion
    let buybackYield: Double              // Buyback portion
    let shareCountChange: Double          // Percentage change (negative = buybacks reducing count)

    var shareCountDescription: String {
        if shareCountChange < 0 {
            return "Share count decrease by \(String(format: "%.1f", abs(shareCountChange)))%."
        } else if shareCountChange > 0 {
            return "Share count increase by \(String(format: "%.1f", shareCountChange))%."
        } else {
            return "Share count unchanged."
        }
    }

    var formattedSummary: String {
        "Total Yield: \(String(format: "%.1f", totalYield))% (\(String(format: "%.1f", dividendYield))% Dividends + \(String(format: "%.1f", buybackYield))% Buyback)."
    }
}

// MARK: - Dividend Yield Status

enum DividendYieldStatus: String {
    case low = "Low"
    case fair = "Fair"
    case high = "High"
    case veryHigh = "Very High"

    var color: Color {
        switch self {
        case .low: return AppColors.bearish
        case .fair: return AppColors.neutral
        case .high: return AppColors.bullish
        case .veryHigh: return AppColors.primaryBlue
        }
    }

    static func from(yield: Double, industryAverage: Double) -> DividendYieldStatus {
        let ratio = yield / industryAverage
        if ratio < 0.7 { return .low }
        if ratio < 1.0 { return .fair }
        if ratio < 1.5 { return .high }
        return .veryHigh
    }
}

// MARK: - Buyback Status

enum BuybackStatus: String {
    case low = "Low"
    case moderate = "Moderate"
    case high = "High"
    case veryHigh = "Very High"

    var color: Color {
        switch self {
        case .low: return AppColors.bearish
        case .moderate: return AppColors.neutral
        case .high: return AppColors.bullish
        case .veryHigh: return AppColors.primaryBlue
        }
    }
}

// MARK: - Dividend Info

struct DividendInfo {
    let exDividendDate: Date
    let paymentDate: Date
    let fiveYearAvgYield: Double
    let status: DividendYieldStatus
    let buybackStatus: BuybackStatus

    var formattedExDividendDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return formatter.string(from: exDividendDate)
    }

    var formattedPaymentDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return formatter.string(from: paymentDate)
    }

    var formattedYield: String {
        String(format: "%.2f%%", fiveYearAvgYield)
    }
}

extension DividendInfo {
    static let sample: DividendInfo = {
        var exComponents = DateComponents()
        exComponents.year = 2025
        exComponents.month = 11
        exComponents.day = 10
        let exDate = Calendar.current.date(from: exComponents) ?? Date()

        var payComponents = DateComponents()
        payComponents.year = 2025
        payComponents.month = 11
        payComponents.day = 16
        let payDate = Calendar.current.date(from: payComponents) ?? Date()

        return DividendInfo(
            exDividendDate: exDate,
            paymentDate: payDate,
            fiveYearAvgYield: 0.68,
            status: .low,
            buybackStatus: .moderate
        )
    }()
}

// MARK: - Signal of Confidence Section Data

struct SignalOfConfidenceSectionData {
    let dataPoints: [SignalOfConfidenceDataPoint]
    let summary: SignalOfConfidenceSummary
    let dividendInfo: DividendInfo?

    init(
        dataPoints: [SignalOfConfidenceDataPoint],
        summary: SignalOfConfidenceSummary,
        dividendInfo: DividendInfo? = nil
    ) {
        self.dataPoints = dataPoints
        self.summary = summary
        self.dividendInfo = dividendInfo
    }

    /// Get max yield for chart scaling
    var maxYield: Double {
        let maxDividend = dataPoints.map { $0.dividendYield }.max() ?? 0
        let maxBuyback = dataPoints.map { $0.buybackYield }.max() ?? 0
        return max(maxDividend, maxBuyback) * 1.15
    }

    /// Get max capital for chart scaling (in millions)
    var maxCapital: Double {
        let maxDividend = dataPoints.map { $0.dividendAmount }.max() ?? 0
        let maxBuyback = dataPoints.map { $0.buybackAmount }.max() ?? 0
        return max(maxDividend, maxBuyback) * 1.15
    }

    /// Get shares outstanding range for normalization
    var sharesRange: (min: Double, max: Double) {
        let shares = dataPoints.map { $0.sharesOutstanding }
        let minShares = (shares.min() ?? 0) * 0.95
        let maxShares = (shares.max() ?? 1) * 1.05
        return (minShares, maxShares)
    }
}

// MARK: - Sample Data

extension SignalOfConfidenceSectionData {
    static let sampleData = SignalOfConfidenceSectionData(
        dataPoints: [
            SignalOfConfidenceDataPoint(
                period: "Q2 '24",
                dividendYield: 1.3,
                buybackYield: 1.1,
                dividendAmount: 3800,
                buybackAmount: 3200,
                sharesOutstanding: 155
            ),
            SignalOfConfidenceDataPoint(
                period: "Q3 '24",
                dividendYield: 1.6,
                buybackYield: 1.3,
                dividendAmount: 4200,
                buybackAmount: 3500,
                sharesOutstanding: 152
            ),
            SignalOfConfidenceDataPoint(
                period: "Q4 '24",
                dividendYield: 1.55,
                buybackYield: 0.95,
                dividendAmount: 4100,
                buybackAmount: 2500,
                sharesOutstanding: 158
            ),
            SignalOfConfidenceDataPoint(
                period: "Q1 '25",
                dividendYield: 1.35,
                buybackYield: 1.15,
                dividendAmount: 3900,
                buybackAmount: 3300,
                sharesOutstanding: 162
            ),
            SignalOfConfidenceDataPoint(
                period: "Q2 '25",
                dividendYield: 2.65,
                buybackYield: 1.6,
                dividendAmount: 7500,
                buybackAmount: 4500,
                sharesOutstanding: 168
            )
        ],
        summary: SignalOfConfidenceSummary(
            totalYield: 4.2,
            dividendYield: 1.5,
            buybackYield: 2.7,
            shareCountChange: 0.0
        ),
        dividendInfo: .sample
    )
}

// MARK: - Signal of Confidence Info Item

struct SignalOfConfidenceInfoItem: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let icon: String
    let example: String?

    init(title: String, description: String, icon: String, example: String? = nil) {
        self.title = title
        self.description = description
        self.icon = icon
        self.example = example
    }
}

extension SignalOfConfidenceInfoItem {
    static let valueInvestingTips: [SignalOfConfidenceInfoItem] = [
        SignalOfConfidenceInfoItem(
            title: "Total Shareholder Yield",
            description: "The sum of dividend yield and buyback yield. This shows the total percentage of market cap being returned to shareholders annually. A higher yield indicates management confidence and commitment to rewarding shareholders.",
            icon: "percent",
            example: "A 4% total yield (1.5% dividends + 2.5% buybacks) means shareholders receive 4% of their investment back annually."
        ),
        SignalOfConfidenceInfoItem(
            title: "Dividend Consistency",
            description: "Companies that maintain or grow dividends through economic cycles demonstrate financial strength. Look for companies with long dividend track records (Dividend Aristocrats have 25+ years).",
            icon: "calendar.badge.checkmark",
            example: "Apple increased dividends for 12 consecutive years, signaling management's confidence in future cash flows."
        ),
        SignalOfConfidenceInfoItem(
            title: "Buyback Effectiveness",
            description: "Buybacks are most valuable when shares are undervalued. Companies buying back stock at high valuations destroy value. Check if buybacks actually reduce share count or just offset dilution from stock compensation.",
            icon: "arrow.down.circle.fill",
            example: "If share count drops 3% annually from buybacks, EPS grows 3% even with flat earnings."
        ),
        SignalOfConfidenceInfoItem(
            title: "Share Count Trend",
            description: "A declining share count over time indicates effective capital allocation. Rising share counts despite buybacks suggest excessive stock-based compensation diluting existing shareholders.",
            icon: "chart.line.downtrend.xyaxis",
            example: "If a company spends $10B on buybacks but share count increases, the money went to employees, not shareholders."
        ),
        SignalOfConfidenceInfoItem(
            title: "Dividend vs Buyback Trade-off",
            description: "Dividends are taxed immediately; buybacks defer taxes until you sell. However, dividends are harder to cut (signals distress), while buybacks can stop anytime without negative perception.",
            icon: "arrow.left.arrow.right",
            example: "Tech companies often prefer buybacks for tax efficiency; utilities favor dividends for income-seeking investors."
        )
    ]
}

================================================================================
FILE: frontend/ios/ios/Models/TickerDetailModels.swift
================================================================================

//
//  TickerDetailModels.swift
//  ios
//
//  Data models for the Ticker Detail screen
//

import Foundation
import SwiftUI

// MARK: - Ticker Detail Tab
enum TickerDetailTab: String, CaseIterable {
    case overview = "Overview"
    case news = "News"
    case analysis = "Analysis"
    case financials = "Financials"
    case holders = "Holders"
}

// MARK: - Chart Time Range
enum ChartTimeRange: String, CaseIterable {
    case oneDay = "1D"
    case oneWeek = "1W"
    case threeMonths = "3M"
    case sixMonths = "6M"
    case oneYear = "1Y"
    case fiveYears = "5Y"
    case all = "ALL"

    var displayName: String { rawValue }
}

// MARK: - Market Status
enum MarketStatus {
    case open
    case closed(date: Date, time: String, timezone: String)
    case preMarket
    case afterHours

    var displayText: String {
        switch self {
        case .open:
            return "Market Open"
        case .closed(let date, let time, let timezone):
            let formatter = DateFormatter()
            formatter.dateFormat = "MMM d"
            return "Market Closed  \(formatter.string(from: date)), \(time) \(timezone)"
        case .preMarket:
            return "Pre-Market"
        case .afterHours:
            return "After Hours"
        }
    }
}

// MARK: - Key Statistic
struct KeyStatistic: Identifiable {
    let id = UUID()
    let label: String
    let value: String
    let isHighlighted: Bool

    init(label: String, value: String, isHighlighted: Bool = false) {
        self.label = label
        self.value = value
        self.isHighlighted = isHighlighted
    }
}

// MARK: - Key Statistics Group (for card grouping)
struct KeyStatisticsGroup: Identifiable {
    let id = UUID()
    let statistics: [KeyStatistic]
}

// MARK: - Performance Period
struct PerformancePeriod: Identifiable {
    let id = UUID()
    let label: String
    let changePercent: Double

    var isPositive: Bool {
        changePercent >= 0
    }

    var formattedChange: String {
        let sign = changePercent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", changePercent))%"
    }
}

// MARK: - Snapshot Rating Level
enum SnapshotRatingLevel: Int, CaseIterable {
    case excellent = 5
    case strong = 4
    case average = 3
    case weak = 2
    case poor = 1

    var displayName: String {
        switch self {
        case .excellent: return "High"
        case .strong: return "Solid"
        case .average: return "Moderate"
        case .weak: return "Soft"
        case .poor: return "Low"
        }
    }

    var starCount: Int { rawValue }

    var color: Color {
        switch self {
        case .excellent, .strong: return AppColors.bullish
        case .average: return AppColors.neutral
        case .weak, .poor: return AppColors.bearish
        }
    }

    var hasStroke: Bool {
        self == .excellent || self == .poor
    }
}

// MARK: - Snapshot Category
enum SnapshotCategory: String {
    case profitability = "Profitability"
    case growth = "Growth"
    case price = "Price"
    case financialHealth = "Financial Health"
    case insidersOwnership = "Insiders & Ownership"

    var iconName: String {
        switch self {
        case .profitability: return "chart.pie.fill"
        case .growth: return "chart.line.uptrend.xyaxis"
        case .price: return "dollarsign.circle.fill"
        case .financialHealth: return "cross.case.fill"
        case .insidersOwnership: return "person.2.fill"
        }
    }
}

// MARK: - Snapshot Metric
struct SnapshotMetric: Identifiable {
    let id = UUID()
    let name: String
    let value: String
}

// MARK: - Snapshot Item
struct SnapshotItem: Identifiable {
    let id = UUID()
    let category: SnapshotCategory
    let rating: SnapshotRatingLevel
    let metrics: [SnapshotMetric]
    let fullReportAvailable: Bool

    init(category: SnapshotCategory, rating: SnapshotRatingLevel, metrics: [SnapshotMetric], fullReportAvailable: Bool = true) {
        self.category = category
        self.rating = rating
        self.metrics = metrics
        self.fullReportAvailable = fullReportAvailable
    }
}

// MARK: - Sector & Industry Info
struct SectorIndustryInfo {
    let sector: String
    let industry: String
    let sectorPerformance: Double
    let industryRank: String

    var formattedPerformance: String {
        let sign = sectorPerformance >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", sectorPerformance))%"
    }

    var performanceColor: Color {
        sectorPerformance >= 0 ? AppColors.bullish : AppColors.bearish
    }
}

// MARK: - Company Profile
struct CompanyProfile {
    let description: String
    let ceo: String
    let founded: String
    let employees: Int
    let headquarters: String
    let website: String

    var formattedEmployees: String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: employees)) ?? "\(employees)"
    }
}

// MARK: - Related Ticker
struct RelatedTicker: Identifiable {
    let id = UUID()
    let symbol: String
    let name: String
    let price: Double
    let changePercent: Double

    var isPositive: Bool {
        changePercent >= 0
    }

    var formattedPrice: String {
        String(format: "$%.2f", price)
    }

    var formattedChange: String {
        let sign = changePercent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", changePercent))%"
    }
}

// MARK: - Ticker Detail Data
struct TickerDetailData: Identifiable {
    let id = UUID()
    let symbol: String
    let companyName: String
    let currentPrice: Double
    let priceChange: Double
    let priceChangePercent: Double
    let marketStatus: MarketStatus
    let chartData: [Double]
    let keyStatistics: [KeyStatistic]
    let keyStatisticsGroups: [KeyStatisticsGroup]
    let performancePeriods: [PerformancePeriod]
    let snapshots: [SnapshotItem]
    let sectorIndustry: SectorIndustryInfo
    let companyProfile: CompanyProfile
    let relatedTickers: [RelatedTicker]

    var isPositive: Bool {
        priceChange >= 0
    }

    var formattedPrice: String {
        String(format: "$%.2f", currentPrice)
    }

    var formattedChange: String {
        let sign = priceChange >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", priceChange))"
    }

    var formattedChangePercent: String {
        let sign = priceChangePercent >= 0 ? "+" : ""
        return "(\(sign)\(String(format: "%.2f", priceChangePercent))%)"
    }
}

// MARK: - AI Suggestion for Ticker
struct TickerAISuggestion: Identifiable {
    let id = UUID()
    let text: String

    static let defaultSuggestions: [TickerAISuggestion] = [
        TickerAISuggestion(text: "What's the P/E ratio?"),
        TickerAISuggestion(text: "Why does it move?"),
        TickerAISuggestion(text: "Should I buy?"),
        TickerAISuggestion(text: "Is revenue growing?")
    ]
}

// MARK: - Sample Data
extension TickerDetailData {
    static let sampleApple = TickerDetailData(
        symbol: "AAPL",
        companyName: "Apple Inc.",
        currentPrice: 178.42,
        priceChange: 2.34,
        priceChangePercent: 1.33,
        marketStatus: .closed(
            date: Calendar.current.date(from: DateComponents(year: 2024, month: 12, day: 18))!,
            time: "4:00 PM",
            timezone: "EST"
        ),
        chartData: [165, 168, 170, 172, 169, 174, 171, 175, 173, 178, 176, 180, 177, 182, 178],
        keyStatistics: KeyStatistic.sampleData,
        keyStatisticsGroups: KeyStatisticsGroup.sampleData,
        performancePeriods: PerformancePeriod.sampleData,
        snapshots: SnapshotItem.sampleData,
        sectorIndustry: SectorIndustryInfo(
            sector: "Technology",
            industry: "Consumer Electronics",
            sectorPerformance: 2.87,
            industryRank: "#1 of 42"
        ),
        companyProfile: CompanyProfile(
            description: "Apple Inc. designs, manufactures, and markets smartphones, personal computers, tablets, wearables, and accessories worldwide. The company offers iPhone, Mac, iPad, and Wearables, Home and Accessories products.",
            ceo: "Tim Cook",
            founded: "April 1, 1976",
            employees: 161000,
            headquarters: "Cupertino, CA",
            website: "www.apple.com"
        ),
        relatedTickers: RelatedTicker.sampleData
    )
}

extension KeyStatistic {
    static let sampleData: [KeyStatistic] = [
        KeyStatistic(label: "Open", value: "262.36"),
        KeyStatistic(label: "P/E (TTM)", value: "35.15"),
        KeyStatistic(label: "P/S", value: "52.57"),
        KeyStatistic(label: "Short % of Float", value: "0.83%", isHighlighted: true),
        KeyStatistic(label: "Previous Close", value: "267.26"),
        KeyStatistic(label: "P/E (FWD)", value: "31.84"),
        KeyStatistic(label: "P/S", value: "9.31"),
        KeyStatistic(label: "Shares Outstanding", value: "15.638"),
        KeyStatistic(label: "Volume", value: "39.43M"),
        KeyStatistic(label: "EPS (TTM)", value: "7.47"),
        KeyStatistic(label: "BVPS", value: "4.991"),
        KeyStatistic(label: "Float", value: "15.61B"),
        KeyStatistic(label: "Avg. Volume (3M)", value: "45.23M"),
        KeyStatistic(label: "Dividend & Yield", value: "1.04 (0.39%)"),
        KeyStatistic(label: "Beta", value: "1.09"),
        KeyStatistic(label: "% Held by Insiders", value: "1.69%"),
        KeyStatistic(label: "Market Cap", value: "3.89T"),
        KeyStatistic(label: "Ex-Dividend Date", value: "11/10/2025"),
        KeyStatistic(label: "Next Earnings", value: "1/29"),
        KeyStatistic(label: "% Held Inst.", value: "64.28%")
    ]
}

extension KeyStatisticsGroup {
    static let sampleData: [KeyStatisticsGroup] = [
        // Column 1: Price & Volume
        KeyStatisticsGroup(statistics: [
            KeyStatistic(label: "Open", value: "262.36"),
            KeyStatistic(label: "Previous Close", value: "267.26"),
            KeyStatistic(label: "Volume", value: "39.43M"),
            KeyStatistic(label: "Avg. Volume (3M)", value: "45.23M"),
            KeyStatistic(label: "Market Cap", value: "3.89T")
        ]),
        // Column 2: Valuation Ratios
        KeyStatisticsGroup(statistics: [
            KeyStatistic(label: "P/E (TTM)", value: "35.15"),
            KeyStatistic(label: "P/E (FWD)", value: "31.84"),
            KeyStatistic(label: "EPS (TTM)", value: "7.47"),
            KeyStatistic(label: "Dividend & Yield", value: "1.04 (0.39%)"),
            KeyStatistic(label: "Ex-Dividend Date", value: "11/10/2025")
        ]),
        // Column 3: Per Share Data
        KeyStatisticsGroup(statistics: [
            KeyStatistic(label: "P/B", value: "52.57"),
            KeyStatistic(label: "P/S", value: "9.31"),
            KeyStatistic(label: "BVPS", value: "4.991"),
            KeyStatistic(label: "Beta", value: "1.09"),
            KeyStatistic(label: "Next Earnings", value: "1/29")
        ]),
        // Column 4: Ownership & Float
        KeyStatisticsGroup(statistics: [
            KeyStatistic(label: "Short % of Float", value: "0.83%", isHighlighted: true),
            KeyStatistic(label: "Shares Outstanding", value: "15.63B"),
            KeyStatistic(label: "Float", value: "15.61B"),
            KeyStatistic(label: "% Held by Insiders", value: "1.69%"),
            KeyStatistic(label: "% Held Inst.", value: "64.28%")
        ])
    ]
}

extension PerformancePeriod {
    static let sampleData: [PerformancePeriod] = [
        PerformancePeriod(label: "1 Month", changePercent: 8.42),
        PerformancePeriod(label: "3 Months", changePercent: -3.15),
        PerformancePeriod(label: "6 Months", changePercent: 18.67),
        PerformancePeriod(label: "YTD", changePercent: 42.89),
        PerformancePeriod(label: "1 Year", changePercent: 38.24),
        PerformancePeriod(label: "5 Years", changePercent: 287.45)
    ]
}

extension SnapshotItem {
    static let sampleData: [SnapshotItem] = [
        SnapshotItem(
            category: .profitability,
            rating: .excellent,
            metrics: [
                SnapshotMetric(name: "Operating Margin", value: "30.7%"),
                SnapshotMetric(name: "Net Margin", value: "25.3%"),
                SnapshotMetric(name: "Return on Equity (ROE)", value: "147.2%"),
                SnapshotMetric(name: "Return on Assets (ROA)", value: "27.0%")
            ]
        ),
        SnapshotItem(
            category: .growth,
            rating: .average,
            metrics: [
                SnapshotMetric(name: "Revenue Growth (YoY)", value: "-2.8%"),
                SnapshotMetric(name: "EPS Growth", value: "+16.2%"),
                SnapshotMetric(name: "Free Cash Flow Growth (YoY)", value: "+8.9%"),
                SnapshotMetric(name: "Operating Income Growth", value: "+11.4%")
            ]
        ),
        SnapshotItem(
            category: .price,
            rating: .strong,
            metrics: [
                SnapshotMetric(name: "P/E (1.30x sector average 27.04)", value: "35.15"),
                SnapshotMetric(name: "P/S (1.32x sector average 7.19)", value: "9.48"),
                SnapshotMetric(name: "P/FCF (1.0x sector average 25.00)", value: "25.01"),
                SnapshotMetric(name: "EV/EBITDA (1.33x the sector average 18)", value: "24.03")
            ]
        ),
        SnapshotItem(
            category: .financialHealth,
            rating: .poor,
            metrics: [
                SnapshotMetric(name: "Altman Z-Score", value: "4.8"),
                SnapshotMetric(name: "Interest Coverage", value: "43.7x"),
                SnapshotMetric(name: "Cash to Debt", value: "0.38"),
                SnapshotMetric(name: "Free Cash Flow Margin", value: "25.8%"),
                SnapshotMetric(name: "Asset Turnover", value: "1.12")
            ]
        ),
        SnapshotItem(
            category: .insidersOwnership,
            rating: .weak,
            metrics: [
                SnapshotMetric(name: "Institutional Ownership", value: "61.0%"),
                SnapshotMetric(name: "Hedge Fund Holdings", value: "7.2%"),
                SnapshotMetric(name: "Insider Sold (6M shares)", value: "$2.4M"),
                SnapshotMetric(name: "Top 10 Holders", value: "42.6%"),
                SnapshotMetric(name: "Institutional Activity", value: "-3.2%")
            ]
        )
    ]
}

extension RelatedTicker {
    static let sampleData: [RelatedTicker] = [
        RelatedTicker(symbol: "MSFT", name: "Microsoft", price: 421.32, changePercent: 1.8),
        RelatedTicker(symbol: "GOOGL", name: "Alphabet", price: 178.69, changePercent: 2.1),
        RelatedTicker(symbol: "AMZN", name: "Amazon", price: 186.43, changePercent: -0.4),
        RelatedTicker(symbol: "TSLA", name: "Tesla", price: 252.18, changePercent: 3.2),
        RelatedTicker(symbol: "META", name: "Meta", price: 512.76, changePercent: 1.8),
        RelatedTicker(symbol: "NVDA", name: "NVIDIA", price: 489.32, changePercent: 4.7)
    ]
}

// MARK: - Analysis Tab Models

// MARK: - Analyst Consensus
enum AnalystConsensus: String, CaseIterable {
    case strongBuy = "STRONG BUY"
    case buy = "BUY"
    case hold = "HOLD"
    case sell = "SELL"
    case strongSell = "STRONG SELL"

    var color: Color {
        switch self {
        case .strongBuy, .buy:
            return AppColors.bullish
        case .hold:
            return AppColors.neutral
        case .sell, .strongSell:
            return AppColors.bearish
        }
    }
}

// MARK: - Analyst Rating Distribution
struct AnalystRatingDistribution: Identifiable {
    let id = UUID()
    let label: String
    let count: Int
    let color: Color

    var formattedCount: String {
        "\(count)"
    }
}

extension AnalystRatingDistribution {
    static let sampleData: [AnalystRatingDistribution] = [
        AnalystRatingDistribution(label: "Strong Buy", count: 18, color: AppColors.bullish),
        AnalystRatingDistribution(label: "Buy", count: 14, color: Color(hex: "4ADE80")),
        AnalystRatingDistribution(label: "Hold", count: 6, color: AppColors.neutral),
        AnalystRatingDistribution(label: "Sell", count: 2, color: AppColors.bearish),
        AnalystRatingDistribution(label: "Strong Sell", count: 0, color: Color(hex: "991B1B"))
    ]
}

// MARK: - Analyst Price Target
struct AnalystPriceTarget {
    let lowPrice: Double
    let averagePrice: Double
    let highPrice: Double
    let currentPrice: Double

    var formattedLow: String {
        String(format: "$%.2f", lowPrice)
    }

    var formattedAverage: String {
        String(format: "%.2f", averagePrice)
    }

    var formattedHigh: String {
        String(format: "$%.2f", highPrice)
    }

    var formattedCurrent: String {
        String(format: "%.2f", currentPrice)
    }

    var upsidePercent: Double {
        ((averagePrice - currentPrice) / currentPrice) * 100
    }

    var formattedUpside: String {
        let sign = upsidePercent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", upsidePercent))% upside"
    }

    var currentPricePosition: Double {
        guard highPrice > lowPrice else { return 0.5 }
        return (currentPrice - lowPrice) / (highPrice - lowPrice)
    }
    
    var averagePricePosition: Double {
        guard highPrice > lowPrice else { return 0.5 }
        return (averagePrice - lowPrice) / (highPrice - lowPrice)
    }
}

extension AnalystPriceTarget {
    static let sampleData = AnalystPriceTarget(
        lowPrice: 165.00,
        averagePrice: 212.60,
        highPrice: 250.00,
        currentPrice: 178.42
    )
}

// MARK: - Analyst Momentum Period
enum AnalystMomentumPeriod: String, CaseIterable {
    case sixMonths = "6M"
    case oneYear = "1Y"
}

// MARK: - Analyst Momentum Month Data
struct AnalystMomentumMonth: Identifiable {
    let id = UUID()
    let month: String
    let positiveCount: Int
    let negativeCount: Int

    var netValue: Int {
        positiveCount - negativeCount
    }

    var isPositive: Bool {
        netValue >= 0
    }
}

extension AnalystMomentumMonth {
    static let sampleData: [AnalystMomentumMonth] = [
        AnalystMomentumMonth(month: "Jul", positiveCount: 5, negativeCount: 2),
        AnalystMomentumMonth(month: "Aug", positiveCount: 7, negativeCount: 1),
        AnalystMomentumMonth(month: "Sep", positiveCount: 4, negativeCount: 3),
        AnalystMomentumMonth(month: "Oct", positiveCount: 2, negativeCount: 5),
        AnalystMomentumMonth(month: "Nov", positiveCount: 6, negativeCount: 2),
        AnalystMomentumMonth(month: "Dec", positiveCount: 3, negativeCount: 4)
    ]
}

// MARK: - Analyst Actions Summary
struct AnalystActionsSummary {
    let upgrades: Int
    let maintains: Int
    let downgrades: Int
}

extension AnalystActionsSummary {
    static let sampleData = AnalystActionsSummary(
        upgrades: 9,
        maintains: 8,
        downgrades: 2
    )
}

// MARK: - Analyst Action Type
enum AnalystActionType: String, CaseIterable {
    case upgrade = "UPGRADE"
    case downgrade = "DOWNGRADE"
    case maintain = "MAINTAIN"
    case initiated = "INITIATED"
    case reiterated = "REITERATED"

    var color: Color {
        switch self {
        case .upgrade:
            return AppColors.bullish
        case .downgrade:
            return AppColors.bearish
        case .maintain, .initiated, .reiterated:
            return AppColors.textSecondary
        }
    }

    var borderColor: Color {
        switch self {
        case .upgrade:
            return AppColors.bullish
        case .downgrade:
            return AppColors.bearish
        case .maintain, .initiated, .reiterated:
            return AppColors.textMuted
        }
    }

    var hasColoredBadge: Bool {
        switch self {
        case .upgrade, .downgrade:
            return true
        case .maintain, .initiated, .reiterated:
            return false
        }
    }
}

// MARK: - Analyst Rating Type
enum AnalystRatingType: String, CaseIterable {
    case strongBuy = "Strong buy"
    case buy = "Buy"
    case overweight = "Overweight"
    case equalWeight = "Equal-Weight"
    case neutral = "Neutral"
    case underperform = "Underpeform"
    case sell = "Sell"
    case strongSell = "Strong Sell"

    var isPositive: Bool {
        switch self {
        case .strongBuy, .buy, .overweight:
            return true
        case .equalWeight, .neutral:
            return false
        case .underperform, .sell, .strongSell:
            return false
        }
    }

    var color: Color {
        switch self {
        case .strongBuy, .buy, .overweight:
            return AppColors.bullish
        case .equalWeight, .neutral:
            return AppColors.textSecondary
        case .underperform, .sell, .strongSell:
            return AppColors.bearish
        }
    }
}

// MARK: - Analyst Action (Individual upgrade/downgrade entry)
struct AnalystAction: Identifiable {
    let id = UUID()
    let firmName: String
    let actionType: AnalystActionType
    let date: Date
    let previousRating: AnalystRatingType?
    let newRating: AnalystRatingType
    let previousPriceTarget: Double?
    let newPriceTarget: Double?

    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MM/dd/yyyy"
        return formatter.string(from: date)
    }

    var formattedPreviousPrice: String? {
        guard let price = previousPriceTarget else { return nil }
        return String(format: "$%.0f", price)
    }

    var formattedNewPrice: String? {
        guard let price = newPriceTarget else { return nil }
        return String(format: "$%.0f", price)
    }

    var priceChangeColor: Color {
        guard let previous = previousPriceTarget, let new = newPriceTarget else {
            return AppColors.textSecondary
        }
        if new > previous {
            return AppColors.bullish
        } else if new < previous {
            return AppColors.bearish
        }
        return AppColors.textSecondary
    }
}

extension AnalystAction {
    static let sampleData: [AnalystAction] = [
        AnalystAction(
            firmName: "Morgan Stanley",
            actionType: .upgrade,
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 12))!,
            previousRating: .equalWeight,
            newRating: .overweight,
            previousPriceTarget: 325,
            newPriceTarget: 320
        ),
        AnalystAction(
            firmName: "JP Morgan",
            actionType: .upgrade,
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 11))!,
            previousRating: .equalWeight,
            newRating: .overweight,
            previousPriceTarget: 340,
            newPriceTarget: 330
        ),
        AnalystAction(
            firmName: "Goldman Sachs",
            actionType: .maintain,
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 11))!,
            previousRating: .buy,
            newRating: .buy,
            previousPriceTarget: 325,
            newPriceTarget: 325
        ),
        AnalystAction(
            firmName: "BMO Capital Markets",
            actionType: .maintain,
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 8))!,
            previousRating: .buy,
            newRating: .buy,
            previousPriceTarget: 280,
            newPriceTarget: 290
        ),
        AnalystAction(
            firmName: "Barclays",
            actionType: .maintain,
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 7))!,
            previousRating: .buy,
            newRating: .buy,
            previousPriceTarget: 350,
            newPriceTarget: 325
        ),
        AnalystAction(
            firmName: "Piper Sandler",
            actionType: .initiated,
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 3))!,
            previousRating: nil,
            newRating: .buy,
            previousPriceTarget: nil,
            newPriceTarget: 350
        ),
        AnalystAction(
            firmName: "Goldman Sachs",
            actionType: .reiterated,
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 3))!,
            previousRating: .buy,
            newRating: .buy,
            previousPriceTarget: nil,
            newPriceTarget: 325
        ),
        AnalystAction(
            firmName: "Wedbush Securities",
            actionType: .upgrade,
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 14))!,
            previousRating: .buy,
            newRating: .strongBuy,
            previousPriceTarget: 370,
            newPriceTarget: 370
        ),
        AnalystAction(
            firmName: "Morgan Stanley",
            actionType: .downgrade,
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 11, day: 4))!,
            previousRating: .neutral,
            newRating: .underperform,
            previousPriceTarget: 350,
            newPriceTarget: 325
        ),
        AnalystAction(
            firmName: "Scotiabank",
            actionType: .downgrade,
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 11, day: 1))!,
            previousRating: .neutral,
            newRating: .sell,
            previousPriceTarget: 190,
            newPriceTarget: 190
        )
    ]
}

// MARK: - Analyst Ratings Data (Combined)
struct AnalystRatingsData {
    let totalAnalysts: Int
    let updatedDate: Date
    let consensus: AnalystConsensus
    let targetPrice: Double
    let targetUpside: Double
    let distributions: [AnalystRatingDistribution]
    let priceTarget: AnalystPriceTarget
    let momentumData: [AnalystMomentumMonth]
    let netPositive: Int
    let netNegative: Int
    let actionsSummary: AnalystActionsSummary
    let actions: [AnalystAction]

    var formattedTargetPrice: String {
        String(format: "$%.2f", targetPrice)
    }

    var formattedUpside: String {
        let sign = targetUpside >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", targetUpside))% upside"
    }

    var formattedUpdatedDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MM/dd/yyyy"
        return formatter.string(from: updatedDate)
    }
}

extension AnalystRatingsData {
    static let sampleData = AnalystRatingsData(
        totalAnalysts: 40,
        updatedDate: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 5))!,
        consensus: .strongBuy,
        targetPrice: 212.60,
        targetUpside: 17.2,
        distributions: AnalystRatingDistribution.sampleData,
        priceTarget: AnalystPriceTarget.sampleData,
        momentumData: AnalystMomentumMonth.sampleData,
        netPositive: 17,
        netNegative: 7,
        actionsSummary: AnalystActionsSummary.sampleData,
        actions: AnalystAction.sampleData
    )
}

// MARK: - Sentiment Timeframe
enum SentimentTimeframe: String, CaseIterable {
    case last24h = "Last 24H"
    case last7d = "Last 7D"
}

// MARK: - Market Mood Level
enum MarketMoodLevel: String {
    case bullish = "Bullish"
    case neutral = "Neutral"
    case bearish = "Bearish"

    var color: Color {
        switch self {
        case .bearish:
            return AppColors.bullish  // 0-30: Green zone
        case .neutral:
            return Color(hex: "6B7280")  // 31-70: Grey zone
        case .bullish:
            return AppColors.bearish  // 71-100: Red zone
        }
    }

    static func fromScore(_ score: Int) -> MarketMoodLevel {
        switch score {
        case 0...30:
            return .bearish  // Low scores (0-30) = Bearish (left side of gauge)
        case 31...70:
            return .neutral  // Middle scores (31-70) = Neutral
        default:  // 71-100
            return .bullish  // High scores (71-100) = Bullish (right side of gauge)
        }
    }
}


// MARK: - Sentiment Analysis Data
struct SentimentAnalysisData {
    let moodScore: Int // 0-100
    let last24hMood: MarketMoodLevel
    let last7dMood: MarketMoodLevel
    let socialMentions: Double
    let socialMentionsChange: Double
    let newsArticles: Int
    let newsArticlesChange: Double

    var formattedSocialMentions: String {
        if socialMentions >= 1000 {
            return String(format: "%.1fK", socialMentions / 1000)
        }
        return String(format: "%.0f", socialMentions)
    }

    var formattedSocialChange: String {
        let sign = socialMentionsChange >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.0f", socialMentionsChange))% today"
    }

    var formattedNewsArticles: String {
        "\(newsArticles)"
    }

    var formattedNewsChange: String {
        let sign = newsArticlesChange >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.0f", newsArticlesChange))% this week"
    }

    var socialChangeColor: Color {
        socialMentionsChange >= 0 ? AppColors.bullish : AppColors.bearish
    }

    var newsChangeColor: Color {
        newsArticlesChange >= 0 ? AppColors.bullish : AppColors.bearish
    }
}

extension SentimentAnalysisData {
    static let sampleData = SentimentAnalysisData(
        moodScore: 24,
        last24hMood: .bearish,  // 24 is in 0-30 range (Bearish/Red)
        last7dMood: .neutral,   // Neutral is 31-70 range (Grey)
        socialMentions: 12400,
        socialMentionsChange: 24,
        newsArticles: 847,
        newsArticlesChange: 18
    )
}

// MARK: - Technical Signal
enum TechnicalSignal: String, CaseIterable {
    case strongSell = "Strong Sell"
    case sell = "Sell"
    case hold = "Hold"
    case buy = "Buy"
    case strongBuy = "Strong Buy"

    var color: Color {
        switch self {
        case .strongSell:
            return Color(hex: "991B1B")  // Dark red
        case .sell:
            return AppColors.bearish     // Red
        case .hold:
            return Color(hex: "F59E0B")  // Yellow
        case .buy:
            return Color(hex: "4ADE80")  // Light green
        case .strongBuy:
            return AppColors.bullish     // Green
        }
    }

    var gaugePosition: Double {
        switch self {
        case .strongSell: return 0.1
        case .sell: return 0.3
        case .hold: return 0.5
        case .buy: return 0.7
        case .strongBuy: return 0.9
        }
    }
}

// MARK: - Technical Indicator Result
struct TechnicalIndicatorResult {
    let signal: TechnicalSignal
    let matchingIndicators: Int
    let totalIndicators: Int

    var formattedCount: String {
        "\(matchingIndicators) of \(totalIndicators) indicators"
    }
}

// MARK: - Technical Analysis Data
struct TechnicalAnalysisData {
    let dailySignal: TechnicalIndicatorResult
    let weeklySignal: TechnicalIndicatorResult
    let overallSignal: TechnicalSignal
    let gaugeValue: Double // 0.0 to 1.0

    var gaugeLevel: Int {
        switch gaugeValue {
        case 0..<0.2: return 1
        case 0.2..<0.4: return 2
        case 0.4..<0.6: return 3
        case 0.6..<0.8: return 4
        default: return 5
        }
    }
}

extension TechnicalAnalysisData {
    static let sampleData = TechnicalAnalysisData(
        dailySignal: TechnicalIndicatorResult(
            signal: .buy,
            matchingIndicators: 12,
            totalIndicators: 18
        ),
        weeklySignal: TechnicalIndicatorResult(
            signal: .strongBuy,
            matchingIndicators: 14,
            totalIndicators: 18
        ),
        overallSignal: .buy,
        gaugeValue: 0.72
    )
}

// MARK: - Combined Analysis Data
struct TickerAnalysisData {
    let analystRatings: AnalystRatingsData
    let sentimentAnalysis: SentimentAnalysisData
    let technicalAnalysis: TechnicalAnalysisData
}

extension TickerAnalysisData {
    static let sampleData = TickerAnalysisData(
        analystRatings: AnalystRatingsData.sampleData,
        sentimentAnalysis: SentimentAnalysisData.sampleData,
        technicalAnalysis: TechnicalAnalysisData.sampleData
    )
}

// MARK: - Technical Analysis Detail Models

// MARK: - Indicator Signal
enum IndicatorSignal: String {
    case buy = "Buy"
    case sell = "Sell"
    case neutral = "Neutral"

    var color: Color {
        switch self {
        case .buy: return AppColors.bullish
        case .sell: return AppColors.bearish
        case .neutral: return AppColors.textSecondary
        }
    }

    var arrowIcon: String? {
        switch self {
        case .buy: return "arrow.up"
        case .sell: return "arrow.down"
        case .neutral: return nil
        }
    }
}

// MARK: - Indicator Summary (Buy/Neutral/Sell counts)
struct IndicatorSummary {
    let buyCount: Int
    let neutralCount: Int
    let sellCount: Int

    var totalCount: Int {
        buyCount + neutralCount + sellCount
    }
}

// MARK: - Moving Average Indicator
struct MovingAverageIndicator: Identifiable {
    let id = UUID()
    let name: String
    let value: Double
    let signal: IndicatorSignal

    var formattedValue: String {
        String(format: "%.2f", value)
    }
}

extension MovingAverageIndicator {
    static let sampleData: [MovingAverageIndicator] = [
        MovingAverageIndicator(name: "MA(5)", value: 172.34, signal: .buy),
        MovingAverageIndicator(name: "MA(10)", value: 170.89, signal: .buy),
        MovingAverageIndicator(name: "MA(20)", value: 168.45, signal: .sell),
        MovingAverageIndicator(name: "MA(50)", value: 175.23, signal: .buy),
        MovingAverageIndicator(name: "MA(100)", value: 171.67, signal: .buy),
        MovingAverageIndicator(name: "MA(200)", value: 169.12, signal: .buy),
        MovingAverageIndicator(name: "EMA(5)", value: 173.89, signal: .buy),
        MovingAverageIndicator(name: "EMA(10)", value: 172.34, signal: .buy),
        MovingAverageIndicator(name: "EMA(20)", value: 179.56, signal: .neutral),
        MovingAverageIndicator(name: "EMA(50)", value: 180.12, signal: .neutral)
    ]

    static let sampleSummary = IndicatorSummary(buyCount: 8, neutralCount: 2, sellCount: 1)
}

// MARK: - Oscillator Indicator
struct OscillatorIndicator: Identifiable {
    let id = UUID()
    let name: String
    let value: Double
    let signal: IndicatorSignal

    var formattedValue: String {
        String(format: "%.2f", value)
    }
}

extension OscillatorIndicator {
    static let sampleData: [OscillatorIndicator] = [
        OscillatorIndicator(name: "RSI(14)", value: 58.34, signal: .neutral),
        OscillatorIndicator(name: "Stoch(9,6)", value: 42.67, signal: .buy),
        OscillatorIndicator(name: "StochRSI", value: 38.92, signal: .buy),
        OscillatorIndicator(name: "MACD(12,26)", value: 1.23, signal: .buy),
        OscillatorIndicator(name: "ADX(14)", value: 28.45, signal: .neutral),
        OscillatorIndicator(name: "Williams %R", value: -35.67, signal: .neutral),
        OscillatorIndicator(name: "CCI(14)", value: 45.23, signal: .buy),
        OscillatorIndicator(name: "ATR(14)", value: 3.89, signal: .neutral)
    ]

    static let sampleSummary = IndicatorSummary(buyCount: 4, neutralCount: 4, sellCount: 0)
}

// MARK: - Pivot Point Level
struct PivotPointLevel: Identifiable {
    let id = UUID()
    let name: String
    let value: Double
    let levelType: PivotLevelType

    var formattedValue: String {
        String(format: "%.2f", value)
    }

    var valueColor: Color {
        levelType.color
    }
}

enum PivotLevelType {
    case resistance
    case pivot
    case support

    var color: Color {
        switch self {
        case .resistance: return AppColors.bullish
        case .pivot: return AppColors.textPrimary
        case .support: return AppColors.bearish
        }
    }
}

// MARK: - Pivot Points Data
struct PivotPointsData {
    let method: String
    let levels: [PivotPointLevel]
}

extension PivotPointsData {
    static let sampleData = PivotPointsData(
        method: "Classic Method",
        levels: [
            PivotPointLevel(name: "R3", value: 184.56, levelType: .resistance),
            PivotPointLevel(name: "R2", value: 182.34, levelType: .resistance),
            PivotPointLevel(name: "R1", value: 180.67, levelType: .resistance),
            PivotPointLevel(name: "Pivot", value: 178.42, levelType: .pivot),
            PivotPointLevel(name: "S1", value: 176.23, levelType: .support),
            PivotPointLevel(name: "S2", value: 174.89, levelType: .support),
            PivotPointLevel(name: "S3", value: 172.45, levelType: .support)
        ]
    )
}

// MARK: - Volume Analysis Data
struct VolumeAnalysisData {
    let currentVolume: Double
    let currentVolumeChange: Double
    let avgVolume30d: Double
    let volumeTrend: VolumeTrend
    let obv: Double
    let moneyFlowIndex: Double

    var formattedCurrentVolume: String {
        formatVolume(currentVolume)
    }

    var formattedVolumeChange: String {
        let sign = currentVolumeChange >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.0f", currentVolumeChange))%"
    }

    var volumeChangeColor: Color {
        currentVolumeChange >= 0 ? AppColors.bullish : AppColors.bearish
    }

    var formattedAvgVolume: String {
        formatVolume(avgVolume30d)
    }

    var formattedOBV: String {
        let sign = obv >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", obv))"
    }

    var obvColor: Color {
        obv >= 0 ? AppColors.bullish : AppColors.bearish
    }

    var formattedMFI: String {
        String(format: "%.2f", moneyFlowIndex)
    }

    private func formatVolume(_ volume: Double) -> String {
        if volume >= 1_000_000 {
            return String(format: "%.1fM", volume / 1_000_000)
        } else if volume >= 1_000 {
            return String(format: "%.1fK", volume / 1_000)
        }
        return String(format: "%.0f", volume)
    }
}

enum VolumeTrend: String {
    case increasing = "Increasing"
    case decreasing = "Decreasing"
    case stable = "Stable"

    var color: Color {
        switch self {
        case .increasing: return AppColors.bullish
        case .decreasing: return AppColors.bearish
        case .stable: return AppColors.textSecondary
        }
    }

    var icon: String {
        switch self {
        case .increasing: return "arrow.up"
        case .decreasing: return "arrow.down"
        case .stable: return "minus"
        }
    }
}

extension VolumeAnalysisData {
    static let sampleData = VolumeAnalysisData(
        currentVolume: 52_800_000,
        currentVolumeChange: 23,
        avgVolume30d: 42_900_000,
        volumeTrend: .increasing,
        obv: 2.48,
        moneyFlowIndex: 64.23
    )
}

// MARK: - Fibonacci Level
struct FibonacciLevel: Identifiable {
    let id = UUID()
    let percentage: String
    let value: Double
    let isKey: Bool // High, Low markers

    var formattedValue: String {
        String(format: "%.2f", value)
    }
}

// MARK: - Fibonacci Retracement Data
struct FibonacciRetracementData {
    let timeframe: String
    let levels: [FibonacciLevel]
}

extension FibonacciRetracementData {
    static let sampleData = FibonacciRetracementData(
        timeframe: "Weekly Levels",
        levels: [
            FibonacciLevel(percentage: "0.0%", value: 182.45, isKey: true),
            FibonacciLevel(percentage: "23.6%", value: 180.78, isKey: false),
            FibonacciLevel(percentage: "38.2%", value: 179.34, isKey: false),
            FibonacciLevel(percentage: "50.0%", value: 178.42, isKey: false),
            FibonacciLevel(percentage: "61.8%", value: 177.23, isKey: false),
            FibonacciLevel(percentage: "78.6%", value: 175.89, isKey: false),
            FibonacciLevel(percentage: "100.0%", value: 174.39, isKey: true)
        ]
    )
}

// MARK: - Support/Resistance Level
struct SupportResistanceLevel: Identifiable {
    let id = UUID()
    let name: String
    let value: Double
    let strength: LevelStrength
}

enum LevelStrength: String {
    case strong = "Strong"
    case moderate = "Moderate"
    case weak = "Weak"

    var color: Color {
        switch self {
        case .strong: return AppColors.bullish
        case .moderate: return AppColors.neutral
        case .weak: return AppColors.textMuted
        }
    }
}

// MARK: - Key Support & Resistance Data
struct SupportResistanceData {
    let currentPrice: Double
    let resistanceLevels: [SupportResistanceLevel]
    let supportLevels: [SupportResistanceLevel]

    var formattedCurrentPrice: String {
        String(format: "$%.2f", currentPrice)
    }
}

extension SupportResistanceData {
    static let sampleData = SupportResistanceData(
        currentPrice: 178.42,
        resistanceLevels: [
            SupportResistanceLevel(name: "R3", value: 184.56, strength: .strong),
            SupportResistanceLevel(name: "R2", value: 182.34, strength: .moderate),
            SupportResistanceLevel(name: "R1", value: 180.67, strength: .weak)
        ],
        supportLevels: [
            SupportResistanceLevel(name: "S1", value: 176.23, strength: .weak),
            SupportResistanceLevel(name: "S2", value: 174.89, strength: .moderate),
            SupportResistanceLevel(name: "S3", value: 172.45, strength: .strong)
        ]
    )
}

// MARK: - Complete Technical Analysis Detail Data
struct TechnicalAnalysisDetailData {
    let symbol: String
    let movingAverages: [MovingAverageIndicator]
    let movingAveragesSummary: IndicatorSummary
    let oscillators: [OscillatorIndicator]
    let oscillatorsSummary: IndicatorSummary
    let pivotPoints: PivotPointsData
    let volumeAnalysis: VolumeAnalysisData
    let fibonacciRetracement: FibonacciRetracementData
    let supportResistance: SupportResistanceData
}

extension TechnicalAnalysisDetailData {
    static let sampleData = TechnicalAnalysisDetailData(
        symbol: "AAPL",
        movingAverages: MovingAverageIndicator.sampleData,
        movingAveragesSummary: MovingAverageIndicator.sampleSummary,
        oscillators: OscillatorIndicator.sampleData,
        oscillatorsSummary: OscillatorIndicator.sampleSummary,
        pivotPoints: PivotPointsData.sampleData,
        volumeAnalysis: VolumeAnalysisData.sampleData,
        fibonacciRetracement: FibonacciRetracementData.sampleData,
        supportResistance: SupportResistanceData.sampleData
    )
}

// MARK: - Earnings Section Models

// MARK: - Earnings Data Type (EPS vs Revenue)
enum EarningsDataType: String, CaseIterable {
    case eps = "EPS"
    case revenue = "Revenue"
}

// MARK: - Earnings Time Range
enum EarningsTimeRange: String, CaseIterable {
    case oneYear = "1Y"
    case threeYears = "3Y"
}

// MARK: - Earnings Quarter Result
enum EarningsQuarterResult {
    case beat       // Green - actual > estimate
    case missed     // Red - actual < estimate
    case matched    // Green with dashed border - actual == estimate (0% surprise)
    case pending    // Gray - future quarter, only estimate available

    var dotColor: Color {
        switch self {
        case .beat, .matched:
            return AppColors.bullish
        case .missed:
            return AppColors.bearish
        case .pending:
            return AppColors.textSecondary
        }
    }

    var hasDashedBorder: Bool {
        self == .matched
    }
}

// MARK: - Earnings Quarter Data
struct EarningsQuarterData: Identifiable {
    let id = UUID()
    let quarter: String          // e.g., "Q1 '24"
    let actualValue: Double?     // nil for future quarters
    let estimateValue: Double
    let surprisePercent: Double? // nil for future quarters

    var result: EarningsQuarterResult {
        guard let actual = actualValue, let surprise = surprisePercent else {
            return .pending
        }

        if surprise == 0 {
            return .matched
        } else if actual > estimateValue {
            return .beat
        } else {
            return .missed
        }
    }

    var formattedSurprise: String? {
        guard let surprise = surprisePercent else { return nil }
        if surprise == 0 {
            return "0%"
        }
        let sign = surprise > 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", surprise))%"
    }

    var surpriseColor: Color {
        guard let surprise = surprisePercent else { return AppColors.textSecondary }
        if surprise > 0 {
            return AppColors.bullish
        } else if surprise < 0 {
            return AppColors.bearish
        }
        return AppColors.accentCyan
    }
}

// MARK: - Earnings Price Data Point (for price overlay)
struct EarningsPricePoint: Identifiable {
    var id = UUID()
    let quarter: String
    let price: Double
}

// MARK: - Earnings Data (Combined)
// MARK: - Next Earnings Date
enum EarningsReportTiming: String {
    case beforeMarketOpen = "Before Market Open"
    case afterMarketClose = "After Market Close"
    case duringMarketHours = "During Market Hours"
    case unknown = "Time Not Specified"
}

struct NextEarningsDate {
    let date: Date
    let isConfirmed: Bool
    let timing: EarningsReportTiming

    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM d, yyyy"
        return formatter.string(from: date)
    }

    var statusText: String {
        isConfirmed ? "Confirmed" : "Expected"
    }
}

extension NextEarningsDate {
    static let sample = NextEarningsDate(
        date: {
            var components = DateComponents()
            components.year = 2024
            components.month = 1
            components.day = 25
            return Calendar.current.date(from: components) ?? Date()
        }(),
        isConfirmed: false,
        timing: .afterMarketClose
    )
}

struct EarningsData {
    let epsQuarters: [EarningsQuarterData]
    let revenueQuarters: [EarningsQuarterData]
    let priceHistory: [EarningsPricePoint]
    let nextEarningsDate: NextEarningsDate?

    init(
        epsQuarters: [EarningsQuarterData],
        revenueQuarters: [EarningsQuarterData],
        priceHistory: [EarningsPricePoint],
        nextEarningsDate: NextEarningsDate? = nil
    ) {
        self.epsQuarters = epsQuarters
        self.revenueQuarters = revenueQuarters
        self.priceHistory = priceHistory
        self.nextEarningsDate = nextEarningsDate
    }

    func quarters(for dataType: EarningsDataType) -> [EarningsQuarterData] {
        switch dataType {
        case .eps:
            return epsQuarters
        case .revenue:
            return revenueQuarters
        }
    }
}

extension EarningsData {
    static let sampleData = EarningsData(
        epsQuarters: [
            // 2022 data
            EarningsQuarterData(quarter: "Q1 '22", actualValue: 0.45, estimateValue: 0.42, surprisePercent: 7.1),
            EarningsQuarterData(quarter: "Q2 '22", actualValue: 0.52, estimateValue: 0.50, surprisePercent: 4.0),
            EarningsQuarterData(quarter: "Q3 '22", actualValue: 0.48, estimateValue: 0.52, surprisePercent: -7.7),
            EarningsQuarterData(quarter: "Q4 '22", actualValue: 0.55, estimateValue: 0.55, surprisePercent: 0),
            // 2023 data
            EarningsQuarterData(quarter: "Q1 '23", actualValue: 0.58, estimateValue: 0.55, surprisePercent: 5.5),
            EarningsQuarterData(quarter: "Q2 '23", actualValue: 0.62, estimateValue: 0.60, surprisePercent: 3.3),
            EarningsQuarterData(quarter: "Q3 '23", actualValue: 0.55, estimateValue: 0.58, surprisePercent: -5.2),
            EarningsQuarterData(quarter: "Q4 '23", actualValue: 0.68, estimateValue: 0.65, surprisePercent: 4.6),
            // 2024 data
            EarningsQuarterData(quarter: "Q1 '24", actualValue: 0.65, estimateValue: 0.58, surprisePercent: 4.2),
            EarningsQuarterData(quarter: "Q2 '24", actualValue: 1.20, estimateValue: 1.10, surprisePercent: 5.8),
            EarningsQuarterData(quarter: "Q3 '24", actualValue: 0.52, estimateValue: 0.55, surprisePercent: -1.2),
            EarningsQuarterData(quarter: "Q4 '24", actualValue: 0.25, estimateValue: 0.25, surprisePercent: 0),
            // 2025 future data
            EarningsQuarterData(quarter: "Q1 '25", actualValue: nil, estimateValue: 0.72, surprisePercent: nil),
            EarningsQuarterData(quarter: "Q2 '25", actualValue: nil, estimateValue: 1.35, surprisePercent: nil)
        ],
        revenueQuarters: [
            // 2022 data
            EarningsQuarterData(quarter: "Q1 '22", actualValue: 78.5, estimateValue: 76.0, surprisePercent: 3.3),
            EarningsQuarterData(quarter: "Q2 '22", actualValue: 82.3, estimateValue: 80.0, surprisePercent: 2.9),
            EarningsQuarterData(quarter: "Q3 '22", actualValue: 79.8, estimateValue: 82.0, surprisePercent: -2.7),
            EarningsQuarterData(quarter: "Q4 '22", actualValue: 88.2, estimateValue: 88.2, surprisePercent: 0),
            // 2023 data
            EarningsQuarterData(quarter: "Q1 '23", actualValue: 85.5, estimateValue: 83.0, surprisePercent: 3.0),
            EarningsQuarterData(quarter: "Q2 '23", actualValue: 90.2, estimateValue: 88.5, surprisePercent: 1.9),
            EarningsQuarterData(quarter: "Q3 '23", actualValue: 86.8, estimateValue: 89.0, surprisePercent: -2.5),
            EarningsQuarterData(quarter: "Q4 '23", actualValue: 95.5, estimateValue: 93.0, surprisePercent: 2.7),
            // 2024 data
            EarningsQuarterData(quarter: "Q1 '24", actualValue: 94.8, estimateValue: 92.5, surprisePercent: 2.5),
            EarningsQuarterData(quarter: "Q2 '24", actualValue: 98.2, estimateValue: 95.0, surprisePercent: 3.4),
            EarningsQuarterData(quarter: "Q3 '24", actualValue: 89.5, estimateValue: 91.0, surprisePercent: -1.6),
            EarningsQuarterData(quarter: "Q4 '24", actualValue: 102.3, estimateValue: 102.3, surprisePercent: 0),
            // 2025 future data
            EarningsQuarterData(quarter: "Q1 '25", actualValue: nil, estimateValue: 96.0, surprisePercent: nil),
            EarningsQuarterData(quarter: "Q2 '25", actualValue: nil, estimateValue: 105.0, surprisePercent: nil)
        ],
        priceHistory: [
            // 2022 data
            EarningsPricePoint(quarter: "Q1 '22", price: 0.42),
            EarningsPricePoint(quarter: "Q2 '22", price: 0.48),
            EarningsPricePoint(quarter: "Q3 '22", price: 0.52),
            EarningsPricePoint(quarter: "Q4 '22", price: 0.58),
            // 2023 data
            EarningsPricePoint(quarter: "Q1 '23", price: 0.55),
            EarningsPricePoint(quarter: "Q2 '23", price: 0.63),
            EarningsPricePoint(quarter: "Q3 '23", price: 0.68),
            EarningsPricePoint(quarter: "Q4 '23", price: 0.75),
            // 2024 data
            EarningsPricePoint(quarter: "Q1 '24", price: 0.60),
            EarningsPricePoint(quarter: "Q2 '24", price: 0.95),
            EarningsPricePoint(quarter: "Q3 '24", price: 0.98),
            EarningsPricePoint(quarter: "Q4 '24", price: 1.05),
            // 2025 future data
            EarningsPricePoint(quarter: "Q1 '25", price: 0.95),
            EarningsPricePoint(quarter: "Q2 '25", price: nil)
        ],
        nextEarningsDate: .sample
    )

    // Extended 3-year sample data
    static let sampleData3Year = EarningsData(
        epsQuarters: [
            EarningsQuarterData(quarter: "Q1 '22", actualValue: 0.45, estimateValue: 0.42, surprisePercent: 7.1),
            EarningsQuarterData(quarter: "Q2 '22", actualValue: 0.52, estimateValue: 0.50, surprisePercent: 4.0),
            EarningsQuarterData(quarter: "Q3 '22", actualValue: 0.48, estimateValue: 0.52, surprisePercent: -7.7),
            EarningsQuarterData(quarter: "Q4 '22", actualValue: 0.55, estimateValue: 0.55, surprisePercent: 0),
            EarningsQuarterData(quarter: "Q1 '23", actualValue: 0.58, estimateValue: 0.55, surprisePercent: 5.5),
            EarningsQuarterData(quarter: "Q2 '23", actualValue: 0.62, estimateValue: 0.60, surprisePercent: 3.3),
            EarningsQuarterData(quarter: "Q3 '23", actualValue: 0.55, estimateValue: 0.58, surprisePercent: -5.2),
            EarningsQuarterData(quarter: "Q4 '23", actualValue: 0.68, estimateValue: 0.65, surprisePercent: 4.6),
            EarningsQuarterData(quarter: "Q1 '24", actualValue: 0.65, estimateValue: 0.58, surprisePercent: 4.2),
            EarningsQuarterData(quarter: "Q2 '24", actualValue: 1.20, estimateValue: 1.10, surprisePercent: 5.8),
            EarningsQuarterData(quarter: "Q3 '24", actualValue: 0.52, estimateValue: 0.55, surprisePercent: -1.2),
            EarningsQuarterData(quarter: "Q4 '24", actualValue: 0.25, estimateValue: 0.25, surprisePercent: 0)
        ],
        revenueQuarters: [
            EarningsQuarterData(quarter: "Q1 '22", actualValue: 78.5, estimateValue: 76.0, surprisePercent: 3.3),
            EarningsQuarterData(quarter: "Q2 '22", actualValue: 82.3, estimateValue: 80.0, surprisePercent: 2.9),
            EarningsQuarterData(quarter: "Q3 '22", actualValue: 79.8, estimateValue: 82.0, surprisePercent: -2.7),
            EarningsQuarterData(quarter: "Q4 '22", actualValue: 88.2, estimateValue: 88.2, surprisePercent: 0),
            EarningsQuarterData(quarter: "Q1 '23", actualValue: 85.5, estimateValue: 83.0, surprisePercent: 3.0),
            EarningsQuarterData(quarter: "Q2 '23", actualValue: 90.2, estimateValue: 88.5, surprisePercent: 1.9),
            EarningsQuarterData(quarter: "Q3 '23", actualValue: 86.8, estimateValue: 89.0, surprisePercent: -2.5),
            EarningsQuarterData(quarter: "Q4 '23", actualValue: 95.5, estimateValue: 93.0, surprisePercent: 2.7),
            EarningsQuarterData(quarter: "Q1 '24", actualValue: 94.8, estimateValue: 92.5, surprisePercent: 2.5),
            EarningsQuarterData(quarter: "Q2 '24", actualValue: 98.2, estimateValue: 95.0, surprisePercent: 3.4),
            EarningsQuarterData(quarter: "Q3 '24", actualValue: 89.5, estimateValue: 91.0, surprisePercent: -1.6),
            EarningsQuarterData(quarter: "Q4 '24", actualValue: 102.3, estimateValue: 102.3, surprisePercent: 0)
        ],
        priceHistory: []
    )
}

// Fix for nil price in sample data
extension EarningsPricePoint {
    init(quarter: String, price: Double?) {
        self.id = UUID()
        self.quarter = quarter
        self.price = price ?? 0
    }
}

================================================================================
FILE: frontend/ios/ios/Models/TickerNewsModels.swift
================================================================================

//
//  TickerNewsModels.swift
//  ios
//
//  Data models for the Ticker Detail News tab
//

import Foundation
import SwiftUI

// MARK: - Ticker News Article
struct TickerNewsArticle: Identifiable {
    let id = UUID()
    let headline: String
    let source: NewsSource
    let sentiment: NewsSentiment
    let publishedAt: Date
    let thumbnailName: String?
    let relatedTickers: [String]
    let summaryBullets: [String]
    let articleURL: URL?

    var timeAgo: String {
        let interval = Date().timeIntervalSince(publishedAt)
        let minutes = Int(interval / 60)
        let hours = Int(interval / 3600)
        let days = Int(interval / 86400)

        if minutes < 60 {
            return "\(minutes)m ago"
        } else if hours < 24 {
            return "\(hours)h ago"
        } else if days == 1 {
            return "Yesterday"
        } else if days < 7 {
            return "\(days)d ago"
        } else {
            let formatter = DateFormatter()
            formatter.dateFormat = "MMM d"
            return formatter.string(from: publishedAt)
        }
    }

    var hasSummary: Bool {
        !summaryBullets.isEmpty
    }
}

// MARK: - Sample Data
extension TickerNewsArticle {
    static func sampleDataForTicker(_ symbol: String) -> [TickerNewsArticle] {
        let now = Date()

        return [
            TickerNewsArticle(
                headline: "Apple announces record-breaking Q4 earnings, exceeds analyst...",
                source: NewsSource(name: "Bloomberg", iconName: "icon_bloomberg"),
                sentiment: .positive,
                publishedAt: now.addingTimeInterval(-2 * 3600), // 2h ago
                thumbnailName: "news_thumbnail_earnings",
                relatedTickers: [symbol, "MSFT"],
                summaryBullets: [],
                articleURL: URL(string: "https://bloomberg.com/news/apple-q4")
            ),
            TickerNewsArticle(
                headline: "Apple releases iOS 18.2 beta with new AI features for developers",
                source: NewsSource(name: "TechCrunch", iconName: "icon_techcrunch"),
                sentiment: .neutral,
                publishedAt: now.addingTimeInterval(-4 * 3600), // 4h ago
                thumbnailName: "news_thumbnail_ios",
                relatedTickers: [symbol],
                summaryBullets: [],
                articleURL: URL(string: "https://techcrunch.com/apple-ios-18-2")
            ),
            TickerNewsArticle(
                headline: "Apple Vision Pro demand surges in international markets ahead of launch",
                source: NewsSource(name: "Reuters", iconName: "icon_reuters"),
                sentiment: .positive,
                publishedAt: now.addingTimeInterval(-6 * 3600), // 6h ago
                thumbnailName: "news_thumbnail_vision_pro",
                relatedTickers: [symbol, "META"],
                summaryBullets: [],
                articleURL: URL(string: "https://reuters.com/apple-vision-pro")
            ),
            TickerNewsArticle(
                headline: "Apple faces regulatory scrutiny over App Store policies in European Union",
                source: NewsSource(name: "Financial Times", iconName: "icon_ft"),
                sentiment: .negative,
                publishedAt: now.addingTimeInterval(-8 * 3600), // 8h ago
                thumbnailName: "news_thumbnail_eu",
                relatedTickers: [symbol, "GOOGL"],
                summaryBullets: [
                    "High Pre-Orders Abroad: Apple is seeing unusually strong pre-order numbers in Europe and Asia, indicating strong international interest before the official launch.",
                    "Supply Chain Scaling: Apple is ramping up production and logistics overseas to meet anticipated demand and prevent stock shortages.",
                    "Premium Market Appeal: Early excitement suggests that Apple's Vision Pro is resonating with tech enthusiasts and luxury consumers globally."
                ],
                articleURL: URL(string: "https://ft.com/apple-eu-regulation")
            ),
            TickerNewsArticle(
                headline: "Apple suppliers report strong orders for upcoming iPhone 16 production",
                source: NewsSource(name: "The Wall Street Journal", iconName: "icon_wsj"),
                sentiment: .positive,
                publishedAt: now.addingTimeInterval(-24 * 3600), // Yesterday
                thumbnailName: "news_thumbnail_iphone",
                relatedTickers: [symbol],
                summaryBullets: [],
                articleURL: URL(string: "https://wsj.com/apple-iphone-16")
            )
        ]
    }
}

// MARK: - News Source Brand Color Extension
extension NewsSource {
    var brandColorHex: String {
        switch name.lowercased() {
        case "bloomberg":
            return "2800D7" // Purple
        case "techcrunch":
            return "0A9E25" // Green
        case "reuters":
            return "FF6600" // Orange
        case "financial times", "ft":
            return "FCD0A1" // Salmon/Peach
        case "the wall street journal", "wsj", "wall street journal":
            return "0274B6" // Blue
        case "cnbc":
            return "6366F1" // Indigo
        case "marketwatch":
            return "00AC4E" // Green
        case "zacks":
            return "0066CC" // Blue
        default:
            return "3B82F6" // Default blue
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Models/TickerReportModels.swift
================================================================================

//
//  TickerReportModels.swift
//  ios
//
//  Data models for the Ticker Report (Buffett Agent) screen
//

import Foundation
import SwiftUI

// MARK: - Navigation Helper

struct ReportTickerNavigation: Identifiable {
    let id = UUID()
    let ticker: String
}

// MARK: - Report Agent Persona

enum ReportAgentPersona: String, CaseIterable {
    case buffett = "ANALYZED BY BUFFETT AGENT"
    case wood = "ANALYZED BY WOOD AGENT"
    case lynch = "ANALYZED BY LYNCH AGENT"
    case dalio = "ANALYZED BY DALIO AGENT"

    var starRating: Double {
        switch self {
        case .buffett: return 4.0
        case .wood: return 3.5
        case .lynch: return 4.5
        case .dalio: return 4.0
        }
    }
}

// MARK: - Report Quality Rating

struct ReportQualityRating {
    let score: Double       // 0-100
    let maxScore: Double    // 100
    let label: String       // Auto-generated based on score

    var formattedScore: String {
        String(format: "%.0f", score)
    }

    var formattedMax: String {
        "/ \(Int(maxScore))"
    }

    // Helper to generate label from score
    static func labelForScore(_ score: Double) -> String {
        switch score {
        case 90...100:
            return "Excellent Quality Business"
        case 75..<90:
            return "Strong Quality Business"
        case 50..<75:
            return "Fair Quality Business"
        case 30..<50:
            return "Weak Quality Business"
        default:
            return "Distressed Quality Business"
        }
    }

    // Convenience initializer that auto-generates label
    init(score: Double, maxScore: Double = 100) {
        self.score = score
        self.maxScore = maxScore
        self.label = ReportQualityRating.labelForScore(score)
    }

    // Full initializer for custom labels
    init(score: Double, maxScore: Double, label: String) {
        self.score = score
        self.maxScore = maxScore
        self.label = label
    }
}

// MARK: - Executive Summary Bullet

struct ExecutiveSummaryBullet: Identifiable {
    let id = UUID()
    let category: String        // e.g. "Catalyst", "Valuation", "Risk"
    let text: String
    let sentiment: BulletSentiment

    enum BulletSentiment {
        case positive, neutral, negative

        var color: Color {
            switch self {
            case .positive: return AppColors.bullish
            case .neutral: return AppColors.neutral
            case .negative: return AppColors.bearish
            }
        }

        var iconName: String {
            switch self {
            case .positive: return "arrow.up.circle.fill"
            case .neutral: return "minus.circle.fill"
            case .negative: return "arrow.down.circle.fill"
            }
        }
    }
}

// MARK: - Valuation Status

enum ValuationStatus: String {
    case overpriced = "Overpriced"
    case fairValue = "Fair Value"
    case underpriced = "Underpriced"
    case deepUndervalued = "Deep Undervalued"

    var color: Color {
        switch self {
        case .overpriced: return AppColors.bearish
        case .fairValue: return AppColors.neutral
        case .underpriced: return AppColors.bullish
        case .deepUndervalued: return AppColors.bullish
        }
    }

    var backgroundColor: Color {
        color.opacity(0.15)
    }
}

// MARK: - Key Vital: Valuation Card Data

struct ReportValuationData {
    let status: ValuationStatus
    let currentPrice: Double
    let fairValue: Double
    let upsidePotential: Double  // percentage

    var formattedCurrentPrice: String {
        String(format: "$%.2f", currentPrice)
    }

    var formattedFairValue: String {
        String(format: "$%.0f", fairValue)
    }

    var formattedUpside: String {
        let sign = upsidePotential >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", upsidePotential))%"
    }

    var upsideColor: Color {
        upsidePotential >= 0 ? AppColors.bullish : AppColors.bearish
    }
}

// MARK: - Moat Quality Tag

struct MoatTag: Identifiable {
    let id = UUID()
    let label: String
    let strength: MoatStrength

    enum MoatStrength: String {
        case wide = "Wide"
        case narrow = "Narrow"
        case none = "None"

        var color: Color {
            switch self {
            case .wide: return AppColors.bullish
            case .narrow: return AppColors.neutral
            case .none: return AppColors.bearish
            }
        }
    }
}

// MARK: - Key Vital: Moat Card Data

struct ReportMoatData {
    let overallRating: MoatTag.MoatStrength  // Wide, Narrow, or None
    let primarySource: String                 // "High Switching Costs"
    let tags: [MoatTag]
    let valueLabel: String      // "Value" or "Stable"
    let stabilityLabel: String  // "Stable"
}

// MARK: - Financial Health Indicator

enum FinancialHealthLevel: String {
    case strong = "Strong"
    case moderate = "Moderate"
    case weak = "Weak"
    case critical = "Critical"

    var color: Color {
        switch self {
        case .strong: return AppColors.bullish      // Green - Safe Zone
        case .moderate: return AppColors.alertOrange // Orange - Grey Zone
        case .weak: return AppColors.alertOrange     // Orange - Grey Zone
        case .critical: return AppColors.bearish     // Red - Distress
        }
    }
    
    // Z-Score based level
    static func fromZScore(_ score: Double) -> FinancialHealthLevel {
        if score < 1.8 {
            return .critical    // Red - Distress
        } else if score < 3.0 {
            return .weak        // Orange - Grey Zone (could also be .moderate)
        } else {
            return .strong      // Green - Safe Zone
        }
    }
}

// MARK: - Key Vital: Financial Health Card Data

struct ReportFinancialHealthData {
    let level: FinancialHealthLevel
    let altmanZScore: Double
    let altmanZLabel: String            // "Below 1.8 is risk"
    let additionalMetric: String        // "Increasing Cost"
    let additionalMetricStatus: FinancialHealthLevel
    let fcfNote: String                 // "Negative FCF in last 2 years"

    var formattedZScore: String {
        String(format: "%.1f", altmanZScore)
    }
    
    // Convert "Increasing Cost" to "Rising Expenses" for better clarity
    var additionalMetricDisplayText: String {
        if additionalMetric.lowercased().contains("increasing cost") {
            return "Rising Expenses"
        }
        return additionalMetric
    }
}

// MARK: - Key Vitals Section

struct ReportKeyVitals {
    let valuation: ReportValuationData
    let moat: ReportMoatData
    let financialHealth: ReportFinancialHealthData
}

// MARK: - Core Thesis Bullet

struct CoreThesisBullet: Identifiable {
    let id = UUID()
    let text: String
}

// MARK: - Core Thesis Data

struct ReportCoreThesis {
    let bullCase: [CoreThesisBullet]
    let bearCase: [CoreThesisBullet]
}

// MARK: - Deep Dive Metric Card Data

struct DeepDiveMetricCard: Identifiable {
    let id = UUID()
    let title: String           // "Profitability", "Valuation", "Growth", "Health"
    let starRating: Int         // 1-5
    let metrics: [DeepDiveMetric]
    let qualityLabel: String    // "A Cash Machine", "Priced for perfection", etc.
}

// MARK: - Deep Dive Metric

struct DeepDiveMetric: Identifiable {
    let id = UUID()
    let label: String
    let value: String
    let trend: MetricTrend?

    enum MetricTrend {
        case up, down, flat

        var iconName: String {
            switch self {
            case .up: return "arrow.up"
            case .down: return "arrow.down"
            case .flat: return "minus"
            }
        }

        var color: Color {
            switch self {
            case .up: return AppColors.bullish
            case .down: return AppColors.bearish
            case .flat: return AppColors.textSecondary
            }
        }
    }
}

// MARK: - Overall Assessment

struct ReportOverallAssessment {
    let text: String
    let averageRating: Double
    let strongCount: Int
    let weakCount: Int
}

// MARK: - Revenue Forecast Data

struct ReportRevenueForecast {
    let cagr: Double                    // revenue growth percentage
    let epsGrowth: Double               // EPS growth percentage
    let managementGuidance: ManagementGuidance
    let projections: [RevenueProjection]
    let guidanceQuote: String?

    var formattedCAGR: String {
        "+\(String(format: "%.0f", cagr))% CAGR"
    }

    var formattedEPSGrowth: String {
        "+\(String(format: "%.0f", epsGrowth))% CAGR"
    }
}

struct RevenueProjection: Identifiable {
    let id = UUID()
    let period: String      // x-axis category e.g. "FY24", "FY25E"
    let revenue: Double     // revenue value (billions)
    let revenueLabel: String // display label e.g. "$120B"
    let eps: Double         // EPS value e.g. 4.50
    let epsLabel: String    // display label e.g. "$4.50"
    let isForecast: Bool
}

enum ManagementGuidance: String {
    case raised = "RAISED"
    case maintained = "MAINTAINED"
    case lowered = "LOWERED"

    var color: Color {
        switch self {
        case .raised: return AppColors.bullish
        case .maintained: return AppColors.neutral
        case .lowered: return AppColors.bearish
        }
    }

    var backgroundColor: Color {
        color.opacity(0.15)
    }
}

// MARK: - Insider Activity

enum InsiderSentiment: String {
    case positive = "Positive"
    case negative = "Negative"
    case neutral = "Neutral"

    var color: Color {
        switch self {
        case .positive: return AppColors.bullish
        case .negative: return AppColors.bearish
        case .neutral: return AppColors.neutral
        }
    }

    var backgroundColor: Color {
        color.opacity(0.15)
    }
}

struct InsiderTransaction: Identifiable {
    let id = UUID()
    let type: String        // "Buys" or "Sells"
    let count: Int
    let shares: String
    let value: String
}

struct ReportInsiderData {
    let sentiment: InsiderSentiment
    let timeframe: String           // "Last 90 Days"
    let transactions: [InsiderTransaction]
    let ownershipNote: String?      // "The stock is heavily sold off by insiders."
}

// MARK: - Key Management

struct KeyManager: Identifiable {
    let id = UUID()
    let name: String
    let title: String
    let ownership: String       // e.g. "40.3%", "$2,025", etc.
    let ownershipValue: String  // dollar amount or additional info
}

struct ReportKeyManagement {
    let managers: [KeyManager]
    let ownershipInsight: String    // "Oracle's high ownership ensures long-term thinking..."
}

// MARK: - Wall Street Consensus

enum ConsensusRating: String {
    case strongBuy = "BUY RATING"
    case buy = "BUY"
    case hold = "HOLD"
    case sell = "SELL"
    case strongSell = "STRONG SELL"

    var color: Color {
        switch self {
        case .strongBuy, .buy: return AppColors.bullish
        case .hold: return AppColors.neutral
        case .sell, .strongSell: return AppColors.bearish
        }
    }

    var backgroundColor: Color {
        color.opacity(0.15)
    }
}

struct ReportWallStreetConsensus {
    let rating: ConsensusRating
    let currentPrice: Double
    let targetPrice: Double
    let lowTarget: Double
    let highTarget: Double
    let valuationStatus: ValuationStatus
    let discountPercent: Double         // "Trading 33.4% below fair value estimate"
    let hedgeFundNote: String?          // "Net inflow of $430M from institutional..."
    let hedgeFundPriceData: [StockPriceDataPoint]   // Price data for hedge fund chart
    let hedgeFundFlowData: [SmartMoneyFlowDataPoint] // Buy/sell volume data
    let momentumUpgrades: Int
    let momentumDowngrades: Int

    var formattedCurrentPrice: String {
        String(format: "$%.0f", currentPrice)
    }

    var formattedTargetPrice: String {
        String(format: "$%.0f", targetPrice)
    }

    var formattedHighTarget: String {
        String(format: "$%.0f", highTarget)
    }

    var formattedLowTarget: String {
        String(format: "$%.0f", lowTarget)
    }

    var formattedHighTargetPercent: String {
        let percent = ((highTarget - currentPrice) / currentPrice) * 100
        return String(format: "%+.1f%%", percent)
    }

    var formattedAvgTargetPercent: String {
        let percent = ((targetPrice - currentPrice) / currentPrice) * 100
        return String(format: "%+.1f%%", percent)
    }

    var formattedLowTargetPercent: String {
        let percent = ((lowTarget - currentPrice) / currentPrice) * 100
        return String(format: "%+.1f%%", percent)
    }

    var formattedDiscount: String {
        "Trading \(String(format: "%.1f", discountPercent))% below fair value estimate"
    }
}

// MARK: - Critical Factor

struct CriticalFactor: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let severity: CriticalSeverity

    enum CriticalSeverity {
        case high, medium, low

        var color: Color {
            switch self {
            case .high: return AppColors.bearish
            case .medium: return AppColors.alertOrange
            case .low: return AppColors.neutral
            }
        }

        var iconName: String {
            switch self {
            case .high: return "exclamationmark.triangle.fill"
            case .medium: return "exclamationmark.circle.fill"
            case .low: return "info.circle.fill"
            }
        }
    }
}

// MARK: - Price Action

struct PriceEvent {
    let tag: String           // "Earnings Miss", "FDA Approval", "Guidance Cut"
    let date: String          // "Feb 2"
    let index: Int            // position in prices array where event occurred
}

struct PriceActionData {
    let prices: [Double]      // daily closing prices (oldest â†’ newest)
    let currentPrice: Double
    let event: PriceEvent?    // optional catalyst
    let narrative: String     // short explanation text
}

// MARK: - Price Movement (Legacy)

enum PriceTimeframe: String, CaseIterable, Identifiable {
    case oneDay = "1D"
    case oneWeek = "1W"
    case oneMonth = "1M"

    var id: String { rawValue }
}

struct PricePoint: Identifiable {
    let id = UUID()
    let index: Int          // x-axis position
    let price: Double
    let volume: Double?
}

struct PriceMovementStats {
    let currentPrice: Double
    let priceChange: Double
    let percentChange: Double
    let periodHigh: Double
    let periodLow: Double
    let avgVolume: String

    var formattedPrice: String { String(format: "$%.2f", currentPrice) }
    var formattedChange: String {
        let sign = priceChange >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", priceChange))"
    }
    var formattedPercent: String {
        let sign = percentChange >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", percentChange))%"
    }
    var isPositive: Bool { priceChange >= 0 }
    var trendColor: Color { isPositive ? AppColors.bullish : AppColors.bearish }
}

struct ReportPriceMovementData {
    let stats: [PriceTimeframe: PriceMovementStats]
    let points: [PriceTimeframe: [PricePoint]]
}

// MARK: - Moat & Competition

// MARK: - Market Dynamics

enum MarketConcentration: String {
    case monopoly = "Monopoly"
    case duopoly = "Duopoly"
    case oligopoly = "Oligopoly"
    case fragmented = "Fragmented"

    var color: Color {
        switch self {
        case .monopoly: return AppColors.bullish
        case .duopoly: return AppColors.neutral
        case .oligopoly: return AppColors.textSecondary
        case .fragmented: return AppColors.alertOrange
        }
    }

    var backgroundColor: Color {
        switch self {
        case .monopoly: return AppColors.bullish.opacity(0.15)
        case .duopoly: return AppColors.neutral.opacity(0.15)
        case .oligopoly: return AppColors.textSecondary.opacity(0.15)
        case .fragmented: return AppColors.alertOrange.opacity(0.15)
        }
    }
}

enum LifecyclePhase: String {
    case emerging = "Emerging"
    case secularGrowth = "Secular Growth"
    case mature = "Mature"
    case declining = "Declining"

    var color: Color {
        switch self {
        case .emerging: return AppColors.bullish
        case .secularGrowth: return AppColors.primaryBlue
        case .mature: return AppColors.neutral
        case .declining: return AppColors.bearish
        }
    }

    var backgroundColor: Color {
        switch self {
        case .emerging: return AppColors.bullish.opacity(0.15)
        case .secularGrowth: return AppColors.primaryBlue.opacity(0.15)
        case .mature: return AppColors.neutral.opacity(0.15)
        case .declining: return AppColors.bearish.opacity(0.15)
        }
    }
}

struct MarketDynamics {
    let industry: String                    // "Cloud Computing"
    let concentration: MarketConcentration  // .oligopoly
    let cagr5Yr: Double                     // 18.5 (percentage)
    let currentTAM: Double                  // 900 (in billions)
    let futureTAM: Double                   // 1600 (in billions)
    let currentYear: String                 // "2025"
    let futureYear: String                  // "2030"
    let lifecyclePhase: LifecyclePhase      // .secularGrowth

    var formattedCAGR: String {
        let sign = cagr5Yr >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", cagr5Yr))%"
    }

    var formattedCurrentTAM: String {
        if currentTAM >= 1000 {
            return String(format: "$%.1fT", currentTAM / 1000)
        } else {
            return String(format: "$%.0fB", currentTAM)
        }
    }

    var formattedFutureTAM: String {
        if futureTAM >= 1000 {
            return String(format: "$%.1fT", futureTAM / 1000)
        } else {
            return String(format: "$%.0fB", futureTAM)
        }
    }

    var formattedTAMRange: String {
        "\(formattedCurrentTAM) â†’ \(formattedFutureTAM)"
    }
}

enum MoatOverallRating: String {
    case wide = "Wide Moat"
    case narrow = "Narrow Moat"
    case none = "No Moat"

    var color: Color {
        switch self {
        case .wide: return AppColors.alertPurple      // Indigo-500 (Purple) - Elite defense
        case .narrow: return AppColors.accentYellow   // Yellow-500 - Strong but beatable
        case .none: return AppColors.textSecondary    // Gray-500 - No structural advantage
        }
    }

    var backgroundColor: Color {
        switch self {
        case .wide: return AppColors.alertPurple.opacity(0.15)
        case .narrow: return AppColors.accentYellow.opacity(0.15)
        case .none: return AppColors.textSecondary.opacity(0.15)
        }
    }

    var meaning: String {
        switch self {
        case .wide: return ""
        case .narrow: return "Strong defense, but beatable."
        case .none: return "No structural advantage."
        }
    }

    var iconName: String { "shield.lefthalf.filled" }

    // Calculate moat rating from dimensions using the Max-Score Rule
    static func from(dimensions: [MoatDimension]) -> MoatOverallRating {
        guard let maxScore = dimensions.map({ $0.score }).max() else {
            return .none
        }

        if maxScore >= 8.5 {
            return .wide    // Elite defense
        } else if maxScore >= 7.0 {
            return .narrow  // Strong but beatable
        } else {
            return .none    // No structural advantage
        }
    }
}

struct MoatDimension: Identifiable {
    let id = UUID()
    let name: String        // e.g. "Switching Costs"
    let score: Double       // 0.0 - 10.0
    let peerScore: Double   // competitor avg for comparison

    var normalizedScore: Double { score / 10.0 }
    var normalizedPeerScore: Double { peerScore / 10.0 }
}

enum CompetitorThreatLevel: String {
    case low = "Low"
    case moderate = "Moderate"
    case high = "High"

    var color: Color {
        switch self {
        case .low: return AppColors.bullish
        case .moderate: return AppColors.neutral
        case .high: return AppColors.bearish
        }
    }
}

struct CompetitorComparison: Identifiable {
    let id = UUID()
    let name: String
    let ticker: String
    let moatScore: Double       // 0-10
    let marketSharePercent: Double
    let threatLevel: CompetitorThreatLevel
}

struct ReportMoatCompetitionData {
    let marketDynamics: MarketDynamics
    let dimensions: [MoatDimension]
    let durabilityNote: String
    let competitors: [CompetitorComparison]
    let competitiveInsight: String

    // Computed: Overall rating based on Max-Score Rule
    var overallRating: MoatOverallRating {
        MoatOverallRating.from(dimensions: dimensions)
    }

    // Computed: Primary driver (highest scoring dimension)
    var primaryDriver: MoatDimension? {
        dimensions.max(by: { $0.score < $1.score })
    }

    // Computed: Primary driver name
    var primaryDriverName: String {
        primaryDriver?.name ?? "Unknown"
    }
}

// MARK: - Macro & Geopolitical

enum ThreatLevel: String, CaseIterable {
    case low = "LOW"
    case elevated = "ELEVATED"
    case high = "HIGH"
    case severe = "SEVERE"
    case critical = "CRITICAL"

    var color: Color {
        switch self {
        case .low: return AppColors.bullish
        case .elevated: return Color(hex: "84CC16")     // lime
        case .high: return AppColors.neutral
        case .severe: return AppColors.alertOrange
        case .critical: return AppColors.bearish
        }
    }

    var numericLevel: Int {
        switch self {
        case .low: return 1
        case .elevated: return 2
        case .high: return 3
        case .severe: return 4
        case .critical: return 5
        }
    }
}

enum MacroRiskCategory: String {
    case inflation = "Inflation"
    case interestRates = "Interest Rates"
    case geopolitical = "Geopolitical"
    case currency = "Currency"
    case regulation = "Regulation"
    case supplyChain = "Supply Chain"
    case tariffs = "Trade & Tariffs"
    case energy = "Energy"

    var iconName: String {
        switch self {
        case .inflation: return "chart.line.uptrend.xyaxis"
        case .interestRates: return "percent"
        case .geopolitical: return "globe.americas"
        case .currency: return "dollarsign.arrow.circlepath"
        case .regulation: return "building.columns"
        case .supplyChain: return "shippingbox"
        case .tariffs: return "arrow.left.arrow.right"
        case .energy: return "bolt.fill"
        }
    }
}

enum RiskTrend: String {
    case improving = "Improving"
    case stable = "Stable"
    case worsening = "Worsening"

    var iconName: String {
        switch self {
        case .improving: return "arrow.down.right"
        case .stable: return "arrow.right"
        case .worsening: return "arrow.up.right"
        }
    }

    var color: Color {
        switch self {
        case .improving: return AppColors.bullish
        case .stable: return AppColors.textSecondary
        case .worsening: return AppColors.bearish
        }
    }
}

struct MacroRiskFactor: Identifiable {
    let id = UUID()
    let category: MacroRiskCategory
    let title: String
    let impact: Double          // 0.0 - 1.0
    let description: String
    let trend: RiskTrend
    let severity: ThreatLevel
}

struct ReportMacroData {
    let overallThreatLevel: ThreatLevel
    let headline: String            // "Elevated macro risk from rate policy and trade tensions"
    let riskFactors: [MacroRiskFactor]
    let intelligenceBrief: String   // AI summary paragraph
    let lastUpdated: String         // "Updated Feb 8, 2026"
}

// MARK: - Deep Dive Module

struct DeepDiveModule: Identifiable {
    let id = UUID()
    let title: String
    let iconName: String
    let type: DeepDiveModuleType
}

enum DeepDiveModuleType {
    case recentPriceMovement
    case revenueEngine
    case fundamentalsGrowth
    case futureForecast
    case insiderManagement
    case moatCompetition
    case macroGeopolitical
    case wallStreetConsensus
}

// MARK: - Full Report Data

struct TickerReportData: Identifiable {
    let id = UUID()
    let symbol: String
    let companyName: String
    let exchange: String
    let logoName: String?
    let liveDate: String

    // Agent & Rating
    let agent: ReportAgentPersona
    let qualityRating: ReportQualityRating

    // Executive Summary
    let executiveSummaryText: String
    let executiveSummaryBullets: [ExecutiveSummaryBullet]

    // Key Vitals
    let keyVitals: ReportKeyVitals

    // Core Thesis
    let coreThesis: ReportCoreThesis

    // Deep Dive: Fundamentals
    let fundamentalMetrics: [DeepDiveMetricCard]
    let overallAssessment: ReportOverallAssessment

    // Deep Dive: Future Forecast
    let revenueForecast: ReportRevenueForecast

    // Deep Dive: Insider & Management
    let insiderData: ReportInsiderData
    let keyManagement: ReportKeyManagement

    // Deep Dive: Price Action
    let priceAction: PriceActionData

    // Deep Dive: Revenue Engine
    let revenueEngine: ReportRevenueEngineData

    // Deep Dive: Moat & Competition
    let moatCompetition: ReportMoatCompetitionData

    // Deep Dive: Macro & Geopolitical
    let macroData: ReportMacroData

    // Deep Dive: Wall Street
    let wallStreetConsensus: ReportWallStreetConsensus

    // Critical Factors
    let criticalFactors: [CriticalFactor]

    // Disclaimer
    let disclaimerText: String
}

// MARK: - Sample Data

extension TickerReportData {
    static let sampleOracle = TickerReportData(
        symbol: "ORCL",
        companyName: "Oracle",
        exchange: "Nasdaq",
        logoName: nil,
        liveDate: "Live Data as of Feb 8, 8:04 AM",
        agent: .buffett,
        qualityRating: ReportQualityRating(
            score: 82
        ),
        executiveSummaryText: "Oracle is successfully pivoting to cloud infrastructure (OCI) with a massive backlog, but cash burn increases a short-term risk.",
        executiveSummaryBullets: [
            ExecutiveSummaryBullet(
                category: "Catalyst",
                text: "$12.5B RPO guarantees future revenue",
                sentiment: .positive
            ),
            ExecutiveSummaryBullet(
                category: "Valuation",
                text: "Trading at 15% discount to Fair Value",
                sentiment: .positive
            ),
            ExecutiveSummaryBullet(
                category: "Risk",
                text: "Negative Free Cash Flow in Q2",
                sentiment: .negative
            )
        ],
        keyVitals: ReportKeyVitals(
            valuation: ReportValuationData(
                status: .underpriced,
                currentPrice: 142.82,
                fairValue: 190,
                upsidePotential: 33.0
            ),
            moat: ReportMoatData(
                overallRating: .wide,
                primarySource: "High Switching Costs",
                tags: [
                    MoatTag(label: "High Switching Costs", strength: .wide),
                    MoatTag(label: "Network Effects", strength: .narrow)
                ],
                valueLabel: "Value",
                stabilityLabel: "Stable"
            ),
            financialHealth: ReportFinancialHealthData(
                level: FinancialHealthLevel.fromZScore(1.7),  // Will be .critical (Red - Distress)
                altmanZScore: 1.7,
                altmanZLabel: "Distress Zone (Below 1.8)",
                additionalMetric: "Increasing Cost",
                additionalMetricStatus: FinancialHealthLevel.fromZScore(1.7),
                fcfNote: "Negative FCF in last 2 years"
            )
        ),
        coreThesis: ReportCoreThesis(
            bullCase: [
                CoreThesisBullet(text: "$12.5B safety net: Oracle's cloud infrastructure revenue provides a massive cushion against legacy decline"),
                CoreThesisBullet(text: "IaaS widening: Cloud infrastructure growing 66% YoY, capturing enterprise AI workloads"),
                CoreThesisBullet(text: "TikTok safety: Strategic partnership positions Oracle as critical infrastructure provider")
            ],
            bearCase: [
                CoreThesisBullet(text: "Cash flow deceleration: Negative $195 FCF as massive Capex spend outpaces revenue growth"),
                CoreThesisBullet(text: "Credit downgrade danger: Rising debt levels and negative FCF threaten investment-grade rating"),
                CoreThesisBullet(text: "Aggressive self-image: Aggressive cloud data center construction schedule escalating true infrastructure costs")
            ]
        ),
        fundamentalMetrics: [
            DeepDiveMetricCard(
                title: "Profitability",
                starRating: 5,
                metrics: [
                    DeepDiveMetric(label: "Gross Margin", value: "70%", trend: nil),
                    DeepDiveMetric(label: "Net Margin", value: "25%", trend: nil)
                ],
                qualityLabel: "A Cash Machine"
            ),
            DeepDiveMetricCard(
                title: "Valuation",
                starRating: 3,
                metrics: [
                    DeepDiveMetric(label: "P/E Ratio", value: "25x", trend: nil),
                    DeepDiveMetric(label: "P/B Ratio", value: "1.2", trend: nil)
                ],
                qualityLabel: "Priced for perfection"
            ),
            DeepDiveMetricCard(
                title: "Growth",
                starRating: 4,
                metrics: [
                    DeepDiveMetric(label: "Revenue ROII", value: "+18%", trend: .up),
                    DeepDiveMetric(label: "EPS Growth", value: "+22%", trend: .up)
                ],
                qualityLabel: "Accelerating"
            ),
            DeepDiveMetricCard(
                title: "Health",
                starRating: 2,
                metrics: [
                    DeepDiveMetric(label: "Current Ratio", value: "0.8", trend: .down),
                    DeepDiveMetric(label: "Debt/Equity", value: "4.5x", trend: .up)
                ],
                qualityLabel: "Heavy Debt Load"
            )
        ],
        overallAssessment: ReportOverallAssessment(
            text: "Strong profitability and growth, but investor health concerns exist due to high leverage. Monitor debt levels closely.",
            averageRating: 3.5,
            strongCount: 2,
            weakCount: 1
        ),
        revenueForecast: ReportRevenueForecast(
            cagr: 15,
            epsGrowth: 18,
            managementGuidance: .raised,
            projections: [
                RevenueProjection(period: "2026", revenue: 120, revenueLabel: "$120B", eps: 4.50, epsLabel: "$4.50", isForecast: false),
                RevenueProjection(period: "2027", revenue: 132, revenueLabel: "$132B", eps: 5.10, epsLabel: "$5.10", isForecast: true),
                RevenueProjection(period: "2028", revenue: 145, revenueLabel: "$145B", eps: 6.20, epsLabel: "$6.20", isForecast: true)
            ],
            guidanceQuote: "CFO expects accelerating cloud demand in Q3"
        ),
        insiderData: ReportInsiderData(
            sentiment: .negative,
            timeframe: "Last 90 Days",
            transactions: [
                InsiderTransaction(type: "Buys", count: 3, shares: "12", value: "$1,234"),
                InsiderTransaction(type: "Sells", count: 12, shares: "45", value: "$4.1M")
            ],
            ownershipNote: "The stock is heavily sold off by insiders."
        ),
        keyManagement: ReportKeyManagement(
            managers: [
                KeyManager(name: "Lawrence Ellison", title: "Co-Founder", ownership: "40.3%", ownershipValue: "$43.5b"),
                KeyManager(name: "Jeffrey Henley", title: "Co-Founder", ownership: "0.022%", ownershipValue: "$102.6m"),
                KeyManager(name: "Dania Caral", title: "Executive Vice Chair...", ownership: "0.0059%", ownershipValue: "$9.7m"),
                KeyManager(name: "Marla Smith", title: "Executive VP & Chief Accounting Officer", ownership: "0.002%", ownershipValue: "$7.1m"),
                KeyManager(name: "Dietrich Niebuhr", title: "Chief Executive Officer & Director", ownership: "0.0005%", ownershipValue: "$18.7m")
            ],
            ownershipInsight: "Oracle's high ownership ensures long-term thinking, though governance risk is high."
        ),
        priceAction: PriceActionData(
            prices: [
                163.20, 162.80, 164.10, 163.50, 162.90,
                161.40, 160.80, 159.20, 155.30, 150.10,
                148.60, 145.20, 143.80, 141.50, 140.20,
                142.10, 141.30, 143.50, 142.00, 142.82
            ],
            currentPrice: 142.82,
            event: PriceEvent(tag: "Earnings Miss", date: "Feb 2", index: 7),
            narrative: "Oracle dropped 12% after reporting Q3 earnings below consensus estimates. Revenue of $13.8B missed the $14.1B forecast, driven by slower-than-expected cloud migration deals. The sell-off intensified on guidance cut for Q4."
        ),
        revenueEngine: ReportRevenueEngineData.sampleOracle,
        moatCompetition: ReportMoatCompetitionData(
            marketDynamics: MarketDynamics(
                industry: "Cloud Computing",
                concentration: .oligopoly,
                cagr5Yr: 18.5,
                currentTAM: 900,
                futureTAM: 1600,
                currentYear: "2025",
                futureYear: "2030",
                lifecyclePhase: .secularGrowth
            ),
            dimensions: [
                MoatDimension(name: "Switching Costs", score: 9.2, peerScore: 6.5),
                MoatDimension(name: "Network Effects", score: 5.8, peerScore: 7.0),
                MoatDimension(name: "Brand Power", score: 7.5, peerScore: 8.2),
                MoatDimension(name: "Cost Advantage", score: 6.0, peerScore: 5.5),
                MoatDimension(name: "Intangible Assets", score: 8.4, peerScore: 7.0)
            ],
            durabilityNote: "Oracle's moat is anchored by extremely high switching costs in enterprise database and ERP. Customers face multi-year migration timelines and significant retraining costs, creating durable lock-in.",
            competitors: [
                CompetitorComparison(name: "Amazon Web Services", ticker: "AMZN", moatScore: 9.0, marketSharePercent: 31.0, threatLevel: .high),
                CompetitorComparison(name: "Microsoft Azure", ticker: "MSFT", moatScore: 8.5, marketSharePercent: 25.0, threatLevel: .high),
                CompetitorComparison(name: "Google Cloud", ticker: "GOOGL", moatScore: 7.2, marketSharePercent: 11.0, threatLevel: .moderate),
                CompetitorComparison(name: "SAP", ticker: "SAP", moatScore: 7.0, marketSharePercent: 5.0, threatLevel: .low)
            ],
            competitiveInsight: "Oracle holds dominant position in enterprise databases but faces intense hyperscaler competition in cloud infrastructure. Switching cost moat remains the primary defensive asset."
        ),
        macroData: ReportMacroData(
            overallThreatLevel: .elevated,
            headline: "Elevated macro risk from rate policy and US-China trade tensions",
            riskFactors: [
                MacroRiskFactor(
                    category: .interestRates,
                    title: "Fed Rate Uncertainty",
                    impact: 0.72,
                    description: "Higher-for-longer rates pressure growth stock valuations and increase Oracle's debt servicing costs on $86B long-term debt.",
                    trend: .stable,
                    severity: .high
                ),
                MacroRiskFactor(
                    category: .tariffs,
                    title: "US-China Tech Restrictions",
                    impact: 0.65,
                    description: "Export controls on advanced chips may constrain Oracle's AI infrastructure buildout timeline and increase hardware costs.",
                    trend: .worsening,
                    severity: .severe
                ),
                MacroRiskFactor(
                    category: .currency,
                    title: "USD Strength",
                    impact: 0.40,
                    description: "Strong dollar headwind on international revenue (37% of total). Each 1% USD rise impacts revenue by ~$180M annually.",
                    trend: .stable,
                    severity: .elevated
                ),
                MacroRiskFactor(
                    category: .regulation,
                    title: "AI Regulation Wave",
                    impact: 0.55,
                    description: "EU AI Act and potential US frameworks could increase compliance costs for Oracle's AI cloud services.",
                    trend: .worsening,
                    severity: .high
                ),
                MacroRiskFactor(
                    category: .inflation,
                    title: "Data Center Cost Inflation",
                    impact: 0.58,
                    description: "Rising construction and energy costs inflating Capex per data center by an estimated 12-18% YoY.",
                    trend: .improving,
                    severity: .elevated
                ),
                MacroRiskFactor(
                    category: .energy,
                    title: "Power Grid Constraints",
                    impact: 0.45,
                    description: "Growing energy demand for AI data centers straining regional power grids, potentially delaying new facility deployments.",
                    trend: .worsening,
                    severity: .elevated
                )
            ],
            intelligenceBrief: "Oracle's macro exposure is concentrated in two vectors: debt sensitivity to rate policy (largest corporate bond issuer in tech) and supply chain vulnerability to US-China decoupling. The company's aggressive $80B+ Capex plan amplifies both risks. Mitigating factor: 72% of revenue is recurring subscription, providing cash flow resilience. Monitor the March Fed meeting and any escalation in semiconductor export controls.",
            lastUpdated: "Updated Feb 8, 2026"
        ),
        wallStreetConsensus: ReportWallStreetConsensus(
            rating: .strongBuy,
            currentPrice: 142,
            targetPrice: 190,
            lowTarget: 140,
            highTarget: 250,
            valuationStatus: .deepUndervalued,
            discountPercent: 33.4,
            hedgeFundNote: "Net inflow of $430M from institutional investors last quarter.",
            hedgeFundPriceData: [
                StockPriceDataPoint(month: "02/2025", price: 163.20),
                StockPriceDataPoint(month: "03/2025", price: 162.80),
                StockPriceDataPoint(month: "04/2025", price: 161.40),
                StockPriceDataPoint(month: "05/2025", price: 160.80),
                StockPriceDataPoint(month: "06/2025", price: 159.20),
                StockPriceDataPoint(month: "07/2025", price: 155.30),
                StockPriceDataPoint(month: "08/2025", price: 150.10),
                StockPriceDataPoint(month: "09/2025", price: 148.60),
                StockPriceDataPoint(month: "10/2025", price: 145.20),
                StockPriceDataPoint(month: "11/2025", price: 143.80),
                StockPriceDataPoint(month: "12/2025", price: 141.50),
                StockPriceDataPoint(month: "01/2026", price: 142.82)
            ],
            hedgeFundFlowData: [
                SmartMoneyFlowDataPoint(month: "02/2025", buyVolume: 42.1, sellVolume: 35.2),
                SmartMoneyFlowDataPoint(month: "03/2025", buyVolume: 38.5, sellVolume: 42.1),
                SmartMoneyFlowDataPoint(month: "04/2025", buyVolume: 35.2, sellVolume: 48.3),
                SmartMoneyFlowDataPoint(month: "05/2025", buyVolume: 48.9, sellVolume: 32.5),
                SmartMoneyFlowDataPoint(month: "06/2025", buyVolume: 45.2, sellVolume: 38.5),
                SmartMoneyFlowDataPoint(month: "07/2025", buyVolume: 39.8, sellVolume: 45.2),
                SmartMoneyFlowDataPoint(month: "08/2025", buyVolume: 52.1, sellVolume: 41.3),
                SmartMoneyFlowDataPoint(month: "09/2025", buyVolume: 44.5, sellVolume: 38.9),
                SmartMoneyFlowDataPoint(month: "10/2025", buyVolume: 38.9, sellVolume: 55.2),
                SmartMoneyFlowDataPoint(month: "11/2025", buyVolume: 51.2, sellVolume: 36.8),
                SmartMoneyFlowDataPoint(month: "12/2025", buyVolume: 48.5, sellVolume: 33.2),
                SmartMoneyFlowDataPoint(month: "01/2026", buyVolume: 55.8, sellVolume: 31.2)
            ],
            momentumUpgrades: 8,
            momentumDowngrades: 3
        ),
        criticalFactors: [
            CriticalFactor(
                title: "Credit Agency Downgrade",
                description: "Monitor S&P and Moody's ratings for debt-laden companies.",
                severity: .high
            ),
            CriticalFactor(
                title: "Accounting Depreciation Changes",
                description: "Watch for shifts in infrastructure depreciation schedules.",
                severity: .medium
            ),
            CriticalFactor(
                title: "Capex vs Revenue Trajectory",
                description: "Track if cloud revenue growth catches up to infrastructure spend.",
                severity: .medium
            )
        ],
        disclaimerText: "This analysis is for educational purposes only and does not constitute financial advice. AI-generated content may be inaccurate. Always conduct your own research and consult with a qualified financial advisor before making investment decisions."
    )
}

================================================================================
FILE: frontend/ios/ios/Models/TrackingModels.swift
================================================================================

//
//  TrackingModels.swift
//  ios
//
//  Data models for the Tracking screen
//

import Foundation
import SwiftUI

// MARK: - Notifications
extension Notification.Name {
    static let whaleFollowStateChanged = Notification.Name("whaleFollowStateChanged")
}

// MARK: - Tracking Tab
enum TrackingTab: String, CaseIterable {
    case assets = "Assets"
    case whales = "Whales"
}

// MARK: - Asset Sort Option
enum AssetSortOption: String, CaseIterable {
    case name = "Name"
    case price = "Price"
    case change = "Change"
    case marketCap = "Market Cap"

    var displayName: String { rawValue }
}

// MARK: - Tracked Asset
struct TrackedAsset: Identifiable {
    let id = UUID()
    let ticker: String
    let companyName: String
    let price: Double
    let changePercent: Double
    let sparklineData: [Double]

    var isPositive: Bool {
        changePercent >= 0
    }

    var formattedPrice: String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencySymbol = "$"
        formatter.minimumFractionDigits = 2
        formatter.maximumFractionDigits = 2
        return formatter.string(from: NSNumber(value: price)) ?? String(format: "$%.2f", price)
    }

    var formattedChange: String {
        let sign = changePercent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", changePercent))%"
    }
}

// MARK: - Alert Event Type
enum AlertEventType: String, CaseIterable {
    case earnings = "earnings"
    case market = "market"
    case smartMoney = "smart_money"

    var iconBackgroundColor: Color {
        switch self {
        case .earnings: return AppColors.primaryBlue
        case .market: return AppColors.primaryBlue
        case .smartMoney: return AppColors.alertOrange
        }
    }

    var systemIconName: String {
        switch self {
        case .earnings: return "bell.fill"
        case .market: return "bell.fill"
        case .smartMoney: return "lightbulb.fill"
        }
    }
}

// MARK: - Alert Event
struct AlertEvent: Identifiable {
    let id = UUID()
    let type: AlertEventType
    let title: String
    let description: String
    let date: Date?
    let day: Int?
    let month: String?

    var hasDate: Bool {
        day != nil && month != nil
    }

    var formattedDay: String {
        guard let day = day else { return "" }
        return String(day)
    }

    var formattedMonth: String {
        month?.uppercased() ?? ""
    }
}

// MARK: - Smart Money Alert
struct SmartMoneyAlert: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let fundCount: Int
    let ticker: String
    let positionSize: String
}

// MARK: - Sector Allocation
struct SectorAllocation: Identifiable {
    let id = UUID()
    let name: String
    let percentage: Double

    var formattedPercentage: String {
        "\(Int(percentage))%"
    }
}

// MARK: - Diversification Score
struct DiversificationScore: Identifiable {
    let id = UUID()
    let score: Int
    let message: String
    let sectorCount: Int
    let allocations: [SectorAllocation]

    var formattedScore: String {
        "\(score)%"
    }

    var progressValue: Double {
        Double(score) / 100.0
    }
}

// MARK: - Whale Category
enum WhaleCategory: String, CaseIterable {
    case investors = "Investors"
    case institutions = "Institutions"
    case politicians = "Politicians"
    case cryptoWhales = "Crypto"
}

// MARK: - Whale Action
enum WhaleAction: String {
    case bought = "BOUGHT"
    case sold = "SOLD"

    var color: Color {
        switch self {
        case .bought: return AppColors.bullish
        case .sold: return AppColors.bearish
        }
    }
}

// MARK: - Whale Activity
struct WhaleActivity: Identifiable {
    let id = UUID()
    let entityName: String
    let entityAvatarName: String
    let action: WhaleAction
    let ticker: String
    let amount: String
    let source: String
    let date: Date

    var timeAgo: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}

// MARK: - Trending Whale
struct TrendingWhale: Identifiable {
    let id = UUID()
    let name: String
    let category: WhaleCategory
    let avatarName: String
    let followersCount: Int
    let isFollowing: Bool
    let title: String
    let description: String
    let recentTradeCount: Int

    init(name: String, category: WhaleCategory, avatarName: String, followersCount: Int, isFollowing: Bool, title: String = "", description: String = "", recentTradeCount: Int = 0) {
        self.name = name
        self.category = category
        self.avatarName = avatarName
        self.followersCount = followersCount
        self.isFollowing = isFollowing
        self.title = title
        self.description = description
        self.recentTradeCount = recentTradeCount
    }

    var formattedFollowers: String {
        if followersCount >= 1000 {
            return "\(followersCount / 1000)K followers"
        }
        return "\(followersCount) followers"
    }

    var formattedTradeCount: String {
        if recentTradeCount == 1 {
            return "1 trade"
        }
        return "\(recentTradeCount) trades"
    }
}

// MARK: - Whale Trade Group Activity (for Recent Trades timeline)
struct WhaleTradeGroupActivity: Identifiable {
    let id = UUID()
    let entityName: String
    let entityAvatarName: String
    let action: WhaleAction
    let tradeCount: Int
    let totalAmount: String
    let summary: String?
    let date: Date

    var formattedDate: String {
        let calendar = Calendar.current
        let now = Date()

        if calendar.isDateInToday(date) {
            return "Today"
        } else if calendar.isDateInYesterday(date) {
            return "Yesterday"
        }

        let components = calendar.dateComponents([.day], from: date, to: now)
        if let days = components.day, days <= 7 {
            return "\(days) days ago"
        }

        let formatter = DateFormatter()
        formatter.dateFormat = "MMM dd, yyyy"
        return formatter.string(from: date)
    }

    var formattedAmount: String {
        switch action {
        case .bought:
            return "+\(totalAmount)"
        case .sold:
            return "- \(totalAmount)"
        }
    }

    var formattedTradeCount: String {
        if tradeCount == 1 {
            return "1 trade"
        }
        return "\(tradeCount) trades"
    }
}

// MARK: - Grouped Whale Trades (for timeline sections)
struct GroupedWhaleTrades: Identifiable {
    let id = UUID()
    let sectionTitle: String
    let activities: [WhaleTradeGroupActivity]
}

// MARK: - Whale Alert Banner
struct WhaleAlertBanner: Identifiable {
    let id = UUID()
    let title: String
    let description: String
    let ticker: String?
    let actionTitle: String
}

// MARK: - Sample Data
extension TrackedAsset {
    static let sampleData: [TrackedAsset] = [
        TrackedAsset(
            ticker: "AAPL",
            companyName: "Apple Inc.",
            price: 178.42,
            changePercent: 2.34,
            sparklineData: [165, 168, 170, 172, 175, 173, 176, 178]
        ),
        TrackedAsset(
            ticker: "NVDA",
            companyName: "NVIDIA Corp.",
            price: 495.22,
            changePercent: 5.67,
            sparklineData: [450, 460, 470, 465, 480, 490, 495]
        ),
        TrackedAsset(
            ticker: "MSFT",
            companyName: "Microsoft Corp.",
            price: 378.91,
            changePercent: -1.23,
            sparklineData: [390, 388, 385, 382, 380, 378, 379]
        ),
        TrackedAsset(
            ticker: "GOOGL",
            companyName: "Alphabet Inc.",
            price: 139.67,
            changePercent: 1.89,
            sparklineData: [135, 136, 137, 138, 137, 139, 140]
        )
    ]
}

extension AlertEvent {
    static let sampleData: [AlertEvent] = [
        AlertEvent(
            type: .earnings,
            title: "Earnings Alert",
            description: "NVDA reports earnings tomorrow after market close. Analyst consensus: Beat expected",
            date: Calendar.current.date(byAdding: .day, value: 1, to: Date()),
            day: 22,
            month: "FEB"
        ),
        AlertEvent(
            type: .market,
            title: "Market",
            description: "Fed interest rate decision. FOMC meeting announcement",
            date: Calendar.current.date(byAdding: .day, value: 3, to: Date()),
            day: 24,
            month: "FEB"
        )
    ]
}

extension SmartMoneyAlert {
    static let sampleData: SmartMoneyAlert = SmartMoneyAlert(
        title: "Smart Money Following",
        description: "3 hedge funds you follow bought GOOGL this week. Avg. position size: $1.2B",
        fundCount: 3,
        ticker: "GOOGL",
        positionSize: "$1.2B"
    )
}

extension DiversificationScore {
    static let sampleData: DiversificationScore = DiversificationScore(
        score: 78,
        message: "Your portfolio is well-diversified across 5 sectors",
        sectorCount: 5,
        allocations: [
            SectorAllocation(name: "Tech", percentage: 45),
            SectorAllocation(name: "Consumer", percentage: 22),
            SectorAllocation(name: "Finance", percentage: 18),
            SectorAllocation(name: "Energy", percentage: 15)
        ]
    )
}

extension WhaleActivity {
    static let sampleData: [WhaleActivity] = [
        WhaleActivity(
            entityName: "Warren Buffett",
            entityAvatarName: "avatar_buffett",
            action: .bought,
            ticker: "AAPL",
            amount: "$2.4B",
            source: "13F Filing",
            date: Calendar.current.date(byAdding: .day, value: -1, to: Date())!
        ),
        WhaleActivity(
            entityName: "Nancy Pelosi",
            entityAvatarName: "avatar_pelosi",
            action: .sold,
            ticker: "NVDA",
            amount: "$1.5M",
            source: "Congressional Disclosure",
            date: Calendar.current.date(byAdding: .day, value: -2, to: Date())!
        )
    ]
}

extension TrendingWhale {
    // Whales the user is following (shown in FollowedWhalesRow)
    static let trackedWhalesData: [TrendingWhale] = [
        TrendingWhale(
            name: "Warren Buffett",
            category: .investors,
            avatarName: "avatar_buffett",
            followersCount: 125000,
            isFollowing: true,
            recentTradeCount: 3
        ),
        TrendingWhale(
            name: "Nancy Pelosi",
            category: .politicians,
            avatarName: "avatar_pelosi",
            followersCount: 156000,
            isFollowing: true,
            recentTradeCount: 8
        ),
        TrendingWhale(
            name: "Bill Ackman",
            category: .institutions,
            avatarName: "avatar_ackman",
            followersCount: 76000,
            isFollowing: true,
            recentTradeCount: 4
        ),
        TrendingWhale(
            name: "Michael Saylor",
            category: .cryptoWhales,
            avatarName: "avatar_saylor",
            followersCount: 134000,
            isFollowing: true,
            recentTradeCount: 2
        ),
        TrendingWhale(
            name: "Michael Burry",
            category: .investors,
            avatarName: "avatar_burry",
            followersCount: 98000,
            isFollowing: true,
            recentTradeCount: 1
        )
    ]

    // Top 5 popular whales for main screen (mixed categories)
    static let topPopularWhalesData: [TrendingWhale] = [
        TrendingWhale(
            name: "Ray Dalio",
            category: .institutions,
            avatarName: "avatar_dalio",
            followersCount: 112000,
            isFollowing: false,
            title: "Bridgewater Associates"
        ),
        TrendingWhale(
            name: "George Soros",
            category: .investors,
            avatarName: "avatar_soros",
            followersCount: 95000,
            isFollowing: false,
            title: "Soros Fund Management"
        ),
        TrendingWhale(
            name: "Cathie Wood",
            category: .institutions,
            avatarName: "avatar_wood",
            followersCount: 89000,
            isFollowing: false,
            title: "ARK Invest CEO"
        ),
        TrendingWhale(
            name: "Vitalik Buterin",
            category: .cryptoWhales,
            avatarName: "avatar_vitalik",
            followersCount: 201000,
            isFollowing: false,
            title: "Ethereum Co-founder"
        ),
        TrendingWhale(
            name: "Tommy Tuberville",
            category: .politicians,
            avatarName: "avatar_tuberville",
            followersCount: 67000,
            isFollowing: false,
            title: "U.S. Senator"
        )
    ]

    // Hero whales for the carousel
    static let heroWhalesData: [TrendingWhale] = [
        TrendingWhale(
            name: "Warren Buffett",
            category: .investors,
            avatarName: "avatar_buffett",
            followersCount: 125000,
            isFollowing: false,
            title: "Berkshire Hathaway CEO",
            description: "The Oracle of Omaha. Value investing legend with 50+ years of market-beating returns."
        ),
        TrendingWhale(
            name: "Cathie Wood",
            category: .institutions,
            avatarName: "avatar_wood",
            followersCount: 89000,
            isFollowing: false,
            title: "ARK Invest CEO",
            description: "Disruptive innovation champion. Leading the charge in AI, genomics, and blockchain investing."
        ),
        TrendingWhale(
            name: "Ray Dalio",
            category: .institutions,
            avatarName: "avatar_dalio",
            followersCount: 112000,
            isFollowing: false,
            title: "Bridgewater Associates Founder",
            description: "Macro investing pioneer. Built the world's largest hedge fund with radical transparency."
        ),
        TrendingWhale(
            name: "Michael Burry",
            category: .investors,
            avatarName: "avatar_burry",
            followersCount: 98000,
            isFollowing: false,
            title: "Scion Asset Management",
            description: "The Big Short. Legendary contrarian known for calling the 2008 housing crisis."
        )
    ]

    // MARK: - All Whales by Category (for AllWhalesView)

    // 10 Investors
    static let allInvestorsData: [TrendingWhale] = [
        TrendingWhale(name: "Warren Buffett", category: .investors, avatarName: "avatar_buffett", followersCount: 125000, isFollowing: false, title: "Berkshire Hathaway CEO"),
        TrendingWhale(name: "Michael Burry", category: .investors, avatarName: "avatar_burry", followersCount: 98000, isFollowing: false, title: "Scion Asset Management"),
        TrendingWhale(name: "George Soros", category: .investors, avatarName: "avatar_soros", followersCount: 95000, isFollowing: false, title: "Soros Fund Management"),
        TrendingWhale(name: "Carl Icahn", category: .investors, avatarName: "avatar_icahn", followersCount: 87000, isFollowing: false, title: "Icahn Enterprises"),
        TrendingWhale(name: "Stanley Druckenmiller", category: .investors, avatarName: "avatar_druckenmiller", followersCount: 83000, isFollowing: false, title: "Duquesne Family Office"),
        TrendingWhale(name: "Peter Lynch", category: .investors, avatarName: "avatar_lynch", followersCount: 72000, isFollowing: false, title: "Fidelity Investments"),
        TrendingWhale(name: "Howard Marks", category: .investors, avatarName: "avatar_marks", followersCount: 68000, isFollowing: false, title: "Oaktree Capital Co-Chairman"),
        TrendingWhale(name: "Seth Klarman", category: .investors, avatarName: "avatar_klarman", followersCount: 54000, isFollowing: false, title: "Baupost Group"),
        TrendingWhale(name: "Joel Greenblatt", category: .investors, avatarName: "avatar_greenblatt", followersCount: 41000, isFollowing: false, title: "Gotham Capital"),
        TrendingWhale(name: "Mohnish Pabrai", category: .investors, avatarName: "avatar_pabrai", followersCount: 38000, isFollowing: false, title: "Pabrai Investment Funds")
    ]

    // 10 Institutions
    static let allInstitutionsData: [TrendingWhale] = [
        TrendingWhale(name: "Ray Dalio", category: .institutions, avatarName: "avatar_dalio", followersCount: 112000, isFollowing: false, title: "Bridgewater Associates"),
        TrendingWhale(name: "Ken Griffin", category: .institutions, avatarName: "avatar_griffin", followersCount: 92000, isFollowing: false, title: "Citadel CEO"),
        TrendingWhale(name: "Cathie Wood", category: .institutions, avatarName: "avatar_wood", followersCount: 89000, isFollowing: false, title: "ARK Invest CEO"),
        TrendingWhale(name: "Bill Ackman", category: .institutions, avatarName: "avatar_ackman", followersCount: 76000, isFollowing: false, title: "Pershing Square Capital"),
        TrendingWhale(name: "Jim Simons", category: .institutions, avatarName: "avatar_simons", followersCount: 78000, isFollowing: false, title: "Renaissance Technologies"),
        TrendingWhale(name: "Steve Cohen", category: .institutions, avatarName: "avatar_cohen", followersCount: 67000, isFollowing: false, title: "Point72 Chairman"),
        TrendingWhale(name: "David Tepper", category: .institutions, avatarName: "avatar_tepper", followersCount: 58000, isFollowing: false, title: "Appaloosa Management"),
        TrendingWhale(name: "Chase Coleman", category: .institutions, avatarName: "avatar_coleman", followersCount: 51000, isFollowing: false, title: "Tiger Global Management"),
        TrendingWhale(name: "Dan Loeb", category: .institutions, avatarName: "avatar_loeb", followersCount: 45000, isFollowing: false, title: "Third Point CEO"),
        TrendingWhale(name: "Philippe Laffont", category: .institutions, avatarName: "avatar_laffont", followersCount: 39000, isFollowing: false, title: "Coatue Management")
    ]

    // 10 Politicians
    static let allPoliticiansData: [TrendingWhale] = [
        TrendingWhale(name: "Nancy Pelosi", category: .politicians, avatarName: "avatar_pelosi", followersCount: 156000, isFollowing: false, title: "U.S. Representative (CA)"),
        TrendingWhale(name: "Tommy Tuberville", category: .politicians, avatarName: "avatar_tuberville", followersCount: 67000, isFollowing: false, title: "U.S. Senator (AL)"),
        TrendingWhale(name: "Dan Crenshaw", category: .politicians, avatarName: "avatar_crenshaw", followersCount: 53000, isFollowing: false, title: "U.S. Representative (TX)"),
        TrendingWhale(name: "Ro Khanna", category: .politicians, avatarName: "avatar_khanna", followersCount: 35000, isFollowing: false, title: "U.S. Representative (CA)"),
        TrendingWhale(name: "Josh Gottheimer", category: .politicians, avatarName: "avatar_gottheimer", followersCount: 31000, isFollowing: false, title: "U.S. Representative (NJ)"),
        TrendingWhale(name: "Mark Green", category: .politicians, avatarName: "avatar_green", followersCount: 28000, isFollowing: false, title: "U.S. Representative (TN)"),
        TrendingWhale(name: "Michael McCaul", category: .politicians, avatarName: "avatar_mccaul", followersCount: 24000, isFollowing: false, title: "U.S. Representative (TX)"),
        TrendingWhale(name: "John Curtis", category: .politicians, avatarName: "avatar_curtis", followersCount: 22000, isFollowing: false, title: "U.S. Senator (UT)"),
        TrendingWhale(name: "Pat Fallon", category: .politicians, avatarName: "avatar_fallon", followersCount: 19000, isFollowing: false, title: "U.S. Representative (TX)"),
        TrendingWhale(name: "Dan Sullivan", category: .politicians, avatarName: "avatar_sullivan", followersCount: 18000, isFollowing: false, title: "U.S. Senator (AK)")
    ]

    // 5 Crypto Whales
    static let allCryptoWhalesData: [TrendingWhale] = [
        TrendingWhale(name: "Vitalik Buterin", category: .cryptoWhales, avatarName: "avatar_vitalik", followersCount: 201000, isFollowing: false, title: "Ethereum Co-founder"),
        TrendingWhale(name: "Changpeng Zhao", category: .cryptoWhales, avatarName: "avatar_cz", followersCount: 175000, isFollowing: false, title: "Binance Founder"),
        TrendingWhale(name: "Michael Saylor", category: .cryptoWhales, avatarName: "avatar_saylor", followersCount: 134000, isFollowing: false, title: "MicroStrategy Chairman"),
        TrendingWhale(name: "Brian Armstrong", category: .cryptoWhales, avatarName: "avatar_armstrong", followersCount: 88000, isFollowing: false, title: "Coinbase CEO"),
        TrendingWhale(name: "Chris Larsen", category: .cryptoWhales, avatarName: "avatar_larsen", followersCount: 48000, isFollowing: false, title: "Ripple Co-founder")
    ]

    // All popular whales combined
    static let allPopularWhalesData: [TrendingWhale] = allInvestorsData + allInstitutionsData + allPoliticiansData + allCryptoWhalesData

    // Combined for backward compatibility
    static let sampleData: [TrendingWhale] = trackedWhalesData + topPopularWhalesData
}

extension WhaleTradeGroupActivity {
    static let sampleData: [WhaleTradeGroupActivity] = [
        WhaleTradeGroupActivity(
            entityName: "Warren Buffett",
            entityAvatarName: "avatar_buffett",
            action: .bought,
            tradeCount: 6,
            totalAmount: "$4.34B",
            summary: "Significant rebalancing, trimmed 3 Tech positions",
            date: Calendar.current.date(byAdding: .day, value: -7, to: Date())!
        ),
        WhaleTradeGroupActivity(
            entityName: "Bill Ackman",
            entityAvatarName: "avatar_ackman",
            action: .bought,
            tradeCount: 4,
            totalAmount: "$2.82B",
            summary: nil,
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 26))!
        ),
        WhaleTradeGroupActivity(
            entityName: "Nancy Pelosi",
            entityAvatarName: "avatar_pelosi",
            action: .bought,
            tradeCount: 8,
            totalAmount: "$6.53B",
            summary: "Huge bought, add 4 new positions in Tech sector",
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 2))!
        ),
        WhaleTradeGroupActivity(
            entityName: "Warren Buffett",
            entityAvatarName: "avatar_buffett",
            action: .sold,
            tradeCount: 12,
            totalAmount: "$4.5B",
            summary: "Significant sold with 3 closed positions in Banking sector",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 14))!
        )
    ]

    static var groupedSampleData: [GroupedWhaleTrades] {
        sampleData.map { activity in
            GroupedWhaleTrades(
                sectionTitle: activity.formattedDate,
                activities: [activity]
            )
        }
    }

    // Extended sample data for "All Recent Trades" view
    static let allSampleData: [WhaleTradeGroupActivity] = [
        WhaleTradeGroupActivity(
            entityName: "Warren Buffett",
            entityAvatarName: "avatar_buffett",
            action: .bought,
            tradeCount: 6,
            totalAmount: "$4.34B",
            summary: "Significant rebalancing, trimmed 3 Tech positions",
            date: Calendar.current.date(byAdding: .day, value: -7, to: Date())!
        ),
        WhaleTradeGroupActivity(
            entityName: "Bill Ackman",
            entityAvatarName: "avatar_ackman",
            action: .bought,
            tradeCount: 4,
            totalAmount: "$2.82B",
            summary: nil,
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 26))!
        ),
        WhaleTradeGroupActivity(
            entityName: "Nancy Pelosi",
            entityAvatarName: "avatar_pelosi",
            action: .bought,
            tradeCount: 8,
            totalAmount: "$6.53B",
            summary: "Huge bought, add 4 new positions in Tech sector",
            date: Calendar.current.date(from: DateComponents(year: 2026, month: 1, day: 2))!
        ),
        WhaleTradeGroupActivity(
            entityName: "Warren Buffett",
            entityAvatarName: "avatar_buffett",
            action: .sold,
            tradeCount: 12,
            totalAmount: "$4.5B",
            summary: "Significant sold with 3 closed positions in Banking sector",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 14))!
        ),
        WhaleTradeGroupActivity(
            entityName: "Cathie Wood",
            entityAvatarName: "avatar_wood",
            action: .bought,
            tradeCount: 5,
            totalAmount: "$1.92B",
            summary: "New positions in AI and robotics sectors",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 10))!
        ),
        WhaleTradeGroupActivity(
            entityName: "Ray Dalio",
            entityAvatarName: "avatar_dalio",
            action: .sold,
            tradeCount: 7,
            totalAmount: "$3.21B",
            summary: "Reduced exposure to emerging markets",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 8))!
        ),
        WhaleTradeGroupActivity(
            entityName: "Carl Icahn",
            entityAvatarName: "avatar_icahn",
            action: .bought,
            tradeCount: 3,
            totalAmount: "$5.67B",
            summary: "Large stake in energy sector",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 5))!
        ),
        WhaleTradeGroupActivity(
            entityName: "Michael Burry",
            entityAvatarName: "avatar_burry",
            action: .sold,
            tradeCount: 9,
            totalAmount: "$2.45B",
            summary: "Closed multiple tech positions",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 3))!
        ),
        WhaleTradeGroupActivity(
            entityName: "Stanley Druckenmiller",
            entityAvatarName: "avatar_druckenmiller",
            action: .bought,
            tradeCount: 6,
            totalAmount: "$4.11B",
            summary: "Increased healthcare holdings",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 12, day: 1))!
        ),
        WhaleTradeGroupActivity(
            entityName: "George Soros",
            entityAvatarName: "avatar_soros",
            action: .bought,
            tradeCount: 4,
            totalAmount: "$3.87B",
            summary: "Strategic moves in financial sector",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 11, day: 28))!
        ),
        WhaleTradeGroupActivity(
            entityName: "David Tepper",
            entityAvatarName: "avatar_tepper",
            action: .sold,
            tradeCount: 8,
            totalAmount: "$2.93B",
            summary: "Portfolio rebalancing across sectors",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 11, day: 25))!
        ),
        WhaleTradeGroupActivity(
            entityName: "Ken Griffin",
            entityAvatarName: "avatar_griffin",
            action: .bought,
            tradeCount: 11,
            totalAmount: "$6.78B",
            summary: "Major investment in growth stocks",
            date: Calendar.current.date(from: DateComponents(year: 2025, month: 11, day: 22))!
        )
    ]

    static var allGroupedSampleData: [GroupedWhaleTrades] {
        allSampleData.map { activity in
            GroupedWhaleTrades(
                sectionTitle: activity.formattedDate,
                activities: [activity]
            )
        }
    }
}

extension WhaleAlertBanner {
    static let sampleData = WhaleAlertBanner(
        title: "Whale Alert",
        description: "Large crypto whale just moved $50M into COIN stock",
        ticker: "COIN",
        actionTitle: "View Full Alert"
    )
}

================================================================================
FILE: frontend/ios/ios/Models/UpdatesModels.swift
================================================================================

//
//  UpdatesModels.swift
//  ios
//
//  Data models for the Updates/News screen
//

import Foundation

// MARK: - News Sentiment
enum NewsSentiment: String, CaseIterable {
    case positive = "Positive"
    case negative = "Negative"
    case neutral = "Neutral"

    var displayName: String {
        rawValue
    }
}

// MARK: - News Filter Tab
struct NewsFilterTab: Identifiable, Equatable {
    let id = UUID()
    let title: String
    let ticker: String?
    let changePercent: Double?
    let isMarketTab: Bool

    var isPositive: Bool {
        (changePercent ?? 0) >= 0
    }

    var formattedChange: String? {
        guard let change = changePercent else { return nil }
        let sign = change >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", change))%"
    }

    static func == (lhs: NewsFilterTab, rhs: NewsFilterTab) -> Bool {
        lhs.id == rhs.id
    }
}

// MARK: - News Source
struct NewsSource: Identifiable, Hashable {
    let id = UUID()
    let name: String
    let iconName: String?

    var systemIconName: String {
        "newspaper.fill"
    }
    
    // Hashable conformance based on id
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    static func == (lhs: NewsSource, rhs: NewsSource) -> Bool {
        lhs.id == rhs.id
    }
}

// MARK: - News Article
struct NewsArticle: Identifiable, Hashable {
    let id = UUID()
    let headline: String
    let summary: String?
    let source: NewsSource
    let sentiment: NewsSentiment
    let publishedAt: Date
    let thumbnailName: String?
    let relatedTickers: [String]

    var formattedTime: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a"
        return formatter.string(from: publishedAt)
    }

    var isToday: Bool {
        Calendar.current.isDateInToday(publishedAt)
    }

    var isYesterday: Bool {
        Calendar.current.isDateInYesterday(publishedAt)
    }

    var sectionTitle: String {
        if isToday {
            return "TODAY"
        } else if isYesterday {
            return "YESTERDAY"
        } else {
            let formatter = DateFormatter()
            formatter.dateFormat = "MMM d, yyyy"
            return formatter.string(from: publishedAt)
        }
    }
    
    // Hashable conformance based on id
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    static func == (lhs: NewsArticle, rhs: NewsArticle) -> Bool {
        lhs.id == rhs.id
    }
}

// MARK: - News Insight Summary
struct NewsInsightSummary: Identifiable {
    let id = UUID()
    let headline: String
    let bulletPoints: [String]
    let sentiment: MarketSentiment
    let updatedAt: Date
    let summaryType: String

    var timeAgo: String {
        let interval = Date().timeIntervalSince(updatedAt)
        let hours = Int(interval / 3600)
        if hours < 1 {
            return "Updated just now"
        } else if hours == 1 {
            return "Updated 1 hours ago"
        } else {
            return "Updated \(hours) hours ago"
        }
    }

    var summaryBadgeText: String {
        summaryType
    }
}

// MARK: - Grouped News
struct GroupedNews: Identifiable {
    let id = UUID()
    let sectionTitle: String
    let articles: [NewsArticle]
}

// MARK: - News Filter Options
struct NewsFilterOptions {
    var sources: [String]
    var sectors: [String]
    var sentiments: [NewsSentiment]

    static var `default`: NewsFilterOptions {
        NewsFilterOptions(sources: [], sectors: [], sentiments: [])
    }

    var hasActiveFilters: Bool {
        !sources.isEmpty || !sectors.isEmpty || !sentiments.isEmpty
    }
}

================================================================================
FILE: frontend/ios/ios/Models/WhaleProfileModels.swift
================================================================================

//
//  WhaleProfileModels.swift
//  ios
//
//  Data models for the Whale Profile screen
//

import Foundation
import SwiftUI

// MARK: - Whale Profile
struct WhaleProfile: Identifiable, Codable {
    let id: String
    let name: String
    let title: String
    let description: String
    let avatarURL: String?
    let riskProfile: WhaleRiskProfile
    let portfolioValue: Double
    let ytdReturn: Double
    let sectorExposure: [WhaleSectorAllocation]
    let currentHoldings: [WhaleHolding]
    let recentTradeGroups: [WhaleTradeGroup]
    let recentTrades: [WhaleTrade]
    let behaviorSummary: WhaleBehaviorSummary
    let sentimentSummary: String
    var isFollowing: Bool

    // MARK: - Formatted Properties

    var formattedPortfolioValue: String {
        formatLargeNumber(portfolioValue)
    }

    var formattedYTDReturn: String {
        let sign = ytdReturn >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", ytdReturn))%"
    }

    var isPositiveReturn: Bool {
        ytdReturn >= 0
    }

    // MARK: - Helpers

    private func formatLargeNumber(_ number: Double) -> String {
        let absNumber = abs(number)
        if absNumber >= 1_000_000_000_000 {
            return String(format: "$%.1fT", number / 1_000_000_000_000)
        } else if absNumber >= 1_000_000_000 {
            return String(format: "$%.1fB", number / 1_000_000_000)
        } else if absNumber >= 1_000_000 {
            return String(format: "$%.1fM", number / 1_000_000)
        } else if absNumber >= 1_000 {
            return String(format: "$%.1fK", number / 1_000)
        }
        return String(format: "$%.0f", number)
    }
}

// MARK: - Whale Risk Profile
enum WhaleRiskProfile: String, Codable {
    case safeLongTermValue = "Safe, Long-term Value"
    case growthFocused = "Growth Focused"
    case aggressive = "Aggressive"
    case moderate = "Moderate"
    case conservative = "Conservative"
    case highRisk = "High Risk"

    var color: Color {
        switch self {
        case .safeLongTermValue, .conservative:
            return AppColors.accentCyan
        case .moderate:
            return AppColors.primaryBlue
        case .growthFocused:
            return AppColors.bullish
        case .aggressive, .highRisk:
            return AppColors.bearish
        }
    }

    var iconName: String {
        switch self {
        case .safeLongTermValue, .conservative:
            return "shield.fill"
        case .moderate:
            return "chart.line.uptrend.xyaxis"
        case .growthFocused:
            return "arrow.up.right"
        case .aggressive, .highRisk:
            return "bolt.fill"
        }
    }
}

// MARK: - Whale Sector Allocation
struct WhaleSectorAllocation: Identifiable, Codable {
    let id: String
    let name: String
    let percentage: Double
    let colorHex: String

    var color: Color {
        Color(hex: colorHex)
    }

    var formattedPercentage: String {
        "\(Int(percentage))%"
    }

    init(id: String = UUID().uuidString, name: String, percentage: Double, colorHex: String) {
        self.id = id
        self.name = name
        self.percentage = percentage
        self.colorHex = colorHex
    }
}

// MARK: - Whale Holding
struct WhaleHolding: Identifiable, Codable {
    let id: String
    let ticker: String
    let companyName: String
    let logoURL: String?
    let allocation: Double
    let changePercent: Double

    var formattedAllocation: String {
        String(format: "%.1f%%", allocation)
    }

    var formattedChange: String {
        let sign = changePercent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.1f", changePercent))%"
    }

    var isPositive: Bool {
        changePercent >= 0
    }

    init(id: String = UUID().uuidString, ticker: String, companyName: String, logoURL: String? = nil, allocation: Double, changePercent: Double) {
        self.id = id
        self.ticker = ticker
        self.companyName = companyName
        self.logoURL = logoURL
        self.allocation = allocation
        self.changePercent = changePercent
    }
}

// MARK: - Whale Trade Group
/// A batch of trades filed on a specific date, displayed as a single card
struct WhaleTradeGroup: Identifiable, Codable {
    let id: String
    let date: Date
    let tradeCount: Int
    let netAction: WhaleTradeAction
    let netAmount: Double
    let summary: String?
    let insights: [String]
    let trades: [WhaleTrade]

    /// Formatted date for the detail header (e.g. "Feb 05, 2026")
    var formattedDateFull: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM dd, yyyy"
        return formatter.string(from: date)
    }

    /// Formatted date â€” shows relative for recent, or "MMM dd, yyyy" otherwise
    var formattedDate: String {
        let calendar = Calendar.current
        let now = Date()
        let daysAgo = calendar.dateComponents([.day], from: date, to: now).day ?? 0

        if daysAgo == 0 {
            return "Today"
        } else if daysAgo == 1 {
            return "Yesterday"
        } else if daysAgo <= 14 {
            return "\(daysAgo) days ago"
        } else {
            return formattedDateFull
        }
    }

    var formattedTradeCount: String {
        "\(tradeCount) \(tradeCount == 1 ? "trade" : "trades")"
    }

    var formattedNetAmount: String {
        let prefix = netAction == .bought ? "+" : "- "
        return "\(prefix)\(formatAmount(netAmount)) \(netAction.rawValue)"
    }

    private func formatAmount(_ amount: Double) -> String {
        let absAmount = abs(amount)
        if absAmount >= 1_000_000_000 {
            return String(format: "$%.2fB", absAmount / 1_000_000_000)
        } else if absAmount >= 1_000_000 {
            return String(format: "$%.1fM", absAmount / 1_000_000)
        } else if absAmount >= 1_000 {
            return String(format: "$%.0fK", absAmount / 1_000)
        }
        return String(format: "$%.0f", absAmount)
    }

    init(
        id: String = UUID().uuidString,
        date: Date,
        tradeCount: Int,
        netAction: WhaleTradeAction,
        netAmount: Double,
        summary: String? = nil,
        insights: [String] = [],
        trades: [WhaleTrade] = []
    ) {
        self.id = id
        self.date = date
        self.tradeCount = tradeCount
        self.netAction = netAction
        self.netAmount = netAmount
        self.summary = summary
        self.insights = insights
        self.trades = trades
    }
}

// MARK: - Trade Type (filter category)
enum WhaleTradeType: String, CaseIterable, Codable {
    case new = "New"
    case increased = "Increased"
    case decreased = "Decreased"
    case closed = "Closed"

    var iconName: String {
        switch self {
        case .new: return "plus.circle.fill"
        case .increased: return "plus"
        case .decreased: return "minus"
        case .closed: return "minus.circle.fill"
        }
    }

    var iconColor: Color {
        switch self {
        case .new: return AppColors.bullish
        case .increased: return AppColors.bullish
        case .decreased: return AppColors.bearish
        case .closed: return AppColors.bearish
        }
    }
}

// MARK: - Trade Filter Tab
enum TradeFilterTab: String, CaseIterable {
    case all = "All Trades"
    case new = "New"
    case increased = "Increased"
    case decreased = "Decreased"
    case closed = "Closed"

    var iconName: String? {
        switch self {
        case .all: return nil
        case .new: return "plus.circle.fill"
        case .increased: return "plus"
        case .decreased: return "minus"
        case .closed: return "minus.circle.fill"
        }
    }

    var iconColor: Color {
        switch self {
        case .all: return .clear
        case .new: return AppColors.bullish
        case .increased: return AppColors.bullish
        case .decreased: return AppColors.bearish
        case .closed: return AppColors.bearish
        }
    }
}

// MARK: - Whale Trade
/// Individual trade â€” used inside a trade group detail screen
struct WhaleTrade: Identifiable, Codable {
    let id: String
    let ticker: String
    let companyName: String
    let action: WhaleTradeAction
    let tradeType: WhaleTradeType
    let amount: Double
    let previousAllocation: Double
    let newAllocation: Double
    let date: Date

    var formattedAmount: String {
        formatTradeAmount(amount)
    }

    var formattedAllocationChange: String {
        let prev = previousAllocation == 0 ? "0%" : String(format: "%.1f%%", previousAllocation)
        let new = newAllocation == 0 ? "0%" : String(format: "%.1f %%", newAllocation)
        return "\(prev)  \u{2192}  \(new)"
    }

    private func formatTradeAmount(_ amount: Double) -> String {
        let absAmount = abs(amount)
        if absAmount >= 1_000_000_000 {
            return String(format: "$%.2fB", absAmount / 1_000_000_000)
        } else if absAmount >= 1_000_000 {
            return String(format: "$%.2fM", absAmount / 1_000_000)
        } else if absAmount >= 1_000 {
            return String(format: "$%.0fK", absAmount / 1_000)
        }
        return String(format: "$%.0f", absAmount)
    }

    init(
        id: String = UUID().uuidString,
        ticker: String,
        companyName: String,
        action: WhaleTradeAction,
        tradeType: WhaleTradeType = .increased,
        amount: Double,
        previousAllocation: Double = 0,
        newAllocation: Double = 0,
        date: Date = Date()
    ) {
        self.id = id
        self.ticker = ticker
        self.companyName = companyName
        self.action = action
        self.tradeType = tradeType
        self.amount = amount
        self.previousAllocation = previousAllocation
        self.newAllocation = newAllocation
        self.date = date
    }
}

// MARK: - Whale Trade Action
enum WhaleTradeAction: String, Codable {
    case bought = "BOUGHT"
    case sold = "SOLD"

    var color: Color {
        switch self {
        case .bought:
            return AppColors.bullish
        case .sold:
            return AppColors.bearish
        }
    }
}

// MARK: - Whale Behavior Summary
struct WhaleBehaviorSummary: Codable {
    let action: String
    let primaryFocus: String
    let secondaryAction: String
    let secondaryFocus: String

    var formattedSummary: AttributedString {
        var result = AttributedString("This whale is currently ")

        var actionPart = AttributedString(action)
        actionPart.foregroundColor = AppColors.bullish
        result.append(actionPart)

        result.append(AttributedString(" \(primaryFocus) and "))

        var secondaryPart = AttributedString(secondaryAction)
        secondaryPart.foregroundColor = AppColors.textPrimary
        result.append(secondaryPart)

        result.append(AttributedString(" \(secondaryFocus)"))

        return result
    }
}

// MARK: - Date Helper
private func dateFrom(month: Int, day: Int, year: Int) -> Date {
    var components = DateComponents()
    components.year = year
    components.month = month
    components.day = day
    return Calendar.current.date(from: components) ?? Date()
}

// MARK: - Sample Data
extension WhaleProfile {
    static let warrenBuffett = WhaleProfile(
        id: "warren-buffett",
        name: "Warren Buffett",
        title: "Berkshire Hathaway CEO",
        description: "Warren Buffett, widely regarded as one of the greatest investors of all time, has built Berkshire Hathaway into a conglomerate worth hundreds of billions through his patient, value-oriented investment philosophy. Known as the 'Oracle of Omaha,' he focuses on businesses with strong fundamentals, competitive advantages, and reliable management. His approach emphasizes buying quality companies at reasonable prices and holding them for the long term, often decades.",
        avatarURL: nil,
        riskProfile: .safeLongTermValue,
        portfolioValue: 342_800_000_000,
        ytdReturn: 19.4,
        sectorExposure: [
            WhaleSectorAllocation(name: "Tech", percentage: 42, colorHex: "3B82F6"),
            WhaleSectorAllocation(name: "Finance", percentage: 31, colorHex: "22C55E"),
            WhaleSectorAllocation(name: "Energy", percentage: 17, colorHex: "F97316"),
            WhaleSectorAllocation(name: "Other", percentage: 10, colorHex: "6B7280")
        ],
        currentHoldings: [
            WhaleHolding(ticker: "AAPL", companyName: "Apple Inc.", allocation: 47.8, changePercent: 1.8),
            WhaleHolding(ticker: "BAC", companyName: "Bank of America", allocation: 11.2, changePercent: -0.5),
            WhaleHolding(ticker: "AXP", companyName: "American Express", allocation: 9.4, changePercent: 0.0),
            WhaleHolding(ticker: "KO", companyName: "Coca-Cola", allocation: 8.1, changePercent: 3.2),
            WhaleHolding(ticker: "CVX", companyName: "Chevron", allocation: 6.7, changePercent: 3.2),
            WhaleHolding(ticker: "OXY", companyName: "Occidental Petroleum", allocation: 4.9, changePercent: 2.2),
            WhaleHolding(ticker: "KHC", companyName: "Kraft Heinz", allocation: 3.8, changePercent: 0.0),
            WhaleHolding(ticker: "MCO", companyName: "Moody's Corp", allocation: 2.6, changePercent: 0.0),
            WhaleHolding(ticker: "USB", companyName: "U.S. Bancorp", allocation: 2.1, changePercent: 0.2),
            WhaleHolding(ticker: "BK", companyName: "Bank of NY Mellon", allocation: 1.8, changePercent: -0.5)
        ],
        recentTradeGroups: [
            WhaleTradeGroup(
                date: Calendar.current.date(byAdding: .day, value: -7, to: Date())!,
                tradeCount: 7,
                netAction: .bought,
                netAmount: 4_340_000_000,
                summary: "Significant rebalancing (trimmed 3 Tech positions)",
                insights: [
                    "Net accumulating over last filed +$2.2B new positions",
                    "Significant rebalancing (trimmed 3 Tech positions)"
                ],
                trades: [
                    WhaleTrade(ticker: "XYZ", companyName: "XYZ Corp", action: .bought, tradeType: .new, amount: 3_140_000_000, previousAllocation: 0, newAllocation: 1.5),
                    WhaleTrade(ticker: "AAPL", companyName: "Apple Inc.", action: .bought, tradeType: .increased, amount: 2_300_000_000, previousAllocation: 1.0, newAllocation: 2.5),
                    WhaleTrade(ticker: "KO", companyName: "Coca-Cola", action: .bought, tradeType: .increased, amount: 223_640_000, previousAllocation: 1.5, newAllocation: 2.5),
                    WhaleTrade(ticker: "CVX", companyName: "Chevron", action: .bought, tradeType: .increased, amount: 22_640_000, previousAllocation: 1.3, newAllocation: 1.5),
                    WhaleTrade(ticker: "BAC", companyName: "Bank of America", action: .sold, tradeType: .decreased, amount: 59_100_000, previousAllocation: 1.3, newAllocation: 0.5),
                    WhaleTrade(ticker: "BK", companyName: "Bank of NY Mellon", action: .sold, tradeType: .decreased, amount: 24_100_000, previousAllocation: 2.1, newAllocation: 1.8),
                    WhaleTrade(ticker: "ROKU", companyName: "Roku Inc.", action: .sold, tradeType: .closed, amount: 1_130_000_000, previousAllocation: 1.3, newAllocation: 0)
                ]
            ),
            WhaleTradeGroup(
                date: dateFrom(month: 1, day: 4, year: 2025),
                tradeCount: 12,
                netAction: .bought,
                netAmount: 2_200_000_000,
                insights: ["Broad accumulation across energy and finance sectors"],
                trades: [
                    WhaleTrade(ticker: "OXY", companyName: "Occidental Petroleum", action: .bought, tradeType: .increased, amount: 800_000_000, previousAllocation: 3.2, newAllocation: 4.9),
                    WhaleTrade(ticker: "CVX", companyName: "Chevron", action: .bought, tradeType: .increased, amount: 600_000_000, previousAllocation: 5.1, newAllocation: 6.7),
                    WhaleTrade(ticker: "AAPL", companyName: "Apple Inc.", action: .bought, tradeType: .increased, amount: 500_000_000, previousAllocation: 46.8, newAllocation: 47.8)
                ]
            ),
            WhaleTradeGroup(
                date: dateFrom(month: 12, day: 23, year: 2025),
                tradeCount: 9,
                netAction: .sold,
                netAmount: 4_500_000_000,
                summary: "Significant sold with 3 closed positions in Banking sector",
                insights: [
                    "Significant sold with 3 closed positions in Banking sector",
                    "Reduced exposure to regional banks"
                ],
                trades: [
                    WhaleTrade(ticker: "USB", companyName: "U.S. Bancorp", action: .sold, tradeType: .decreased, amount: 1_200_000_000, previousAllocation: 3.5, newAllocation: 2.1),
                    WhaleTrade(ticker: "BAC", companyName: "Bank of America", action: .sold, tradeType: .decreased, amount: 900_000_000, previousAllocation: 12.1, newAllocation: 11.2)
                ]
            ),
            WhaleTradeGroup(
                date: dateFrom(month: 10, day: 4, year: 2025),
                tradeCount: 9,
                netAction: .sold,
                netAmount: 2_870_000_000,
                trades: [
                    WhaleTrade(ticker: "KHC", companyName: "Kraft Heinz", action: .sold, tradeType: .decreased, amount: 870_000_000, previousAllocation: 4.5, newAllocation: 3.8),
                    WhaleTrade(ticker: "MCO", companyName: "Moody's Corp", action: .sold, tradeType: .decreased, amount: 500_000_000, previousAllocation: 3.2, newAllocation: 2.6)
                ]
            ),
            WhaleTradeGroup(
                date: dateFrom(month: 8, day: 29, year: 2025),
                tradeCount: 11,
                netAction: .bought,
                netAmount: 1_450_000_000,
                trades: [
                    WhaleTrade(ticker: "AAPL", companyName: "Apple Inc.", action: .bought, tradeType: .increased, amount: 650_000_000, previousAllocation: 45.2, newAllocation: 46.8),
                    WhaleTrade(ticker: "AXP", companyName: "American Express", action: .bought, tradeType: .increased, amount: 400_000_000, previousAllocation: 8.8, newAllocation: 9.4)
                ]
            )
        ],
        recentTrades: [],
        behaviorSummary: WhaleBehaviorSummary(
            action: "Accumulating",
            primaryFocus: "energy stocks",
            secondaryAction: "Holding",
            secondaryFocus: "core tech positions"
        ),
        sentimentSummary: "Warren Buffett maintains a conservative, value-driven approach with significant exposure to financial services and technology blue chips. Recent activity shows increased energy sector positioning while maintaining core long-term holdings. His strategy emphasizes quality businesses with strong fundamentals and predictable cash flows.",
        isFollowing: true
    )

    static let cathieWood = WhaleProfile(
        id: "cathie-wood",
        name: "Cathie Wood",
        title: "ARK Invest CEO",
        description: "Cathie Wood is the founder and CEO of ARK Invest, known for her bold, research-driven approach to disruptive innovation investing. Her firm focuses on companies at the forefront of technological breakthroughs in areas like artificial intelligence, genomics, blockchain, and automation. Unlike traditional value investors, Wood embraces volatility and concentrates her portfolios in high-conviction growth stocks that she believes will reshape industries over the next decade.",
        avatarURL: nil,
        riskProfile: .growthFocused,
        portfolioValue: 14_200_000_000,
        ytdReturn: -8.3,
        sectorExposure: [
            WhaleSectorAllocation(name: "Tech", percentage: 55, colorHex: "3B82F6"),
            WhaleSectorAllocation(name: "Healthcare", percentage: 20, colorHex: "22C55E"),
            WhaleSectorAllocation(name: "Finance", percentage: 15, colorHex: "F97316"),
            WhaleSectorAllocation(name: "Other", percentage: 10, colorHex: "6B7280")
        ],
        currentHoldings: [
            WhaleHolding(ticker: "TSLA", companyName: "Tesla Inc.", allocation: 12.5, changePercent: -2.3),
            WhaleHolding(ticker: "COIN", companyName: "Coinbase", allocation: 8.2, changePercent: 5.1),
            WhaleHolding(ticker: "ROKU", companyName: "Roku Inc.", allocation: 7.8, changePercent: -1.2)
        ],
        recentTradeGroups: [
            WhaleTradeGroup(
                date: Calendar.current.date(byAdding: .day, value: -2, to: Date())!,
                tradeCount: 8,
                netAction: .bought,
                netAmount: 156_000_000,
                summary: "Heavy TSLA accumulation across ARK funds",
                insights: ["Heavy TSLA accumulation across ARK funds"],
                trades: [
                    WhaleTrade(ticker: "TSLA", companyName: "Tesla Inc.", action: .bought, tradeType: .increased, amount: 120_000_000, previousAllocation: 10.5, newAllocation: 12.5),
                    WhaleTrade(ticker: "COIN", companyName: "Coinbase", action: .bought, tradeType: .increased, amount: 36_000_000, previousAllocation: 7.5, newAllocation: 8.2)
                ]
            ),
            WhaleTradeGroup(
                date: Calendar.current.date(byAdding: .day, value: -9, to: Date())!,
                tradeCount: 5,
                netAction: .sold,
                netAmount: 42_000_000,
                trades: [
                    WhaleTrade(ticker: "ROKU", companyName: "Roku Inc.", action: .sold, tradeType: .decreased, amount: 42_000_000, previousAllocation: 8.5, newAllocation: 7.8)
                ]
            )
        ],
        recentTrades: [],
        behaviorSummary: WhaleBehaviorSummary(
            action: "Buying",
            primaryFocus: "innovation stocks",
            secondaryAction: "Reducing",
            secondaryFocus: "mature tech holdings"
        ),
        sentimentSummary: "Cathie Wood continues her focus on disruptive innovation, emphasizing AI, genomics, and blockchain technologies.",
        isFollowing: false
    )
}

================================================================================
FILE: frontend/ios/ios/Services/AIVoiceManager.swift
================================================================================

//
//  AIVoiceManager.swift
//  ios
//
//  Service: Manages AI text-to-speech with word-by-word progress tracking
//  Uses AVSpeechSynthesizer for natural voice reading with callbacks for UI updates
//

import AVFoundation
import Combine

@MainActor
class AIVoiceManager: NSObject, ObservableObject {
    // MARK: - Published Properties
    @Published var isPlaying: Bool = false
    @Published var currentWordRange: NSRange = NSRange(location: 0, length: 0)
    @Published var currentWordIndex: Int = 0
    @Published var progress: Double = 0.0

    // MARK: - Private Properties
    private var synthesizer: AVSpeechSynthesizer?
    private var currentText: String = ""
    private var wordRanges: [NSRange] = []
    private var onComplete: (() -> Void)?

    // MARK: - Singleton
    static let shared = AIVoiceManager()

    override init() {
        super.init()
        setupSynthesizer()
        setupAudioSession()
    }

    // MARK: - Setup

    private func setupSynthesizer() {
        synthesizer = AVSpeechSynthesizer()
        synthesizer?.delegate = self
    }

    private func setupAudioSession() {
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            print("Failed to setup audio session: \(error)")
        }
    }

    // MARK: - Public Methods

    /// Speak the given text with word-by-word progress tracking
    func speak(_ text: String, onComplete: (() -> Void)? = nil) {
        guard let synthesizer = synthesizer else { return }

        // Stop any current speech
        if synthesizer.isSpeaking {
            synthesizer.stopSpeaking(at: .immediate)
        }

        currentText = text
        self.onComplete = onComplete
        wordRanges = calculateWordRanges(for: text)
        currentWordIndex = 0
        progress = 0.0

        let utterance = AVSpeechUtterance(string: text)
        utterance.voice = AVSpeechSynthesisVoice(language: "en-US")
        utterance.rate = AVSpeechUtteranceDefaultSpeechRate * 0.9  // Slightly slower for clarity
        utterance.pitchMultiplier = 1.0
        utterance.volume = 1.0

        isPlaying = true
        synthesizer.speak(utterance)
    }

    /// Pause the current speech
    func pause() {
        synthesizer?.pauseSpeaking(at: .word)
        isPlaying = false
    }

    /// Resume paused speech
    func resume() {
        synthesizer?.continueSpeaking()
        isPlaying = true
    }

    /// Stop speaking completely
    func stop() {
        synthesizer?.stopSpeaking(at: .immediate)
        isPlaying = false
        currentWordIndex = 0
        currentWordRange = NSRange(location: 0, length: 0)
        progress = 0.0
    }

    /// Toggle between play and pause
    func togglePlayPause() {
        if isPlaying {
            pause()
        } else {
            if synthesizer?.isPaused == true {
                resume()
            }
        }
    }

    // MARK: - Word Range Calculation

    private func calculateWordRanges(for text: String) -> [NSRange] {
        var ranges: [NSRange] = []

        // Use natural language processing to find word boundaries
        var currentIndex = 0
        let words = text.components(separatedBy: .whitespacesAndNewlines).filter { !$0.isEmpty }

        for word in words {
            if let range = text.range(of: word, range: text.index(text.startIndex, offsetBy: currentIndex)..<text.endIndex) {
                let nsRange = NSRange(range, in: text)
                ranges.append(nsRange)
                currentIndex = nsRange.location + nsRange.length
            }
        }

        return ranges
    }

    /// Get the index of the word at a given character position
    func wordIndex(forCharacterAt position: Int) -> Int {
        for (index, range) in wordRanges.enumerated() {
            if position >= range.location && position < range.location + range.length {
                return index
            }
        }
        return wordRanges.count - 1
    }
}

// MARK: - AVSpeechSynthesizerDelegate

extension AIVoiceManager: AVSpeechSynthesizerDelegate {
    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, willSpeakRangeOfSpeechString characterRange: NSRange, utterance: AVSpeechUtterance) {
        Task { @MainActor in
            self.currentWordRange = characterRange
            self.currentWordIndex = self.wordIndex(forCharacterAt: characterRange.location)

            // Calculate progress
            let totalLength = self.currentText.count
            if totalLength > 0 {
                self.progress = Double(characterRange.location + characterRange.length) / Double(totalLength)
            }
        }
    }

    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
        Task { @MainActor in
            self.isPlaying = false
            self.progress = 1.0
            self.onComplete?()
        }
    }

    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didPause utterance: AVSpeechUtterance) {
        Task { @MainActor in
            self.isPlaying = false
        }
    }

    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didContinue utterance: AVSpeechUtterance) {
        Task { @MainActor in
            self.isPlaying = true
        }
    }

    nonisolated func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didCancel utterance: AVSpeechUtterance) {
        Task { @MainActor in
            self.isPlaying = false
            self.currentWordIndex = 0
            self.progress = 0.0
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Services/AudioManager.swift
================================================================================

//
//  AudioManager.swift
//  ios
//
//  Central state management for the Global Audio Player
//  Injected environment-wide to enable playback control from anywhere in the app
//

import Foundation
import SwiftUI
import Combine
import AVFoundation

// MARK: - Audio Manager
@MainActor
final class AudioManager: ObservableObject {
    // MARK: - Singleton (for environment injection)
    static let shared = AudioManager()

    // MARK: - Published State
    @Published private(set) var currentEpisode: AudioEpisode?
    @Published private(set) var playbackState: PlaybackState = .idle
    @Published private(set) var currentTime: TimeInterval = 0
    @Published private(set) var duration: TimeInterval = 0
    @Published var playbackSpeed: PlaybackSpeed = .normal
    @Published var sleepTimer: SleepTimerOption = .off
    @Published private(set) var sleepTimerRemaining: TimeInterval = 0

    // Queue management
    @Published private(set) var queue: [AudioQueueItem] = []
    @Published private(set) var playbackHistory: [AudioEpisode] = []

    // Playback completion publisher - fires when current episode finishes naturally
    let playbackDidComplete = PassthroughSubject<AudioEpisode, Never>()

    // UI State
    @Published var isMiniPlayerExpanded: Bool = false
    @Published var showFullScreenPlayer: Bool = false
    @Published var isCompactMode: Bool = false  // True when chat keyboard is active (shows status island)
    @Published var isPlayerHiddenByScroll: Bool = false  // True when scroll-based hiding is active

    // MARK: - Computed Properties
    var isPlaying: Bool {
        playbackState == .playing
    }

    var hasActiveEpisode: Bool {
        currentEpisode != nil && playbackState.isActive
    }

    var progress: Double {
        guard duration > 0 else { return 0 }
        return currentTime / duration
    }

    var remainingTime: TimeInterval {
        max(0, duration - currentTime)
    }

    var formattedCurrentTime: String {
        formatTime(currentTime)
    }

    var formattedRemainingTime: String {
        "-" + formatTime(remainingTime)
    }

    var formattedDuration: String {
        formatTime(duration)
    }

    // MARK: - Private Properties
    private var playbackTimer: Timer?
    private var sleepTimerInstance: Timer?
    private var cancellables = Set<AnyCancellable>()

    // Audio session configuration
    private let audioSession = AVAudioSession.sharedInstance()

    // MARK: - Initialization
    private init() {
        setupAudioSession()
        setupObservers()
    }

    // MARK: - Audio Session Setup
    private func setupAudioSession() {
        do {
            try audioSession.setCategory(.playback, mode: .spokenAudio, options: [.allowBluetoothA2DP, .allowAirPlay])
            try audioSession.setActive(true)
        } catch {
            print("Failed to setup audio session: \(error)")
        }
    }

    private func setupObservers() {
        // Observe playback speed changes
        $playbackSpeed
            .sink { [weak self] speed in
                self?.updatePlaybackSpeed(speed)
            }
            .store(in: &cancellables)

        // Observe sleep timer changes
        $sleepTimer
            .sink { [weak self] option in
                self?.configureSleepTimer(option)
            }
            .store(in: &cancellables)
    }

    // MARK: - Playback Controls

    /// Load a new episode without starting playback (starts paused)
    func load(_ episode: AudioEpisode) {
        // Add current episode to history if exists
        if let current = currentEpisode {
            addToHistory(current)
        }

        currentEpisode = episode
        duration = episode.duration
        currentTime = 0
        playbackState = .paused
    }

    /// Play a new episode
    func play(_ episode: AudioEpisode) {
        // Add current episode to history if exists
        if let current = currentEpisode {
            addToHistory(current)
        }

        currentEpisode = episode
        duration = episode.duration
        currentTime = 0
        playbackState = .loading

        // Simulate loading delay then start playing
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
            self?.playbackState = .playing
            self?.startPlaybackTimer()
        }
    }

    /// Resume playback
    func resume() {
        guard currentEpisode != nil else { return }
        playbackState = .playing
        startPlaybackTimer()
    }

    /// Pause playback
    func pause() {
        playbackState = .paused
        stopPlaybackTimer()
    }

    /// Toggle play/pause
    func togglePlayPause() {
        switch playbackState {
        case .playing:
            pause()
        case .paused:
            resume()
        case .idle:
            if let episode = currentEpisode {
                play(episode)
            }
        default:
            break
        }
    }

    /// Stop playback and clear current episode
    func stop() {
        stopPlaybackTimer()
        stopSleepTimer()
        playbackState = .idle

        // Add to history before clearing
        if let episode = currentEpisode {
            addToHistory(episode)
        }

        currentEpisode = nil
        currentTime = 0
        duration = 0
        showFullScreenPlayer = false
    }

    /// Seek to specific time
    func seek(to time: TimeInterval) {
        currentTime = max(0, min(time, duration))
    }

    /// Seek by offset (positive = forward, negative = backward)
    func seekBy(_ offset: TimeInterval) {
        seek(to: currentTime + offset)
    }

    /// Skip forward 15 seconds
    func skipForward() {
        seekBy(15)
    }

    /// Skip backward 15 seconds
    func skipBackward() {
        seekBy(-15)
    }

    /// Seek to progress (0.0 - 1.0)
    func seekToProgress(_ progress: Double) {
        let clampedProgress = max(0, min(1, progress))
        seek(to: duration * clampedProgress)
    }

    // MARK: - Queue Management

    /// Add episode to queue
    func addToQueue(_ episode: AudioEpisode) {
        let item = AudioQueueItem(episode: episode)
        queue.append(item)
    }

    /// Remove from queue
    func removeFromQueue(at index: Int) {
        guard queue.indices.contains(index) else { return }
        queue.remove(at: index)
    }

    /// Play next in queue
    func playNext() {
        guard !queue.isEmpty else {
            stop()
            return
        }

        let nextItem = queue.removeFirst()
        play(nextItem.episode)
    }

    /// Clear queue
    func clearQueue() {
        queue.removeAll()
    }

    // MARK: - Speed Control

    private func updatePlaybackSpeed(_ speed: PlaybackSpeed) {
        // In real implementation, update AVPlayer rate
        // For simulation, this affects the timer interval
        if playbackState == .playing {
            stopPlaybackTimer()
            startPlaybackTimer()
        }
    }

    // MARK: - Sleep Timer

    private func configureSleepTimer(_ option: SleepTimerOption) {
        stopSleepTimer()

        guard option != .off else {
            sleepTimerRemaining = 0
            return
        }

        if option == .endOfEpisode {
            sleepTimerRemaining = remainingTime
        } else {
            sleepTimerRemaining = TimeInterval(option.rawValue * 60)
        }

        startSleepTimer()
    }

    private func startSleepTimer() {
        sleepTimerInstance = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            Task { @MainActor [weak self] in
                guard let self = self else { return }
                if self.sleepTimerRemaining > 0 {
                    self.sleepTimerRemaining -= 1
                } else {
                    self.pause()
                    self.sleepTimer = .off
                    self.stopSleepTimer()
                }
            }
        }
    }

    private func stopSleepTimer() {
        sleepTimerInstance?.invalidate()
        sleepTimerInstance = nil
    }

    // MARK: - Playback Timer (Simulation)

    private func startPlaybackTimer() {
        stopPlaybackTimer()

        let interval = 1.0 / playbackSpeed.rawValue
        playbackTimer = Timer.scheduledTimer(withTimeInterval: interval, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            Task { @MainActor [weak self] in
                guard let self = self else { return }
                if self.currentTime < self.duration {
                    self.currentTime += 1
                } else {
                    self.handlePlaybackComplete()
                }
            }
        }
    }

    private func stopPlaybackTimer() {
        playbackTimer?.invalidate()
        playbackTimer = nil
    }

    private func handlePlaybackComplete() {
        stopPlaybackTimer()

        // Notify listeners that the episode completed naturally
        if let episode = currentEpisode {
            playbackDidComplete.send(episode)
        }

        if !queue.isEmpty {
            playNext()
        } else {
            playbackState = .paused
            currentTime = duration
        }
    }

    // MARK: - History Management

    private func addToHistory(_ episode: AudioEpisode) {
        // Remove if already in history to avoid duplicates
        playbackHistory.removeAll { $0.id == episode.id }
        // Add to front
        playbackHistory.insert(episode, at: 0)
        // Keep only last 50 items
        if playbackHistory.count > 50 {
            playbackHistory = Array(playbackHistory.prefix(50))
        }
    }

    // MARK: - UI Actions

    /// Expand mini player to full screen
    func expandPlayer() {
        withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
            showFullScreenPlayer = true
        }
    }

    /// Collapse full screen player to mini player
    func collapsePlayer() {
        withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
            showFullScreenPlayer = false
        }
    }

    /// Enter compact mode (status island at top)
    func enterCompactMode() {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.85)) {
            isCompactMode = true
        }
    }

    /// Exit compact mode (show full mini player at bottom)
    func exitCompactMode() {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.85)) {
            isCompactMode = false
        }
    }

    /// Hide player via scroll (used by detail screens)
    func hidePlayerByScroll() {
        guard !isPlayerHiddenByScroll else { return }
        withAnimation(.easeInOut(duration: 0.25)) {
            isPlayerHiddenByScroll = true
        }
    }

    /// Show player after scroll hiding
    func showPlayerAfterScroll() {
        guard isPlayerHiddenByScroll else { return }
        withAnimation(.easeInOut(duration: 0.25)) {
            isPlayerHiddenByScroll = false
        }
    }

    /// Reset scroll hiding state (call when leaving detail screens)
    func resetScrollHiding() {
        isPlayerHiddenByScroll = false
    }

    // MARK: - Helpers

    private func formatTime(_ time: TimeInterval) -> String {
        let totalSeconds = Int(time)
        let hours = totalSeconds / 3600
        let minutes = (totalSeconds % 3600) / 60
        let seconds = totalSeconds % 60

        if hours > 0 {
            return String(format: "%d:%02d:%02d", hours, minutes, seconds)
        } else {
            return String(format: "%d:%02d", minutes, seconds)
        }
    }
}

// MARK: - Environment Key
struct AudioManagerKey: EnvironmentKey {
    static let defaultValue: AudioManager = AudioManager.shared
}

extension EnvironmentValues {
    var audioManager: AudioManager {
        get { self[AudioManagerKey.self] }
        set { self[AudioManagerKey.self] = newValue }
    }
}

// MARK: - View Extension for Easy Access
extension View {
    func withAudioManager() -> some View {
        self.environmentObject(AudioManager.shared)
    }
}

================================================================================
FILE: frontend/ios/ios/Theme/AppTheme.swift
================================================================================

//
//  AppTheme.swift
//  ios
//
//  AI Value Investor App - Theme System
//

import SwiftUI

// MARK: - App Colors
struct AppColors {
    // Background Colors
    static let background = Color(hex: "171B26")
    static let cardBackground = Color(hex: "1E2330")
    static let cardBackgroundLight = Color(hex: "252B3B")

    // Accent Colors
    static let primaryBlue = Color(hex: "3B82F6")
    static let accentCyan = Color(hex: "06B6D4")
    static let accentYellow = Color(hex: "FACC15")

    // Sentiment Colors
    static let bullish = Color(hex: "22C55E")
    static let bearish = Color(hex: "EF4444")
    static let neutral = Color(hex: "F59E0B")

    // Text Colors
    static let textPrimary = Color.white
    static let textSecondary = Color(hex: "9CA3AF")
    static let textMuted = Color(hex: "6B7280")

    // Alert Colors
    static let alertOrange = Color(hex: "F97316")
    static let alertBlue = Color(hex: "3B82F6")
    static let alertPurple = Color(hex: "A855F7")

    // Card Gradient Colors
    static let microsoftBlue = Color(hex: "0078D4")
    static let googleBlue = Color(hex: "4285F4")
    static let amdRed = Color(hex: "ED1C24")

    // Tab Bar
    static let tabBarBackground = Color(hex: "0D1117")
    static let tabBarSelected = Color(hex: "3B82F6")
    static let tabBarUnselected = Color(hex: "6B7280")

    // Growth Chart Colors
    static let growthBarBlue = Color(hex: "5B9CF6")
    static let growthYoYYellow = Color(hex: "FACC15")
    static let growthSectorGray = Color(hex: "9CA3AF")
    static let chipSelectedBackground = Color(hex: "3B82F6")
    static let chipUnselectedBackground = Color(hex: "2D3548")
    static let toggleBackground = Color(hex: "1E2330")
    static let toggleSelectedBackground = Color(hex: "374151")

    // Profit Power Chart Colors
    static let profitGrossMargin = Color(hex: "3B82F6")       // Blue - matches primaryBlue
    static let profitOperatingMargin = Color(hex: "F97316")   // Orange
    static let profitFCFMargin = Color(hex: "A855F7")         // Purple
    static let profitNetMargin = Color(hex: "22C55E")         // Green - matches bullish
    static let profitSectorAverage = Color(hex: "9CA3AF")     // Gray - matches textSecondary

    // Signal of Confidence Chart Colors
    static let confidenceDividends = Color(hex: "3B82F6")     // Blue - matches primaryBlue
    static let confidenceBuybacks = Color(hex: "22C55E")      // Green - matches bullish
    static let confidenceSharesOutstanding = Color(hex: "FACC15") // Yellow - matches growthYoYYellow
}

// MARK: - Color Extension for Hex
extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}

// MARK: - App Typography
struct AppTypography {
    // Headlines
    static let largeTitle = Font.system(size: 28, weight: .bold)
    static let title = Font.system(size: 22, weight: .bold)
    static let title2 = Font.system(size: 20, weight: .semibold)
    static let title3 = Font.system(size: 18, weight: .semibold)

    // Body
    static let headline = Font.system(size: 17, weight: .semibold)
    static let body = Font.system(size: 15, weight: .regular)
    static let bodyBold = Font.system(size: 15, weight: .semibold)
    static let callout = Font.system(size: 14, weight: .regular)
    static let calloutBold = Font.system(size: 14, weight: .semibold)

    // Small
    static let subheadline = Font.system(size: 13, weight: .regular)
    static let footnote = Font.system(size: 12, weight: .regular)
    static let footnoteBold = Font.system(size: 12, weight: .semibold)
    static let caption = Font.system(size: 11, weight: .regular)
    static let captionBold = Font.system(size: 11, weight: .medium)

    // Ticker Numbers
    static let tickerPrice = Font.system(size: 14, weight: .bold, design: .rounded)
    static let tickerChange = Font.system(size: 10, weight: .semibold, design: .rounded)
    static let tickerName = Font.system(size: 9, weight: .regular)
}

// MARK: - App Spacing
struct AppSpacing {
    static let xxs: CGFloat = 2
    static let xs: CGFloat = 4
    static let sm: CGFloat = 8
    static let md: CGFloat = 12
    static let lg: CGFloat = 16
    static let xl: CGFloat = 20
    static let xxl: CGFloat = 24
    static let xxxl: CGFloat = 32
}

// MARK: - App Corner Radius
struct AppCornerRadius {
    static let small: CGFloat = 6
    static let medium: CGFloat = 10
    static let large: CGFloat = 14
    static let extraLarge: CGFloat = 18
    static let pill: CGFloat = 20
}

// MARK: - App Shadows
struct AppShadows {
    static let cardShadow = Shadow(color: Color.black.opacity(0.2), radius: 8, x: 0, y: 4)
    static let buttonShadow = Shadow(color: Color.black.opacity(0.15), radius: 4, x: 0, y: 2)
}

struct Shadow {
    let color: Color
    let radius: CGFloat
    let x: CGFloat
    let y: CGFloat
}

================================================================================
FILE: frontend/ios/ios/ViewModels/HomeViewModel.swift
================================================================================

//
//  HomeViewModel.swift
//  ios
//
//  ViewModel for Home screen - MVVM Architecture
//

import Foundation
import Combine

@MainActor
class HomeViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var marketTickers: [MarketTicker] = []
    @Published var marketInsight: MarketInsight?
    @Published var dailyBriefings: [DailyBriefingItem] = []
    @Published var recentResearch: [ResearchReport] = []
    @Published var selectedTab: HomeTab = .home
    @Published var isLoading: Bool = false
    @Published var error: String?

    // MARK: - Initialization
    init() {
        loadMockData()
    }

    // MARK: - Data Loading
    func loadMockData() {
        isLoading = true

        // Simulate network delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
            self?.loadMarketTickers()
            self?.loadMarketInsight()
            self?.loadDailyBriefings()
            self?.loadRecentResearch()
            self?.isLoading = false
        }
    }

    func refresh() async {
        isLoading = true
        // Simulate API call
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        loadMockData()
    }

    // MARK: - Mock Data Loaders
    private func loadMarketTickers() {
        marketTickers = [
            MarketTicker(
                name: "S&P 500",
                price: 6783.45,
                changePercent: 0.85,
                sparklineData: generateSparklineData(positive: true)
            ),
            MarketTicker(
                name: "Nasdaq",
                price: 23293.23,
                changePercent: 0.85,
                sparklineData: generateSparklineData(positive: true)
            ),
            MarketTicker(
                name: "Bitcoin",
                price: 89394.43,
                changePercent: -2.34,
                sparklineData: generateSparklineData(positive: false)
            ),
            MarketTicker(
                name: "Gold",
                price: 4322.43,
                changePercent: -1.34,
                sparklineData: generateSparklineData(positive: false)
            )
        ]
    }

    private func loadMarketInsight() {
        marketInsight = MarketInsight(
            headline: "Tech Stocks Rally on Strong AI Earnings",
            bulletPoints: [
                "Major technology companies posted impressive Q4 results driven by AI infrastructure investments.",
                "Cloud computing revenue exceeded expectations, with Microsoft and Google leading the charge. Market sentiment remains bullish heading into 2024."
            ],
            sentiment: .bullish,
            updatedAt: Date().addingTimeInterval(-3600)
        )
    }

    private func loadDailyBriefings() {
        let calendar = Calendar.current
        var dateComponents = DateComponents()
        dateComponents.month = 2
        dateComponents.day = 24
        dateComponents.year = 2025
        let earningsDate = calendar.date(from: dateComponents)

        dailyBriefings = [
            DailyBriefingItem(
                type: .whalesAlert,
                title: "Whales Alert",
                subtitle: "Large crypto whale just moved $50M into COIN stock",
                date: nil,
                badgeText: nil
            ),
            DailyBriefingItem(
                type: .earningsAlert,
                title: "Earnings Alert",
                subtitle: "NVDA reports earnings tomorrow after market close.",
                date: earningsDate,
                badgeText: "24\nFEB"
            ),
            DailyBriefingItem(
                type: .whalesFollowing,
                title: "Whales Your Following",
                subtitle: "3 hedge funds you follow bought GOOGL this week. Avg. position size: $1.2B",
                date: nil,
                badgeText: nil
            ),
            DailyBriefingItem(
                type: .wiserTrending,
                title: "Wiser: Trending",
                subtitle: "How can I invest in OpenAI even though the company is not yet listed on the stock exchange?",
                date: nil,
                badgeText: nil
            )
        ]
    }

    private func loadRecentResearch() {
        recentResearch = [
            ResearchReport(
                stockTicker: "MSFT",
                stockName: "Microsoft",
                companyLogoName: "icon_microsoft",
                persona: .warrenBuffett,
                headline: "Microsoft: The AI Moat Deepens",
                summary: "Azure's AI services and UX Pilot AI partnership position MSFT as a dominant force in enterprise AI. Q4 cloud growth of 28% YoY signals strong market demand.",
                rating: 4.6,
                targetPrice: 425,
                createdAt: Date().addingTimeInterval(-10800),
                gradientColors: ["0078D4", "00BCF2"]
            ),
            ResearchReport(
                stockTicker: "GOOGL",
                stockName: "Google",
                companyLogoName: "icon_google",
                persona: .peterLynch,
                headline: "Google: Gemini's Market Impact",
                summary: "Gemini AI integration across products shows promise. Search market share stable while cloud business accelerates with 26% growth.",
                rating: 4.2,
                targetPrice: 155,
                createdAt: Date().addingTimeInterval(-345600),
                gradientColors: ["4285F4", "34A853"]
            ),
            ResearchReport(
                stockTicker: "AMD",
                stockName: "AMD",
                companyLogoName: "icon_amd",
                persona: .cathieWood,
                headline: "AMD: AI Chip Wars Heat Up",
                summary: "MI300 series gaining traction in data centers. While trailing NVIDIA, AMD's competitive pricing and supply availability create opportunities.",
                rating: 3.3,
                targetPrice: 23,
                createdAt: Date().addingTimeInterval(-432000),
                gradientColors: ["ED1C24", "FF6B6B"]
            )
        ]
    }

    // MARK: - Helpers
    private func generateSparklineData(positive: Bool) -> [Double] {
        var data: [Double] = []
        var value = Double.random(in: 90...110)

        for _ in 0..<20 {
            let change = Double.random(in: -3...3)
            let trend = positive ? 0.5 : -0.5
            value += change + trend
            value = max(80, min(120, value))
            data.append(value)
        }

        return data
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/InvestorPathViewModel.swift
================================================================================

// note
//  InvestorJourneyViewModel.swift
//  ios
// 
//  ViewModel for The Investor Journey screen - MVVM Architecture
//

import Foundation
import Combine

@MainActor
class InvestorJourneyViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var journeyData: InvestorJourneyData?
    @Published var studySchedule: StudySchedule = .defaultSchedule
    @Published var quote: InvestorQuote = .buffettQuote
    @Published var isLoading: Bool = false
    @Published var error: String?
    @Published var selectedLesson: Lesson?
    @Published var showLessonStory: Bool = false

    // MARK: - Computed Properties
    var totalLessonsCompleted: Int {
        journeyData?.totalLessonsCompleted ?? 0
    }

    var totalLessons: Int {
        journeyData?.totalLessons ?? 0
    }

    var levels: [LevelProgress] {
        journeyData?.levels ?? []
    }

    var nextLessonId: UUID? {
        // Find the first incomplete lesson across all levels
        for level in levels {
            if let firstIncomplete = level.firstIncompleteLessonId {
                return firstIncomplete
            }
        }
        return nil
    }

    var nextLessonLevelId: UUID? {
        // Find the level containing the first incomplete lesson
        for level in levels {
            if level.firstIncompleteLessonId != nil {
                return level.id
            }
        }
        return nil
    }

    // MARK: - Initialization
    init() {
        loadData()
    }

    // MARK: - Data Loading
    func loadData() {
        isLoading = true

        // Simulate network delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) { [weak self] in
            self?.journeyData = InvestorJourneyData.sampleData
            self?.isLoading = false
        }
    }

    func refresh() async {
        isLoading = true
        try? await Task.sleep(nanoseconds: 500_000_000)
        loadData()
    }

    // MARK: - Actions
    func selectLesson(_ lesson: Lesson) {
        selectedLesson = lesson
        showLessonStory = true
    }

    func dismissLessonStory() {
        showLessonStory = false
        selectedLesson = nil
    }

    /// Generate story content for a lesson
    func getStoryContent(for lesson: Lesson) -> LessonStoryContent {
        // Find the level containing this lesson
        let levelInfo = findLevelForLesson(lesson)

        // For now, return sample content based on the lesson title
        // In a real app, this would fetch from a backend or local storage
        return LessonStoryContent(
            lessonLabel: "LESSON \(levelInfo.lessonIndex + 1): \(lesson.title.uppercased())",
            lessonNumber: levelInfo.lessonIndex + 1,
            totalLessonsInLevel: levelInfo.totalInLevel,
            estimatedMinutes: lesson.durationMinutes,
            cards: generateCardsForLesson(lesson)
        )
    }

    private func findLevelForLesson(_ lesson: Lesson) -> (level: JourneyLevel, lessonIndex: Int, totalInLevel: Int) {
        for levelProgress in levels {
            if let index = levelProgress.lessons.firstIndex(where: { $0.id == lesson.id }) {
                return (levelProgress.level, index, levelProgress.lessons.count)
            }
        }
        return (.foundation, 0, 1)
    }

    private func generateCardsForLesson(_ lesson: Lesson) -> [LessonTopicCard] {
        // Generate appropriate cards based on the lesson
        // This is sample content - in production, this would come from a CMS or backend
        var cards: [LessonTopicCard] = []

        // Title card
        cards.append(.titleCard(
            title: lesson.title,
            subtitle: generateHighlightedSubtitle(from: lesson.description),
            audioText: lesson.description
        ))

        // Add 2-3 content cards based on the lesson
        let contentCards = generateContentCards(for: lesson)
        cards.append(contentsOf: contentCards)

        // Completion card
        cards.append(.completionCard(
            title: "You're ready.",
            subtitle: "You've learned the core idea. Practice with a real stock to reinforce it.",
            ctaDestination: determineCTADestination(for: lesson)
        ))

        return cards
    }

    private func generateHighlightedSubtitle(from description: String) -> [HighlightedTextSegment] {
        // Find a key word to highlight (first word or important term)
        let words = description.split(separator: " ")
        guard let firstWord = words.first else {
            return [.init(description)]
        }

        let rest = description.dropFirst(firstWord.count + 1)
        return [
            .init(String(firstWord), highlighted: true),
            .init(" " + rest)
        ]
    }

    private func generateContentCards(for lesson: Lesson) -> [LessonTopicCard] {
        // Generate content based on lesson title
        // This provides meaningful sample content for each lesson type
        switch lesson.title {
        case "The Buffett Way":
            return [
                .contentCard(
                    content: [
                        .init("Price is what the "),
                        .init("market", highlighted: true),
                        .init(" asks. Value is what the business is worth. The gap between them is where investing opportunities are found.")
                    ],
                    audioText: "Price is what the market asks. Value is what the business is worth. The gap between them is where investing opportunities are found."
                ),
                .contentCard(
                    content: [
                        .init("Price "),
                        .init("changes", highlighted: true),
                        .init(" with emotion. Value is anchored in fundamentals. Knowing the difference helps you invest, not speculate.")
                    ],
                    audioText: "Price changes with emotion. Value is anchored in fundamentals. Knowing the difference helps you invest, not speculate."
                )
            ]
        case "Compound Interest":
            return [
                .contentCard(
                    content: [
                        .init("Your money "),
                        .init("grows", highlighted: true),
                        .init(" on itself. Interest earns interest, creating a snowball effect over time.")
                    ],
                    audioText: "Your money grows on itself. Interest earns interest, creating a snowball effect over time."
                ),
                .contentCard(
                    content: [
                        .init("Time is your greatest "),
                        .init("ally", highlighted: true),
                        .init(". The earlier you start, the more powerful the compounding effect becomes.")
                    ],
                    audioText: "Time is your greatest ally. The earlier you start, the more powerful the compounding effect becomes."
                )
            ]
        case "Mr. Market":
            return [
                .contentCard(
                    content: [
                        .init("Imagine a "),
                        .init("moody", highlighted: true),
                        .init(" business partner who offers to buy or sell his share every day at different prices.")
                    ],
                    audioText: "Imagine a moody business partner who offers to buy or sell his share every day at different prices."
                ),
                .contentCard(
                    content: [
                        .init("You're not "),
                        .init("obligated", highlighted: true),
                        .init(" to trade with Mr. Market. Only act when the price is in your favor.")
                    ],
                    audioText: "You're not obligated to trade with Mr. Market. Only act when the price is in your favor."
                )
            ]
        default:
            // Generic content for other lessons
            return [
                .contentCard(
                    content: [
                        .init("Understanding this "),
                        .init("concept", highlighted: true),
                        .init(" is essential for making informed investment decisions.")
                    ],
                    audioText: "Understanding this concept is essential for making informed investment decisions."
                ),
                .contentCard(
                    content: [
                        .init("Apply this "),
                        .init("knowledge", highlighted: true),
                        .init(" to analyze real stocks and build your investment skills.")
                    ],
                    audioText: "Apply this knowledge to analyze real stocks and build your investment skills."
                )
            ]
        }
    }

    private func determineCTADestination(for lesson: Lesson) -> LessonCTADestination {
        // Determine appropriate CTA based on lesson content
        switch lesson.title {
        case "Key Statistics", "The Income Statement", "The Balance Sheet", "Cash Flow is King":
            return .analyzeStock
        case "Portfolio Gardening":
            return .viewPortfolio
        default:
            return .analyzeStock
        }
    }

    func openChatWithBook() {
        print("Opening chat with The Intelligent Investor")
        // Navigate to chat with book
    }

    func updateMorningSessionTime(_ date: Date) {
        studySchedule.morningSessionTime = date
        saveSchedule()
    }

    func updateReviewTime(_ date: Date) {
        studySchedule.reviewTime = date
        saveSchedule()
    }

    func toggleDailyReminder(_ enabled: Bool) {
        studySchedule.dailyReminderEnabled = enabled
        saveSchedule()
    }

    // MARK: - Private Methods
    private func saveSchedule() {
        // Save schedule to persistent storage
        print("Schedule updated: Daily reminder \(studySchedule.dailyReminderEnabled ? "enabled" : "disabled")")
        print("Morning session: \(studySchedule.formattedMorningTime)")
        print("Review time: \(studySchedule.formattedReviewTime)")
    }

    // MARK: - Level Access
    func getLevelProgress(for level: JourneyLevel) -> LevelProgress? {
        levels.first { $0.level == level }
    }

    // MARK: - Progress Tracking
    func markLessonCompleted(_ lesson: Lesson, in level: JourneyLevel) {
        // In a real app, this would update the backend and local state
        print("Marked lesson '\(lesson.title)' as completed in \(level.title)")
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/LearnViewModel.swift
================================================================================

//
//  LearnViewModel.swift
//  ios
//
//  ViewModel for Learn (Wiser) screen - MVVM Architecture
//

import Foundation
import Combine

@MainActor
class LearnViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var selectedTab: LearnTab = .learn
    @Published var currentLevel: InvestorLevel = .foundation
    @Published var journeyTrack: JourneyTrack?
    @Published var nextLesson: NextLesson?
    @Published var moneyMoves: [MoneyMove] = []
    @Published var books: [EducationBook] = []
    @Published var discussions: [CommunityDiscussion] = []
    @Published var creditBalance: CreditBalance?
    @Published var isLoading: Bool = false
    @Published var error: String?
    @Published var searchText: String = ""

    // MARK: - Initialization
    init() {
        loadMockData()
    }

    // MARK: - Data Loading
    func loadMockData() {
        isLoading = true

        // Simulate network delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) { [weak self] in
            self?.loadJourneyData()
            self?.loadNextLesson()
            self?.loadMoneyMoves()
            self?.loadBooks()
            self?.loadDiscussions()
            self?.loadCreditBalance()
            self?.isLoading = false
        }
    }

    func refresh() async {
        isLoading = true
        try? await Task.sleep(nanoseconds: 800_000_000)
        loadMockData()
    }

    // MARK: - Private Loaders
    private func loadJourneyData() {
        journeyTrack = JourneyTrack.sampleBeginner
        currentLevel = .foundation
    }

    private func loadNextLesson() {
        nextLesson = NextLesson.sampleData
    }

    private func loadMoneyMoves() {
        moneyMoves = MoneyMove.sampleData
    }

    private func loadBooks() {
        books = EducationBook.sampleData
    }

    private func loadDiscussions() {
        discussions = CommunityDiscussion.sampleData
    }

    private func loadCreditBalance() {
        creditBalance = CreditBalance(
            credits: 47,
            renewalDate: Calendar.current.date(from: DateComponents(year: 2025, month: 1, day: 1)) ?? Date()
        )
    }

    // MARK: - Actions
    func selectTab(_ tab: LearnTab) {
        selectedTab = tab
    }

    func toggleBookmark(for moneyMove: MoneyMove) {
        if let index = moneyMoves.firstIndex(where: { $0.id == moneyMove.id }) {
            let updatedMoneyMove = MoneyMove(
                title: moneyMove.title,
                subtitle: moneyMove.subtitle,
                category: moneyMove.category,
                estimatedMinutes: moneyMove.estimatedMinutes,
                learnerCount: moneyMove.learnerCount,
                isBookmarked: !moneyMove.isBookmarked
            )
            moneyMoves[index] = updatedMoneyMove
        }
    }

    func continueJourney() {
        print("Continue journey tapped")
    }

    func startLesson(_ lesson: NextLesson) {
        print("Start lesson: \(lesson.lessonTitle)")
    }

    func openMoneyMove(_ moneyMove: MoneyMove) {
        print("Open money move: \(moneyMove.title)")
    }

    func openBook(_ book: EducationBook) {
        print("Open book: \(book.title)")
    }

    func chatWithBook(_ book: EducationBook) {
        print("Chat with book: \(book.title)")
    }

    func readKeyIdeas(_ book: EducationBook) {
        print("Read key ideas: \(book.title)")
    }

    func openDiscussion(_ discussion: CommunityDiscussion) {
        print("Open discussion by: \(discussion.authorName)")
    }

    func addCredits() {
        print("Add credits tapped")
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/NewsDetailViewModel.swift
================================================================================

//
//  NewsDetailViewModel.swift
//  ios
//
//  ViewModel for the News Detail screen
//

import SwiftUI
import Combine

@MainActor
class NewsDetailViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var articleDetail: NewsArticleDetail?
    @Published var isLoading: Bool = false
    @Published var showShareSheet: Bool = false

    // MARK: - Private Properties
    private let article: NewsArticle

    // MARK: - Initialization
    init(article: NewsArticle) {
        self.article = article
        // Don't load immediately in init
    }

    // MARK: - Public Methods
    func loadArticleDetail() {
        isLoading = true

        // Simulate loading article details
        // In production, this would fetch from an API
        let mockTakeaways = generateMockTakeaways(for: article)

        // Create article detail immediately (we're already on MainActor)
        self.articleDetail = NewsArticleDetail(
            from: self.article,
            keyTakeaways: mockTakeaways,
            heroImageName: self.article.thumbnailName ?? "news_hero_placeholder",
            readTimeMinutes: 4,
            articleURL: URL(string: "https://example.com/article")
        )

        self.isLoading = false
    }

    func refresh() async {
        isLoading = true
        // Simulate network delay
        try? await Task.sleep(nanoseconds: 500_000_000)
        loadArticleDetail()
        isLoading = false
    }

    func openFullStory() {
        guard let url = articleDetail?.articleURL else { return }
        UIApplication.shared.open(url)
    }

    func shareArticle() {
        showShareSheet = true
    }

    // MARK: - Private Methods
    private func generateMockTakeaways(for article: NewsArticle) -> [KeyTakeaway] {
        // Generate contextual takeaways based on sentiment
        let takeaways: [String]

        switch article.sentiment {
        case .negative:
            takeaways = [
                "Despite record Q4 results, missing expectations signals slowing growth and weaker-than-hoped execution.",
                "A miss in a flagship quarter raises doubts about forward demand and near-term visibility.",
                "Leadership transition at this scale introduces strategic and execution risk during a critical AI cycle.",
                "With expectations priced for perfection, even a small miss could trigger outsized market pressure."
            ]
        case .positive:
            takeaways = [
                "Strong quarterly performance exceeded analyst expectations across all key metrics.",
                "Revenue growth acceleration signals robust demand and effective market positioning.",
                "Management's forward guidance suggests continued momentum in upcoming quarters.",
                "Institutional investors have increased positions, reflecting growing confidence."
            ]
        case .neutral:
            takeaways = [
                "Results came in line with market expectations, maintaining steady performance.",
                "No significant surprises in the earnings report, suggesting stability.",
                "Management guidance remains consistent with prior quarters.",
                "Market reaction has been muted as investors await more clarity."
            ]
        }

        return takeaways.enumerated().map { index, text in
            KeyTakeaway(index: index + 1, text: text)
        }
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/PriceActionViewModel.swift
================================================================================

//
//  PriceActionViewModel.swift
//  ios
//
//  ViewModel: Processes raw price data + optional event into display-ready context.
//  Smart Label Logic determines the most relevant timeframe and tag automatically.
//

import Foundation
import SwiftUI
import Combine

// MARK: - Output Context

struct PriceActionContext {
    let tag: String               // "Earnings Miss", "Sharp Decline", "Normal"
    let displayPercentage: String // "-12.4%"
    let percentValue: Double      // -12.4
    let timeLabel: String         // "Since Feb 2", "Last 5 Days", "Last 30 Days"
    let chartData: [Double]       // sparkline price array
    let eventIndex: Int?          // dot position in chartData (nil = no event)
    let narrative: String
    let isPositive: Bool

    var trendColor: Color { isPositive ? AppColors.bullish : AppColors.bearish }
}

// MARK: - ViewModel

class PriceActionViewModel: ObservableObject {
    @Published private(set) var context: PriceActionContext

    init(data: PriceActionData) {
        self.context = Self.process(data: data)
    }

    // MARK: - Smart Label Logic

    private static func process(data: PriceActionData) -> PriceActionContext {
        let prices = data.prices
        let current = data.currentPrice

        // 1) Event-driven: calculate change from event date
        if let event = data.event, event.index >= 0, event.index < prices.count {
            let eventPrice = prices[event.index]
            let pct = ((current - eventPrice) / eventPrice) * 100

            // Show a few points before the event for context
            let leadIn = 3
            let startIdx = max(0, event.index - leadIn)
            let chartSlice = Array(prices[startIdx...])
            let adjustedEventIdx = event.index - startIdx

            return PriceActionContext(
                tag: event.tag,
                displayPercentage: formatPercent(pct),
                percentValue: pct,
                timeLabel: "Since \(event.date)",
                chartData: chartSlice,
                eventIndex: adjustedEventIdx,
                narrative: data.narrative,
                isPositive: pct >= 0
            )
        }

        // 2) No event â€” check for significant momentum windows

        // > 5% move in last 5 days
        if prices.count >= 5 {
            let ref = prices[prices.count - 5]
            let pct = ((current - ref) / ref) * 100
            if abs(pct) > 5 {
                return PriceActionContext(
                    tag: pct > 0 ? "Rally" : "Sharp Decline",
                    displayPercentage: formatPercent(pct),
                    percentValue: pct,
                    timeLabel: "Last 5 Days",
                    chartData: Array(prices.suffix(7)),
                    eventIndex: nil,
                    narrative: data.narrative,
                    isPositive: pct >= 0
                )
            }
        }

        // > 10% move in last 15 days
        if prices.count >= 15 {
            let ref = prices[prices.count - 15]
            let pct = ((current - ref) / ref) * 100
            if abs(pct) > 10 {
                return PriceActionContext(
                    tag: pct > 0 ? "Momentum" : "Correction",
                    displayPercentage: formatPercent(pct),
                    percentValue: pct,
                    timeLabel: "Last 15 Days",
                    chartData: Array(prices.suffix(17)),
                    eventIndex: nil,
                    narrative: data.narrative,
                    isPositive: pct >= 0
                )
            }
        }

        // 3) Default: Last 30 Days â†’ Normal
        let count = min(30, prices.count)
        let ref = prices[prices.count - count]
        let pct = ((current - ref) / ref) * 100

        return PriceActionContext(
            tag: "Normal",
            displayPercentage: formatPercent(pct),
            percentValue: pct,
            timeLabel: "Last 30 Days",
            chartData: Array(prices.suffix(count)),
            eventIndex: nil,
            narrative: data.narrative,
            isPositive: pct >= 0
        )
    }

    private static func formatPercent(_ value: Double) -> String {
        String(format: "%+.1f%%", value)
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/ResearchViewModel.swift
================================================================================

//
//  ResearchViewModel.swift
//  ios
//
//  ViewModel for Research screen - MVVM Architecture
//

import Foundation
import Combine

@MainActor
class ResearchViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var selectedTab: ResearchTab = .research
    @Published var searchText: String = ""
    @Published var quickTickers: [QuickTicker] = QuickTicker.defaults
    @Published var personas: [AnalysisPersona] = AnalysisPersona.allCases
    @Published var selectedPersona: AnalysisPersona = .warrenBuffett
    @Published var features: [AnalysisFeature] = AnalysisFeature.allFeatures
    @Published var creditBalance: CreditBalance = .mock
    @Published var trendingAnalyses: [TrendingAnalysis] = TrendingAnalysis.mockTrending
    @Published var analysisCost: AnalysisCost = .standard
    @Published var isLoading: Bool = false
    @Published var isGeneratingAnalysis: Bool = false
    @Published var error: String?

    // Reports Tab Properties
    @Published var reports: [AnalysisReport] = AnalysisReport.mockReports
    @Published var reportSortOption: ReportSortOption = .dateNewest {
        didSet {
            sortReports()
        }
    }
    @Published var communityInsights: [CommunityInsight] = CommunityInsight.mockInsights

    // MARK: - Initialization
    init(prefilledTicker: String? = nil) {
        if let ticker = prefilledTicker {
            _searchText = Published(initialValue: ticker)
        }
        loadMockData()
        sortReports()
    }

    // MARK: - Data Loading
    func loadMockData() {
        isLoading = true

        // Simulate network delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) { [weak self] in
            self?.quickTickers = QuickTicker.defaults
            self?.personas = AnalysisPersona.allCases
            self?.features = AnalysisFeature.allFeatures
            self?.trendingAnalyses = TrendingAnalysis.mockTrending
            self?.isLoading = false
        }
    }

    func refresh() async {
        isLoading = true
        // Simulate API call
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        loadMockData()
    }

    // MARK: - Actions
    func selectPersona(_ persona: AnalysisPersona) {
        selectedPersona = persona
    }

    func selectQuickTicker(_ ticker: QuickTicker) {
        searchText = ticker.symbol
    }

    func generateAnalysis() {
        guard !searchText.isEmpty else { return }
        guard creditBalance.credits >= analysisCost.credits else {
            error = "Insufficient credits"
            return
        }

        isGeneratingAnalysis = true

        // Simulate analysis generation
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { [weak self] in
            self?.isGeneratingAnalysis = false
            // In real app, navigate to results or update state
            print("Analysis generated for \(self?.searchText ?? "") using \(self?.selectedPersona.rawValue ?? "") style")
        }
    }

    func addMoreCredits() {
        // Navigate to purchase flow
        print("Add more credits tapped")
    }

    func exploreTrending() {
        // Navigate to trending analyses
        print("Explore trending tapped")
    }

    func selectTrendingAnalysis(_ analysis: TrendingAnalysis) {
        searchText = analysis.title
        print("Selected trending: \(analysis.title)")
    }

    func viewAllPersonas() {
        print("View all personas tapped")
    }

    // MARK: - Reports Tab Actions
    func sortReports() {
        switch reportSortOption {
        case .dateNewest:
            reports.sort { $0.date > $1.date }
        case .dateOldest:
            reports.sort { $0.date < $1.date }
        case .ratingHigh:
            reports.sort { ($0.rating ?? 0) > ($1.rating ?? 0) }
        case .ratingLow:
            reports.sort { ($0.rating ?? 0) < ($1.rating ?? 0) }
        }
    }

    func openReport(_ report: AnalysisReport) {
        guard report.status == .ready else { return }
        print("Opening report: \(report.companyName)")
    }

    func retryReport(_ report: AnalysisReport) {
        guard report.status == .failed else { return }
        print("Retrying report: \(report.companyName)")
    }

    func joinDiscussion() {
        print("Join discussion tapped")
    }

    func likeInsight(_ insight: CommunityInsight) {
        print("Liked insight from: \(insight.userName)")
    }

    func commentOnInsight(_ insight: CommunityInsight) {
        print("Comment on insight from: \(insight.userName)")
    }

    func shareInsight(_ insight: CommunityInsight) {
        print("Share insight from: \(insight.userName)")
    }

    // MARK: - Computed Properties
    var canGenerateAnalysis: Bool {
        !searchText.isEmpty && creditBalance.credits >= analysisCost.credits
    }

    var selectedPersonaDescription: String {
        selectedPersona.description
    }

    var analysisStyleTitle: String {
        "\(selectedPersona.rawValue.components(separatedBy: " ").last ?? "") Style Analysis"
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/SearchViewModel.swift
================================================================================

//
//  SearchViewModel.swift
//  ios
//
//  ViewModel for Search screen - MVVM Architecture
//

import Foundation
import Combine

@MainActor
class SearchViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var searchText: String = ""
    @Published var querySuggestions: [SearchQuerySuggestion] = []
    @Published var recentSearches: [SearchResultItem] = []
    @Published var latestNews: [SearchNewsItem] = []
    @Published var books: [SearchBookItem] = []
    @Published var isLoading: Bool = false
    @Published var error: String?

    // MARK: - Initialization
    init() {
        loadMockData()
    }

    // MARK: - Data Loading
    func loadMockData() {
        isLoading = true

        // Simulate network delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) { [weak self] in
            self?.loadQuerySuggestions()
            self?.loadRecentSearches()
            self?.loadLatestNews()
            self?.loadBooks()
            self?.isLoading = false
        }
    }

    func refresh() async {
        isLoading = true
        try? await Task.sleep(nanoseconds: 800_000_000)
        loadMockData()
    }

    // MARK: - Private Loaders
    private func loadQuerySuggestions() {
        querySuggestions = SearchQuerySuggestion.sampleData
    }

    private func loadRecentSearches() {
        recentSearches = SearchResultItem.sampleData
    }

    private func loadLatestNews() {
        latestNews = SearchNewsItem.sampleData
    }

    private func loadBooks() {
        books = SearchBookItem.sampleData
    }

    // MARK: - Actions
    func performSearch() {
        guard !searchText.isEmpty else { return }
        print("Searching for: \(searchText)")
        // In a real app, this would trigger an API call
    }

    func selectSuggestion(_ suggestion: SearchQuerySuggestion) {
        searchText = suggestion.text
        performSearch()
    }

    func selectSearchResult(_ item: SearchResultItem) {
        print("Selected: \(item.name)")
        // Navigate to detail view
    }

    func toggleFollow(for item: SearchResultItem) {
        if let index = recentSearches.firstIndex(where: { $0.id == item.id }) {
            let updatedItem = SearchResultItem(
                type: item.type,
                ticker: item.ticker,
                name: item.name,
                subtitle: item.subtitle,
                imageName: item.imageName,
                isFollowable: item.isFollowable,
                isFollowing: !item.isFollowing
            )
            recentSearches[index] = updatedItem
        }
    }

    func clearAllRecentSearches() {
        recentSearches.removeAll()
    }

    func openNewsItem(_ item: SearchNewsItem) {
        print("Opening news: \(item.headline)")
    }

    func openBook(_ book: SearchBookItem) {
        print("Opening book: \(book.title)")
    }

    func chatWithBook(_ book: SearchBookItem) {
        print("Chat with book: \(book.title)")
    }

    func readKeyIdeas(_ book: SearchBookItem) {
        print("Read key ideas: \(book.title)")
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/TickerDetailViewModel.swift
================================================================================

//
//  TickerDetailViewModel.swift
//  ios
//
//  ViewModel for the Ticker Detail screen
//

import Foundation
import SwiftUI
import Combine

@MainActor
class TickerDetailViewModel: ObservableObject {
    // MARK: - Published Properties

    @Published var tickerData: TickerDetailData?
    @Published var newsArticles: [TickerNewsArticle] = []
    @Published var analysisData: TickerAnalysisData?
    @Published var earningsData: EarningsData?
    @Published var growthData: GrowthSectionData?
    @Published var profitPowerData: ProfitPowerSectionData?
    @Published var signalOfConfidenceData: SignalOfConfidenceSectionData?
    @Published var revenueBreakdownData: RevenueBreakdownData?
    @Published var healthCheckData: HealthCheckSectionData?
    @Published var holdersData: HoldersData?
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published var selectedTab: TickerDetailTab = .overview
    @Published var selectedChartRange: ChartTimeRange = .threeMonths
    @Published var isFavorite: Bool = false
    @Published var aiInputText: String = ""

    // Analysis tab state
    @Published var selectedMomentumPeriod: AnalystMomentumPeriod = .sixMonths
    @Published var selectedSentimentTimeframe: SentimentTimeframe = .last24h

    // MARK: - Private Properties

    private let tickerSymbol: String

    // MARK: - Initialization

    init(tickerSymbol: String) {
        self.tickerSymbol = tickerSymbol
    }

    // MARK: - Public Methods

    func loadTickerData() {
        isLoading = true
        errorMessage = nil

        // Simulate API call with sample data
        // In production, this would fetch from your backend
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
            guard let self = self else { return }

            // For demo, use sample data
            self.tickerData = TickerDetailData.sampleApple
            self.newsArticles = TickerNewsArticle.sampleDataForTicker(self.tickerSymbol)
            self.analysisData = TickerAnalysisData.sampleData
            self.earningsData = EarningsData.sampleData
            self.growthData = GrowthSectionData.sampleData
            self.profitPowerData = ProfitPowerSectionData.sampleData
            self.signalOfConfidenceData = SignalOfConfidenceSectionData.sampleData
            self.revenueBreakdownData = RevenueBreakdownData.sampleApple
            self.healthCheckData = HealthCheckSectionData.sampleData
            self.holdersData = HoldersData.sampleData
            self.isLoading = false
        }
    }

    func refresh() async {
        loadTickerData()
    }

    func toggleFavorite() {
        isFavorite.toggle()
        // TODO: Persist favorite state to backend/local storage
    }

    func handleNotificationTap() {
        // TODO: Navigate to notification settings for this ticker
        print("Notification settings for \(tickerSymbol)")
    }

    func handleMoreOptions() {
        // TODO: Show more options action sheet
        print("More options for \(tickerSymbol)")
    }

    func handleDeepResearch() {
        // TODO: Navigate to AI Deep Research view
        print("AI Deep Research for \(tickerSymbol)")
    }

    func handleWebsiteTap() {
        guard let website = tickerData?.companyProfile.website,
              let url = URL(string: "https://\(website)") else { return }

        UIApplication.shared.open(url)
    }

    func handleRelatedTickerTap(_ ticker: RelatedTicker) {
        // TODO: Navigate to related ticker detail
        print("Navigate to \(ticker.symbol)")
    }

    func handleNewsArticleTap(_ article: TickerNewsArticle) {
        // TODO: Navigate to full news detail view
        print("Open news article: \(article.headline)")
    }

    func handleNewsExternalLink(_ article: TickerNewsArticle) {
        guard let url = article.articleURL else { return }
        UIApplication.shared.open(url)
    }

    func handleNewsTickerTap(_ ticker: String) {
        // TODO: Navigate to ticker detail for the related ticker
        print("Navigate to ticker: \(ticker)")
    }

    func handleSuggestionTap(_ suggestion: TickerAISuggestion) {
        aiInputText = suggestion.text
    }

    func handleAISend() {
        guard !aiInputText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }

        // TODO: Send AI query
        print("AI Query: \(aiInputText)")
        aiInputText = ""
    }

    func updateChartRange(_ range: ChartTimeRange) {
        selectedChartRange = range
        // TODO: Fetch new chart data for selected range
    }

    // MARK: - Analysis Tab Handlers

    func handleAnalystRatingsMore() {
        // TODO: Show more analyst ratings options
        print("Analyst ratings more options for \(tickerSymbol)")
    }

    func handleSentimentMore() {
        // TODO: Show more sentiment analysis options
        print("Sentiment analysis more options for \(tickerSymbol)")
    }

    func handleTechnicalDetail() {
        // TODO: Navigate to detailed technical analysis view
        print("Technical analysis detail for \(tickerSymbol)")
    }

    // MARK: - Financials Tab Handlers

    func handleEarningsDetail() {
        // TODO: Navigate to detailed earnings view
        print("Earnings detail for \(tickerSymbol)")
    }

    func handleGrowthDetail() {
        // TODO: Navigate to detailed growth view
        print("Growth detail for \(tickerSymbol)")
    }

    func handleProfitPowerDetail() {
        // TODO: Navigate to detailed profit power view
        print("Profit power detail for \(tickerSymbol)")
    }

    func handleSignalOfConfidenceDetail() {
        // TODO: Navigate to detailed signal of confidence view
        print("Signal of confidence detail for \(tickerSymbol)")
    }

    func handleRevenueBreakdownDetail() {
        // TODO: Navigate to detailed revenue breakdown view
        print("Revenue breakdown detail for \(tickerSymbol)")
    }

    func handleHealthCheckDetail() {
        // TODO: Navigate to detailed health check view
        print("Health check detail for \(tickerSymbol)")
    }

    // MARK: - Computed Properties

    var formattedPrice: String {
        tickerData?.formattedPrice ?? "--"
    }

    var formattedChange: String {
        tickerData?.formattedChange ?? "--"
    }

    var formattedChangePercent: String {
        tickerData?.formattedChangePercent ?? "--"
    }

    var isPositive: Bool {
        tickerData?.isPositive ?? true
    }

    var chartData: [Double] {
        tickerData?.chartData ?? []
    }

    var aiSuggestions: [TickerAISuggestion] {
        TickerAISuggestion.defaultSuggestions
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/TickerReportViewModel.swift
================================================================================

//
//  TickerReportViewModel.swift
//  ios
//
//  ViewModel for the Ticker Report screen - MVVM Architecture
//

import Foundation
import Combine

@MainActor
class TickerReportViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var reportData: TickerReportData?
    @Published var isLoading: Bool = false
    @Published var error: String?

    // Deep Dive Section Expansion States
    @Published var expandedSections: Set<DeepDiveModuleType> = []

    // MARK: - Private Properties
    private let ticker: String

    // Deep Dive Modules - stored once to avoid regenerating UUIDs on every access
    let deepDiveModules: [DeepDiveModule] = [
        DeepDiveModule(title: "Recent Price Movement", iconName: "chart.xyaxis.line", type: .recentPriceMovement),
        DeepDiveModule(title: "The Revenue Engine", iconName: "dollarsign.circle", type: .revenueEngine),
        DeepDiveModule(title: "Fundamentals & Growth", iconName: "chart.bar.fill", type: .fundamentalsGrowth),
        DeepDiveModule(title: "Future Forecast", iconName: "binoculars.fill", type: .futureForecast),
        DeepDiveModule(title: "Insider & Management", iconName: "person.2.fill", type: .insiderManagement),
        DeepDiveModule(title: "Industry & Competitive Moat", iconName: "shield.fill", type: .moatCompetition),
        DeepDiveModule(title: "Macro-Economic & Geopolitical", iconName: "globe", type: .macroGeopolitical),
        DeepDiveModule(title: "Wall Street Consensus", iconName: "building.columns.fill", type: .wallStreetConsensus)
    ]

    // MARK: - Initialization
    init(ticker: String) {
        self.ticker = ticker
        loadReport()
    }

    // MARK: - Data Loading
    func loadReport() {
        isLoading = true
        // Simulate network delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
            self?.reportData = TickerReportData.sampleOracle
            self?.isLoading = false
        }
    }

    func refresh() async {
        isLoading = true
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        loadReport()
    }

    // MARK: - Section Toggle
    func toggleSection(_ type: DeepDiveModuleType) {
        if expandedSections.contains(type) {
            expandedSections.remove(type)
        } else {
            expandedSections.insert(type)
        }
    }

    func isSectionExpanded(_ type: DeepDiveModuleType) -> Bool {
        expandedSections.contains(type)
    }

    // MARK: - Actions
    func shareTapped() {
        print("Share report tapped for \(ticker)")
    }

    func viewDetailedAnalysis() {
        print("View detailed analysis tapped for \(ticker)")
    }

    func chatWithReport() {
        print("Chat with report tapped for \(ticker)")
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/TrackingViewModel.swift
================================================================================

//
//  TrackingViewModel.swift
//  ios
//
//  ViewModel for the Tracking screen
//

import Foundation
import SwiftUI
import Combine

@MainActor
class TrackingViewModel: ObservableObject {
    // MARK: - Private
    private var cancellables = Set<AnyCancellable>()

    // MARK: - Published Properties

    // Tab State
    @Published var selectedTab: TrackingTab = .assets
    @Published var searchText: String = ""

    // Assets Tab
    @Published var trackedAssets: [TrackedAsset] = TrackedAsset.sampleData
    @Published var sortOption: AssetSortOption = .name
    @Published var sortAscending: Bool = true

    // Alerts & Events
    @Published var alertEvents: [AlertEvent] = AlertEvent.sampleData
    @Published var smartMoneyAlert: SmartMoneyAlert? = SmartMoneyAlert.sampleData

    // Portfolio Insights
    @Published var diversificationScore: DiversificationScore? = DiversificationScore.sampleData

    // Whales Tab
    @Published var selectedWhaleCategory: WhaleCategory = .investors
    @Published var whaleActivities: [WhaleActivity] = WhaleActivity.sampleData
    @Published var trackedWhales: [TrendingWhale] = TrendingWhale.trackedWhalesData
    @Published var popularWhales: [TrendingWhale] = TrendingWhale.topPopularWhalesData
    @Published var heroWhales: [TrendingWhale] = TrendingWhale.heroWhalesData
    @Published var allPopularWhales: [TrendingWhale] = TrendingWhale.allPopularWhalesData
    @Published var showAllWhales: Bool = false
    @Published var showAllTrades: Bool = false
    @Published var groupedWhaleTrades: [GroupedWhaleTrades] = WhaleTradeGroupActivity.groupedSampleData
    @Published var allWhaleTrades: [GroupedWhaleTrades] = WhaleTradeGroupActivity.allGroupedSampleData
    @Published var whaleAlertBanner: WhaleAlertBanner? = WhaleAlertBanner.sampleData

    // Loading States
    @Published var isLoading: Bool = false
    @Published var isRefreshing: Bool = false

    // Sheet States
    @Published var showAddAssetSheet: Bool = false
    @Published var showSortSheet: Bool = false
    
    // Navigation States
    @Published var selectedTickerSymbol: String?
    @Published var selectedWhaleId: String?
    @Published var selectedTradeGroup: TradeGroupNavigation?

    // MARK: - Init

    init() {
        NotificationCenter.default.publisher(for: .whaleFollowStateChanged)
            .receive(on: RunLoop.main)
            .sink { [weak self] notification in
                self?.handleFollowStateChange(notification)
            }
            .store(in: &cancellables)
    }

    // MARK: - Computed Properties

    var filteredAssets: [TrackedAsset] {
        var assets = trackedAssets

        // Apply search filter
        if !searchText.isEmpty {
            assets = assets.filter { asset in
                asset.ticker.localizedCaseInsensitiveContains(searchText) ||
                asset.companyName.localizedCaseInsensitiveContains(searchText)
            }
        }

        // Apply sorting
        switch sortOption {
        case .name:
            assets.sort { sortAscending ? $0.ticker < $1.ticker : $0.ticker > $1.ticker }
        case .price:
            assets.sort { sortAscending ? $0.price < $1.price : $0.price > $1.price }
        case .change:
            assets.sort { sortAscending ? $0.changePercent < $1.changePercent : $0.changePercent > $1.changePercent }
        case .marketCap:
            // For now, sort by price as proxy for market cap
            assets.sort { sortAscending ? $0.price < $1.price : $0.price > $1.price }
        }

        return assets
    }

    var filteredWhaleActivities: [WhaleActivity] {
        // Filter by category if needed
        // For now, return all activities
        whaleActivities
    }

    // MARK: - Actions

    func refresh() async {
        isRefreshing = true
        // Simulate network delay
        try? await Task.sleep(nanoseconds: 1_500_000_000)

        // In a real app, fetch data from API here
        // For now, we use sample data

        isRefreshing = false
    }

    func loadData() async {
        isLoading = true
        // Simulate initial load
        try? await Task.sleep(nanoseconds: 800_000_000)
        isLoading = false
    }

    func addNewAsset() {
        showAddAssetSheet = true
    }

    func openSortOptions() {
        showSortSheet = true
    }

    func toggleSort() {
        sortAscending.toggle()
    }

    func selectSortOption(_ option: AssetSortOption) {
        sortOption = option
        showSortSheet = false
    }

    func removeAsset(_ asset: TrackedAsset) {
        trackedAssets.removeAll { $0.id == asset.id }
    }

    func selectWhaleCategory(_ category: WhaleCategory) {
        selectedWhaleCategory = category
        // Reload whale activities based on category
    }

    func toggleFollowWhale(_ whale: TrendingWhale) {
        let newFollowing = !whale.isFollowing
        let updatedWhale = TrendingWhale(
            name: whale.name,
            category: whale.category,
            avatarName: whale.avatarName,
            followersCount: whale.followersCount,
            isFollowing: newFollowing,
            title: whale.title,
            description: whale.description,
            recentTradeCount: whale.recentTradeCount
        )

        // Update isFollowing in-place across all lists (don't remove)
        if let index = popularWhales.firstIndex(where: { $0.name == whale.name }) {
            popularWhales[index] = updatedWhale
        }
        if let index = allPopularWhales.firstIndex(where: { $0.name == whale.name }) {
            allPopularWhales[index] = updatedWhale
        }
        if let index = heroWhales.firstIndex(where: { $0.name == whale.name }) {
            heroWhales[index] = updatedWhale
        }

        if newFollowing {
            // Add to tracked whales if not already there
            if !trackedWhales.contains(where: { $0.name == whale.name }) {
                trackedWhales.append(updatedWhale)
            }
        } else {
            // Remove from tracked whales
            trackedWhales.removeAll { $0.name == whale.name }
        }
    }

    // MARK: - Follow State Sync

    private func handleFollowStateChange(_ notification: Notification) {
        guard let userInfo = notification.userInfo,
              let isFollowing = userInfo["isFollowing"] as? Bool else { return }

        let whaleId = userInfo["whaleId"] as? String ?? ""
        let whaleName = userInfo["whaleName"] as? String ?? ""

        // Match whale by ID (slug) first, then fall back to name
        func nameToId(_ name: String) -> String {
            name.lowercased().replacingOccurrences(of: " ", with: "-")
        }
        func matches(_ whale: TrendingWhale) -> Bool {
            nameToId(whale.name) == whaleId || whale.name == whaleName
        }

        // Helper to create an updated whale with new follow state
        func makeUpdated(_ whale: TrendingWhale, following: Bool) -> TrendingWhale {
            TrendingWhale(
                name: whale.name,
                category: whale.category,
                avatarName: whale.avatarName,
                followersCount: whale.followersCount,
                isFollowing: following,
                title: whale.title,
                description: whale.description,
                recentTradeCount: whale.recentTradeCount
            )
        }

        // Update isFollowing in-place across all discovery lists
        if let index = popularWhales.firstIndex(where: { matches($0) }) {
            popularWhales[index] = makeUpdated(popularWhales[index], following: isFollowing)
        }
        if let index = allPopularWhales.firstIndex(where: { matches($0) }) {
            allPopularWhales[index] = makeUpdated(allPopularWhales[index], following: isFollowing)
        }
        if let index = heroWhales.firstIndex(where: { matches($0) }) {
            heroWhales[index] = makeUpdated(heroWhales[index], following: isFollowing)
        }

        if isFollowing {
            // Already tracked â€” nothing to do
            guard !trackedWhales.contains(where: { matches($0) }) else { return }

            // Find whale data from any list to copy into tracked
            if let whale = allPopularWhales.first(where: { matches($0) }) {
                trackedWhales.append(makeUpdated(whale, following: true))
            } else if let whale = heroWhales.first(where: { matches($0) }) {
                trackedWhales.append(makeUpdated(whale, following: true))
            } else {
                // Whale not in any list â€” create from notification data
                let title = userInfo["whaleTitle"] as? String ?? ""
                let newWhale = TrendingWhale(
                    name: whaleName,
                    category: .investors,
                    avatarName: "",
                    followersCount: 0,
                    isFollowing: true,
                    title: title
                )
                trackedWhales.append(newWhale)
            }
        } else {
            // Unfollowing â€” remove from tracked
            trackedWhales.removeAll { matches($0) }
        }
    }

    func viewMorePopularWhales() {
        showAllWhales = true
    }

    func viewMoreRecentTrades() {
        showAllTrades = true
    }

    func viewAssetDetail(_ asset: TrackedAsset) {
        selectedTickerSymbol = asset.ticker
    }

    func viewAlertDetail(_ alert: AlertEvent) {
        print("View alert detail: \(alert.title)")
    }

    func viewWhaleDetail(_ activity: WhaleActivity) {
        // Convert entity name to whale ID format
        selectedWhaleId = activity.entityName.lowercased().replacingOccurrences(of: " ", with: "-")
    }

    func viewWhaleProfile(_ whale: TrendingWhale) {
        selectedWhaleId = whale.name.lowercased().replacingOccurrences(of: " ", with: "-")
    }

    func viewTradeGroupDetail(_ activity: WhaleTradeGroupActivity) {
        // Create a WhaleTradeGroup from the activity
        // In a real app, you'd fetch the full trade group data from your API
        // For now, we'll create sample data based on the activity
        
        let tradeGroup = WhaleTradeGroup(
            id: UUID().uuidString,
            date: activity.date,
            tradeCount: activity.tradeCount,
            netAction: activity.action == .bought ? .bought : .sold,
            netAmount: parseAmount(activity.totalAmount),
            summary: activity.summary,
            insights: generateInsights(for: activity),
            trades: generateSampleTrades(for: activity)
        )
        
        selectedTradeGroup = TradeGroupNavigation(tradeGroup: tradeGroup, whaleName: activity.entityName)
    }
    
    // Helper to parse amount string like "$4.34B" to Double
    private func parseAmount(_ amountString: String) -> Double {
        let cleaned = amountString.replacingOccurrences(of: "$", with: "").replacingOccurrences(of: ",", with: "")
        
        if let value = Double(cleaned.dropLast()) {
            let suffix = cleaned.last
            switch suffix {
            case "B": return value * 1_000_000_000
            case "M": return value * 1_000_000
            case "K": return value * 1_000
            default: return Double(cleaned) ?? 0
            }
        }
        return 0
    }
    
    // Generate sample insights
    private func generateInsights(for activity: WhaleTradeGroupActivity) -> [String] {
        var insights: [String] = []
        
        if activity.tradeCount > 5 {
            insights.append("High trading activity detected")
        }
        
        if activity.action == .bought {
            insights.append("Bullish positioning in this sector")
        } else {
            insights.append("Portfolio rebalancing activity")
        }
        
        return insights
    }
    
    // Generate sample trades
    private func generateSampleTrades(for activity: WhaleTradeGroupActivity) -> [WhaleTrade] {
        // Generate sample trades based on the activity
        let tickers = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA", "NVDA"]
        let companies = ["Apple Inc.", "Microsoft", "Alphabet Inc.", "Amazon", "Tesla", "NVIDIA"]
        
        return (0..<min(activity.tradeCount, 6)).map { index in
            let tradeType: WhaleTradeType = {
                let random = Int.random(in: 0...3)
                switch random {
                case 0: return .new
                case 1: return .increased
                case 2: return .decreased
                default: return .closed
                }
            }()
            
            let previousAllocation = Double.random(in: 0...15)
            let newAllocation: Double
            
            switch tradeType {
            case .new:
                newAllocation = Double.random(in: 1...10)
            case .increased:
                newAllocation = previousAllocation + Double.random(in: 1...5)
            case .decreased:
                newAllocation = max(0, previousAllocation - Double.random(in: 1...5))
            case .closed:
                newAllocation = 0
            }
            
            return WhaleTrade(
                id: UUID().uuidString,
                ticker: tickers[index % tickers.count],
                companyName: companies[index % companies.count],
                action: activity.action == .bought ? .bought : .sold,
                tradeType: tradeType,
                amount: Double.random(in: 1000000...50000000),
                previousAllocation: previousAllocation,
                newAllocation: newAllocation,
                date: activity.date
            )
        }
    }

    func viewWhaleAlert() {
        print("View whale alert tapped")
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/TradeGroupDetailViewModel.swift
================================================================================

//
//  TradeGroupDetailViewModel.swift
//  ios
//
//  ViewModel for the Trade Group Detail screen
//

import Foundation
import SwiftUI
import Combine

class TradeGroupDetailViewModel: ObservableObject {
    // MARK: - Published Properties

    @Published var tradeGroup: WhaleTradeGroup
    @Published var selectedFilter: TradeFilterTab = .all
    @Published var selectedTickerSymbol: String?

    let whaleName: String

    // MARK: - Computed Properties

    var filteredTrades: [WhaleTrade] {
        switch selectedFilter {
        case .all:
            return tradeGroup.trades
        case .new:
            return tradeGroup.trades.filter { $0.tradeType == .new }
        case .increased:
            return tradeGroup.trades.filter { $0.tradeType == .increased }
        case .decreased:
            return tradeGroup.trades.filter { $0.tradeType == .decreased }
        case .closed:
            return tradeGroup.trades.filter { $0.tradeType == .closed }
        }
    }

    var filterCounts: [TradeFilterTab: Int] {
        var counts: [TradeFilterTab: Int] = [:]
        counts[.all] = tradeGroup.trades.count
        counts[.new] = tradeGroup.trades.filter { $0.tradeType == .new }.count
        counts[.increased] = tradeGroup.trades.filter { $0.tradeType == .increased }.count
        counts[.decreased] = tradeGroup.trades.filter { $0.tradeType == .decreased }.count
        counts[.closed] = tradeGroup.trades.filter { $0.tradeType == .closed }.count
        return counts
    }

    // MARK: - Initialization

    init(tradeGroup: WhaleTradeGroup, whaleName: String) {
        self.tradeGroup = tradeGroup
        self.whaleName = whaleName
    }

    // MARK: - Actions

    func selectFilter(_ filter: TradeFilterTab) {
        withAnimation(.easeInOut(duration: 0.2)) {
            selectedFilter = filter
        }
    }

    func viewTrade(_ trade: WhaleTrade) {
        selectedTickerSymbol = trade.ticker
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/UpdatesViewModel.swift
================================================================================

//
//  UpdatesViewModel.swift
//  ios
//
//  ViewModel for Updates/News screen - MVVM Architecture
//

import Foundation
import Combine

@MainActor
class UpdatesViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var filterTabs: [NewsFilterTab] = []
    @Published var selectedTab: NewsFilterTab?
    @Published var insightSummary: NewsInsightSummary?
    @Published var newsArticles: [NewsArticle] = []
    @Published var groupedNews: [GroupedNews] = []
    @Published var filterOptions: NewsFilterOptions = .default
    @Published var isLoading: Bool = false
    @Published var isRefreshing: Bool = false
    @Published var error: String?
    @Published var showFilterSheet: Bool = false

    // MARK: - Private Properties
    private var allNewsArticles: [NewsArticle] = []
    private var stockSummaries: [String: NewsInsightSummary] = [:]

    // MARK: - Initialization
    init() {
        loadMockData()
    }

    // MARK: - Data Loading
    func loadMockData() {
        isLoading = true

        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
            self?.loadFilterTabs()
            self?.loadAllStockSummaries()
            self?.loadAllNewsArticles()
            self?.updateContentForSelectedTab()
            self?.isLoading = false
        }
    }

    func refresh() async {
        isRefreshing = true
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        loadMockData()
        isRefreshing = false
    }

    func selectTab(_ tab: NewsFilterTab) {
        selectedTab = tab
        loadNewsForTab(tab)
    }

    func addNewTicker() {
        // Navigate to ticker search
        print("Add new ticker tapped")
    }

    func openFilterOptions() {
        showFilterSheet = true
    }

    // MARK: - Private Methods
    private func loadFilterTabs() {
        filterTabs = [
            NewsFilterTab(
                title: "Market",
                ticker: nil,
                changePercent: nil,
                isMarketTab: true
            ),
            NewsFilterTab(
                title: "AAPL",
                ticker: "AAPL",
                changePercent: 2.4,
                isMarketTab: false
            ),
            NewsFilterTab(
                title: "TSLA",
                ticker: "TSLA",
                changePercent: -1.2,
                isMarketTab: false
            )
        ]
        selectedTab = filterTabs.first
    }

    private func loadAllStockSummaries() {
        // Market Summary (default)
        stockSummaries["Market"] = NewsInsightSummary(
            headline: "Tech Stocks Rally on Strong AI Earnings",
            bulletPoints: [
                "Major technology companies posted impressive Q4 results driven by AI infrastructure investments.",
                "Cloud computing revenue exceeded expectations, with Microsoft and Google leading the charge. Market sentiment remains bullish heading into 2024."
            ],
            sentiment: .bullish,
            updatedAt: Date().addingTimeInterval(-3600),
            summaryType: "24h - AI Summary"
        )

        // AAPL Summary
        stockSummaries["AAPL"] = NewsInsightSummary(
            headline: "Apple's AI Strategy Drives Strong Momentum",
            bulletPoints: [
                "Apple Intelligence features in iOS 18 are seeing strong adoption with 78% of new iPhone users enabling AI capabilities.",
                "Services revenue hit $25B quarterly record, with App Store and Apple Music leading growth. Analysts raised price targets citing AI monetization potential."
            ],
            sentiment: .bullish,
            updatedAt: Date().addingTimeInterval(-1800),
            summaryType: "AAPL - AI Summary"
        )

        // TSLA Summary
        stockSummaries["TSLA"] = NewsInsightSummary(
            headline: "Tesla Delivery Numbers Beat Expectations",
            bulletPoints: [
                "Q4 deliveries reached 484,000 units, surpassing analyst estimates of 473,000. Model Y remains the best-selling EV globally.",
                "FSD v12 rollout accelerating with 2M+ miles driven. Energy storage deployments grew 125% YoY, diversifying revenue streams."
            ],
            sentiment: .bullish,
            updatedAt: Date().addingTimeInterval(-2700),
            summaryType: "TSLA - AI Summary"
        )
    }

    private func loadAllNewsArticles() {
        let calendar = Calendar.current
        let now = Date()

        // Today's timestamps
        let today1 = calendar.date(bySettingHour: 14, minute: 45, second: 0, of: now)!
        let today2 = calendar.date(bySettingHour: 14, minute: 1, second: 0, of: now)!
        let today3 = calendar.date(bySettingHour: 9, minute: 45, second: 0, of: now)!
        let today4 = calendar.date(bySettingHour: 11, minute: 30, second: 0, of: now)!
        let today5 = calendar.date(bySettingHour: 10, minute: 15, second: 0, of: now)!

        // Yesterday's timestamps
        let yesterday = calendar.date(byAdding: .day, value: -1, to: now)!
        let yesterday1 = calendar.date(bySettingHour: 16, minute: 30, second: 0, of: yesterday)!
        let yesterday2 = calendar.date(bySettingHour: 11, minute: 15, second: 0, of: yesterday)!
        let yesterday3 = calendar.date(bySettingHour: 14, minute: 20, second: 0, of: yesterday)!
        let yesterday4 = calendar.date(bySettingHour: 9, minute: 45, second: 0, of: yesterday)!

        // Older articles (2 days ago)
        let twoDaysAgo = calendar.date(byAdding: .day, value: -2, to: now)!
        let older1 = calendar.date(bySettingHour: 10, minute: 0, second: 0, of: twoDaysAgo)!
        let older2 = calendar.date(bySettingHour: 15, minute: 30, second: 0, of: twoDaysAgo)!
        let older3 = calendar.date(bySettingHour: 13, minute: 45, second: 0, of: twoDaysAgo)!

        allNewsArticles = [
            // ===== MARKET NEWS =====
            NewsArticle(
                headline: "Oil prices stabilize as OPEC + members agreed to maintain current production levels.",
                summary: nil,
                source: NewsSource(name: "Reuters", iconName: "icon_reuters"),
                sentiment: .neutral,
                publishedAt: today1,
                thumbnailName: "news_oil_opec",
                relatedTickers: ["XOM", "CVX", "BP"]
            ),
            NewsArticle(
                headline: "NVIDIA Announces Record Q4 Earnings, Missed Expectations and CEO step down",
                summary: nil,
                source: NewsSource(name: "CNBC", iconName: "icon_cnbc"),
                sentiment: .negative,
                publishedAt: today2,
                thumbnailName: "news_nvidia",
                relatedTickers: ["NVDA"]
            ),
            NewsArticle(
                headline: "Fed signals potential rate cuts in early 2025 amid cooling inflation data.",
                summary: nil,
                source: NewsSource(name: "WSJ", iconName: "icon_wsj"),
                sentiment: .positive,
                publishedAt: yesterday2,
                thumbnailName: "news_fed",
                relatedTickers: ["SPY", "QQQ"]
            ),
            NewsArticle(
                headline: "Microsoft Azure revenue grows 29% YoY driven by AI workloads and enterprise adoption.",
                summary: nil,
                source: NewsSource(name: "MarketWatch", iconName: "icon_marketwatch"),
                sentiment: .positive,
                publishedAt: older1,
                thumbnailName: "news_microsoft",
                relatedTickers: ["MSFT"]
            ),

            // ===== APPLE (AAPL) NEWS =====
            NewsArticle(
                headline: "Apple Unveils Revolutionary AI Features in iOS 18 Beta and increase 20% profit for the next year.",
                summary: nil,
                source: NewsSource(name: "Zacks", iconName: "icon_zacks"),
                sentiment: .positive,
                publishedAt: today3,
                thumbnailName: "news_apple",
                relatedTickers: ["AAPL"]
            ),
            NewsArticle(
                headline: "Apple's Services Revenue Hits Record $25 Billion in Q4, App Store Growth Accelerates",
                summary: nil,
                source: NewsSource(name: "Bloomberg", iconName: "icon_bloomberg"),
                sentiment: .positive,
                publishedAt: today4,
                thumbnailName: "news_apple",
                relatedTickers: ["AAPL"]
            ),
            NewsArticle(
                headline: "iPhone 16 Pro Max Demand Exceeds Supply, Apple Increases Production Orders by 10%",
                summary: nil,
                source: NewsSource(name: "CNBC", iconName: "icon_cnbc"),
                sentiment: .positive,
                publishedAt: yesterday3,
                thumbnailName: "news_apple",
                relatedTickers: ["AAPL"]
            ),
            NewsArticle(
                headline: "Apple Intelligence Features See 78% Adoption Rate Among New iPhone Users",
                summary: nil,
                source: NewsSource(name: "Reuters", iconName: "icon_reuters"),
                sentiment: .positive,
                publishedAt: yesterday4,
                thumbnailName: "news_apple",
                relatedTickers: ["AAPL"]
            ),
            NewsArticle(
                headline: "Apple Expands Partnership with TSMC for 2nm Chip Production in 2025",
                summary: nil,
                source: NewsSource(name: "WSJ", iconName: "icon_wsj"),
                sentiment: .positive,
                publishedAt: older2,
                thumbnailName: "news_apple",
                relatedTickers: ["AAPL", "TSM"]
            ),

            // ===== TESLA (TSLA) NEWS =====
            NewsArticle(
                headline: "Tesla reports strong Q4 deliveries beating Wall Street estimates by 15%.",
                summary: nil,
                source: NewsSource(name: "Bloomberg", iconName: "icon_bloomberg"),
                sentiment: .positive,
                publishedAt: yesterday1,
                thumbnailName: "news_tesla",
                relatedTickers: ["TSLA"]
            ),
            NewsArticle(
                headline: "Tesla's Full Self-Driving V12 Reaches 2 Million Miles Driven Without Intervention",
                summary: nil,
                source: NewsSource(name: "CNBC", iconName: "icon_cnbc"),
                sentiment: .positive,
                publishedAt: today5,
                thumbnailName: "news_tesla",
                relatedTickers: ["TSLA"]
            ),
            NewsArticle(
                headline: "Tesla Energy Storage Deployments Surge 125% YoY, Megapack Demand Exceeds Supply",
                summary: nil,
                source: NewsSource(name: "Reuters", iconName: "icon_reuters"),
                sentiment: .positive,
                publishedAt: yesterday4,
                thumbnailName: "news_tesla",
                relatedTickers: ["TSLA"]
            ),
            NewsArticle(
                headline: "Tesla Cybertruck Production Ramps Up, Deliveries Begin in European Markets",
                summary: nil,
                source: NewsSource(name: "MarketWatch", iconName: "icon_marketwatch"),
                sentiment: .positive,
                publishedAt: older3,
                thumbnailName: "news_tesla",
                relatedTickers: ["TSLA"]
            ),
            NewsArticle(
                headline: "Elon Musk Confirms Tesla Robotaxi Event Scheduled for Q2 2025",
                summary: nil,
                source: NewsSource(name: "Bloomberg", iconName: "icon_bloomberg"),
                sentiment: .positive,
                publishedAt: older1,
                thumbnailName: "news_tesla",
                relatedTickers: ["TSLA"]
            )
        ]
    }

    private func loadNewsForTab(_ tab: NewsFilterTab) {
        isLoading = true

        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) { [weak self] in
            self?.updateContentForSelectedTab()
            self?.isLoading = false
        }
    }

    private func updateContentForSelectedTab() {
        guard let tab = selectedTab else { return }

        // Update AI Summary based on selected tab
        let summaryKey = tab.isMarketTab ? "Market" : (tab.ticker ?? "Market")
        insightSummary = stockSummaries[summaryKey]
        
        print("ðŸ”„ UpdatesViewModel: Loading content for tab '\(tab.title)' with ticker '\(tab.ticker ?? "nil")'")

        // Filter news articles based on selected tab
        if tab.isMarketTab {
            // Market tab shows all general market news (excluding stock-specific)
            newsArticles = allNewsArticles.filter { article in
                // Show articles that are general market news
                let generalMarketTickers = ["XOM", "CVX", "BP", "NVDA", "SPY", "QQQ", "MSFT"]
                return article.relatedTickers.contains { generalMarketTickers.contains($0) }
            }
        } else if let ticker = tab.ticker {
            // Stock-specific tab shows only news for that ticker
            newsArticles = allNewsArticles.filter { article in
                article.relatedTickers.contains(ticker)
            }
        } else {
            newsArticles = allNewsArticles
        }
        
        print("ðŸ“° Found \(newsArticles.count) articles for '\(tab.title)'")

        groupNewsArticles()
    }

    private func groupNewsArticles() {
        var groups: [String: [NewsArticle]] = [:]

        for article in newsArticles {
            let sectionTitle = article.sectionTitle
            if groups[sectionTitle] == nil {
                groups[sectionTitle] = []
            }
            groups[sectionTitle]?.append(article)
        }

        // Sort groups by date (TODAY first)
        let sortedKeys = groups.keys.sorted { key1, key2 in
            if key1 == "TODAY" { return true }
            if key2 == "TODAY" { return false }
            if key1 == "YESTERDAY" { return true }
            if key2 == "YESTERDAY" { return false }
            return key1 > key2
        }

        groupedNews = sortedKeys.map { key in
            GroupedNews(
                sectionTitle: key,
                articles: groups[key]?.sorted { $0.publishedAt > $1.publishedAt } ?? []
            )
        }
    }
}

================================================================================
FILE: frontend/ios/ios/ViewModels/WhaleProfileViewModel.swift
================================================================================

//
//  WhaleProfileViewModel.swift
//  ios
//
//  ViewModel for the Whale Profile screen
//

import Foundation
import SwiftUI
import Combine

@MainActor
class WhaleProfileViewModel: ObservableObject {
    // MARK: - Published Properties

    @Published var profile: WhaleProfile?
    @Published var isLoading: Bool = false
    @Published var isRefreshing: Bool = false
    @Published var errorMessage: String?

    // Navigation
    @Published var selectedTickerSymbol: String?
    @Published var selectedTradeGroupId: String?
    @Published var showAllHoldings: Bool = false
    @Published var showRecentTradesInfo: Bool = false

    // MARK: - Configuration

    private let whaleId: String
    private let maxVisibleHoldings: Int = 10
    private let maxVisibleTrades: Int = 5
    private let whaleService = WhaleService.shared
    private var cancellables = Set<AnyCancellable>()

    // MARK: - Computed Properties

    var displayedHoldings: [WhaleHolding] {
        guard let profile = profile else { return [] }
        if showAllHoldings {
            return profile.currentHoldings
        }
        return Array(profile.currentHoldings.prefix(maxVisibleHoldings))
    }

    var displayedTradeGroups: [WhaleTradeGroup] {
        guard let profile = profile else { return [] }
        return profile.recentTradeGroups
    }

    var hasMoreHoldings: Bool {
        guard let profile = profile else { return false }
        return profile.currentHoldings.count > maxVisibleHoldings
    }

    func tradeGroup(for id: String) -> WhaleTradeGroup? {
        profile?.recentTradeGroups.first { $0.id == id }
    }

    // MARK: - Initialization

    init(whaleId: String) {
        self.whaleId = whaleId
        loadProfile()
        observeFollowChanges()
    }
    
    // MARK: - Observation
    
    private func observeFollowChanges() {
        // Update profile when follow status changes in the shared service
        whaleService.$followedWhaleIds
            .sink { [weak self] _ in
                self?.updateFollowStatus()
            }
            .store(in: &cancellables)
    }
    
    private func updateFollowStatus() {
        guard var currentProfile = profile else { return }
        let isFollowing = whaleService.isFollowing(whaleId)
        
        if currentProfile.isFollowing != isFollowing {
            currentProfile = WhaleProfile(
                id: currentProfile.id,
                name: currentProfile.name,
                title: currentProfile.title,
                description: currentProfile.description,
                avatarURL: currentProfile.avatarURL,
                riskProfile: currentProfile.riskProfile,
                portfolioValue: currentProfile.portfolioValue,
                ytdReturn: currentProfile.ytdReturn,
                sectorExposure: currentProfile.sectorExposure,
                currentHoldings: currentProfile.currentHoldings,
                recentTradeGroups: currentProfile.recentTradeGroups,
                recentTrades: currentProfile.recentTrades,
                behaviorSummary: currentProfile.behaviorSummary,
                sentimentSummary: currentProfile.sentimentSummary,
                isFollowing: isFollowing
            )
            profile = currentProfile
        }
    }

    // MARK: - Data Loading

    func loadProfile() {
        isLoading = true
        errorMessage = nil

        // Simulate network delay and load mock data
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
            guard let self = self else { return }

            // In a real app, fetch from API based on whaleId
            var loadedProfile: WhaleProfile?
            switch self.whaleId {
            case "warren-buffett":
                loadedProfile = WhaleProfile.warrenBuffett
            case "cathie-wood":
                loadedProfile = WhaleProfile.cathieWood
            default:
                loadedProfile = WhaleProfile.warrenBuffett
            }
            
            // Update follow status from shared service
            if var profile = loadedProfile {
                let isFollowing = self.whaleService.isFollowing(self.whaleId)
                profile = WhaleProfile(
                    id: profile.id,
                    name: profile.name,
                    title: profile.title,
                    description: profile.description,
                    avatarURL: profile.avatarURL,
                    riskProfile: profile.riskProfile,
                    portfolioValue: profile.portfolioValue,
                    ytdReturn: profile.ytdReturn,
                    sectorExposure: profile.sectorExposure,
                    currentHoldings: profile.currentHoldings,
                    recentTradeGroups: profile.recentTradeGroups,
                    recentTrades: profile.recentTrades,
                    behaviorSummary: profile.behaviorSummary,
                    sentimentSummary: profile.sentimentSummary,
                    isFollowing: isFollowing
                )
                self.profile = profile
            }

            self.isLoading = false
        }
    }

    func refresh() async {
        isRefreshing = true

        // Simulate network delay
        try? await Task.sleep(nanoseconds: 1_000_000_000)

        // Reload profile data
        loadProfile()

        isRefreshing = false
    }

    // MARK: - Actions

    func toggleFollow() {
        guard let currentProfile = profile else { return }
        let newFollowState = !currentProfile.isFollowing
        let updatedProfile = WhaleProfile(
            id: currentProfile.id,
            name: currentProfile.name,
            title: currentProfile.title,
            description: currentProfile.description,
            avatarURL: currentProfile.avatarURL,
            riskProfile: currentProfile.riskProfile,
            portfolioValue: currentProfile.portfolioValue,
            ytdReturn: currentProfile.ytdReturn,
            sectorExposure: currentProfile.sectorExposure,
            currentHoldings: currentProfile.currentHoldings,
            recentTradeGroups: currentProfile.recentTradeGroups,
            recentTrades: currentProfile.recentTrades,
            behaviorSummary: currentProfile.behaviorSummary,
            sentimentSummary: currentProfile.sentimentSummary,
            isFollowing: newFollowState
        )
        profile = updatedProfile

        // Notify TrackingViewModel so the followed whales row stays in sync
        NotificationCenter.default.post(
            name: .whaleFollowStateChanged,
            object: nil,
            userInfo: [
                "whaleId": whaleId,
                "whaleName": currentProfile.name,
                "whaleTitle": currentProfile.title,
                "isFollowing": newFollowState
            ]
        )
    }

    func viewHolding(_ holding: WhaleHolding) {
        selectedTickerSymbol = holding.ticker
    }

    func viewTradeGroup(_ group: WhaleTradeGroup) {
        selectedTradeGroupId = group.id
    }

    func viewMoreHoldings() {
        showAllHoldings = true
    }

    func showOptionsMenu() {
        // Handle options menu
        print("Options menu tapped")
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AIBadge.swift
================================================================================

//
//  AIBadge.swift
//  ios
//
//  Atom: AI Summary badge indicator
//

import SwiftUI

struct AIBadge: View {
    let text: String

    var body: some View {
        Text(text)
            .font(AppTypography.captionBold)
            .foregroundColor(AppColors.accentCyan)
            .padding(.horizontal, AppSpacing.sm)
            .padding(.vertical, AppSpacing.xs)
            .background(AppColors.accentCyan.opacity(0.15))
            .clipShape(Capsule())
    }
}

#Preview {
    VStack(spacing: 10) {
        AIBadge(text: "24h - AI Summary")
        AIBadge(text: "AI Generated")
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AIVoiceOrb.swift
================================================================================

//
//  AIVoiceOrb.swift
//  ios
//
//  Atom: Animated AI voice orb similar to Siri visualization
//  Displays a glowing, animated sphere that indicates AI is speaking
//

import SwiftUI

struct AIVoiceOrb: View {
    let isAnimating: Bool
    var size: CGFloat = 120

    @State private var phase: CGFloat = 0
    @State private var innerPhase: CGFloat = 0
    @State private var glowOpacity: Double = 0.6
    @State private var pulseScale: CGFloat = 1.0
    
    @StateObject private var voiceManager = AIVoiceManager.shared

    // Gradient colors for the orb
    private let primaryGradient = LinearGradient(
        colors: [
            Color(hex: "06B6D4"),   // Cyan
            Color(hex: "3B82F6"),   // Blue
            Color(hex: "8B5CF6"),   // Purple
            Color(hex: "EC4899")    // Pink
        ],
        startPoint: .topLeading,
        endPoint: .bottomTrailing
    )

    private let innerGradient = LinearGradient(
        colors: [
            Color(hex: "06B6D4").opacity(0.8),
            Color(hex: "3B82F6").opacity(0.6),
            Color(hex: "EC4899").opacity(0.4)
        ],
        startPoint: .top,
        endPoint: .bottom
    )

    var body: some View {
        ZStack {
            // Outer glow
            Circle()
                .fill(
                    RadialGradient(
                        colors: [
                            Color(hex: "06B6D4").opacity(0.3),
                            Color(hex: "3B82F6").opacity(0.1),
                            Color.clear
                        ],
                        center: .center,
                        startRadius: size * 0.3,
                        endRadius: size * 0.8
                    )
                )
                .frame(width: size * 1.6, height: size * 1.6)
                .opacity(glowOpacity)
                .scaleEffect(pulseScale)

            // Main orb background
            Circle()
                .fill(
                    RadialGradient(
                        colors: [
                            Color(hex: "1E3A5F"),
                            Color(hex: "0F172A")
                        ],
                        center: .center,
                        startRadius: 0,
                        endRadius: size * 0.5
                    )
                )
                .frame(width: size, height: size)
                .scaleEffect(pulseScale)

            // Wave layers
            ForEach(0..<3, id: \.self) { index in
                WaveLayer(
                    phase: phase + CGFloat(index) * 0.3,
                    amplitude: isAnimating ? 8 + CGFloat(index) * 2 : 3,
                    frequency: 3 - CGFloat(index) * 0.5
                )
                .stroke(
                    LinearGradient(
                        colors: [
                            Color(hex: "06B6D4").opacity(0.6 - Double(index) * 0.15),
                            Color(hex: "EC4899").opacity(0.4 - Double(index) * 0.1)
                        ],
                        startPoint: .leading,
                        endPoint: .trailing
                    ),
                    lineWidth: 2 - CGFloat(index) * 0.5
                )
                .frame(width: size * 0.7, height: size * 0.3)
                .offset(y: CGFloat(index - 1) * 8)
                .scaleEffect(pulseScale)
            }

            // Inner highlight
            Circle()
                .fill(
                    RadialGradient(
                        colors: [
                            Color.white.opacity(0.15),
                            Color.clear
                        ],
                        center: UnitPoint(x: 0.3, y: 0.3),
                        startRadius: 0,
                        endRadius: size * 0.4
                    )
                )
                .frame(width: size * 0.9, height: size * 0.9)
                .scaleEffect(pulseScale)

            // Rim gradient
            Circle()
                .strokeBorder(
                    AngularGradient(
                        colors: [
                            Color(hex: "06B6D4").opacity(0.5),
                            Color(hex: "3B82F6").opacity(0.3),
                            Color(hex: "8B5CF6").opacity(0.4),
                            Color(hex: "EC4899").opacity(0.5),
                            Color(hex: "06B6D4").opacity(0.5)
                        ],
                        center: .center,
                        startAngle: .degrees(phase * 50),
                        endAngle: .degrees(phase * 50 + 360.0)
                    ),
                    lineWidth: 2
                )
                .frame(width: size, height: size)
                .scaleEffect(pulseScale)
        }
        .onAppear {
            startAnimations()
        }
        .onChange(of: isAnimating) { _, newValue in
            if newValue {
                startAnimations()
            }
        }
        .onChange(of: voiceManager.currentWordRange) { _, _ in
            // Pulse on each word change
            if isAnimating {
                pulseBeat()
            }
        }
    }

    private func startAnimations() {
        // Wave phase animation
        withAnimation(
            .linear(duration: 2)
            .repeatForever(autoreverses: false)
        ) {
            phase = .pi * 2
        }

        // Glow pulse animation
        withAnimation(
            .easeInOut(duration: 1.5)
            .repeatForever(autoreverses: true)
        ) {
            glowOpacity = isAnimating ? 0.8 : 0.4
        }
    }
    
    /// Create a quick pulse/beat effect
    private func pulseBeat() {
        // Quick scale up then back to normal
        withAnimation(.easeOut(duration: 0.1)) {
            pulseScale = 1.15
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            withAnimation(.easeIn(duration: 0.15)) {
                pulseScale = 1.0
            }
        }
    }
}

// MARK: - Wave Layer Shape

struct WaveLayer: Shape {
    var phase: CGFloat
    var amplitude: CGFloat
    var frequency: CGFloat

    var animatableData: CGFloat {
        get { phase }
        set { phase = newValue }
    }

    func path(in rect: CGRect) -> Path {
        var path = Path()
        let midY = rect.midY
        let width = rect.width

        path.move(to: CGPoint(x: 0, y: midY))

        for x in stride(from: 0, through: width, by: 1) {
            let relativeX = x / width
            let sine = sin((relativeX * frequency * .pi * 2) + phase)
            let y = midY + sine * amplitude
            path.addLine(to: CGPoint(x: x, y: y))
        }

        return path
    }
}

#Preview {
    VStack(spacing: 40) {
        AIVoiceOrb(isAnimating: true, size: 120)
        AIVoiceOrb(isAnimating: false, size: 80)
    }
    .frame(maxWidth: .infinity, maxHeight: .infinity)
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AlertCategoryIcon.swift
================================================================================

//
//  AlertCategoryIcon.swift
//  ios
//
//  Atom: Icon for alert/event categories
//

import SwiftUI

struct AlertCategoryIcon: View {
    let type: AlertEventType
    var size: CGFloat = 40

    private var iconSize: CGFloat {
        size * 0.45
    }

    var body: some View {
        ZStack {
            Circle()
                .fill(type.iconBackgroundColor.opacity(0.15))
                .frame(width: size, height: size)

            Image(systemName: type.systemIconName)
                .font(.system(size: iconSize, weight: .semibold))
                .foregroundColor(type.iconBackgroundColor)
        }
    }
}

#Preview {
    HStack(spacing: 20) {
        AlertCategoryIcon(type: .earnings)
        AlertCategoryIcon(type: .market)
        AlertCategoryIcon(type: .smartMoney)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AlertIconView.swift
================================================================================

//
//  AlertIconView.swift
//  ios
//
//  Atom: Icon container for alert types
//

import SwiftUI

struct AlertIconView: View {
    let type: AlertType

    private var backgroundColor: Color {
        switch type {
        case .whalesAlert:
            return AppColors.alertOrange
        case .earningsAlert:
            return AppColors.alertBlue
        case .whalesFollowing:
            return AppColors.alertBlue
        case .wiserTrending:
            return AppColors.alertPurple
        }
    }

    var body: some View {
        ZStack {
            Circle()
                .fill(backgroundColor.opacity(0.2))
                .frame(width: 40, height: 40)

            Image(systemName: type.systemIconName)
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(backgroundColor)
        }
    }
}

#Preview {
    HStack(spacing: 20) {
        AlertIconView(type: .whalesAlert)
        AlertIconView(type: .earningsAlert)
        AlertIconView(type: .whalesFollowing)
        AlertIconView(type: .wiserTrending)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AnalysisConsensusBadge.swift
================================================================================

//
//  AnalysisConsensusBadge.swift
//  ios
//
//  Badge displaying analyst consensus rating (STRONG BUY, BUY, etc.)
//

import SwiftUI

struct AnalysisConsensusBadge: View {
    let consensus: AnalystConsensus

    var body: some View {
        Text(consensus.rawValue)
            .font(AppTypography.title2)
            .fontWeight(.bold)
            .foregroundColor(consensus.color)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.lg) {
            AnalysisConsensusBadge(consensus: .strongBuy)
            AnalysisConsensusBadge(consensus: .buy)
            AnalysisConsensusBadge(consensus: .hold)
            AnalysisConsensusBadge(consensus: .sell)
            AnalysisConsensusBadge(consensus: .strongSell)
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AnalysisSectionHeader.swift
================================================================================

//
//  AnalysisSectionHeader.swift
//  ios
//
//  Header for analysis sections with title and optional action button
//

import SwiftUI

struct AnalysisSectionHeader: View {
    let title: String
    let subtitle: String?
    let actionText: String?
    let onAction: (() -> Void)?
    let showMoreButton: Bool

    init(
        title: String,
        subtitle: String? = nil,
        actionText: String? = nil,
        onAction: (() -> Void)? = nil,
        showMoreButton: Bool = true
    ) {
        self.title = title
        self.subtitle = subtitle
        self.actionText = actionText
        self.onAction = onAction
        self.showMoreButton = showMoreButton
    }

    var body: some View {
        HStack(alignment: .top) {
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                if let subtitle = subtitle {
                    Text(subtitle)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }
            }

            Spacer()

            if let actionText = actionText, let onAction = onAction {
                Button(action: onAction) {
                    Text(actionText)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
            } else if showMoreButton {
                Button {
                    onAction?()
                } label: {
                    Image(systemName: "ellipsis")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                        .frame(width: 24, height: 24)
                }
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            AnalysisSectionHeader(
                title: "Analyst Ratings",
                subtitle: "Total Analysts 40\nUpdated On 01/05/2026 ET"
            )

            AnalysisSectionHeader(
                title: "Sentiment Analysis"
            )

            AnalysisSectionHeader(
                title: "Technical Analysis",
                actionText: "Detail",
                onAction: {}
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AnalysisTimeframeToggle.swift
================================================================================

//
//  AnalysisTimeframeToggle.swift
//  ios
//
//  Toggle button for switching between timeframes (6M/1Y, 24H/7D)
//

import SwiftUI

struct AnalysisTimeframeToggle<T: RawRepresentable & CaseIterable & Equatable>: View where T.RawValue == String, T.AllCases: RandomAccessCollection {
    @Binding var selectedOption: T
    let options: [T]

    var body: some View {
        HStack(spacing: 0) {
            ForEach(options, id: \.rawValue) { option in
                Button {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedOption = option
                    }
                } label: {
                    Text(option.rawValue)
                        .font(AppTypography.captionBold)
                        .foregroundColor(selectedOption == option ? AppColors.textPrimary : AppColors.textSecondary)
                        .padding(.horizontal, AppSpacing.md)
                        .padding(.vertical, AppSpacing.sm)
                        .background(
                            selectedOption == option ?
                            AppColors.cardBackgroundLight : Color.clear
                        )
                        .cornerRadius(AppCornerRadius.small)
                }
            }
        }
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.small)
        .overlay(
            RoundedRectangle(cornerRadius: AppCornerRadius.small)
                .stroke(AppColors.cardBackgroundLight, lineWidth: 1)
        )
    }
}

// MARK: - Specific Toggle for Momentum Period
struct MomentumPeriodToggle: View {
    @Binding var selectedPeriod: AnalystMomentumPeriod

    var body: some View {
        AnalysisTimeframeToggle(
            selectedOption: $selectedPeriod,
            options: AnalystMomentumPeriod.allCases.map { $0 }
        )
    }
}

// MARK: - Specific Toggle for Sentiment Timeframe
struct SentimentTimeframeToggleView: View {
    @Binding var selectedTimeframe: SentimentTimeframe

    var body: some View {
        AnalysisTimeframeToggle(
            selectedOption: $selectedTimeframe,
            options: SentimentTimeframe.allCases.map { $0 }
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            MomentumPeriodToggle(selectedPeriod: .constant(.sixMonths))
            SentimentTimeframeToggleView(selectedTimeframe: .constant(.last24h))
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AnalystActionBadge.swift
================================================================================

//
//  AnalystActionBadge.swift
//  ios
//
//  Badge showing analyst action counts (Upgrades, Maintains, Downgrades)
//

import SwiftUI

enum AnalystSummaryActionType: String {
    case upgrades = "Upgrades"
    case maintains = "Maintains"
    case downgrades = "Downgrades"

    var iconName: String {
        switch self {
        case .upgrades: return "arrow.up"
        case .maintains: return "equal"
        case .downgrades: return "arrow.down"
        }
    }

    var color: Color {
        switch self {
        case .upgrades: return AppColors.bullish
        case .maintains: return AppColors.textSecondary
        case .downgrades: return AppColors.bearish
        }
    }
}

struct AnalystActionBadge: View {
    let actionType: AnalystSummaryActionType
    let count: Int

    var body: some View {
        VStack(spacing: AppSpacing.xs) {
            // Icon and count
            HStack(spacing: AppSpacing.xs) {
                Image(systemName: actionType.iconName)
                    .font(.system(size: 10, weight: .bold))
                    .foregroundColor(actionType.color)

                Text("\(count)")
                    .font(AppTypography.footnoteBold)
                    .foregroundColor(AppColors.textPrimary)
            }

            // Label
            Text(actionType.rawValue)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, AppSpacing.md)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
        .overlay(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .stroke(AppColors.cardBackgroundLight, lineWidth: 1)
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.md) {
            AnalystActionBadge(actionType: .upgrades, count: 9)
            AnalystActionBadge(actionType: .maintains, count: 8)
            AnalystActionBadge(actionType: .downgrades, count: 2)
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AnalystActionTypeBadge.swift
================================================================================

//
//  AnalystActionTypeBadge.swift
//  ios
//
//  Badge displaying analyst action type (UPGRADE, DOWNGRADE, MAINTAIN, etc.)
//

import SwiftUI

struct AnalystActionTypeBadge: View {
    let actionType: AnalystActionType

    var body: some View {
        Text(actionType.rawValue)
            .font(AppTypography.captionBold)
            .foregroundColor(badgeTextColor)
            .padding(.horizontal, AppSpacing.sm)
            .padding(.vertical, AppSpacing.xs)
            .background(badgeBackground)
            .cornerRadius(AppCornerRadius.small)
    }

    private var badgeTextColor: Color {
        switch actionType {
        case .upgrade:
            return AppColors.bullish
        case .downgrade:
            return AppColors.bearish
        case .maintain, .initiated, .reiterated:
            return AppColors.textSecondary
        }
    }

    private var badgeBackground: Color {
        switch actionType {
        case .upgrade:
            return AppColors.bullish.opacity(0.15)
        case .downgrade:
            return AppColors.bearish.opacity(0.15)
        case .maintain, .initiated, .reiterated:
            return Color.clear
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.lg) {
            AnalystActionTypeBadge(actionType: .upgrade)
            AnalystActionTypeBadge(actionType: .downgrade)
            AnalystActionTypeBadge(actionType: .maintain)
            AnalystActionTypeBadge(actionType: .initiated)
            AnalystActionTypeBadge(actionType: .reiterated)
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ArticleActionButton.swift
================================================================================

//
//  ArticleActionButton.swift
//  ios
//
//  Atom: Action button for article interactions (Listen, Share, etc.)
//

import SwiftUI

struct ArticleActionButton: View {
    let icon: String
    let label: String
    var isActive: Bool = false
    var style: ActionButtonStyle = .standard
    var onTap: (() -> Void)?

    enum ActionButtonStyle {
        case standard
        case primary
        case compact

        var backgroundColor: Color {
            switch self {
            case .standard: return AppColors.cardBackgroundLight
            case .primary: return AppColors.primaryBlue
            case .compact: return Color.clear
            }
        }

        var foregroundColor: Color {
            switch self {
            case .standard: return AppColors.textSecondary
            case .primary: return .white
            case .compact: return AppColors.textSecondary
            }
        }
    }

    var body: some View {
        Button(action: { onTap?() }) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: icon)
                    .font(.system(size: style == .compact ? 16 : 14, weight: .medium))

                if style != .compact {
                    Text(label)
                        .font(AppTypography.caption)
                }
            }
            .foregroundColor(isActive ? AppColors.primaryBlue : style.foregroundColor)
            .padding(.horizontal, style == .compact ? AppSpacing.sm : AppSpacing.md)
            .padding(.vertical, style == .compact ? AppSpacing.sm : AppSpacing.sm)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                    .fill(style.backgroundColor)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        HStack(spacing: AppSpacing.md) {
            ArticleActionButton(icon: "headphones", label: "Listen")
            ArticleActionButton(icon: "square.and.arrow.up", label: "Share")
            ArticleActionButton(icon: "bookmark", label: "Save", isActive: true)
        }

        HStack(spacing: AppSpacing.md) {
            ArticleActionButton(icon: "iphone", label: "Mobile Post", style: .primary)
            ArticleActionButton(icon: "bolt.fill", label: "Instant", style: .primary)
        }

        HStack(spacing: AppSpacing.md) {
            ArticleActionButton(icon: "heart", label: "", style: .compact)
            ArticleActionButton(icon: "bubble.left", label: "", style: .compact)
            ArticleActionButton(icon: "arrow.2.squarepath", label: "", style: .compact)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ArticleAuthorAvatar.swift
================================================================================

//
//  ArticleAuthorAvatar.swift
//  ios
//
//  Atom: Avatar display for article authors with initials fallback
//

import SwiftUI

struct ArticleAuthorAvatar: View {
    let name: String
    let imageName: String?
    var size: CGFloat = 40
    var showVerifiedBadge: Bool = false

    private var initials: String {
        let components = name.components(separatedBy: " ")
        let initialsArray = components.compactMap { $0.first }.prefix(2)
        return String(initialsArray).uppercased()
    }

    var body: some View {
        ZStack(alignment: .bottomTrailing) {
            // Avatar
            if let imageName = imageName {
                Image(imageName)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .frame(width: size, height: size)
                    .clipShape(Circle())
            } else {
                // Initials fallback with gradient
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [
                                Color(hex: "3B82F6"),
                                Color(hex: "8B5CF6")
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: size, height: size)
                    .overlay(
                        Text(initials)
                            .font(.system(size: size * 0.4, weight: .semibold))
                            .foregroundColor(.white)
                    )
            }

            // Verified badge
            if showVerifiedBadge {
                Image(systemName: "checkmark.seal.fill")
                    .font(.system(size: size * 0.35))
                    .foregroundColor(AppColors.primaryBlue)
                    .background(
                        Circle()
                            .fill(AppColors.background)
                            .frame(width: size * 0.4, height: size * 0.4)
                    )
                    .offset(x: 2, y: 2)
            }
        }
    }
}

#Preview {
    HStack(spacing: AppSpacing.lg) {
        ArticleAuthorAvatar(name: "The Alpha", imageName: nil)
        ArticleAuthorAvatar(name: "John Doe", imageName: nil, size: 50, showVerifiedBadge: true)
        ArticleAuthorAvatar(name: "Sarah", imageName: nil, size: 32)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ArticleSectionIcon.swift
================================================================================

//
//  ArticleSectionIcon.swift
//  ios
//
//  Atom: Icon badge for article section headers
//

import SwiftUI

struct ArticleSectionIcon: View {
    let icon: String
    var color: Color = AppColors.primaryBlue
    var size: CGFloat = 32

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: size * 0.25)
                .fill(color.opacity(0.15))
                .frame(width: size, height: size)

            Image(systemName: icon)
                .font(.system(size: size * 0.45, weight: .semibold))
                .foregroundColor(color)
        }
    }
}

#Preview {
    HStack(spacing: AppSpacing.lg) {
        ArticleSectionIcon(icon: "chart.bar.fill", color: AppColors.primaryBlue)
        ArticleSectionIcon(icon: "cpu.fill", color: AppColors.alertPurple)
        ArticleSectionIcon(icon: "shield.checkered", color: AppColors.bullish)
        ArticleSectionIcon(icon: "flame.fill", color: AppColors.bearish, size: 40)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ArticleStatisticValue.swift
================================================================================

//
//  ArticleStatisticValue.swift
//  ios
//
//  Atom: Large statistic display with value and label
//

import SwiftUI

struct ArticleStatisticValue: View {
    let value: String
    let label: String
    var trend: StatisticTrend?
    var trendValue: String?
    var alignment: HorizontalAlignment = .leading

    var body: some View {
        VStack(alignment: alignment, spacing: AppSpacing.xs) {
            // Value with optional trend
            HStack(spacing: AppSpacing.xs) {
                Text(value)
                    .font(.system(size: 28, weight: .bold, design: .rounded))
                    .foregroundColor(AppColors.textPrimary)

                if let trend = trend, let trendValue = trendValue {
                    HStack(spacing: 2) {
                        Image(systemName: trend.icon)
                            .font(.system(size: 10, weight: .bold))
                        Text(trendValue)
                            .font(.system(size: 11, weight: .semibold))
                    }
                    .foregroundColor(trend.color)
                    .padding(.horizontal, AppSpacing.xs)
                    .padding(.vertical, 2)
                    .background(
                        Capsule()
                            .fill(trend.color.opacity(0.15))
                    )
                }
            }

            // Label
            Text(label)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.xl) {
        ArticleStatisticValue(
            value: "$180B",
            label: "Total Value Locked",
            trend: .up,
            trendValue: "340%"
        )

        ArticleStatisticValue(
            value: "4.2M",
            label: "Daily Active Users",
            trend: .up,
            trendValue: "127%",
            alignment: .center
        )

        ArticleStatisticValue(
            value: "2,400+",
            label: "DeFi Protocols"
        )
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ArticleTagPill.swift
================================================================================

//
//  ArticleTagPill.swift
//  ios
//
//  Atom: Tag pill for article labels (MUST READ, FEATURED, etc.)
//

import SwiftUI

struct ArticleTagPill: View {
    let text: String
    var style: TagPillStyle = .standard

    enum TagPillStyle {
        case standard
        case featured
        case warning
        case success

        var backgroundColor: Color {
            switch self {
            case .standard: return Color.black.opacity(0.4)
            case .featured: return Color(hex: "F59E0B").opacity(0.2)
            case .warning: return Color(hex: "EF4444").opacity(0.2)
            case .success: return Color(hex: "22C55E").opacity(0.2)
            }
        }

        var borderColor: Color {
            switch self {
            case .standard: return Color.white.opacity(0.3)
            case .featured: return Color(hex: "F59E0B").opacity(0.5)
            case .warning: return Color(hex: "EF4444").opacity(0.5)
            case .success: return Color(hex: "22C55E").opacity(0.5)
            }
        }

        var textColor: Color {
            switch self {
            case .standard: return .white
            case .featured: return Color(hex: "F59E0B")
            case .warning: return Color(hex: "EF4444")
            case .success: return Color(hex: "22C55E")
            }
        }
    }

    var body: some View {
        Text(text.uppercased())
            .font(AppTypography.captionBold)
            .foregroundColor(style.textColor)
            .tracking(0.8)
            .padding(.horizontal, AppSpacing.md)
            .padding(.vertical, AppSpacing.xs)
            .background(
                Capsule()
                    .fill(style.backgroundColor)
                    .overlay(
                        Capsule()
                            .strokeBorder(style.borderColor, lineWidth: 1)
                    )
            )
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ArticleTagPill(text: "Must Read")
        ArticleTagPill(text: "Featured", style: .featured)
        ArticleTagPill(text: "Warning", style: .warning)
        ArticleTagPill(text: "Success", style: .success)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AttachmentButton.swift
================================================================================

//
//  AttachmentButton.swift
//  ios
//
//  Atom: Plus button for adding attachments in chat
//

import SwiftUI

struct AttachmentButton: View {
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            ZStack {
                RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                    .fill(AppColors.cardBackgroundLight)
                    .frame(width: 44, height: 44)

                Image(systemName: "plus")
                    .font(.system(size: 20, weight: .medium))
                    .foregroundColor(AppColors.textSecondary)
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    AttachmentButton()
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/AudioArtworkThumbnail.swift
================================================================================

//
//  AudioArtworkThumbnail.swift
//  ios
//
//  Atom: Small artwork thumbnail for audio episodes
//  Displays gradient background with category icon
//

import SwiftUI

struct AudioArtworkThumbnail: View {
    let episode: AudioEpisode
    var size: CGFloat = 48
    var cornerRadius: CGFloat = AppCornerRadius.medium

    var body: some View {
        ZStack {
            // Gradient background
            LinearGradient(
                colors: episode.artworkColors,
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )

            // Category icon
            Image(systemName: episode.artworkIcon)
                .font(.system(size: size * 0.4, weight: .semibold))
                .foregroundColor(.white.opacity(0.9))
        }
        .frame(width: size, height: size)
        .clipShape(RoundedRectangle(cornerRadius: cornerRadius))
    }
}

// MARK: - Large Artwork (for Full Screen Player)
struct AudioArtworkLarge: View {
    let episode: AudioEpisode
    var size: CGFloat = 280
    @State private var isAnimating: Bool = false

    var body: some View {
        ZStack {
            // Outer glow effect
            Circle()
                .fill(
                    RadialGradient(
                        colors: [
                            episode.artworkColors.first?.opacity(0.4) ?? .clear,
                            .clear
                        ],
                        center: .center,
                        startRadius: size * 0.4,
                        endRadius: size * 0.7
                    )
                )
                .frame(width: size * 1.4, height: size * 1.4)
                .scaleEffect(isAnimating ? 1.1 : 1.0)
                .animation(
                    .easeInOut(duration: 2.0).repeatForever(autoreverses: true),
                    value: isAnimating
                )

            // Main artwork
            ZStack {
                // Gradient background
                LinearGradient(
                    colors: episode.artworkColors,
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )

                // Grainy texture
                Canvas { context, canvasSize in
                    for _ in 0..<Int(canvasSize.width * canvasSize.height / 100) {
                        let x = CGFloat.random(in: 0..<canvasSize.width)
                        let y = CGFloat.random(in: 0..<canvasSize.height)
                        let opacity = Double.random(in: 0.02...0.06)
                        context.fill(
                            Path(ellipseIn: CGRect(x: x, y: y, width: 1, height: 1)),
                            with: .color(.white.opacity(opacity))
                        )
                    }
                }

                // Icon
                Image(systemName: episode.artworkIcon)
                    .font(.system(size: size * 0.35, weight: .semibold))
                    .foregroundColor(.white.opacity(0.9))
            }
            .frame(width: size, height: size)
            .clipShape(RoundedRectangle(cornerRadius: AppCornerRadius.extraLarge))
            .shadow(color: episode.artworkColors.first?.opacity(0.5) ?? .clear, radius: 30, y: 10)
        }
        .onAppear {
            isAnimating = true
        }
    }
}

// MARK: - Preview
#Preview {
    VStack(spacing: AppSpacing.xxl) {
        // Thumbnails
        HStack(spacing: AppSpacing.lg) {
            AudioArtworkThumbnail(episode: .sampleMoneyMoves)
            AudioArtworkThumbnail(episode: .sampleFTX)
            AudioArtworkThumbnail(episode: .sampleBook)
            AudioArtworkThumbnail(episode: .sampleDailyBrief)
        }

        // Large artwork
        AudioArtworkLarge(episode: .sampleMoneyMoves)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/BookmarkButton.swift
================================================================================

//
//  BookmarkButton.swift
//  ios
//
//  Atom: Bookmark toggle button for saving content
//

import SwiftUI

struct BookmarkButton: View {
    let isBookmarked: Bool
    var size: CGFloat = 20
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Image(systemName: isBookmarked ? "bookmark.fill" : "bookmark")
                .font(.system(size: size, weight: .medium))
                .foregroundColor(isBookmarked ? AppColors.primaryBlue : AppColors.textMuted)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    HStack(spacing: AppSpacing.xl) {
        BookmarkButton(isBookmarked: false)
        BookmarkButton(isBookmarked: true)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/BulletPointIndicator.swift
================================================================================

//
//  BulletPointIndicator.swift
//  ios
//
//  Atom: Colored indicator icon for bullet points
//

import SwiftUI

struct BulletPointIndicator: View {
    let type: ChatBulletPoint.IndicatorType

    var body: some View {
        Image(systemName: type.iconName)
            .font(.system(size: 14, weight: .medium))
            .foregroundColor(type.color)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        BulletPointIndicator(type: .success)
        BulletPointIndicator(type: .warning)
        BulletPointIndicator(type: .info)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ChapterCountBadge.swift
================================================================================

//
//  ChapterCountBadge.swift
//  ios
//
//  Atom: Badge showing number of chapters in a lesson or book
//

import SwiftUI

struct ChapterCountBadge: View {
    let count: Int
    var showIcon: Bool = true

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            if showIcon {
                Image(systemName: "book.closed.fill")
                    .font(.system(size: 10, weight: .medium))
            }

            Text("\(count) chapters")
                .font(AppTypography.caption)
        }
        .foregroundColor(AppColors.textSecondary)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ChapterCountBadge(count: 5)
        ChapterCountBadge(count: 12, showIcon: false)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ChatHistoryTypeBadge.swift
================================================================================

//
//  ChatHistoryTypeBadge.swift
//  ios
//
//  Atom: Type badge for chat history items (BOOK, CONCEPT, STOCK, etc.)
//

import SwiftUI

struct ChatHistoryTypeBadge: View {
    let type: ChatHistoryItemType

    var body: some View {
        Text(type.displayName)
            .font(AppTypography.captionBold)
            .foregroundColor(type.textColor)
    }
}

#Preview {
    VStack(alignment: .leading, spacing: AppSpacing.md) {
        ForEach(ChatHistoryItemType.allCases, id: \.rawValue) { type in
            ChatHistoryTypeBadge(type: type)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ClearAllButton.swift
================================================================================

//
//  ClearAllButton.swift
//  ios
//
//  Atom: Button to clear all items (e.g., recent searches)
//

import SwiftUI

struct ClearAllButton: View {
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Text("Clear All")
                .font(AppTypography.callout)
                .foregroundColor(AppColors.bearish)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ClearAllButton()
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/CommentCountLabel.swift
================================================================================

//
//  CommentCountLabel.swift
//  ios
//
//  Atom: Label showing comment count
//

import SwiftUI

struct CommentCountLabel: View {
    let count: Int
    var showIcon: Bool = true

    private var formattedCount: String {
        if count >= 1000 {
            return String(format: "%.1fk", Double(count) / 1000.0)
        }
        return "\(count)"
    }

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            if showIcon {
                Image(systemName: "bubble.left.fill")
                    .font(.system(size: 12, weight: .medium))
            }

            Text("\(formattedCount) Comments")
                .font(AppTypography.caption)
        }
        .foregroundColor(AppColors.textSecondary)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        CommentCountLabel(count: 124)
        CommentCountLabel(count: 5, showIcon: false)
        CommentCountLabel(count: 2500)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/CompanyLogoView.swift
================================================================================

//
//  CompanyLogoView.swift
//  ios
//
//  Atom: Company logo placeholder with fallback to initials
//

import SwiftUI

struct CompanyLogoView: View {
    let ticker: String
    let imageName: String?
    let size: CGFloat
    let gradientColors: [String]?

    init(ticker: String, imageName: String? = nil, size: CGFloat = 40, gradientColors: [String]? = nil) {
        self.ticker = ticker
        self.imageName = imageName
        self.size = size
        self.gradientColors = gradientColors
    }

    private var fallbackGradient: LinearGradient {
        if let colors = gradientColors, colors.count >= 2 {
            return LinearGradient(
                colors: colors.map { Color(hex: $0) },
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        }
        return LinearGradient(
            colors: [AppColors.cardBackgroundLight, AppColors.cardBackground],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }

    var body: some View {
        ZStack {
            if let imageName = imageName {
                // Try to load asset image
                Image(imageName)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: size * 0.6, height: size * 0.6)
                    .frame(width: size, height: size)
                    .background(fallbackGradient)
                    .clipShape(RoundedRectangle(cornerRadius: size * 0.25))
            } else {
                // Fallback to initials
                Text(String(ticker.prefix(1)))
                    .font(.system(size: size * 0.4, weight: .bold))
                    .foregroundColor(.white)
                    .frame(width: size, height: size)
                    .background(fallbackGradient)
                    .clipShape(RoundedRectangle(cornerRadius: size * 0.25))
            }
        }
    }
}

// MARK: - System Symbol Logo (for placeholder)
struct SystemLogoView: View {
    let systemName: String
    let size: CGFloat
    let gradientColors: [String]

    private var gradient: LinearGradient {
        LinearGradient(
            colors: gradientColors.map { Color(hex: $0) },
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }

    var body: some View {
        Image(systemName: systemName)
            .font(.system(size: size * 0.4, weight: .semibold))
            .foregroundColor(.white)
            .frame(width: size, height: size)
            .background(gradient)
            .clipShape(RoundedRectangle(cornerRadius: size * 0.25))
    }
}

#Preview {
    VStack(spacing: 20) {
        CompanyLogoView(ticker: "MSFT", size: 50, gradientColors: ["0078D4", "00BCF2"])
        CompanyLogoView(ticker: "GOOGL", size: 50, gradientColors: ["4285F4", "34A853"])
        CompanyLogoView(ticker: "AMD", size: 50, gradientColors: ["ED1C24", "FF6B6B"])
        SystemLogoView(systemName: "building.2.fill", size: 50, gradientColors: ["0078D4", "00BCF2"])
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/CreditsBadge.swift
================================================================================

//
//  CreditsBadge.swift
//  ios
//
//  Atom: Displays credit count with icon
//

import SwiftUI

struct CreditsBadge: View {
    let credits: Int
    var showIcon: Bool = true
    var style: CreditsBadgeStyle = .compact

    enum CreditsBadgeStyle {
        case compact
        case large
    }

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            if showIcon {
                Text("ðŸŽŸï¸")
                    .font(style == .large ? .system(size: 16) : .system(size: 12))
            }

            Text(style == .large ? "\(credits)" : "You have \(credits) credits remaining")
                .font(style == .large ? AppTypography.largeTitle : AppTypography.caption)
                .fontWeight(style == .large ? .bold : .regular)
                .foregroundColor(style == .large ? AppColors.textPrimary : AppColors.textSecondary)

            if style == .large {
                Text("credits")
                    .font(AppTypography.body)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        CreditsBadge(credits: 47, style: .compact)
        CreditsBadge(credits: 47, style: .large)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/DateBadge.swift
================================================================================

//
//  DateBadge.swift
//  ios
//
//  Atom: Calendar-style date badge
//

import SwiftUI

struct DateBadge: View {
    let day: String
    let month: String

    init(day: String, month: String) {
        self.day = day
        self.month = month
    }

    init(from date: Date) {
        let formatter = DateFormatter()
        formatter.dateFormat = "d"
        self.day = formatter.string(from: date)
        formatter.dateFormat = "MMM"
        self.month = formatter.string(from: date).uppercased()
    }

    var body: some View {
        VStack(spacing: 0) {
            Text(day)
                .font(.system(size: 20, weight: .bold, design: .rounded))
                .foregroundColor(.white)

            Text(month)
                .font(.system(size: 10, weight: .semibold))
                .foregroundColor(.white.opacity(0.8))
        }
        .frame(width: 48, height: 48)
        .background(AppColors.alertBlue)
        .cornerRadius(AppCornerRadius.medium)
    }
}

#Preview {
    VStack(spacing: 20) {
        DateBadge(day: "24", month: "FEB")
        DateBadge(from: Date())
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/DonutChartView.swift
================================================================================

//
//  DonutChartView.swift
//  ios
//
//  Atom: A reusable donut/ring chart component for displaying
//  proportional data like sector allocation or portfolio distribution.
//

import SwiftUI

// MARK: - Donut Chart Segment
struct DonutChartSegment: Identifiable {
    let id: String
    let value: Double
    let color: Color
    let label: String

    init(id: String = UUID().uuidString, value: Double, color: Color, label: String) {
        self.id = id
        self.value = value
        self.color = color
        self.label = label
    }
}

// MARK: - Donut Chart View
struct DonutChartView: View {
    let segments: [DonutChartSegment]
    let lineWidth: CGFloat
    let showLabels: Bool

    private var total: Double {
        segments.reduce(0) { $0 + $1.value }
    }

    init(
        segments: [DonutChartSegment],
        lineWidth: CGFloat = 24,
        showLabels: Bool = true
    ) {
        self.segments = segments
        self.lineWidth = lineWidth
        self.showLabels = showLabels
    }

    var body: some View {
        HStack(spacing: AppSpacing.xl) {
            // Donut Chart
            ZStack {
                // Background ring
                Circle()
                    .stroke(
                        AppColors.cardBackgroundLight,
                        lineWidth: lineWidth
                    )

                // Segment rings
                ForEach(Array(segments.enumerated()), id: \.element.id) { index, segment in
                    DonutSegmentShape(
                        startAngle: startAngle(for: index),
                        endAngle: endAngle(for: index)
                    )
                    .stroke(
                        segment.color,
                        style: StrokeStyle(
                            lineWidth: lineWidth,
                            lineCap: .butt
                        )
                    )
                }
            }
            .rotationEffect(.degrees(-90))
            .frame(width: 100, height: 100)
            .padding(lineWidth / 2)

            // Legend
            if showLabels {
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    ForEach(segments) { segment in
                        DonutChartLegendItem(
                            color: segment.color,
                            label: segment.label,
                            value: segment.value / total * 100
                        )
                    }
                }
            }
        }
    }

    // MARK: - Angle Calculations

    private func startAngle(for index: Int) -> Angle {
        let precedingTotal = segments.prefix(index).reduce(0) { $0 + $1.value }
        return Angle(degrees: (precedingTotal / total) * 360)
    }

    private func endAngle(for index: Int) -> Angle {
        let includingTotal = segments.prefix(index + 1).reduce(0) { $0 + $1.value }
        return Angle(degrees: (includingTotal / total) * 360)
    }
}

// MARK: - Donut Segment Shape
struct DonutSegmentShape: Shape {
    let startAngle: Angle
    let endAngle: Angle

    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let radius = min(rect.width, rect.height) / 2

        path.addArc(
            center: center,
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle,
            clockwise: false
        )

        return path
    }
}

// MARK: - Legend Item
struct DonutChartLegendItem: View {
    let color: Color
    let label: String
    let value: Double

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            Circle()
                .fill(color)
                .frame(width: 8, height: 8)

            Text(label)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)

            Text(String(format: "%.0f%%", value))
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textPrimary)
        }
    }
}

// MARK: - Preview
#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xxl) {
            // Standard donut chart
            DonutChartView(
                segments: [
                    DonutChartSegment(value: 42, color: AppColors.primaryBlue, label: "Tech"),
                    DonutChartSegment(value: 31, color: AppColors.bullish, label: "Finance"),
                    DonutChartSegment(value: 27, color: AppColors.alertOrange, label: "Energy")
                ]
            )
            .padding()
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)

            // Smaller donut chart
            DonutChartView(
                segments: [
                    DonutChartSegment(value: 65, color: AppColors.primaryBlue, label: "Tech"),
                    DonutChartSegment(value: 20, color: AppColors.bullish, label: "Healthcare"),
                    DonutChartSegment(value: 15, color: AppColors.alertOrange, label: "Finance")
                ],
                lineWidth: 16
            )
            .padding()
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/EarningsDataTypeToggle.swift
================================================================================

//
//  EarningsDataTypeToggle.swift
//  ios
//
//  Atom: Toggle button for switching between EPS and Revenue data types
//

import SwiftUI

struct EarningsDataTypeToggle: View {
    @Binding var selectedType: EarningsDataType

    var body: some View {
        HStack(spacing: 0) {
            ForEach(EarningsDataType.allCases, id: \.rawValue) { type in
                Button {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedType = type
                    }
                } label: {
                    Text(type.rawValue)
                        .font(AppTypography.footnoteBold)
                        .foregroundColor(selectedType == type ? AppColors.textPrimary : AppColors.textSecondary)
                        .padding(.horizontal, AppSpacing.lg)
                        .padding(.vertical, AppSpacing.sm)
                        .background(
                            selectedType == type ?
                            AppColors.primaryBlue : Color.clear
                        )
                        .cornerRadius(AppCornerRadius.medium)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .background(AppColors.cardBackgroundLight)
        .cornerRadius(AppCornerRadius.medium)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        EarningsDataTypeToggle(selectedType: .constant(.eps))
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/EarningsLegendItem.swift
================================================================================

//
//  EarningsLegendItem.swift
//  ios
//
//  Atom: Single legend item with colored circle and label
//

import SwiftUI

enum EarningsLegendType {
    case surprised
    case estimate
    case beat
    case missed

    var color: Color {
        switch self {
        case .surprised:
            return AppColors.neutral  // Yellow/Orange
        case .estimate:
            return AppColors.textSecondary  // Gray
        case .beat:
            return AppColors.bullish  // Green
        case .missed:
            return AppColors.bearish  // Red
        }
    }

    var label: String {
        switch self {
        case .surprised:
            return "Surprised"
        case .estimate:
            return "Estimate"
        case .beat:
            return "Beat"
        case .missed:
            return "Missed"
        }
    }
}

struct EarningsLegendItem: View {
    let type: EarningsLegendType

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            if type == .surprised {
                // Show gray "%" symbol for Surprised
                Text("%")
                    .font(.system(size: 12, weight: .bold))
                    .foregroundColor(AppColors.textSecondary)
                    .frame(width: 12, height: 12)
            } else {
                // Show colored circle for other types
                Circle()
                    .fill(type.color)
                    .frame(width: 10, height: 10)
            }

            Text(type.label)
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textSecondary)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.xl) {
            EarningsLegendItem(type: .surprised)
            EarningsLegendItem(type: .estimate)
            EarningsLegendItem(type: .beat)
            EarningsLegendItem(type: .missed)
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/EarningsPriceToggle.swift
================================================================================

//
//  EarningsPriceToggle.swift
//  ios
//
//  Atom: Toggle button for showing/hiding price line on earnings chart
//

import SwiftUI

struct EarningsPriceToggle: View {
    @Binding var isEnabled: Bool

    var body: some View {
        Button {
            withAnimation(.easeInOut(duration: 0.2)) {
                isEnabled.toggle()
            }
        } label: {
            Text("Price")
                .font(AppTypography.footnoteBold)
                .foregroundColor(isEnabled ? AppColors.primaryBlue : AppColors.textSecondary)
                .padding(.horizontal, AppSpacing.md)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    RoundedRectangle(cornerRadius: AppCornerRadius.small)
                        .stroke(isEnabled ? AppColors.primaryBlue : AppColors.cardBackgroundLight, lineWidth: 1)
                )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.lg) {
            EarningsPriceToggle(isEnabled: .constant(false))
            EarningsPriceToggle(isEnabled: .constant(true))
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/EarningsResultDot.swift
================================================================================

//
//  EarningsResultDot.swift
//  ios
//
//  Atom: Colored dot indicator for earnings results (Beat/Miss/Estimate)
//

import SwiftUI

struct EarningsResultDot: View {
    let result: EarningsQuarterResult
    let size: CGFloat

    init(result: EarningsQuarterResult, size: CGFloat = 12) {
        self.result = result
        self.size = size
    }

    var body: some View {
        ZStack {
            // Main dot
            Circle()
                .fill(result.dotColor)
                .frame(width: size, height: size)

            // Dashed border for matched results
            if result.hasDashedBorder {
                Circle()
                    .stroke(
                        AppColors.textPrimary,
                        style: StrokeStyle(lineWidth: 2, dash: [3, 2])
                    )
                    .frame(width: size + 4, height: size + 4)
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.xl) {
            VStack(spacing: AppSpacing.sm) {
                EarningsResultDot(result: .beat)
                Text("Beat")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            VStack(spacing: AppSpacing.sm) {
                EarningsResultDot(result: .missed)
                Text("Missed")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            VStack(spacing: AppSpacing.sm) {
                EarningsResultDot(result: .matched)
                Text("Matched")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            VStack(spacing: AppSpacing.sm) {
                EarningsResultDot(result: .pending)
                Text("Estimate")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/EarningsTimeRangeToggle.swift
================================================================================

//
//  EarningsTimeRangeToggle.swift
//  ios
//
//  Atom: Toggle button for switching between 1Y and 3Y time ranges
//

import SwiftUI

struct EarningsTimeRangeToggle: View {
    @Binding var selectedRange: EarningsTimeRange

    var body: some View {
        HStack(spacing: 0) {
            ForEach(EarningsTimeRange.allCases, id: \.rawValue) { range in
                Button {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedRange = range
                    }
                } label: {
                    Text(range.rawValue)
                        .font(AppTypography.footnoteBold)
                        .foregroundColor(selectedRange == range ? AppColors.textPrimary : AppColors.textSecondary)
                        .padding(.horizontal, AppSpacing.md)
                        .padding(.vertical, AppSpacing.sm)
                        .background(
                            selectedRange == range ?
                            AppColors.cardBackgroundLight : Color.clear
                        )
                        .cornerRadius(AppCornerRadius.small)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.small)
        .overlay(
            RoundedRectangle(cornerRadius: AppCornerRadius.small)
                .stroke(AppColors.cardBackgroundLight, lineWidth: 1)
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        EarningsTimeRangeToggle(selectedRange: .constant(.oneYear))
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/EventDateBadge.swift
================================================================================

//
//  EventDateBadge.swift
//  ios
//
//  Atom: Date badge for events showing day and month
//

import SwiftUI

struct EventDateBadge: View {
    let day: String
    let month: String

    var body: some View {
        VStack(spacing: 0) {
            Text(day)
                .font(.system(size: 20, weight: .bold))
                .foregroundColor(AppColors.textPrimary)

            Text(month)
                .font(.system(size: 10, weight: .semibold))
                .foregroundColor(AppColors.textSecondary)
        }
        .frame(width: 48, height: 48)
        .background(AppColors.cardBackgroundLight)
        .cornerRadius(AppCornerRadius.medium)
    }
}

#Preview {
    HStack(spacing: 20) {
        EventDateBadge(day: "22", month: "FEB")
        EventDateBadge(day: "24", month: "FEB")
        EventDateBadge(day: "1", month: "MAR")
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/FeatureIcon.swift
================================================================================

//
//  FeatureIcon.swift
//  ios
//
//  Atom: Feature icon with colored background
//

import SwiftUI

struct FeatureIcon: View {
    let systemIconName: String
    let color: Color
    var size: CGFloat = 36

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: AppCornerRadius.small)
                .fill(color.opacity(0.2))
                .frame(width: size, height: size)

            Image(systemName: systemIconName)
                .font(.system(size: size * 0.45, weight: .semibold))
                .foregroundColor(color)
        }
    }
}

#Preview {
    HStack(spacing: AppSpacing.lg) {
        FeatureIcon(systemIconName: "chart.pie.fill", color: Color(hex: "22C55E"))
        FeatureIcon(systemIconName: "building.2.fill", color: Color(hex: "3B82F6"))
        FeatureIcon(systemIconName: "sparkles", color: Color(hex: "F97316"))
        FeatureIcon(systemIconName: "exclamationmark.triangle.fill", color: Color(hex: "EF4444"))
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/FollowButton.swift
================================================================================

//
//  FollowButton.swift
//  ios
//
//  Atom: Small button to follow/unfollow a person or entity
//

import SwiftUI

struct FollowButton: View {
    let isFollowing: Bool
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Text(isFollowing ? "Following" : "Follow")
                .font(AppTypography.captionBold)
                .foregroundColor(isFollowing ? AppColors.textSecondary : AppColors.primaryBlue)
                .padding(.horizontal, AppSpacing.md)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    isFollowing
                        ? AppColors.cardBackgroundLight
                        : AppColors.primaryBlue.opacity(0.15)
                )
                .cornerRadius(AppCornerRadius.small)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        FollowButton(isFollowing: false)
        FollowButton(isFollowing: true)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/GradientProgressBar.swift
================================================================================

//
//  GradientProgressBar.swift
//  ios
//
//  Atom: Progress bar with gradient fill
//

import SwiftUI

struct GradientProgressBar: View {
    let progress: Double
    var height: CGFloat = 8
    var gradientColors: [Color] = [AppColors.bullish, AppColors.neutral]

    private var clampedProgress: Double {
        min(max(progress, 0), 1)
    }

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Background track
                RoundedRectangle(cornerRadius: height / 2)
                    .fill(AppColors.cardBackgroundLight)
                    .frame(height: height)

                // Progress fill
                RoundedRectangle(cornerRadius: height / 2)
                    .fill(
                        LinearGradient(
                            colors: gradientColors,
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .frame(width: geometry.size.width * clampedProgress, height: height)
            }
        }
        .frame(height: height)
    }
}

#Preview {
    VStack(spacing: 20) {
        GradientProgressBar(progress: 0.78)
        GradientProgressBar(progress: 0.5, gradientColors: [AppColors.primaryBlue, AppColors.accentCyan])
        GradientProgressBar(progress: 0.25, height: 12)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/GrowthInfoIcon.swift
================================================================================

//
//  GrowthInfoIcon.swift
//  ios
//
//  Atom: Info icon button that displays growth explanation sheet
//

import SwiftUI

struct GrowthInfoIcon: View {
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            ZStack {
                Circle()
                    .stroke(AppColors.textMuted, lineWidth: 1.5)
                    .frame(width: 20, height: 20)

                Text("i")
                    .font(.system(size: 12, weight: .semibold, design: .serif))
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.sm) {
            Text("Growth")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            GrowthInfoIcon(action: {})
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/GrowthLegendDot.swift
================================================================================

//
//  GrowthLegendDot.swift
//  ios
//
//  Atom: Legend indicator dot for growth chart
//

import SwiftUI

enum GrowthLegendDotStyle {
    case filled
    case dashed

    var strokeStyle: StrokeStyle? {
        switch self {
        case .filled:
            return nil
        case .dashed:
            return StrokeStyle(lineWidth: 2, dash: [4, 3])
        }
    }
}

struct GrowthLegendDot: View {
    let color: Color
    let style: GrowthLegendDotStyle
    let size: CGFloat

    init(color: Color, style: GrowthLegendDotStyle = .filled, size: CGFloat = 10) {
        self.color = color
        self.style = style
        self.size = size
    }

    var body: some View {
        Group {
            switch style {
            case .filled:
                Circle()
                    .fill(color)
                    .frame(width: size, height: size)
            case .dashed:
                Circle()
                    .stroke(color, style: style.strokeStyle!)
                    .frame(width: size, height: size)
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.xl) {
            GrowthLegendDot(color: AppColors.growthYoYYellow)
            GrowthLegendDot(color: AppColors.growthBarBlue)
            GrowthLegendDot(color: AppColors.growthSectorGray, style: .dashed)
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/GrowthMetricChip.swift
================================================================================

//
//  GrowthMetricChip.swift
//  ios
//
//  Atom: Selectable chip for growth metric type (EPS, Revenue, etc.)
//

import SwiftUI

struct GrowthMetricChip: View {
    let metricType: GrowthMetricType
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            Text(metricType.rawValue)
                .font(AppTypography.calloutBold)
                .foregroundColor(isSelected ? AppColors.textPrimary : AppColors.textSecondary)
                .padding(.horizontal, AppSpacing.lg)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                        .fill(isSelected ? AppColors.chipSelectedBackground : AppColors.chipUnselectedBackground)
                )
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.sm) {
            GrowthMetricChip(
                metricType: .eps,
                isSelected: false,
                action: {}
            )

            GrowthMetricChip(
                metricType: .revenue,
                isSelected: true,
                action: {}
            )

            GrowthMetricChip(
                metricType: .netIncome,
                isSelected: false,
                action: {}
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/GrowthPeriodToggle.swift
================================================================================

//
//  GrowthPeriodToggle.swift
//  ios
//
//  Atom: Toggle between Annual and Quarterly period views
//

import SwiftUI

struct GrowthPeriodToggle: View {
    @Binding var selectedPeriod: GrowthPeriodType

    var body: some View {
        HStack(spacing: 0) {
            ForEach(GrowthPeriodType.allCases) { period in
                Button(action: {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedPeriod = period
                    }
                }) {
                    Text(period.rawValue)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(selectedPeriod == period ? AppColors.textPrimary : AppColors.textMuted)
                        .padding(.horizontal, AppSpacing.md)
                        .padding(.vertical, AppSpacing.xs + 2)
                        .background(
                            RoundedRectangle(cornerRadius: AppCornerRadius.small)
                                .fill(selectedPeriod == period ? AppColors.toggleSelectedBackground : Color.clear)
                        )
                }
                .buttonStyle(.plain)
            }
        }
        .padding(AppSpacing.xs)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.toggleBackground)
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            GrowthPeriodToggle(selectedPeriod: .constant(.annual))
            GrowthPeriodToggle(selectedPeriod: .constant(.quarterly))
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/GrowthYoYLabel.swift
================================================================================

//
//  GrowthYoYLabel.swift
//  ios
//
//  Atom: Year-over-Year percentage label with color coding
//

import SwiftUI

struct GrowthYoYLabel: View {
    let yoyPercent: Double

    var body: some View {
        Text(formattedValue)
            .font(AppTypography.caption)
            .foregroundColor(yoyColor)
    }

    private var formattedValue: String {
        String(format: "%.2f%%", yoyPercent)
    }

    private var yoyColor: Color {
        yoyPercent >= 0 ? AppColors.bullish : AppColors.bearish
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.lg) {
            GrowthYoYLabel(yoyPercent: 7.92)
            GrowthYoYLabel(yoyPercent: -2.30)
            GrowthYoYLabel(yoyPercent: 0.00)
            GrowthYoYLabel(yoyPercent: -10.92)
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/HealthCheckGaugeBar.swift
================================================================================

//
//  HealthCheckGaugeBar.swift
//  ios
//
//  Atom: Gradient gauge bar for health check metrics with position indicator
//

import SwiftUI

struct HealthCheckGaugeBar: View {
    let position: Double  // 0.0 to 1.0
    let metricType: HealthCheckMetricType
    var height: CGFloat = 8

    private var clampedPosition: Double {
        min(max(position, 0.02), 0.98)  // Keep indicator visible
    }

    /// Returns gradient colors based on metric type
    /// Some metrics are "lower is better" (green->yellow->red)
    /// Others are "higher is better" (red->yellow->green)
    private var gradientColors: [Color] {
        switch metricType {
        case .debtToEquity:
            // Lower is better: green -> yellow -> red
            return [
                AppColors.bullish,
                Color(hex: "84CC16"),  // Lime
                AppColors.neutral,
                AppColors.alertOrange,
                AppColors.bearish
            ]
        case .peRatio:
            // Lower is better (value): green -> yellow -> red
            return [
                AppColors.bullish,
                Color(hex: "84CC16"),
                AppColors.neutral,
                AppColors.alertOrange,
                AppColors.bearish
            ]
        case .returnOnEquity:
            // Higher is better: red -> yellow -> green
            return [
                AppColors.bearish,
                AppColors.alertOrange,
                AppColors.neutral,
                Color(hex: "84CC16"),
                AppColors.bullish
            ]
        case .currentRatio:
            // Higher is better (within reason): red -> yellow -> green
            return [
                AppColors.bearish,
                AppColors.alertOrange,
                AppColors.neutral,
                Color(hex: "84CC16"),
                AppColors.bullish
            ]
        }
    }

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Gradient background bar
                RoundedRectangle(cornerRadius: height / 2)
                    .fill(
                        LinearGradient(
                            colors: gradientColors,
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .frame(height: height)

                // Sector average marker (white vertical line at ~60%)
                Rectangle()
                    .fill(Color.white.opacity(0.6))
                    .frame(width: 2, height: height + 4)
                    .offset(x: geometry.size.width * 0.6 - 1)

                // Position indicator (white circle)
                Circle()
                    .fill(Color.white)
                    .frame(width: height + 6, height: height + 6)
                    .shadow(color: Color.black.opacity(0.3), radius: 2, x: 0, y: 1)
                    .offset(x: geometry.size.width * clampedPosition - (height + 6) / 2.0)
            }
        }
        .frame(height: height + 6)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xxl) {
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                Text("Debt-to-Equity (Low = Good)")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                HealthCheckGaugeBar(position: 0.25, metricType: .debtToEquity)
            }

            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                Text("P/E Ratio (Low = Good)")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                HealthCheckGaugeBar(position: 0.42, metricType: .peRatio)
            }

            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                Text("ROE (High = Good)")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                HealthCheckGaugeBar(position: 0.35, metricType: .returnOnEquity)
            }

            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                Text("Current Ratio (High = Good)")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                HealthCheckGaugeBar(position: 0.68, metricType: .currentRatio)
            }
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/HealthCheckInfoIcon.swift
================================================================================

//
//  HealthCheckInfoIcon.swift
//  ios
//
//  Atom: Info icon button that displays Health Check explanation sheet
//

import SwiftUI

struct HealthCheckInfoIcon: View {
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            ZStack {
                Circle()
                    .stroke(AppColors.textMuted, lineWidth: 1.5)
                    .frame(width: 20, height: 20)

                Text("i")
                    .font(.system(size: 12, weight: .semibold, design: .serif))
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.sm) {
            Text("Health Check")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            HealthCheckInfoIcon(action: {})
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/HealthCheckStatusBadge.swift
================================================================================

//
//  HealthCheckStatusBadge.swift
//  ios
//
//  Atom: Badge displaying health check rating status (e.g., "[2/4] Mix")
//

import SwiftUI

struct HealthCheckStatusBadge: View {
    let rating: HealthCheckRating
    let passedCount: Int
    let totalCount: Int

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            // Checkmark icon
            Image(systemName: rating.iconName)
                .font(.system(size: 14, weight: .semibold))
                .foregroundColor(rating.color)

            // Rating text: [2/4] Mix
            Text("[\(passedCount)/\(totalCount)] \(rating.rawValue)")
                .font(AppTypography.calloutBold)
                .foregroundColor(rating.color)
        }
        .padding(.horizontal, AppSpacing.sm)
        .padding(.vertical, AppSpacing.xs)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.small)
                .fill(rating.color.opacity(0.15))
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.lg) {
            HealthCheckStatusBadge(rating: .excellent, passedCount: 4, totalCount: 4)
            HealthCheckStatusBadge(rating: .good, passedCount: 3, totalCount: 4)
            HealthCheckStatusBadge(rating: .mix, passedCount: 2, totalCount: 4)
            HealthCheckStatusBadge(rating: .caution, passedCount: 1, totalCount: 4)
            HealthCheckStatusBadge(rating: .poor, passedCount: 0, totalCount: 4)
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/HistoryButton.swift
================================================================================

//
//  HistoryButton.swift
//  ios
//
//  Atom: Hamburger menu button for chat history
//

import SwiftUI

struct HistoryButton: View {
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Image(systemName: "line.3.horizontal")
                .font(.system(size: 20, weight: .medium))
                .foregroundColor(AppColors.textPrimary)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    HistoryButton()
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/HolderBreakdownLegendItem.swift
================================================================================

//
//  HolderBreakdownLegendItem.swift
//  ios
//
//  Atom: Single legend item for shareholder breakdown
//  Shows colored dot, label, and percentage
//

import SwiftUI

struct HolderBreakdownLegendItem: View {
    let color: Color
    let label: String
    let percentage: String

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            // Color indicator dot
            Circle()
                .fill(color)
                .frame(width: 10, height: 10)

            // Label
            Text(label)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)

            Spacer()

            // Percentage value
            Text(percentage)
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textPrimary)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.md) {
            HolderBreakdownLegendItem(
                color: HoldersColors.insiders,
                label: "Insiders",
                percentage: "12%"
            )

            HolderBreakdownLegendItem(
                color: HoldersColors.institutions,
                label: "Institutions",
                percentage: "55%"
            )

            HolderBreakdownLegendItem(
                color: HoldersColors.publicOther,
                label: "Public/Other",
                percentage: "33%"
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ImpactBadge.swift
================================================================================

//
//  ImpactBadge.swift
//  ios
//
//  Atom: Impact level badge for risk factors
//

import SwiftUI

struct ImpactBadge: View {
    let level: RiskFactor.ImpactLevel

    var body: some View {
        Text(level.rawValue)
            .font(AppTypography.captionBold)
            .foregroundColor(level.color)
            .padding(.horizontal, AppSpacing.sm)
            .padding(.vertical, AppSpacing.xs)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.small)
                    .fill(level.color.opacity(0.15))
            )
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ImpactBadge(level: .high)
        ImpactBadge(level: .medium)
        ImpactBadge(level: .variable)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/IndicatorSignalBadge.swift
================================================================================

//
//  IndicatorSignalBadge.swift
//  ios
//
//  Badge showing indicator signal (Buy/Sell/Neutral) with optional arrow
//

import SwiftUI

struct IndicatorSignalBadge: View {
    let signal: IndicatorSignal

    var body: some View {
        HStack(spacing: AppSpacing.xxs) {
            Text(signal.rawValue)
                .font(AppTypography.caption)
                .foregroundColor(signal.color)

            if let icon = signal.arrowIcon {
                Image(systemName: icon)
                    .font(.system(size: 8, weight: .bold))
                    .foregroundColor(signal.color)
            }
        }
    }
}

// MARK: - Indicator Summary Badges (Buy: X | Neutral: X | Sell: X)
struct IndicatorSummaryBadges: View {
    let summary: IndicatorSummary

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            SummaryBadge(label: "Buy:", count: summary.buyCount, color: AppColors.bullish)
            SummaryBadge(label: "Neutral:", count: summary.neutralCount, color: AppColors.textSecondary)
            SummaryBadge(label: "Sell:", count: summary.sellCount, color: AppColors.bearish)
        }
    }
}

struct SummaryBadge: View {
    let label: String
    let count: Int
    let color: Color

    var body: some View {
        HStack(spacing: AppSpacing.xxs) {
            Text(label)
                .font(AppTypography.caption)
                .foregroundColor(color)

            Text("\(count)")
                .font(AppTypography.captionBold)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.xs)
                .padding(.vertical, 2)
                .background(color.opacity(0.2))
                .cornerRadius(AppCornerRadius.small)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            HStack(spacing: AppSpacing.lg) {
                IndicatorSignalBadge(signal: .buy)
                IndicatorSignalBadge(signal: .sell)
                IndicatorSignalBadge(signal: .neutral)
            }

            IndicatorSummaryBadges(
                summary: IndicatorSummary(buyCount: 8, neutralCount: 2, sellCount: 1)
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/InputOptionButton.swift
================================================================================

//
//  InputOptionButton.swift
//  ios
//
//  Atom: Option button for Voice/Image input in chat
//

import SwiftUI

struct InputOptionButton: View {
    let type: ChatAttachmentType
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: type.iconName)
                    .font(.system(size: 14, weight: .medium))

                Text(type.rawValue)
                    .font(AppTypography.callout)
            }
            .foregroundColor(AppColors.textSecondary)
            .padding(.horizontal, AppSpacing.lg)
            .padding(.vertical, AppSpacing.sm)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                    .fill(AppColors.cardBackground)
            )
            .overlay(
                RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                    .stroke(AppColors.cardBackgroundLight, lineWidth: 1)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    HStack(spacing: AppSpacing.md) {
        InputOptionButton(type: .voice)
        InputOptionButton(type: .image)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/JourneyStepIndicator.swift
================================================================================

//
//  JourneyStepIndicator.swift
//  ios
//
//  Atom: Step indicator for journey progress (checkmark, number, or active state)
//

import SwiftUI

struct JourneyStepIndicator: View {
    let stepNumber: Int
    let isCompleted: Bool
    let isActive: Bool

    private var backgroundColor: Color {
        if isCompleted {
            return AppColors.bullish
        } else if isActive {
            return AppColors.primaryBlue
        }
        return AppColors.cardBackgroundLight
    }

    private var foregroundColor: Color {
        if isCompleted || isActive {
            return .white
        }
        return AppColors.textMuted
    }

    var body: some View {
        ZStack {
            Circle()
                .fill(backgroundColor)
                .frame(width: 24, height: 24)

            if isCompleted {
                Image(systemName: "checkmark")
                    .font(.system(size: 12, weight: .bold))
                    .foregroundColor(foregroundColor)
            } else {
                Text("\(stepNumber)")
                    .font(.system(size: 12, weight: .semibold))
                    .foregroundColor(foregroundColor)
            }
        }
    }
}

#Preview {
    HStack(spacing: AppSpacing.lg) {
        JourneyStepIndicator(stepNumber: 1, isCompleted: true, isActive: false)
        JourneyStepIndicator(stepNumber: 2, isCompleted: true, isActive: false)
        JourneyStepIndicator(stepNumber: 3, isCompleted: true, isActive: false)
        JourneyStepIndicator(stepNumber: 4, isCompleted: false, isActive: true)
        JourneyStepIndicator(stepNumber: 5, isCompleted: false, isActive: false)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/LearnerCountBadge.swift
================================================================================

//
//  LearnerCountBadge.swift
//  ios
//
//  Atom: Badge showing number of learners for educational content
//

import SwiftUI

struct LearnerCountBadge: View {
    let count: String
    var showIcon: Bool = true

    var body: some View {
        HStack(spacing: AppSpacing.xxs) {
            if showIcon {
                Image(systemName: "person.2.fill")
                    .font(.system(size: 10, weight: .medium))
            }

            Text("\(count) investors")
                .font(AppTypography.caption)
        }
        .foregroundColor(AppColors.textSecondary)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        LearnerCountBadge(count: "1.4k")
        LearnerCountBadge(count: "500", showIcon: false)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/LessonCategoryBadge.swift
================================================================================

//
//  LessonCategoryBadge.swift
//  ios
//
//  Atom: Badge showing lesson category (e.g., Crypto)
//

import SwiftUI

struct LessonCategoryBadge: View {
    let category: LessonCategory

    var body: some View {
        if let badgeText = category.badgeText {
            Text(badgeText)
                .font(AppTypography.caption)
                .fontWeight(.medium)
                .foregroundColor(category.badgeColor)
                .padding(.horizontal, AppSpacing.sm)
                .padding(.vertical, AppSpacing.xxs)
                .background(category.badgeColor.opacity(0.15))
                .cornerRadius(AppCornerRadius.small)
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        LessonCategoryBadge(category: .crypto)
        LessonCategoryBadge(category: .standard)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/LessonDurationLabel.swift
================================================================================

//
//  LessonDurationLabel.swift
//  ios
//
//  Atom: Label showing lesson duration with clock icon
//

import SwiftUI

struct LessonDurationLabel: View {
    let durationMinutes: Int
    var textColor: Color = AppColors.textMuted

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            Image(systemName: "clock")
                .font(.system(size: 10))

            Text("\(durationMinutes) min")
                .font(AppTypography.caption)
        }
        .foregroundColor(textColor)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        LessonDurationLabel(durationMinutes: 3)
        LessonDurationLabel(durationMinutes: 8)
        LessonDurationLabel(durationMinutes: 12, textColor: AppColors.textSecondary)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/LessonStatusBadge.swift
================================================================================

//
//  LessonStatusBadge.swift
//  ios
//
//  Atom: Badge showing lesson status (Completed, Up Next, Not Started)
//

import SwiftUI

struct LessonStatusBadge: View {
    let status: LessonStatus

    private var showBadge: Bool {
        status != .notStarted
    }

    var body: some View {
        if showBadge {
            HStack(spacing: AppSpacing.xs) {
                if status == .completed {
                    Image(systemName: "checkmark")
                        .font(.system(size: 9, weight: .bold))
                }

                Text(status.rawValue)
                    .font(AppTypography.caption)
                    .fontWeight(.medium)
            }
            .foregroundColor(status.color)
            .padding(.horizontal, AppSpacing.sm)
            .padding(.vertical, AppSpacing.xs)
            .background(status.backgroundColor)
            .cornerRadius(AppCornerRadius.small)
        } else {
            Text(status.rawValue)
                .font(AppTypography.caption)
                .foregroundColor(status.color)
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        LessonStatusBadge(status: .completed)
        LessonStatusBadge(status: .upNext)
        LessonStatusBadge(status: .notStarted)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/LessonStoryProgressBar.swift
================================================================================

//
//  LessonStoryProgressBar.swift
//  ios
//
//  Atom: Segmented progress bar for lesson story cards (Instagram/TikTok style)
//

import SwiftUI

struct LessonStoryProgressBar: View {
    let currentIndex: Int
    let totalCount: Int
    var currentProgress: CGFloat = 1.0  // Progress within current segment (0-1)

    private let segmentSpacing: CGFloat = 4
    private let segmentHeight: CGFloat = 3
    private let cornerRadius: CGFloat = 1.5

    var body: some View {
        GeometryReader { geometry in
            let totalSpacing = segmentSpacing * CGFloat(totalCount - 1)
            let segmentWidth = (geometry.size.width - totalSpacing) / CGFloat(totalCount)

            HStack(spacing: segmentSpacing) {
                ForEach(0..<totalCount, id: \.self) { index in
                    segmentView(
                        for: index,
                        width: segmentWidth
                    )
                }
            }
        }
        .frame(height: segmentHeight)
    }

    @ViewBuilder
    private func segmentView(for index: Int, width: CGFloat) -> some View {
        ZStack(alignment: .leading) {
            // Background track
            RoundedRectangle(cornerRadius: cornerRadius)
                .fill(Color.white.opacity(0.3))
                .frame(width: width, height: segmentHeight)

            // Filled portion
            if index < currentIndex {
                // Completed segments
                RoundedRectangle(cornerRadius: cornerRadius)
                    .fill(Color.white)
                    .frame(width: width, height: segmentHeight)
            } else if index == currentIndex {
                // Current segment with progress
                RoundedRectangle(cornerRadius: cornerRadius)
                    .fill(Color.white)
                    .frame(width: width * currentProgress, height: segmentHeight)
            }
            // Future segments remain empty (just background)
        }
        .frame(width: width, height: segmentHeight)
    }
}

#Preview {
    VStack(spacing: 30) {
        // First segment active
        LessonStoryProgressBar(currentIndex: 0, totalCount: 4)
            .padding(.horizontal, 16)

        // Second segment active with partial progress
        LessonStoryProgressBar(currentIndex: 1, totalCount: 4, currentProgress: 0.5)
            .padding(.horizontal, 16)

        // Third segment complete
        LessonStoryProgressBar(currentIndex: 2, totalCount: 4)
            .padding(.horizontal, 16)

        // Last segment active
        LessonStoryProgressBar(currentIndex: 3, totalCount: 4)
            .padding(.horizontal, 16)
    }
    .padding(.vertical, 50)
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/LevelBadge.swift
================================================================================

//
//  LevelBadge.swift
//  ios
//
//  Atom: Badge showing investor level (Foundation, Analyst, Strategist, Master)//

import SwiftUI

struct LevelBadge: View {
    let level: InvestorLevel
    let isActive: Bool
    let isCompleted: Bool

    private var backgroundColor: Color {
        if isActive || isCompleted {
            return level.color
        }
        return AppColors.cardBackgroundLight
    }

    private var iconColor: Color {
        if isActive || isCompleted {
            return .white
        }
        return AppColors.textMuted
    }

    private var textColor: Color {
        if isActive || isCompleted {
            return AppColors.textPrimary
        }
        return AppColors.textMuted
    }

    var body: some View {
        VStack(spacing: AppSpacing.xs) {
            // Icon circle
            ZStack {
                Circle()
                    .fill(backgroundColor)
                    .frame(width: 44, height: 44)

                Image(systemName: level.iconName)
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(iconColor)
            }

            // Label
            Text(level.rawValue)
                .font(AppTypography.caption)
                .foregroundColor(textColor)
        }
    }
}

#Preview {
    HStack(spacing: AppSpacing.xl) {
        LevelBadge(level: .foundation, isActive: true, isCompleted: true)
        LevelBadge(level: .analyst, isActive: false, isCompleted: false)
        LevelBadge(level: .strategist, isActive: false, isCompleted: false)
        LevelBadge(level: .master, isActive: false, isCompleted: false)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/LevelProgressBar.swift
================================================================================

//
//  LevelProgressBar.swift
//  ios
//
//  Atom: Progress bar with level color and fraction display
//

import SwiftUI

struct LevelProgressBar: View {
    let progress: Double
    let completed: Int
    let total: Int
    var color: Color = AppColors.primaryBlue
    var height: CGFloat = 4

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            // Progress bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background track
                    RoundedRectangle(cornerRadius: height / 2)
                        .fill(AppColors.cardBackgroundLight)
                        .frame(height: height)

                    // Progress fill
                    RoundedRectangle(cornerRadius: height / 2)
                        .fill(color)
                        .frame(
                            width: geometry.size.width * CGFloat(min(max(progress, 0), 1)),
                            height: height
                        )
                }
            }
            .frame(height: height)

            // Progress text
            Text("\(completed)/\(total)")
                .font(AppTypography.caption)
                .fontWeight(.medium)
                .foregroundColor(AppColors.textMuted)
                .frame(minWidth: 28, alignment: .trailing)
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        LevelProgressBar(progress: 0.14, completed: 1, total: 7, color: AppColors.bullish)
        LevelProgressBar(progress: 0.0, completed: 0, total: 7, color: AppColors.primaryBlue)
        LevelProgressBar(progress: 0.5, completed: 3, total: 6, color: AppColors.alertPurple)
        LevelProgressBar(progress: 1.0, completed: 6, total: 6, color: AppColors.neutral)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/LiveIndicator.swift
================================================================================

//
//  LiveIndicator.swift
//  ios
//
//  Atom: Animated live/pulsing indicator dot
//

import SwiftUI

struct LiveIndicator: View {
    @State private var isAnimating = false

    var body: some View {
//        Circle()
//            .fill(AppColors.bearish)
//            .frame(width: 8, height: 8)
//            .scaleEffect(isAnimating ? 1.2 : 1.0)
//            .opacity(isAnimating ? 0.7 : 1.0)
//            .animation(
//                Animation.easeInOut(duration: 1.0)
//                    .repeatForever(autoreverses: true),
//                value: isAnimating
//            )
//            .onAppear {
//                isAnimating = true
//            }
        ZStack {

                    // Outer pulsing ring (fixed position)

                    Circle()

                        .fill(AppColors.bearish.opacity(0.3))

                        .frame(width: 12, height: 12)

                        .scaleEffect(isAnimating ? 1.0 : 0.8)

                        .opacity(isAnimating ? 0.0 : 0.5)

         

                    // Inner solid dot (never moves)

                    Circle()

                        .fill(AppColors.bearish)

                        .frame(width: 8, height: 8)

                }

                .frame(width: 12, height: 12) // Fixed frame prevents layout shifts

                .animation(

                    Animation.easeInOut(duration: 1.0)

                        .repeatForever(autoreverses: true),

                    value: isAnimating

                )

                .onAppear {

                    isAnimating = true

                }
    }
}

#Preview {
    HStack(spacing: 8) {
        LiveIndicator()
        Text("Live News")
            .font(AppTypography.bodyBold)
            .foregroundColor(AppColors.textPrimary)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/MarketStatusBadge.swift
================================================================================

//
//  MarketStatusBadge.swift
//  ios
//
//  Atom: Market status indicator badge (Open, Closed, Pre-Market, After Hours)
//

import SwiftUI

struct MarketStatusBadge: View {
    let status: MarketStatus

    private var statusColor: Color {
        switch status {
        case .open:
            return AppColors.bullish
        case .closed:
            return AppColors.textMuted
        case .preMarket, .afterHours:
            return AppColors.neutral
        }
    }

    private var showPulse: Bool {
        if case .open = status {
            return true
        }
        return false
    }

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            // Status indicator dot
            Circle()
                .fill(statusColor)
                .frame(width: 6, height: 6)

            // Status text
            Text(status.displayText)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        MarketStatusBadge(status: .open)
        MarketStatusBadge(status: .closed(
            date: Date(),
            time: "4:00 PM",
            timezone: "EST"
        ))
        MarketStatusBadge(status: .preMarket)
        MarketStatusBadge(status: .afterHours)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/MarqueeText.swift
================================================================================

//
//  MarqueeText.swift
//  ios
//
//  Atom: Auto-scrolling marquee text for long titles
//  Used when text overflows its container
//

import SwiftUI

struct MarqueeText: View {
    let text: String
    var font: Font = AppTypography.bodyBold
    var color: Color = AppColors.textPrimary
    var speed: Double = 30 // points per second
    var delayBeforeScroll: Double = 2.0
    var spacing: CGFloat = 40

    @State private var textWidth: CGFloat = 0
    @State private var containerWidth: CGFloat = 0
    @State private var offset: CGFloat = 0
    @State private var isAnimating: Bool = false

    private var needsScrolling: Bool {
        textWidth > containerWidth
    }

    var body: some View {
        GeometryReader { geometry in
            let containerW = geometry.size.width

            ZStack(alignment: .leading) {
                if needsScrolling {
                    // Scrolling text with duplicate for seamless loop
                    HStack(spacing: spacing) {
                        textView
                        textView
                    }
                    .offset(x: offset)
                    .onAppear {
                        containerWidth = containerW
                        startScrollingIfNeeded()
                    }
                    .onChange(of: text) { _, _ in
                        resetAnimation()
                    }
                } else {
                    // Static text when it fits
                    textView
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .clipped()
            .onAppear {
                containerWidth = containerW
            }
        }
        .frame(height: measureTextHeight())
    }

    private var textView: some View {
        Text(text)
            .font(font)
            .foregroundColor(color)
            .lineLimit(1)
            .fixedSize(horizontal: true, vertical: false)
            .background(
                GeometryReader { proxy in
                    Color.clear
                        .onAppear {
                            textWidth = proxy.size.width
                        }
                }
            )
    }

    private func measureTextHeight() -> CGFloat {
        // Approximate height based on font
        return 20
    }

    private func startScrollingIfNeeded() {
        guard needsScrolling, !isAnimating else { return }
        isAnimating = true

        // Initial delay before starting scroll
        DispatchQueue.main.asyncAfter(deadline: .now() + delayBeforeScroll) {
            animateScroll()
        }
    }

    private func animateScroll() {
        guard needsScrolling else { return }

        let totalWidth = textWidth + spacing
        let animationDuration = totalWidth / speed

        withAnimation(.linear(duration: animationDuration)) {
            offset = -totalWidth
        }

        // Reset and repeat
        DispatchQueue.main.asyncAfter(deadline: .now() + animationDuration) {
            offset = 0
            // Small pause at reset point
            DispatchQueue.main.asyncAfter(deadline: .now() + delayBeforeScroll) {
                if needsScrolling {
                    animateScroll()
                }
            }
        }
    }

    private func resetAnimation() {
        isAnimating = false
        offset = 0
        textWidth = 0

        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            startScrollingIfNeeded()
        }
    }
}

// MARK: - Preview
#Preview {
    VStack(spacing: AppSpacing.xl) {
        // Short text (no scroll)
        MarqueeText(text: "Short Title")
            .frame(width: 200)
            .background(AppColors.cardBackground)

        // Long text (scrolls)
        MarqueeText(text: "The Future of Digital Finance: Exploring the Intersection of Fintech Innovation")
            .frame(width: 200)
            .background(AppColors.cardBackground)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/MessageTimestamp.swift
================================================================================

//
//  MessageTimestamp.swift
//  ios
//
//  Atom: Timestamp label for chat messages
//

import SwiftUI

struct MessageTimestamp: View {
    let time: String
    var alignment: HorizontalAlignment = .trailing

    var body: some View {
        Text(time)
            .font(AppTypography.caption)
            .foregroundColor(AppColors.textMuted)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        MessageTimestamp(time: "2:36 PM")
        MessageTimestamp(time: "2:38 PM", alignment: .leading)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/MiniStockChart.swift
================================================================================

//
//  MiniStockChart.swift
//  ios
//
//  Atom: Mini chart for stock performance display
//

import SwiftUI

struct MiniStockChart: View {
    let data: [Double]
    let isPositive: Bool
    var height: CGFloat = 80

    private var normalizedData: [CGFloat] {
        guard let minVal = data.min(), let maxVal = data.max(), maxVal > minVal else {
            return data.map { _ in CGFloat(0.5) }
        }
        return data.map { CGFloat(($0 - minVal) / (maxVal - minVal)) }
    }

    var body: some View {
        GeometryReader { geometry in
            let width = geometry.size.width
            let stepX = width / CGFloat(max(normalizedData.count - 1, 1))

            ZStack {
                // Gradient fill under the line
                Path { path in
                    guard !normalizedData.isEmpty else { return }

                    path.move(to: CGPoint(x: 0, y: height))

                    for (index, value) in normalizedData.enumerated() {
                        let x = CGFloat(index) * stepX
                        let y = height - (value * height)
                        path.addLine(to: CGPoint(x: x, y: y))
                    }

                    path.addLine(to: CGPoint(x: width, y: height))
                    path.closeSubpath()
                }
                .fill(
                    LinearGradient(
                        colors: [
                            (isPositive ? AppColors.bullish : AppColors.bearish).opacity(0.3),
                            (isPositive ? AppColors.bullish : AppColors.bearish).opacity(0.0)
                        ],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )

                // Line
                Path { path in
                    guard !normalizedData.isEmpty else { return }

                    for (index, value) in normalizedData.enumerated() {
                        let x = CGFloat(index) * stepX
                        let y = height - (value * height)

                        if index == 0 {
                            path.move(to: CGPoint(x: x, y: y))
                        } else {
                            path.addLine(to: CGPoint(x: x, y: y))
                        }
                    }
                }
                .stroke(
                    isPositive ? AppColors.bullish : AppColors.bearish,
                    style: StrokeStyle(lineWidth: 2, lineCap: .round, lineJoin: .round)
                )
            }
        }
        .frame(height: height)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        MiniStockChart(data: [220, 225, 218, 230, 235, 228, 240, 238, 245, 242], isPositive: true)
        MiniStockChart(data: [250, 245, 240, 235, 230, 228, 225, 220], isPositive: false)
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/MomentumLegendItem.swift
================================================================================

//
//  MomentumLegendItem.swift
//  ios
//
//  Legend item for momentum chart (Net Positive/Net Negative)
//

import SwiftUI

struct MomentumLegendItem: View {
    let color: Color
    let label: String
    let value: Int

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            Circle()
                .fill(color)
                .frame(width: 8, height: 8)

            Text(label)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)

            Text(value >= 0 ? "+\(value)" : "\(value)")
                .font(AppTypography.captionBold)
                .foregroundColor(color)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.lg) {
            MomentumLegendItem(color: AppColors.bullish, label: "Net Positive", value: 17)
            MomentumLegendItem(color: AppColors.bearish, label: "Net Negative", value: -7)
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/MoreOptionsButton.swift
================================================================================

//
//  MoreOptionsButton.swift
//  ios
//
//  Atom: Three-dot menu button for more options
//

import SwiftUI

struct MoreOptionsButton: View {
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Image(systemName: "ellipsis")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(AppColors.textMuted)
                .rotationEffect(.degrees(90))
                .frame(width: 24, height: 24)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    MoreOptionsButton()
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/NewsCardBulletPoint.swift
================================================================================

//
//  NewsCardBulletPoint.swift
//  ios
//
//  Atom: Bullet point item for news card expanded content
//

import SwiftUI

struct NewsCardBulletPoint: View {
    let text: String

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.sm) {
            // Bullet dot
            Circle()
                .fill(AppColors.textMuted)
                .frame(width: 5, height: 5)
                .padding(.top, 6)

            // Bullet text with bold title support
            formattedText
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
    }

    private var formattedText: Text {
        // Check if text has a bold prefix (text before colon)
        if let colonIndex = text.firstIndex(of: ":") {
            let boldPart = String(text[..<colonIndex])
            let normalPart = String(text[text.index(after: colonIndex)...])
            return Text("\(Text(boldPart + ":").fontWeight(.semibold).foregroundColor(AppColors.textPrimary))\(Text(normalPart))")
        } else {
            return Text(text)
        }
    }
}

#Preview {
    VStack(alignment: .leading, spacing: AppSpacing.md) {
        NewsCardBulletPoint(text: "High Pre-Orders Abroad: Apple is seeing unusually strong pre-order numbers in Europe and Asia.")
        NewsCardBulletPoint(text: "Supply Chain Scaling: Apple is ramping up production and logistics overseas.")
        NewsCardBulletPoint(text: "An example: This is an explain.")
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/NewsCardExpandIcon.swift
================================================================================

//
//  NewsCardExpandIcon.swift
//  ios
//
//  Atom: Expand/collapse chevron icon for news cards
//

import SwiftUI

struct NewsCardExpandIcon: View {
    let isExpanded: Bool
    var size: CGFloat = 16

    var body: some View {
        Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
            .font(.system(size: size, weight: .semibold))
            .foregroundColor(AppColors.textSecondary)
            .animation(.easeInOut(duration: 0.2), value: isExpanded)
    }
}

#Preview {
    HStack(spacing: AppSpacing.xxl) {
        VStack(spacing: AppSpacing.sm) {
            NewsCardExpandIcon(isExpanded: false)
            Text("Collapsed")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }

        VStack(spacing: AppSpacing.sm) {
            NewsCardExpandIcon(isExpanded: true)
            Text("Expanded")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/NewsExternalLinkIcon.swift
================================================================================

//
//  NewsExternalLinkIcon.swift
//  ios
//
//  Atom: External link icon for opening full article
//

import SwiftUI

struct NewsExternalLinkIcon: View {
    var size: CGFloat = 16

    var body: some View {
        Image(systemName: "arrow.up.right.square")
            .font(.system(size: size, weight: .medium))
            .foregroundColor(AppColors.textSecondary)
    }
}

#Preview {
    HStack(spacing: AppSpacing.lg) {
        NewsExternalLinkIcon()
        NewsExternalLinkIcon(size: 20)
        NewsExternalLinkIcon(size: 24)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/NewsSentimentBadge.swift
================================================================================

//
//  NewsSentimentBadge.swift
//  ios
//
//  Atom: Displays news sentiment as a colored badge
//

import SwiftUI

struct NewsSentimentBadge: View {
    let sentiment: NewsSentiment

    private var backgroundColor: Color {
        switch sentiment {
        case .positive:
            return AppColors.bullish.opacity(0.2)
        case .negative:
            return AppColors.bearish.opacity(0.2)
        case .neutral:
            return AppColors.neutral.opacity(0.2)
        }
    }

    private var textColor: Color {
        switch sentiment {
        case .positive:
            return AppColors.bullish
        case .negative:
            return AppColors.bearish
        case .neutral:
            return AppColors.neutral
        }
    }

    var body: some View {
        Text(sentiment.displayName)
            .font(AppTypography.captionBold)
            .foregroundColor(textColor)
            .padding(.horizontal, AppSpacing.sm)
            .padding(.vertical, AppSpacing.xs)
            .background(backgroundColor)
            .clipShape(Capsule())
    }
}

#Preview {
    VStack(spacing: 10) {
        NewsSentimentBadge(sentiment: .positive)
        NewsSentimentBadge(sentiment: .negative)
        NewsSentimentBadge(sentiment: .neutral)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/NewsSourceBrandIcon.swift
================================================================================

//
//  NewsSourceBrandIcon.swift
//  ios
//
//  Atom: Branded news source icon with background color
//

import SwiftUI

struct NewsSourceBrandIcon: View {
    let source: NewsSource
    var size: CGFloat = 32
    var cornerRadius: CGFloat = 8

    private var brandColor: Color {
        Color(hex: source.brandColor)
    }

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: cornerRadius)
                .fill(brandColor)

            // Use custom icon if available, otherwise system icon
            if let iconName = source.iconName {
                Image(iconName)
                    .resizable()
                    .scaledToFit()
                    .frame(width: size * 0.5, height: size * 0.5)
                    .foregroundColor(.white)
            } else {
                Image(systemName: "newspaper.fill")
                    .font(.system(size: size * 0.45, weight: .semibold))
                    .foregroundColor(.white)
            }
        }
        .frame(width: size, height: size)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        HStack(spacing: AppSpacing.md) {
            NewsSourceBrandIcon(source: NewsSource(name: "CNBC", iconName: nil))
            Text("CNBC")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)
        }

        HStack(spacing: AppSpacing.md) {
            NewsSourceBrandIcon(source: NewsSource(name: "Reuters", iconName: nil))
            Text("Reuters")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)
        }

        HStack(spacing: AppSpacing.md) {
            NewsSourceBrandIcon(source: NewsSource(name: "Bloomberg", iconName: nil))
            Text("Bloomberg")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/NumberedBadge.swift
================================================================================

//
//  NumberedBadge.swift
//  ios
//
//  Atom: Circular numbered badge for key takeaways
//

import SwiftUI

struct NumberedBadge: View {
    let number: Int
    var size: CGFloat = 24
    var backgroundColor: Color = AppColors.primaryBlue
    var textColor: Color = AppColors.textPrimary

    var body: some View {
        Text("\(number)")
            .font(.system(size: size * 0.5, weight: .bold, design: .rounded))
            .foregroundColor(textColor)
            .frame(width: size, height: size)
            .background(backgroundColor)
            .clipShape(Circle())
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        HStack(spacing: AppSpacing.md) {
            NumberedBadge(number: 1)
            NumberedBadge(number: 2)
            NumberedBadge(number: 3)
            NumberedBadge(number: 4)
        }

        HStack(spacing: AppSpacing.md) {
            NumberedBadge(number: 1, size: 20)
            NumberedBadge(number: 2, size: 28)
            NumberedBadge(number: 3, size: 32)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/OverallProgressIndicator.swift
================================================================================

//
//  OverallProgressIndicator.swift
//  ios
//
//  Atom: Shows overall lesson progress with segmented bar
//

import SwiftUI

struct OverallProgressIndicator: View {
    let completed: Int
    let total: Int
    var segmentCount: Int = 27

    private var progress: Double {
        guard total > 0 else { return 0 }
        return Double(completed) / Double(total)
    }

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            // Segmented progress bar
            GeometryReader { geometry in
                HStack(spacing: 2) {
                    ForEach(0..<segmentCount, id: \.self) { index in
                        let isCompleted = index < completed
                        RoundedRectangle(cornerRadius: 2)
                            .fill(isCompleted ? AppColors.bullish : AppColors.cardBackgroundLight)
                            .frame(height: 6)
                    }
                }
            }
            .frame(height: 6)
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        OverallProgressIndicator(completed: 1, total: 27)
        OverallProgressIndicator(completed: 10, total: 27)
        OverallProgressIndicator(completed: 27, total: 27)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/PageIndicatorDots.swift
================================================================================

//
//  PageIndicatorDots.swift
//  ios
//
//  Atom: Page indicator dots for carousel/pagination
//

import SwiftUI

struct PageIndicatorDots: View {
    let currentPage: Int
    let totalPages: Int

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            ForEach(0..<totalPages, id: \.self) { index in
                Circle()
                    .fill(index == currentPage ? AppColors.textPrimary : AppColors.textMuted)
                    .frame(width: 8, height: 8)
            }
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        PageIndicatorDots(currentPage: 0, totalPages: 3)
        PageIndicatorDots(currentPage: 1, totalPages: 3)
        PageIndicatorDots(currentPage: 2, totalPages: 3)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/PerformanceBadge.swift
================================================================================

//
//  PerformanceBadge.swift
//  ios
//
//  Atom: Performance percentage badge with color indication
//

import SwiftUI

struct PerformanceBadge: View {
    let changePercent: Double
    var fontSize: CGFloat = 13
    var showBackground: Bool = false

    private var isPositive: Bool {
        changePercent >= 0
    }

    private var formattedChange: String {
        let sign = changePercent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", changePercent))%"
    }

    private var color: Color {
        isPositive ? AppColors.bullish : AppColors.bearish
    }

    var body: some View {
        Text(formattedChange)
            .font(.system(size: fontSize, weight: .semibold))
            .foregroundColor(color)
            .padding(.horizontal, showBackground ? AppSpacing.sm : 0)
            .padding(.vertical, showBackground ? AppSpacing.xs : 0)
            .background(
                showBackground
                    ? RoundedRectangle(cornerRadius: AppCornerRadius.small)
                        .fill(color.opacity(0.15))
                    : nil
            )
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        PerformanceBadge(changePercent: 8.42)
        PerformanceBadge(changePercent: -3.15)
        PerformanceBadge(changePercent: 18.67, showBackground: true)
        PerformanceBadge(changePercent: -5.23, showBackground: true)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/PersonaBadge.swift
================================================================================

//
//  PersonaBadge.swift
//  ios
//
//  Atom: Badge showing investor persona name
//

import SwiftUI

struct PersonaBadge: View {
    let persona: InvestorPersona

    var body: some View {
        Text(persona.displayName)
            .font(AppTypography.caption)
            .foregroundColor(.white)
            .padding(.horizontal, AppSpacing.sm)
            .padding(.vertical, AppSpacing.xs)
            .background(Color(hex: persona.badgeColor))
            .clipShape(Capsule())
    }
}

#Preview {
    VStack(spacing: 10) {
        ForEach(InvestorPersona.allCases, id: \.self) { persona in
            PersonaBadge(persona: persona)
        }
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/PersonaIcon.swift
================================================================================

//
//  PersonaIcon.swift
//  ios
//
//  Atom: Persona avatar icon with customizable style
//

import SwiftUI

struct PersonaIcon: View {
    let persona: AnalysisPersona
    var size: CGFloat = 48
    var isSelected: Bool = false

    var body: some View {
        ZStack {
            Circle()
                .fill(
                    isSelected
                        ? persona.accentColor
                        : AppColors.cardBackgroundLight
                )
                .frame(width: size, height: size)

            Image(systemName: persona.systemIconName)
                .font(.system(size: size * 0.4, weight: .semibold))
                .foregroundColor(
                    isSelected
                        ? AppColors.textPrimary
                        : persona.accentColor
                )
        }
    }
}

#Preview {
    HStack(spacing: AppSpacing.lg) {
        ForEach(AnalysisPersona.allCases) { persona in
            PersonaIcon(persona: persona, isSelected: persona == .warrenBuffett)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/PlayAudioButton.swift
================================================================================

//
//  PlayAudioButton.swift
//  ios
//
//  Atom: Play audio button that integrates with AudioManager
//  Displays play/pause state and triggers audio playback
//

import SwiftUI

struct PlayAudioButton: View {
    @EnvironmentObject private var audioManager: AudioManager
    let episode: AudioEpisode
    var style: Style = .primary
    var size: Size = .medium

    enum Style {
        case primary   // Filled blue button
        case secondary // Outlined button
        case minimal   // Just icon
    }

    enum Size {
        case small
        case medium
        case large

        var iconSize: CGFloat {
            switch self {
            case .small: return 12
            case .medium: return 14
            case .large: return 18
            }
        }

        var padding: (h: CGFloat, v: CGFloat) {
            switch self {
            case .small: return (AppSpacing.md, AppSpacing.sm)
            case .medium: return (AppSpacing.lg, AppSpacing.sm)
            case .large: return (AppSpacing.xl, AppSpacing.md)
            }
        }
    }

    private var isCurrentEpisode: Bool {
        audioManager.currentEpisode?.id == episode.id
    }

    private var isPlaying: Bool {
        isCurrentEpisode && audioManager.isPlaying
    }

    var body: some View {
        Button(action: handleTap) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: isPlaying ? "pause.fill" : "play.fill")
                    .font(.system(size: size.iconSize, weight: .semibold))
                    .offset(x: isPlaying ? 0 : 1)

                if style != .minimal {
                    Text(buttonLabel)
                        .font(AppTypography.calloutBold)
                }
            }
            .foregroundColor(foregroundColor)
            .padding(.horizontal, size.padding.h)
            .padding(.vertical, size.padding.v)
            .background(background)
            .clipShape(Capsule())
        }
        .buttonStyle(PlainButtonStyle())
    }

    private var buttonLabel: String {
        if isPlaying {
            return "Pause"
        } else if isCurrentEpisode && audioManager.playbackState == .paused {
            return "Resume"
        } else {
            return "Listen"
        }
    }

    private var foregroundColor: Color {
        switch style {
        case .primary:
            return .white
        case .secondary:
            return AppColors.primaryBlue
        case .minimal:
            return AppColors.textPrimary
        }
    }

    @ViewBuilder
    private var background: some View {
        switch style {
        case .primary:
            LinearGradient(
                colors: [AppColors.primaryBlue, Color(hex: "6366F1")],
                startPoint: .leading,
                endPoint: .trailing
            )
        case .secondary:
            Capsule()
                .strokeBorder(AppColors.primaryBlue, lineWidth: 1.5)
        case .minimal:
            Color.clear
        }
    }

    private func handleTap() {
        if isCurrentEpisode {
            audioManager.togglePlayPause()
        } else {
            audioManager.play(episode)
        }
    }
}

// MARK: - Large Play Button (for hero cards)
struct LargePlayButton: View {
    @EnvironmentObject private var audioManager: AudioManager
    let episode: AudioEpisode
    var showLabel: Bool = true

    private var isCurrentEpisode: Bool {
        audioManager.currentEpisode?.id == episode.id
    }

    private var isPlaying: Bool {
        isCurrentEpisode && audioManager.isPlaying
    }

    var body: some View {
        Button(action: handleTap) {
            HStack(spacing: AppSpacing.md) {
                ZStack {
                    Circle()
                        .fill(.white)
                        .frame(width: 48, height: 48)

                    Image(systemName: isPlaying ? "pause.fill" : "play.fill")
                        .font(.system(size: 18, weight: .bold))
                        .foregroundColor(AppColors.background)
                        .offset(x: isPlaying ? 0 : 2)
                }

                if showLabel {
                    VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                        Text(isPlaying ? "Now Playing" : "Listen Now")
                            .font(AppTypography.bodyBold)
                            .foregroundColor(.white)

                        Text(episode.formattedDuration)
                            .font(AppTypography.caption)
                            .foregroundColor(.white.opacity(0.8))
                    }
                }
            }
        }
        .buttonStyle(PlainButtonStyle())
    }

    private func handleTap() {
        if isCurrentEpisode {
            audioManager.togglePlayPause()
        } else {
            audioManager.play(episode)
        }
    }
}

// MARK: - Preview
#Preview {
    VStack(spacing: AppSpacing.xl) {
        // Primary styles
        HStack(spacing: AppSpacing.lg) {
            PlayAudioButton(episode: .sampleMoneyMoves, style: .primary, size: .small)
            PlayAudioButton(episode: .sampleMoneyMoves, style: .primary, size: .medium)
            PlayAudioButton(episode: .sampleMoneyMoves, style: .primary, size: .large)
        }

        // Secondary style
        PlayAudioButton(episode: .sampleMoneyMoves, style: .secondary)

        // Minimal style
        PlayAudioButton(episode: .sampleMoneyMoves, style: .minimal)

        // Large play button
        ZStack {
            LinearGradient(
                colors: [Color(hex: "1E3A5F"), Color(hex: "0D1B2A")],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .frame(height: 120)
            .clipShape(RoundedRectangle(cornerRadius: AppCornerRadius.large))

            LargePlayButton(episode: .sampleMoneyMoves)
        }
    }
    .padding()
    .background(AppColors.background)
    .environmentObject(AudioManager.shared)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/PriceActionBadge.swift
================================================================================

//
//  PriceActionBadge.swift
//  ios
//
//  Atom: Capsule badge showing a price catalyst tag and percentage change.
//  e.g. [ Earnings Miss  -12.4% ]
//

import SwiftUI

struct PriceActionBadge: View {
    let tag: String
    let percentage: String
    let isPositive: Bool

    private var percentColor: Color {
        isPositive ? AppColors.bullish : AppColors.bearish
    }

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            Text(tag)
                .font(AppTypography.captionBold)
                .foregroundColor(AppColors.textPrimary)
        }
        .padding(.horizontal, AppSpacing.md)
        .padding(.vertical, AppSpacing.sm)
        .background(
            Capsule()
                .fill(AppColors.cardBackgroundLight)
                .overlay(
                    Capsule()
                        .stroke(percentColor.opacity(0.25), lineWidth: 1)
                )
        )
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        PriceActionBadge(tag: "Earnings Miss", percentage: "-12.4%", isPositive: false)
        PriceActionBadge(tag: "FDA Approval", percentage: "+24.1%", isPositive: true)
        PriceActionBadge(tag: "Normal", percentage: "+1.2%", isPositive: true)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/PriceChangeLabel.swift
================================================================================

//
//  PriceChangeLabel.swift
//  ios
//
//  Atom: Price change label with arrow indicator
//

import SwiftUI

struct PriceChangeLabel: View {
    let changePercent: Double
    var showArrow: Bool = true
    var fontSize: CGFloat = 13

    private var isPositive: Bool {
        changePercent >= 0
    }

    private var formattedChange: String {
        let sign = changePercent >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", changePercent))%"
    }

    private var color: Color {
        isPositive ? AppColors.bullish : AppColors.bearish
    }

    var body: some View {
        HStack(spacing: 2) {
            if showArrow {
                Image(systemName: isPositive ? "arrowtriangle.up.fill" : "arrowtriangle.down.fill")
                    .font(.system(size: fontSize * 0.7))
            }

            Text(formattedChange)
                .font(.system(size: fontSize, weight: .semibold))
        }
        .foregroundColor(color)
    }
}

#Preview {
    VStack(spacing: 12) {
        PriceChangeLabel(changePercent: 2.34)
        PriceChangeLabel(changePercent: -1.23)
        PriceChangeLabel(changePercent: 5.67, showArrow: false)
        PriceChangeLabel(changePercent: -0.45, fontSize: 16)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ProfitPowerInfoIcon.swift
================================================================================

//
//  ProfitPowerInfoIcon.swift
//  ios
//
//  Atom: Info icon button that displays profit power explanation sheet
//

import SwiftUI

struct ProfitPowerInfoIcon: View {
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            ZStack {
                Circle()
                    .stroke(AppColors.textMuted, lineWidth: 1.5)
                    .frame(width: 20, height: 20)

                Text("i")
                    .font(.system(size: 12, weight: .semibold, design: .serif))
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.sm) {
            Text("Profit Power")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            ProfitPowerInfoIcon(action: {})
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ProfitPowerLegendItem.swift
================================================================================

//
//  ProfitPowerLegendItem.swift
//  ios
//
//  Atom: Single legend item with colored dot/line and label for Profit Power chart
//

import SwiftUI

struct ProfitPowerLegendItem: View {
    let marginType: ProfitMarginType

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            legendIndicator

            Text(marginType.shortName)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)
                .multilineTextAlignment(.leading)
                .lineLimit(2)
                .fixedSize(horizontal: false, vertical: true)
        }
    }

    @ViewBuilder
    private var legendIndicator: some View {
        if marginType.isDashed {
            // Dashed circle for sector average
            Circle()
                .stroke(marginType.color, style: StrokeStyle(lineWidth: 2, dash: [4, 3]))
                .frame(width: 10, height: 10)
        } else {
            // Filled circle for regular margins
            Circle()
                .fill(marginType.color)
                .frame(width: 10, height: 10)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(alignment: .leading, spacing: AppSpacing.md) {
            ForEach(ProfitMarginType.allCases) { marginType in
                ProfitPowerLegendItem(marginType: marginType)
            }
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ProfitPowerPeriodToggle.swift
================================================================================

//
//  ProfitPowerPeriodToggle.swift
//  ios
//
//  Atom: Toggle between Annual and Quarterly period views for Profit Power chart
//

import SwiftUI

struct ProfitPowerPeriodToggle: View {
    @Binding var selectedPeriod: ProfitPowerPeriodType

    var body: some View {
        HStack(spacing: 0) {
            ForEach(ProfitPowerPeriodType.allCases) { period in
                Button(action: {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedPeriod = period
                    }
                }) {
                    Text(period.rawValue)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(selectedPeriod == period ? AppColors.textPrimary : AppColors.textMuted)
                        .padding(.horizontal, AppSpacing.md)
                        .padding(.vertical, AppSpacing.xs + 2)
                        .background(
                            RoundedRectangle(cornerRadius: AppCornerRadius.small)
                                .fill(selectedPeriod == period ? AppColors.toggleSelectedBackground : Color.clear)
                        )
                }
                .buttonStyle(.plain)
            }
        }
        .padding(AppSpacing.xs)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.toggleBackground)
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            ProfitPowerPeriodToggle(selectedPeriod: .constant(.annual))
            ProfitPowerPeriodToggle(selectedPeriod: .constant(.quarterly))
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ProgressBar.swift
================================================================================

//
//  ProgressBar.swift
//  ios
//
//  Atom: Horizontal progress bar with percentage
//

import SwiftUI

struct ProgressBar: View {
    let progress: Double // 0.0 to 1.0
    var height: CGFloat = 6
    var showPercentage: Bool = true
    var color: Color = AppColors.primaryBlue

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Progress bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background track
                    RoundedRectangle(cornerRadius: height / 2)
                        .fill(AppColors.cardBackgroundLight)
                        .frame(height: height)

                    // Progress fill
                    RoundedRectangle(cornerRadius: height / 2)
                        .fill(color)
                        .frame(width: geometry.size.width * CGFloat(min(max(progress, 0), 1)), height: height)
                }
            }
            .frame(height: height)

            // Percentage text
            if showPercentage {
                Text("\(Int(progress * 100))%")
                    .font(AppTypography.footnote)
                    .fontWeight(.medium)
                    .foregroundColor(AppColors.textSecondary)
                    .frame(width: 40, alignment: .trailing)
            }
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        ProgressBar(progress: 0.67)
        ProgressBar(progress: 0.33, color: AppColors.neutral)
        ProgressBar(progress: 1.0, color: AppColors.bullish)
        ProgressBar(progress: 0.0)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/RatingBadge.swift
================================================================================

//
//  RatingBadge.swift
//  ios
//
//  Atom: Displays rating score with color coding
//

import SwiftUI

struct RatingBadge: View {
    let rating: Double
    let maxRating: Double

    init(rating: Double, maxRating: Double = 5.0) {
        self.rating = rating
        self.maxRating = maxRating
    }

    private var backgroundColor: Color {
        let ratio = rating / maxRating
        if ratio >= 0.8 {
            return AppColors.bullish
        } else if ratio >= 0.6 {
            return AppColors.primaryBlue
        } else if ratio >= 0.4 {
            return AppColors.neutral
        } else {
            return AppColors.bearish
        }
    }

    var body: some View {
        Text(String(format: "%.1f/%.0f", rating, maxRating))
            .font(AppTypography.captionBold)
            .foregroundColor(.white)
            .padding(.horizontal, AppSpacing.sm)
            .padding(.vertical, AppSpacing.xs)
            .background(backgroundColor)
            .cornerRadius(AppCornerRadius.small)
    }
}

#Preview {
    HStack(spacing: 10) {
        RatingBadge(rating: 4.6)
        RatingBadge(rating: 4.2)
        RatingBadge(rating: 3.3)
        RatingBadge(rating: 2.0)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/RatingDistributionBar.swift
================================================================================

//
//  RatingDistributionBar.swift
//  ios
//
//  Horizontal bar representing a single rating distribution
//

import SwiftUI

struct RatingDistributionBar: View {
    let label: String
    let count: Int
    let color: Color
    let maxCount: Int

    private var fillRatio: CGFloat {
        guard maxCount > 0 else { return 0 }
        return CGFloat(count) / CGFloat(maxCount)
    }

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Label
            Text(label)
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textSecondary)
                .frame(width: 70, alignment: .leading)

            // Bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background track
                    RoundedRectangle(cornerRadius: 2)
                        .fill(AppColors.cardBackgroundLight)
                        .frame(height: 8)

                    // Filled portion
                    RoundedRectangle(cornerRadius: 2)
                        .fill(color)
                        .frame(width: geometry.size.width * fillRatio, height: 8)
                }
            }
            .frame(height: 8)

            // Count
            Text("\(count)")
                .font(AppTypography.footnoteBold)
                .foregroundColor(AppColors.textPrimary)
                .frame(width: 24, alignment: .trailing)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.md) {
            RatingDistributionBar(label: "Strong Buy", count: 18, color: AppColors.bullish, maxCount: 18)
            RatingDistributionBar(label: "Buy", count: 14, color: Color(hex: "4ADE80"), maxCount: 18)
            RatingDistributionBar(label: "Hold", count: 6, color: AppColors.neutral, maxCount: 18)
            RatingDistributionBar(label: "Sell", count: 2, color: AppColors.bearish, maxCount: 18)
            RatingDistributionBar(label: "Strong Sell", count: 0, color: Color(hex: "991B1B"), maxCount: 18)
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ReadTimeLabel.swift
================================================================================

//
//  ReadTimeLabel.swift
//  ios
//
//  Atom: Label showing estimated reading/learning time
//

import SwiftUI

struct ReadTimeLabel: View {
    let minutes: Int
    var showIcon: Bool = true
    var style: Style = .compact

    enum Style {
        case compact
        case expanded
    }

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            if showIcon {
                Image(systemName: "clock")
                    .font(.system(size: 10, weight: .medium))
            }

            Text(formattedTime)
                .font(AppTypography.caption)
        }
        .foregroundColor(AppColors.textSecondary)
    }

    private var formattedTime: String {
        switch style {
        case .compact:
            return "\(minutes) min"
        case .expanded:
            return "\(minutes) minutes"
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ReadTimeLabel(minutes: 8)
        ReadTimeLabel(minutes: 12, style: .expanded)
        ReadTimeLabel(minutes: 4, showIcon: false)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ReadingHighlightText.swift
================================================================================

//
//  ReadingHighlightText.swift
//  ios
//
//  Atom: Text view that highlights words progressively as AI voice reads
//  Creates a karaoke-style effect where spoken words are highlighted
//

import SwiftUI

struct ReadingHighlightText: View {
    let text: String
    let currentWordRange: NSRange
    let isReading: Bool
    var baseColor: Color = AppColors.textSecondary
    var highlightColor: Color = AppColors.accentCyan
    var spokenColor: Color = AppColors.textPrimary
    var font: Font = .system(size: 20, weight: .regular)

    var body: some View {
        highlightedTextView
            .font(font)
            .lineSpacing(6)
    }

    @ViewBuilder
    private var highlightedTextView: some View {
        if isReading && currentWordRange.length > 0 {
            // Show progressive highlighting
            buildHighlightedText()
        } else {
            // Show base text
            Text(text)
                .foregroundColor(baseColor)
        }
    }

    private func buildHighlightedText() -> Text {
        let nsText = text as NSString
        let totalLength = nsText.length

        // Safety check
        guard currentWordRange.location < totalLength else {
            return Text(text).foregroundColor(baseColor)
        }

        // Build AttributedString with different colors
        var attributedString = AttributedString()

        // Text before current word (already spoken) - keep base color
        if currentWordRange.location > 0 {
            let spokenText = nsText.substring(to: currentWordRange.location)
            var portion = AttributedString(spokenText)
            portion.foregroundColor = baseColor
            attributedString.append(portion)
        }

        // Current word being spoken - cyan highlight
        let endOfCurrentWord = min(currentWordRange.location + currentWordRange.length, totalLength)
        let currentWord = nsText.substring(with: NSRange(location: currentWordRange.location, length: endOfCurrentWord - currentWordRange.location))
        var currentPortion = AttributedString(currentWord)
        currentPortion.foregroundColor = highlightColor
        attributedString.append(currentPortion)

        // Remaining text (not yet spoken) - base color
        if endOfCurrentWord < totalLength {
            let remainingText = nsText.substring(from: endOfCurrentWord)
            var remainingPortion = AttributedString(remainingText)
            remainingPortion.foregroundColor = baseColor
            attributedString.append(remainingPortion)
        }

        return Text(attributedString)
    }
}

// MARK: - Segmented Version for pre-highlighted text

struct ReadingHighlightSegmentedText: View {
    let segments: [HighlightedTextSegment]
    let currentWordRange: NSRange
    let isReading: Bool
    var baseColor: Color = AppColors.textSecondary
    var highlightColor: Color = AppColors.accentCyan
    var spokenColor: Color = AppColors.textPrimary
    var font: Font = .system(size: 20, weight: .regular)

    // Computed full text for range calculations
    private var fullText: String {
        segments.map { $0.text }.joined()
    }

    var body: some View {
        highlightedTextView
            .font(font)
            .lineSpacing(6)
    }

    @ViewBuilder
    private var highlightedTextView: some View {
        if isReading && currentWordRange.length > 0 {
            buildHighlightedText()
        } else {
            // Show base segmented text with original highlighting
            buildBaseSegmentedText()
        }
    }

    private func buildBaseSegmentedText() -> Text {
        var attributedString = AttributedString()
        
        for segment in segments {
            var portion = AttributedString(segment.text)
            portion.foregroundColor = segment.isHighlighted ? highlightColor : baseColor
            attributedString.append(portion)
        }
        
        return Text(attributedString)
    }

    private func buildHighlightedText() -> Text {
        let nsText = fullText as NSString
        let totalLength = nsText.length

        guard currentWordRange.location < totalLength else {
            return buildBaseSegmentedText()
        }

        var attributedString = AttributedString()
        var currentPosition = 0

        for segment in segments {
            let segmentLength = segment.text.count
            let segmentEnd = currentPosition + segmentLength

            // Determine how this segment relates to the current reading position
            let currentWordStart = currentWordRange.location
            let currentWordEnd = min(currentWordRange.location + currentWordRange.length, totalLength)

            if segmentEnd <= currentWordStart {
                // Entire segment is before current word - use original coloring
                var portion = AttributedString(segment.text)
                portion.foregroundColor = segment.isHighlighted ? highlightColor : baseColor
                attributedString.append(portion)
            } else if currentPosition >= currentWordEnd {
                // Segment is after current word - use original coloring
                var portion = AttributedString(segment.text)
                portion.foregroundColor = segment.isHighlighted ? highlightColor : baseColor
                attributedString.append(portion)
            } else {
                // Segment contains the current word or is being spoken
                let nsSegment = segment.text as NSString

                // Calculate relative positions within this segment
                let relativeCurrentWordStart = max(0, currentWordStart - currentPosition)
                let relativeCurrentWordEnd = min(segmentLength, currentWordEnd - currentPosition)

                // Part 1: Text before current word
                if relativeCurrentWordStart > 0 {
                    let beforePortion = nsSegment.substring(to: relativeCurrentWordStart)
                    var portion = AttributedString(beforePortion)
                    portion.foregroundColor = segment.isHighlighted ? highlightColor : baseColor
                    attributedString.append(portion)
                }

                // Part 2: Current word being spoken (highlight color)
                if relativeCurrentWordEnd > relativeCurrentWordStart {
                    let currentPortion = nsSegment.substring(with: NSRange(location: relativeCurrentWordStart, length: relativeCurrentWordEnd - relativeCurrentWordStart))
                    var portion = AttributedString(currentPortion)
                    portion.foregroundColor = highlightColor
                    attributedString.append(portion)
                }

                // Part 3: Text after current word
                if relativeCurrentWordEnd < segmentLength {
                    let afterPortion = nsSegment.substring(from: relativeCurrentWordEnd)
                    var portion = AttributedString(afterPortion)
                    portion.foregroundColor = segment.isHighlighted ? highlightColor : baseColor
                    attributedString.append(portion)
                }
            }

            currentPosition = segmentEnd
        }

        return Text(attributedString)
    }
}

#Preview {
    VStack(spacing: 30) {
        // Simple text with highlighting
        ReadingHighlightText(
            text: "Price is what the market asks. Value is what the business is worth.",
            currentWordRange: NSRange(location: 18, length: 6), // "market"
            isReading: true
        )
        .padding()

        // Not reading state
        ReadingHighlightText(
            text: "Price is what the market asks. Value is what the business is worth.",
            currentWordRange: NSRange(location: 0, length: 0),
            isReading: false
        )
        .padding()

        // Segmented text
        ReadingHighlightSegmentedText(
            segments: [
                HighlightedTextSegment("Price is what the "),
                HighlightedTextSegment("market", highlighted: true),
                HighlightedTextSegment(" asks.")
            ],
            currentWordRange: NSRange(location: 5, length: 2), // "is"
            isReading: true
        )
        .padding()
    }
    .frame(maxWidth: .infinity, maxHeight: .infinity)
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/RecentActivitiesInfoIcon.swift
================================================================================

//
//  RecentActivitiesInfoIcon.swift
//  ios
//
//  Atom: Info icon button for Recent Activities section
//  Tappable icon that triggers educational sheet
//

import SwiftUI

struct RecentActivitiesInfoIcon: View {
    let onTap: () -> Void

    var body: some View {
        Button(action: onTap) {
            Image(systemName: "info.circle")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(AppColors.textMuted)
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        RecentActivitiesInfoIcon {
            print("Info tapped")
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/RelatedTickerChip.swift
================================================================================

//
//  RelatedTickerChip.swift
//  ios
//
//  Atom: Small chip displaying a related ticker symbol
//

import SwiftUI

struct RelatedTickerChip: View {
    let symbol: String
    var isHighlighted: Bool = false

    var body: some View {
        Text(symbol)
            .font(AppTypography.captionBold)
            .foregroundColor(isHighlighted ? AppColors.primaryBlue : AppColors.textSecondary)
            .padding(.horizontal, AppSpacing.sm)
            .padding(.vertical, AppSpacing.xs)
            .background(
                isHighlighted
                    ? AppColors.primaryBlue.opacity(0.15)
                    : AppColors.cardBackgroundLight
            )
            .cornerRadius(AppCornerRadius.small)
    }
}

#Preview {
    HStack(spacing: AppSpacing.sm) {
        RelatedTickerChip(symbol: "AAPL", isHighlighted: true)
        RelatedTickerChip(symbol: "MSFT")
        RelatedTickerChip(symbol: "GOOGL")
        RelatedTickerChip(symbol: "META")
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/RelatedTickerTag.swift
================================================================================

//
//  RelatedTickerTag.swift
//  ios
//
//  Atom: Tag showing a related stock ticker
//

import SwiftUI

struct RelatedTickerTag: View {
    let ticker: String
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Text(ticker)
                .font(AppTypography.footnote)
                .fontWeight(.medium)
                .foregroundColor(AppColors.textSecondary)
                .padding(.horizontal, AppSpacing.md)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    RoundedRectangle(cornerRadius: AppCornerRadius.small)
                        .fill(AppColors.cardBackgroundLight)
                )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    HStack(spacing: AppSpacing.sm) {
        RelatedTickerTag(ticker: "APPL")
        RelatedTickerTag(ticker: "ORCL")
        RelatedTickerTag(ticker: "TSLA")
        RelatedTickerTag(ticker: "NVDA")
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ReportMetricRow.swift
================================================================================

//
//  ReportMetricRow.swift
//  ios
//
//  Atom: Label-value row for displaying metrics in report cards
//

import SwiftUI

struct ReportMetricRow: View {
    let label: String
    let value: String
    var valueColor: Color = AppColors.textPrimary
    var labelColor: Color = AppColors.textSecondary
    var trend: DeepDiveMetric.MetricTrend? = nil

    var body: some View {
        HStack {
            Text(label)
                .font(AppTypography.subheadline)
                .foregroundColor(labelColor)

            Spacer()

            HStack(spacing: AppSpacing.xs) {
                if let trend = trend {
                    Image(systemName: trend.iconName)
                        .font(.system(size: 10, weight: .bold))
                        .foregroundColor(trend.color)
                }
                Text(value)
                    .font(AppTypography.subheadline)
                    .fontWeight(.semibold)
                    .foregroundColor(valueColor)
            }
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.sm) {
        ReportMetricRow(label: "Gross Margin", value: "70%")
        ReportMetricRow(label: "Net Margin", value: "25%", valueColor: AppColors.bullish)
        ReportMetricRow(label: "Revenue ROII", value: "+18%", trend: .up)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ReportScoreGauge.swift
================================================================================

//
//  ReportScoreGauge.swift
//  ios
//
//  Atom: Circular score display for the report quality rating (e.g. 82)
//

import SwiftUI

struct ReportScoreGauge: View {
    let score: Double
    let maxScore: Double
    let label: String
    var size: GaugeSize = .regular

    enum GaugeSize {
        case small
        case regular

        var circleSize: CGFloat {
            switch self {
            case .small: return 52
            case .regular: return 72
            }
        }

        var lineWidth: CGFloat {
            switch self {
            case .small: return 4
            case .regular: return 6
            }
        }

        var scoreFontSize: CGFloat {
            switch self {
            case .small: return 16
            case .regular: return 24
            }
        }

        var maxScoreFontSize: CGFloat {
            switch self {
            case .small: return 10
            case .regular: return 12
            }
        }

        var labelFont: Font {
            switch self {
            case .small: return AppTypography.caption
            case .regular: return AppTypography.footnote
            }
        }

        var spacing: CGFloat {
            switch self {
            case .small: return AppSpacing.xxs
            case .regular: return AppSpacing.sm
            }
        }
    }

    private var progress: Double {
        score / maxScore
    }

    private var scoreColor: Color {
        switch score {
        case 90...100: return AppColors.bullish          // Excellent Quality Business
        case 75..<90: return AppColors.bullish           // Strong Quality Business
        case 50..<75: return AppColors.neutral           // Fair Quality Business
        case 30..<50: return AppColors.alertOrange       // Weak Quality Business
        default: return AppColors.bearish                // Distressed Quality Business
        }
    }

    var body: some View {
        VStack(spacing: size.spacing) {
            ZStack {
                // Background circle
                Circle()
                    .stroke(AppColors.cardBackgroundLight, lineWidth: size.lineWidth)
                    .frame(width: size.circleSize, height: size.circleSize)

                // Progress arc
                Circle()
                    .trim(from: 0, to: progress)
                    .stroke(
                        scoreColor,
                        style: StrokeStyle(lineWidth: size.lineWidth, lineCap: .round)
                    )
                    .frame(width: size.circleSize, height: size.circleSize)
                    .rotationEffect(.degrees(-90))

                // Score text
                Text(String(format: "%.0f", score))
                    .font(.system(size: size.scoreFontSize, weight: .bold, design: .rounded))
                    .foregroundColor(AppColors.textPrimary)
            }

            if !label.isEmpty {
                Text(label)
                    .font(size.labelFont)
                    .foregroundColor(AppColors.textSecondary)
                    .multilineTextAlignment(.center)
            }
        }
    }
}

#Preview {
    ReportScoreGauge(score: 82, maxScore: 100, label: "Strong Quality Business")
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ReportSentimentBadge.swift
================================================================================

//
//  ReportSentimentBadge.swift
//  ios
//
//  Atom: Colored badge for sentiment labels (Overpriced, Underpriced, RAISED, etc.)
//

import SwiftUI

struct ReportSentimentBadge: View {
    let text: String
    let textColor: Color
    let backgroundColor: Color
    var fontSize: Font = AppTypography.caption

    var body: some View {
        Text(text)
            .font(fontSize)
            .fontWeight(.semibold)
            .foregroundColor(textColor)
            .padding(.horizontal, AppSpacing.sm)
            .padding(.vertical, AppSpacing.xs)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.small)
                    .fill(backgroundColor)
            )
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ReportSentimentBadge(
            text: "Overpriced",
            textColor: AppColors.bearish,
            backgroundColor: AppColors.bearish.opacity(0.15)
        )
        ReportSentimentBadge(
            text: "Underpriced",
            textColor: AppColors.bullish,
            backgroundColor: AppColors.bullish.opacity(0.15)
        )
        ReportSentimentBadge(
            text: "RAISED",
            textColor: AppColors.bullish,
            backgroundColor: AppColors.bullish.opacity(0.15)
        )
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ReportStatusBadge.swift
================================================================================

//
//  ReportStatusBadge.swift
//  ios
//
//  Atom: Status badge for report cards (Processing, Failed, Ready)
//

import SwiftUI

struct ReportStatusBadge: View {
    let status: ReportStatus

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            if status == .processing {
                // Animated dots for processing
                Image(systemName: "ellipsis")
                    .font(.system(size: 10, weight: .bold))
            }

            Text(status.rawValue)
                .font(AppTypography.caption)
                .fontWeight(.semibold)
        }
        .foregroundColor(status.color)
        .padding(.horizontal, AppSpacing.sm)
        .padding(.vertical, AppSpacing.xs)
        .background(
            Capsule()
                .fill(status.backgroundColor)
        )
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ReportStatusBadge(status: .processing)
        ReportStatusBadge(status: .failed)
        ReportStatusBadge(status: .ready)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/RevenueBreakdownLegendItem.swift
================================================================================

//
//  RevenueBreakdownLegendItem.swift
//  ios
//
//  Atom: Single legend item for revenue breakdown chart
//

import SwiftUI

struct RevenueBreakdownLegendItem: View {
    let color: Color
    let name: String
    let value: String
    let percentage: String

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.sm) {
            // Color dot
            Circle()
                .fill(color)
                .frame(width: 10, height: 10)
                .padding(.top, 4)

            // Name
            Text(name)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textPrimary)
                .frame(minWidth: 60, alignment: .leading)

            Spacer()

            // Value and percentage stacked
            VStack(alignment: .trailing, spacing: 0) {
                Text(value)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textPrimary)
                Text("(\(percentage))")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.md) {
            RevenueBreakdownLegendItem(
                color: .blue,
                name: "iPhone",
                value: "205.5B",
                percentage: "52%"
            )

            RevenueBreakdownLegendItem(
                color: .purple,
                name: "Services",
                value: "73.10B",
                percentage: "23%"
            )

            RevenueBreakdownLegendItem(
                color: .green,
                name: "Net Profit",
                value: "72B",
                percentage: "38%"
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SectionHeader.swift
================================================================================

//
//  SectionHeader.swift
//  ios
//
//  Atom: Section header with optional "See All" button
//

import SwiftUI

struct SectionHeader: View {
    let title: String
    var showSeeAll: Bool = false
    var onSeeAllTapped: (() -> Void)?

    var body: some View {
        HStack {
            Text(title)
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            Spacer()

            if showSeeAll {
                Button(action: {
                    onSeeAllTapped?()
                }) {
                    Text("See All")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
    }
}

#Preview {
    VStack(spacing: 20) {
        SectionHeader(title: "Daily Briefing")
        SectionHeader(title: "Recent Research", showSeeAll: true)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SegmentedTabControl.swift
================================================================================

//
//  SegmentedTabControl.swift
//  ios
//
//  Atom: Custom segmented control for tab switching
//

import SwiftUI

struct SegmentedTabControl<T: Hashable & RawRepresentable>: View where T.RawValue == String {
    let tabs: [T]
    @Binding var selectedTab: T

    var body: some View {
        HStack(spacing: 0) {
            ForEach(tabs, id: \.rawValue) { tab in
                Button {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedTab = tab
                    }
                } label: {
                    Text(tab.rawValue)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(selectedTab == tab ? AppColors.textPrimary : AppColors.textMuted)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, AppSpacing.md)
                        .background(
                            selectedTab == tab
                                ? AppColors.cardBackgroundLight
                                : Color.clear
                        )
                        .cornerRadius(AppCornerRadius.medium)
                }
                .buttonStyle(.plain)
            }
        }
        .padding(AppSpacing.xs)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var selected = TrackingTab.assets

        var body: some View {
            SegmentedTabControl(
                tabs: TrackingTab.allCases,
                selectedTab: $selected
            )
            .padding()
            .background(AppColors.background)
        }
    }

    return PreviewWrapper()
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SemiCircleGauge.swift
================================================================================

//
//  SemiCircleGauge.swift
//  ios
//
//  Semi-circle gauge for displaying sentiment/technical analysis scores
//

import SwiftUI

// MARK: - Gauge Type
enum GaugeType {
    case sentiment   // 3 zones: Bearish (0-30), Neutral (31-70), Bullish (71-100)
    case technical   // 5 zones: Strong Sell, Sell, Hold, Buy, Strong Buy

    var zoneColors: [Color] {
        switch self {
        case .sentiment:
            // Green (Bearish) -> Grey (Neutral) -> Red (Bullish)
            return [
                AppColors.bullish,           // 0-30: Green (Bearish)
                AppColors.bullish,
                Color(hex: "6B7280"),         // 31-70: Grey (Neutral)
                Color(hex: "6B7280"),
                AppColors.bearish            // 71-100: Red (Bullish)
            ]
        case .technical:
            // 5 distinct zones
            return [
                Color(hex: "991B1B"),         // Strong Sell - Dark Red
                AppColors.bearish,            // Sell - Red
                AppColors.neutral,            // Hold - Yellow
                Color(hex: "4ADE80"),         // Buy - Light Green
                AppColors.bullish             // Strong Buy - Green
            ]
        }
    }
}

struct SemiCircleGauge: View {
    let value: Double // 0.0 to 1.0
    let displayValue: String
    let label: String
    let labelColor: Color
    let gaugeType: GaugeType
    let showLabels: Bool
    let size: CGFloat

    init(
        value: Double,
        displayValue: String,
        label: String,
        labelColor: Color,
        gaugeType: GaugeType = .technical,
        showLabels: Bool = true,
        size: CGFloat = 200
    ) {
        self.value = min(max(value, 0), 1) // Clamp between 0 and 1
        self.displayValue = displayValue
        self.label = label
        self.labelColor = labelColor
        self.gaugeType = gaugeType
        self.showLabels = showLabels
        self.size = size
    }

    // Gradient colors for the gauge arc
    private let gradientColors: [Color] = [
        Color(hex: "EF4444"), // Red (bearish)
        Color(hex: "F97316"), // Orange
        Color(hex: "F59E0B"), // Yellow (neutral)
        Color(hex: "84CC16"), // Lime
        Color(hex: "22C55E")  // Green (bullish)
    ]

    private var needleAngle: Double {
        // Convert value (0-1) to angle (-180 to 0 degrees)
        // 0 = -180Â°, 0.5 = -90Â°, 1 = 0Â°
        return -180 + (value * 180)
    }

    var body: some View {
        VStack(spacing: AppSpacing.sm) {
            ZStack {
                // Background arc
                SemiCircleArc()
                    .stroke(AppColors.cardBackgroundLight, lineWidth: 20)
                    .frame(width: size, height: size / 2)

                // Colored zone arcs
                gaugeArcs

                // Needle
                GaugeNeedle(angle: needleAngle)
                    .frame(width: size, height: size / 2)

                // Center display
                VStack(spacing: 2) {
                    Text(displayValue)
                        .font(.system(size: size * 0.2, weight: .bold, design: .rounded))
                        .foregroundColor(labelColor)

                    Text(label)
                        .font(AppTypography.headline)
                        .foregroundColor(labelColor)
                }
                .offset(y: size * 0.1)

                // Scale labels
                if showLabels {
                    HStack {
                        Text("0")
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)

                        Spacer()

                        Text("50")
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)

                        Spacer()

                        Text("100")
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                    }
                    .frame(width: size + 20)
                    .offset(y: size * 0.35)
                }
            }
            .frame(width: size, height: size * 0.7)
        }
    }

    @ViewBuilder
    private var gaugeArcs: some View {
        switch gaugeType {
        case .sentiment:
            SentimentGaugeArcs(size: size)
        case .technical:
            TechnicalGaugeArcs(size: size)
        }
    }
}

// MARK: - Sentiment Gauge Arcs (3 zones)
struct SentimentGaugeArcs: View {
    let size: CGFloat

    var body: some View {
        ZStack {
            // Zone 1: Bearish (0-30) - Green - Left side
            SemiCircleArcSegment(startAngle: 180, endAngle: 126)
                .stroke(AppColors.bullish, style: StrokeStyle(lineWidth: 20, lineCap: .butt))
                .frame(width: size, height: size / 2)

            // Zone 2: Neutral (31-70) - Grey - Middle
            SemiCircleArcSegment(startAngle: 126, endAngle: 54)
                .stroke(Color(hex: "6B7280"), style: StrokeStyle(lineWidth: 20, lineCap: .butt))
                .frame(width: size, height: size / 2)

            // Zone 3: Bullish (71-100) - Red - Right side
            SemiCircleArcSegment(startAngle: 54, endAngle: 0)
                .stroke(AppColors.bearish, style: StrokeStyle(lineWidth: 20, lineCap: .butt))
                .frame(width: size, height: size / 2)
        }
    }
}

// MARK: - Technical Gauge Arcs (5 zones)
struct TechnicalGaugeArcs: View {
    let size: CGFloat

    var body: some View {
        ZStack {
            // Zone 1: Strong Sell (0-20) - Dark Red
            SemiCircleArcSegment(startAngle: 180, endAngle: 144)
                .stroke(Color(hex: "991B1B"), style: StrokeStyle(lineWidth: 20, lineCap: .butt))
                .frame(width: size, height: size / 2)

            // Zone 2: Sell (21-40) - Red
            SemiCircleArcSegment(startAngle: 144, endAngle: 108)
                .stroke(AppColors.bearish, style: StrokeStyle(lineWidth: 20, lineCap: .butt))
                .frame(width: size, height: size / 2)

            // Zone 3: Hold (41-60) - Yellow
            SemiCircleArcSegment(startAngle: 108, endAngle: 72)
                .stroke(AppColors.neutral, style: StrokeStyle(lineWidth: 20, lineCap: .butt))
                .frame(width: size, height: size / 2)

            // Zone 4: Buy (61-80) - Light Green
            SemiCircleArcSegment(startAngle: 72, endAngle: 36)
                .stroke(Color(hex: "4ADE80"), style: StrokeStyle(lineWidth: 20, lineCap: .butt))
                .frame(width: size, height: size / 2)

            // Zone 5: Strong Buy (81-100) - Green
            SemiCircleArcSegment(startAngle: 36, endAngle: 0)
                .stroke(AppColors.bullish, style: StrokeStyle(lineWidth: 20, lineCap: .butt))
                .frame(width: size, height: size / 2)
        }
    }
}

// MARK: - Semi Circle Arc Segment Shape
struct SemiCircleArcSegment: Shape {
    let startAngle: Double
    let endAngle: Double

    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.maxY)
        let radius = min(rect.width, rect.height * 2) / 2 - 10

        path.addArc(
            center: center,
            radius: radius,
            startAngle: .degrees(startAngle + 180),  // Adjust for coordinate system
            endAngle: .degrees(endAngle + 180),
            clockwise: true
        )

        return path
    }
}

// MARK: - Semi Circle Arc Shape (full arc for background)
struct SemiCircleArc: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.maxY)
        let radius = min(rect.width, rect.height * 2) / 2 - 10

        path.addArc(
            center: center,
            radius: radius,
            startAngle: .degrees(180),
            endAngle: .degrees(0),
            clockwise: false
        )

        return path
    }
}

// MARK: - Gauge Needle
struct GaugeNeedle: View {
    let angle: Double

    var body: some View {
        GeometryReader { geometry in
            let center = CGPoint(x: geometry.size.width / 2, y: geometry.size.height)
            let needleLength = min(geometry.size.width, geometry.size.height * 2) / 2 - 30

            Path { path in
                path.move(to: center)
                let endX = center.x + needleLength * cos(angle * .pi / 180)
                let endY = center.y + needleLength * sin(angle * .pi / 180)
                path.addLine(to: CGPoint(x: endX, y: endY))
            }
            .stroke(AppColors.textPrimary, style: StrokeStyle(lineWidth: 3, lineCap: .round))

            // Center circle
            Circle()
                .fill(AppColors.textPrimary)
                .frame(width: 12, height: 12)
                .position(center)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xxxl) {
            // Sentiment Gauge - Bearish (low value = bearish)
            VStack {
                Text("Sentiment Gauge (Bearish - Score 24)")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                SemiCircleGauge(
                    value: 0.24,
                    displayValue: "24",
                    label: "Bearish",
                    labelColor: AppColors.bearish,
                    gaugeType: .sentiment
                )
            }

            // Technical Gauge - Buy
            VStack {
                Text("Technical Gauge (Buy)")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                SemiCircleGauge(
                    value: 0.72,
                    displayValue: "Buy",
                    label: "12 of 18 indicators",
                    labelColor: AppColors.bullish,
                    gaugeType: .technical
                )
            }
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SendButton.swift
================================================================================

//
//  SendButton.swift
//  ios
//
//  Atom: Send button for chat input
//

import SwiftUI

struct SendButton: View {
    let isEnabled: Bool
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            ZStack {
                Circle()
                    .fill(isEnabled ? AppColors.primaryBlue : AppColors.cardBackgroundLight)
                    .frame(width: 44, height: 44)

                Image(systemName: "paperplane.fill")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(isEnabled ? .white : AppColors.textMuted)
                    .rotationEffect(.degrees(45))
            }
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(!isEnabled)
    }
}

#Preview {
    HStack(spacing: AppSpacing.lg) {
        SendButton(isEnabled: false)
        SendButton(isEnabled: true)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SentimentBadge.swift
================================================================================

//
//  SentimentBadge.swift
//  ios
//
//  Atom: Displays market sentiment as a badge
//

import SwiftUI

struct SentimentBadge: View {
    let sentiment: MarketSentiment

    private var backgroundColor: Color {
        switch sentiment {
        case .bullish:
            return AppColors.bullish.opacity(0.2)
        case .bearish:
            return AppColors.bearish.opacity(0.2)
        case .neutral:
            return AppColors.neutral.opacity(0.2)
        }
    }

    private var textColor: Color {
        switch sentiment {
        case .bullish:
            return AppColors.bullish
        case .bearish:
            return AppColors.bearish
        case .neutral:
            return AppColors.neutral
        }
    }

    private var icon: String {
        switch sentiment {
        case .bullish:
            return "arrow.up.right"
        case .bearish:
            return "arrow.down.right"
        case .neutral:
            return "minus"
        }
    }

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            Image(systemName: icon)
                .font(.system(size: 10, weight: .bold))

            Text(sentiment.rawValue)
                .font(AppTypography.captionBold)
        }
        .foregroundColor(textColor)
        .padding(.horizontal, AppSpacing.sm)
        .padding(.vertical, AppSpacing.xs)
        .background(backgroundColor)
        .clipShape(Capsule())
    }
}

#Preview {
    VStack(spacing: 10) {
        SentimentBadge(sentiment: .bullish)
        SentimentBadge(sentiment: .bearish)
        SentimentBadge(sentiment: .neutral)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SentimentPercentageBadge.swift
================================================================================

//
//  SentimentPercentageBadge.swift
//  ios
//
//  Atom: Sentiment badge showing Bullish/Bearish percentage
//

import SwiftUI

struct SentimentPercentageBadge: View {
    let sentiment: SentimentAnalysis.SentimentType
    let percentage: Int

    var body: some View {
        Text("\(sentiment.rawValue) \(percentage)%")
            .font(AppTypography.calloutBold)
            .foregroundColor(sentiment.color)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        SentimentPercentageBadge(sentiment: .bullish, percentage: 68)
        SentimentPercentageBadge(sentiment: .bearish, percentage: 45)
        SentimentPercentageBadge(sentiment: .neutral, percentage: 50)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ShareSheet.swift
================================================================================

//
//  ShareSheet.swift
//  ios
//
//  Atom: Share sheet component using UIActivityViewController
//  A UIKit bridge for presenting the native iOS share sheet
//

import SwiftUI

struct ShareSheet: UIViewControllerRepresentable {
    let items: [Any]
    var excludedActivityTypes: [UIActivity.ActivityType]? = nil

    func makeUIViewController(context: Context) -> UIActivityViewController {
        let controller = UIActivityViewController(activityItems: items, applicationActivities: nil)
        controller.excludedActivityTypes = excludedActivityTypes
        return controller
    }

    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}

// MARK: - Preview
#Preview {
    Text("Share Sheet")
        .sheet(isPresented: .constant(true)) {
            ShareSheet(items: ["Sample content to share"])
        }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/ShareholderBreakdownInfoIcon.swift
================================================================================

//
//  ShareholderBreakdownInfoIcon.swift
//  ios
//
//  Atom: Info icon button for Shareholder Breakdown section
//  Tappable icon that triggers educational sheet
//

import SwiftUI

struct ShareholderBreakdownInfoIcon: View {
    let onTap: () -> Void

    var body: some View {
        Button(action: onTap) {
            Image(systemName: "info.circle")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(AppColors.textMuted)
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ShareholderBreakdownInfoIcon {
            print("Info tapped")
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SignalOfConfidenceInfoIcon.swift
================================================================================

//
//  SignalOfConfidenceInfoIcon.swift
//  ios
//
//  Atom: Info icon button for Signal of Confidence section
//

import SwiftUI

struct SignalOfConfidenceInfoIcon: View {
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            ZStack {
                Circle()
                    .fill(AppColors.cardBackgroundLight)
                    .frame(width: 24, height: 24)

                Image(systemName: "info")
                    .font(.system(size: 12, weight: .semibold))
                    .foregroundColor(AppColors.textSecondary)
            }
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        SignalOfConfidenceInfoIcon {
            print("Info tapped")
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SignalOfConfidenceLegendItem.swift
================================================================================

//
//  SignalOfConfidenceLegendItem.swift
//  ios
//
//  Atom: Single legend item with colored indicator and label for Signal of Confidence chart
//

import SwiftUI

struct SignalOfConfidenceLegendItem: View {
    let metricType: SignalOfConfidenceMetricType

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            Circle()
                .fill(metricType.color)
                .frame(width: 10, height: 10)

            Text(metricType.rawValue)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)
                .lineLimit(1)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(alignment: .leading, spacing: AppSpacing.md) {
            ForEach(SignalOfConfidenceMetricType.allCases) { metricType in
                SignalOfConfidenceLegendItem(metricType: metricType)
            }
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SignalOfConfidenceViewToggle.swift
================================================================================

//
//  SignalOfConfidenceViewToggle.swift
//  ios
//
//  Atom: Toggle between Yield (%) and Capital ($) views for Signal of Confidence chart
//

import SwiftUI

struct SignalOfConfidenceViewToggle: View {
    @Binding var selectedView: SignalOfConfidenceViewType

    var body: some View {
        HStack(spacing: 0) {
            ForEach(SignalOfConfidenceViewType.allCases) { viewType in
                Button(action: {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedView = viewType
                    }
                }) {
                    Text(viewType.rawValue)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(selectedView == viewType ? AppColors.textPrimary : AppColors.textMuted)
                        .padding(.horizontal, AppSpacing.md)
                        .padding(.vertical, AppSpacing.xs + 2)
                        .background(
                            RoundedRectangle(cornerRadius: AppCornerRadius.small)
                                .fill(selectedView == viewType ? AppColors.toggleSelectedBackground : Color.clear)
                        )
                }
                .buttonStyle(.plain)
            }
        }
        .padding(AppSpacing.xs)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.toggleBackground)
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            SignalOfConfidenceViewToggle(selectedView: .constant(.yield))
            SignalOfConfidenceViewToggle(selectedView: .constant(.capital))
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SmartMoneyFlowLegendItem.swift
================================================================================

//
//  SmartMoneyFlowLegendItem.swift
//  ios
//
//  Atom: Single legend item for smart money flow chart
//  Shows colored dot and label
//

import SwiftUI

struct SmartMoneyFlowLegendItem: View {
    let color: Color
    let label: String

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            // Color indicator dot
            Circle()
                .fill(color)
                .frame(width: 8, height: 8)

            // Label
            Text(label)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.lg) {
            SmartMoneyFlowLegendItem(
                color: HoldersColors.buyVolume,
                label: "Buy Volume"
            )

            SmartMoneyFlowLegendItem(
                color: HoldersColors.sellVolume,
                label: "Sell Volume"
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SmartMoneyInfoIcon.swift
================================================================================

//
//  SmartMoneyInfoIcon.swift
//  ios
//
//  Atom: Info icon button for Smart Money section
//  Tappable icon that triggers educational sheet
//

import SwiftUI

struct SmartMoneyInfoIcon: View {
    let onTap: () -> Void

    var body: some View {
        Button(action: onTap) {
            Image(systemName: "info.circle")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(AppColors.textMuted)
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        SmartMoneyInfoIcon {
            print("Info tapped")
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SnapshotRatingIndicator.swift
================================================================================

//
//  SnapshotRatingIndicator.swift
//  ios
//
//  Atom: Rating indicator with icon and optional stroke for Snapshots
//

import SwiftUI

struct SnapshotRatingIndicator: View {
    let category: SnapshotCategory
    let rating: SnapshotRatingLevel
    var iconSize: CGFloat = 18

    private var backgroundColor: Color {
        rating.color.opacity(0.15)
    }

    private var iconColor: Color {
        rating.color
    }

    var body: some View {
        ZStack {
            // Background circle
            Circle()
                .fill(backgroundColor)
                .frame(width: iconSize + 12, height: iconSize + 12)

            // Stroke for excellent (5-star) or poor (1-star) ratings
            if rating.hasStroke {
                Circle()
                    .stroke(rating.color, lineWidth: 2)
                    .frame(width: iconSize + 12, height: iconSize + 12)
            }

            // Icon
            Image(systemName: category.iconName)
                .font(.system(size: iconSize * 0.7, weight: .semibold))
                .foregroundColor(iconColor)
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        HStack(spacing: AppSpacing.lg) {
            SnapshotRatingIndicator(category: .profitability, rating: .excellent)
            SnapshotRatingIndicator(category: .growth, rating: .average)
            SnapshotRatingIndicator(category: .price, rating: .strong)
        }
        HStack(spacing: AppSpacing.lg) {
            SnapshotRatingIndicator(category: .financialHealth, rating: .poor)
            SnapshotRatingIndicator(category: .insidersOwnership, rating: .weak)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SnapshotStarRating.swift
================================================================================

//
//  SnapshotStarRating.swift
//  ios
//
//  Atom: Star rating display for Snapshots with colored/gray stars
//

import SwiftUI

struct SnapshotStarRating: View {
    let rating: SnapshotRatingLevel
    let maxRating: Int = 5
    var starSize: CGFloat = 12

    var body: some View {
        HStack(spacing: 2) {
            ForEach(0..<maxRating, id: \.self) { index in
                Image(systemName: index < rating.starCount ? "star.fill" : "star")
                    .font(.system(size: starSize))
                    .foregroundColor(index < rating.starCount ? rating.color : AppColors.textMuted)
            }
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        HStack(spacing: AppSpacing.lg) {
            SnapshotStarRating(rating: .excellent)
            Text("Excellent").foregroundColor(.white)
        }
        HStack(spacing: AppSpacing.lg) {
            SnapshotStarRating(rating: .strong)
            Text("Strong").foregroundColor(.white)
        }
        HStack(spacing: AppSpacing.lg) {
            SnapshotStarRating(rating: .average)
            Text("Average").foregroundColor(.white)
        }
        HStack(spacing: AppSpacing.lg) {
            SnapshotStarRating(rating: .weak)
            Text("Weak").foregroundColor(.white)
        }
        HStack(spacing: AppSpacing.lg) {
            SnapshotStarRating(rating: .poor)
            Text("Poor").foregroundColor(.white)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SortButton.swift
================================================================================

//
//  SortButton.swift
//  ios
//
//  Atom: Sort button with icon
//

import SwiftUI

struct SortButton: View {
    var onTap: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            HStack(spacing: AppSpacing.xs) {
                Text("Sort")
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)

                Image(systemName: "arrow.up.arrow.down")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(AppColors.textSecondary)
            }
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    SortButton()
        .padding()
        .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SourceLabel.swift
================================================================================

//
//  SourceLabel.swift
//  ios
//
//  Atom: Displays news source with icon
//

import SwiftUI

struct SourceLabel: View {
    let source: NewsSource

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            Image(systemName: source.systemIconName)
                .font(.system(size: 10, weight: .medium))
                .foregroundColor(AppColors.textMuted)

            Text(source.name)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }
    }
}

#Preview {
    VStack(spacing: 10) {
        SourceLabel(source: NewsSource(name: "Reuters", iconName: nil))
        SourceLabel(source: NewsSource(name: "CNBC", iconName: nil))
        SourceLabel(source: NewsSource(name: "Bloomberg", iconName: nil))
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SparklineView.swift
================================================================================

//
//  SparklineView.swift
//  ios
//
//  Atom: Mini chart for market tickers
//

import SwiftUI

struct SparklineView: View {
    let data: [Double]
    let isPositive: Bool

    private var lineColor: Color {
        isPositive ? AppColors.bullish : AppColors.bearish
    }

    private var gradientColor: LinearGradient {
        LinearGradient(
            colors: [lineColor.opacity(0.3), lineColor.opacity(0.0)],
            startPoint: .top,
            endPoint: .bottom
        )
    }

    var body: some View {
        GeometryReader { geometry in
            let width = geometry.size.width
            let height = geometry.size.height

            if data.count > 1 {
                let minValue = data.min() ?? 0
                let maxValue = data.max() ?? 1
                let range = maxValue - minValue
                let stepX = width / CGFloat(data.count - 1)

                ZStack {
                    // Gradient fill
                    Path { path in
                        path.move(to: CGPoint(x: 0, y: height))

                        for (index, value) in data.enumerated() {
                            let x = CGFloat(index) * stepX
                            let y = height - (CGFloat((value - minValue) / range) * height)
                            if index == 0 {
                                path.addLine(to: CGPoint(x: x, y: y))
                            } else {
                                path.addLine(to: CGPoint(x: x, y: y))
                            }
                        }

                        path.addLine(to: CGPoint(x: width, y: height))
                        path.closeSubpath()
                    }
                    .fill(gradientColor)

                    // Line
                    Path { path in
                        for (index, value) in data.enumerated() {
                            let x = CGFloat(index) * stepX
                            let y = height - (CGFloat((value - minValue) / range) * height)
                            if index == 0 {
                                path.move(to: CGPoint(x: x, y: y))
                            } else {
                                path.addLine(to: CGPoint(x: x, y: y))
                            }
                        }
                    }
                    .stroke(lineColor, style: StrokeStyle(lineWidth: 1.5, lineCap: .round, lineJoin: .round))
                }
            }
        }
    }
}

#Preview {
    VStack(spacing: 20) {
        SparklineView(
            data: [100, 102, 98, 105, 103, 108, 110, 107, 112, 115],
            isPositive: true
        )
        .frame(width: 80, height: 30)

        SparklineView(
            data: [115, 112, 108, 105, 110, 103, 100, 98, 95, 92],
            isPositive: false
        )
        .frame(width: 80, height: 30)
    }
    .padding()
    .background(AppColors.cardBackground)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/StarRatingView.swift
================================================================================

//
//  StarRatingView.swift
//  ios
//
//  Atom: Star rating display (0-5 scale)
//

import SwiftUI

struct StarRatingView: View {
    let rating: Double
    let maxRating: Int = 5
    var starSize: CGFloat = 14
    var showValue: Bool = true

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            // Stars
            HStack(spacing: 2) {
                ForEach(0..<maxRating, id: \.self) { index in
                    starImage(for: index)
                        .font(.system(size: starSize))
                        .foregroundColor(starColor(for: index))
                }
            }

            // Rating value
            if showValue {
                Text(String(format: "%.1f", rating))
                    .font(AppTypography.footnote)
                    .fontWeight(.semibold)
                    .foregroundColor(AppColors.textPrimary)
            }
        }
    }

    private func starImage(for index: Int) -> Image {
        let threshold = Double(index) + 0.5
        if rating >= Double(index + 1) {
            return Image(systemName: "star.fill")
        } else if rating >= threshold {
            return Image(systemName: "star.leadinghalf.filled")
        } else {
            return Image(systemName: "star")
        }
    }

    private func starColor(for index: Int) -> Color {
        if rating > Double(index) {
            return Color(hex: "F59E0B") // Gold/Amber
        } else {
            return AppColors.textMuted
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        StarRatingView(rating: 5.0)
        StarRatingView(rating: 4.5)
        StarRatingView(rating: 3.0)
        StarRatingView(rating: 2.5)
        StarRatingView(rating: 0.0)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/StockPriceDisplay.swift
================================================================================

//
//  StockPriceDisplay.swift
//  ios
//
//  Atom: Large stock price display with change percentage
//

import SwiftUI

struct StockPriceDisplay: View {
    let price: String
    let change: String
    let period: String
    let isPositive: Bool

    var body: some View {
        HStack(alignment: .top) {
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(price)
                    .font(.system(size: 32, weight: .bold, design: .rounded))
                    .foregroundColor(AppColors.textPrimary)

                Text("Current Price")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            Spacer()

            VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                Text(change)
                    .font(AppTypography.headline)
                    .foregroundColor(isPositive ? AppColors.bullish : AppColors.bearish)

                Text(period)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        StockPriceDisplay(price: "$242.84", change: "+8.7%", period: "1 Month", isPositive: true)
        StockPriceDisplay(price: "$185.92", change: "-2.3%", period: "1 Week", isPositive: false)
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/StorageProgressBar.swift
================================================================================

//
//  StorageProgressBar.swift
//  ios
//
//  Atom: Progress bar for storage usage display
//

import SwiftUI

struct StorageProgressBar: View {
    let progress: Double // 0.0 to 1.0

    private var progressColor: Color {
        if progress > 0.9 {
            return AppColors.bearish
        } else if progress > 0.7 {
            return AppColors.neutral
        } else {
            return AppColors.primaryBlue
        }
    }

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Background track
                Capsule()
                    .fill(AppColors.cardBackgroundLight)
                    .frame(height: 6)

                // Progress fill
                Capsule()
                    .fill(progressColor)
                    .frame(width: geometry.size.width * CGFloat(min(progress, 1.0)), height: 6)
            }
        }
        .frame(height: 6)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        StorageProgressBar(progress: 0.3)
        StorageProgressBar(progress: 0.73)
        StorageProgressBar(progress: 0.85)
        StorageProgressBar(progress: 0.95)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/StudyScheduleTimeLabel.swift
================================================================================

//
//  StudyScheduleTimeLabel.swift
//  ios
//
//  Atom: Time label for study schedule (e.g., "9:00 AM")
//

import SwiftUI

struct StudyScheduleTimeLabel: View {
    let time: String
    var isEditable: Bool = true
    var color: Color = AppColors.primaryBlue

    var body: some View {
        Text(time)
            .font(AppTypography.calloutBold)
            .foregroundColor(color)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        StudyScheduleTimeLabel(time: "9:00 AM")
        StudyScheduleTimeLabel(time: "8:00 PM", color: AppColors.textSecondary)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/SuggestionChipView.swift
================================================================================

//
//  SuggestionChipView.swift
//  ios
//
//  Atom: Suggestion chip/pill for chat suggestions
//

import SwiftUI

struct SuggestionChipView: View {
    let chip: SuggestionChip
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Text(chip.text)
                .font(AppTypography.callout)
                .foregroundColor(chip.type.textColor)
                .padding(.horizontal, AppSpacing.lg)
                .padding(.vertical, AppSpacing.md)
                .background(
                    RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                        .fill(chip.type.backgroundColor)
                )
                .overlay(
                    RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                        .stroke(chip.type.borderColor, lineWidth: 1)
                )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ForEach(SuggestionChip.sampleData) { chip in
            SuggestionChipView(chip: chip)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/TabPill.swift
================================================================================

//
//  TabPill.swift
//  ios
//
//  Atom: Tab pill button for segment control
//

import SwiftUI

struct TabPill: View {
    let title: String
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Text(title)
                .font(AppTypography.callout)
                .fontWeight(isSelected ? .semibold : .regular)
                .foregroundColor(isSelected ? AppColors.textPrimary : AppColors.textSecondary)
                .padding(.horizontal, AppSpacing.lg)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    Group {
                        if isSelected {
                            Capsule()
                                .fill(AppColors.cardBackgroundLight)
                        }
                    }
                )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    HStack(spacing: 0) {
        TabPill(title: "Research", isSelected: true)
        TabPill(title: "Reports", isSelected: false)
    }
    .padding(AppSpacing.xs)
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.pill)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/TappableSearchBar.swift
================================================================================

//
//  TappableSearchBar.swift
//  ios
//
//  Atom: A search bar placeholder that acts as a button to navigate to search
//

import SwiftUI

struct TappableSearchBar: View {
    var placeholder: String = "Search ticker or ask AI..."
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "magnifyingglass")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(AppColors.textMuted)

                Text(placeholder)
                    .font(AppTypography.body)
                    .foregroundColor(AppColors.textMuted)

                Spacer()
            }
            .padding(.horizontal, AppSpacing.md)
            .padding(.vertical, AppSpacing.md)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack {
        TappableSearchBar()
        TappableSearchBar(placeholder: "Search or ask Caudex AI...")
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/TechnicalLevelIndicator.swift
================================================================================

//
//  TechnicalLevelIndicator.swift
//  ios
//
//  Numbered indicator (1-5) for technical analysis gauge levels
//

import SwiftUI

struct TechnicalLevelIndicator: View {
    let level: Int
    let isActive: Bool
    let activeColor: Color

    var body: some View {
        ZStack {
            Circle()
                .fill(isActive ? activeColor : AppColors.cardBackgroundLight)
                .frame(width: 28, height: 28)

            Text("\(level)")
                .font(AppTypography.footnoteBold)
                .foregroundColor(isActive ? AppColors.textPrimary : AppColors.textMuted)
        }
    }
}

// MARK: - Technical Level Indicators Row
struct TechnicalLevelIndicatorsRow: View {
    let activeLevel: Int // 1-5
    let labels: [String]

    private let levelColors: [Color] = [
        Color(hex: "991B1B"), // Strong Sell - dark red
        AppColors.bearish,    // Sell - red
        AppColors.neutral,    // Hold - yellow
        Color(hex: "4ADE80"), // Buy - light green
        AppColors.bullish     // Strong Buy - green
    ]

    var body: some View {
        HStack(spacing: 0) {
            ForEach(1...5, id: \.self) { level in
                VStack(spacing: AppSpacing.sm) {
                    // Level indicator
                    TechnicalLevelIndicator(
                        level: level,
                        isActive: level == activeLevel,
                        activeColor: levelColors[level - 1]
                    )
                    
                    // Label with fixed height to keep circles aligned
                    Text(labels[level - 1])
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .multilineTextAlignment(.center)
                        .frame(height: 32) // Fixed height to accommodate 2 lines
                }
                .frame(maxWidth: .infinity)
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            TechnicalLevelIndicatorsRow(
                activeLevel: 4,
                labels: ["Strong\nSell", "Sell", "Hold", "Buy", "Strong\nBuy"]
            )

            HStack(spacing: AppSpacing.md) {
                TechnicalLevelIndicator(level: 1, isActive: false, activeColor: AppColors.bearish)
                TechnicalLevelIndicator(level: 2, isActive: false, activeColor: AppColors.bearish)
                TechnicalLevelIndicator(level: 3, isActive: true, activeColor: AppColors.neutral)
                TechnicalLevelIndicator(level: 4, isActive: false, activeColor: AppColors.bullish)
                TechnicalLevelIndicator(level: 5, isActive: false, activeColor: AppColors.bullish)
            }
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/TechnicalSignalBadge.swift
================================================================================

//
//  TechnicalSignalBadge.swift
//  ios
//
//  Badge displaying technical signal (Buy, Sell, Hold, etc.)
//

import SwiftUI

struct TechnicalSignalBadge: View {
    let title: String
    let signal: TechnicalSignal
    let indicatorCount: String
    var isSelected: Bool = false

    var body: some View {
        VStack(alignment: .center, spacing: AppSpacing.xs) {
            Text(title)
                .font(AppTypography.caption)
                .foregroundColor(isSelected ? AppColors.textPrimary : AppColors.textMuted)

            Text(indicatorCount)
                .font(AppTypography.caption)
                .foregroundColor(isSelected ? AppColors.textSecondary : AppColors.textMuted)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, AppSpacing.md)
        .padding(.horizontal, AppSpacing.sm)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(isSelected ? AppColors.cardBackgroundLight : AppColors.cardBackground)
        )
        .overlay(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .stroke(isSelected ? Color.gray : Color.clear, lineWidth: 2)
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        HStack(spacing: AppSpacing.md) {
            TechnicalSignalBadge(
                title: "Daily Signal",
                signal: .buy,
                indicatorCount: "12 of 18 indicators",
                isSelected: true
            )

            TechnicalSignalBadge(
                title: "Weekly Signal",
                signal: .strongBuy,
                indicatorCount: "14 of 18 indicators",
                isSelected: false
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/TickerChip.swift
================================================================================

//
//  TickerChip.swift
//  ios
//
//  Atom: Quick ticker selection chip
//

import SwiftUI

struct TickerChip: View {
    let ticker: QuickTicker
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Text(ticker.symbol)
                .font(AppTypography.footnote)
                .fontWeight(.medium)
                .foregroundColor(isSelected ? AppColors.textPrimary : AppColors.textSecondary)
                .padding(.horizontal, AppSpacing.md)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    RoundedRectangle(cornerRadius: AppCornerRadius.small)
                        .fill(isSelected ? AppColors.primaryBlue : AppColors.cardBackgroundLight)
                )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    HStack(spacing: AppSpacing.sm) {
        TickerChip(ticker: QuickTicker(symbol: "AAPL"))
        TickerChip(ticker: QuickTicker(symbol: "TSLA"), isSelected: true)
        TickerChip(ticker: QuickTicker(symbol: "NVDA"))
        TickerChip(ticker: QuickTicker(symbol: "BTC"))
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/TimeAgoLabel.swift
================================================================================

//
//  TimeAgoLabel.swift
//  ios
//
//  Atom: Label showing time ago or date for chat history items
//

import SwiftUI

struct TimeAgoLabel: View {
    let text: String

    var body: some View {
        Text(text)
            .font(AppTypography.caption)
            .foregroundColor(AppColors.textMuted)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        TimeAgoLabel(text: "2h ago")
        TimeAgoLabel(text: "1d ago")
        TimeAgoLabel(text: "12/20/2025")
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/TimeRangeButton.swift
================================================================================

//
//  TimeRangeButton.swift
//  ios
//
//  Atom: Time range selection button for chart
//

import SwiftUI

struct TimeRangeButton: View {
    let range: ChartTimeRange
    let isSelected: Bool
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Text(range.displayName)
                .font(AppTypography.footnoteBold)
                .foregroundColor(isSelected ? AppColors.textPrimary : AppColors.textMuted)
                .padding(.horizontal, 10)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    isSelected
                        ? RoundedRectangle(cornerRadius: AppCornerRadius.small)
                            .fill(AppColors.cardBackgroundLight)
                        : nil
                )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    HStack(spacing: AppSpacing.xs) {
        TimeRangeButton(range: .oneDay, isSelected: false)
        TimeRangeButton(range: .oneWeek, isSelected: false)
        TimeRangeButton(range: .threeMonths, isSelected: true)
        TimeRangeButton(range: .oneYear, isSelected: false)
        TimeRangeButton(range: .fiveYears, isSelected: false)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/TimelineConnector.swift
================================================================================

//
//  TimelineConnector.swift
//  ios
//
//  Atom: Vertical line connecting timeline items
//

import SwiftUI

struct TimelineConnector: View {
    var height: CGFloat = 60

    var body: some View {
        Rectangle()
            .fill(AppColors.textMuted.opacity(0.3))
            .frame(width: 1, height: height)
    }
}

#Preview {
    VStack(spacing: 0) {
        TimelineDot()
        TimelineConnector(height: 40)
        TimelineDot()
        TimelineConnector(height: 60)
        TimelineDot(isHighlighted: true)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/TimelineDot.swift
================================================================================

//
//  TimelineDot.swift
//  ios
//
//  Atom: Timeline indicator dot for news feed
//

import SwiftUI

struct TimelineDot: View {
    var isHighlighted: Bool = false
    var size: CGFloat = 8

    var body: some View {
        Circle()
            .fill(isHighlighted ? AppColors.primaryBlue : AppColors.textMuted)
            .frame(width: size, height: size)
    }
}

#Preview {
    VStack(spacing: 20) {
        TimelineDot()
        TimelineDot(isHighlighted: true)
        TimelineDot(isHighlighted: true, size: 12)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/TrendingInterestBadge.swift
================================================================================

//
//  TrendingInterestBadge.swift
//  ios
//
//  Atom: Displays trending interest percentage with chart icon
//

import SwiftUI

struct TrendingInterestBadge: View {
    let interestPercent: Int

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            Image(systemName: "chart.line.uptrend.xyaxis")
                .font(.system(size: 10, weight: .semibold))

            Text("+\(interestPercent)% interest")
                .font(AppTypography.caption)
                .fontWeight(.medium)
        }
        .foregroundColor(AppColors.bullish)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        TrendingInterestBadge(interestPercent: 127)
        TrendingInterestBadge(interestPercent: 89)
        TrendingInterestBadge(interestPercent: 203)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Atoms/UserAvatar.swift
================================================================================

//
//  UserAvatar.swift
//  ios
//
//  Atom: User avatar circle with fallback initials
//

import SwiftUI

struct UserAvatar: View {
    let name: String
    let imageName: String?
    var size: CGFloat = 40

    private var initials: String {
        let components = name.components(separatedBy: " ")
        let firstInitial = components.first?.first.map(String.init) ?? ""
        let lastInitial = components.count > 1 ? components.last?.first.map(String.init) ?? "" : ""
        return "\(firstInitial)\(lastInitial)"
    }

    private var backgroundColor: Color {
        // Generate consistent color based on name
        let colors: [Color] = [
            Color(hex: "3B82F6"),
            Color(hex: "22C55E"),
            Color(hex: "F97316"),
            Color(hex: "A855F7"),
            Color(hex: "06B6D4"),
            Color(hex: "EF4444")
        ]
        let index = abs(name.hashValue) % colors.count
        return colors[index]
    }

    var body: some View {
        ZStack {
            if let imageName = imageName, !imageName.isEmpty {
                // Try to load image
                Image(imageName)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .frame(width: size, height: size)
                    .clipShape(Circle())
            } else {
                // Fallback to initials
                Circle()
                    .fill(backgroundColor)
                    .frame(width: size, height: size)
                    .overlay(
                        Text(initials)
                            .font(.system(size: size * 0.4, weight: .semibold))
                            .foregroundColor(AppColors.textPrimary)
                    )
            }
        }
    }
}

#Preview {
    HStack(spacing: AppSpacing.md) {
        UserAvatar(name: "David Martinez", imageName: nil)
        UserAvatar(name: "Sarah Johnson", imageName: nil)
        UserAvatar(name: "John Doe", imageName: nil, size: 32)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AIDeepResearchButton.swift
================================================================================

//
//  AIDeepResearchButton.swift
//  ios
//
//  Molecule: AI Deep Research call-to-action button
//

import SwiftUI

struct AIDeepResearchButton: View {
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.sm) {
                // Sparkle icon
                Image(systemName: "sparkles")
                    .font(.system(size: 16, weight: .semibold))

                Text("AI Deep Research")
                    .font(AppTypography.bodyBold)
            }
            .foregroundColor(AppColors.textPrimary)
            .frame(maxWidth: .infinity)
            .padding(.vertical, AppSpacing.lg)
            .background(
                LinearGradient(
                    colors: [
                        AppColors.primaryBlue,
                        AppColors.accentCyan
                    ],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    AIDeepResearchButton()
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AIMessageContent.swift
================================================================================

//
//  AIMessageContent.swift
//  ios
//
//  Molecule: AI message content that renders different rich content types
//

import SwiftUI

struct AIMessageContent: View {
    let content: [RichContentType]
    let timestamp: String

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            ForEach(Array(content.enumerated()), id: \.offset) { _, item in
                renderContent(item)
            }

            // Timestamp
            MessageTimestamp(time: timestamp, alignment: .leading)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

    @ViewBuilder
    private func renderContent(_ content: RichContentType) -> some View {
        switch content {
        case .text(let text):
            Text(text)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textPrimary)
                .fixedSize(horizontal: false, vertical: true)

        case .sentimentAnalysis(let analysis):
            SentimentAnalysisCard(analysis: analysis)

        case .stockPerformance(let performance):
            StockPerformanceCard(performance: performance)

        case .riskFactors(let data):
            RiskFactorsCard(data: data)

        case .tip(let tipData):
            TipCard(tip: tipData)

        case .bulletPoints(let points):
            VStack(alignment: .leading, spacing: AppSpacing.md) {
                ForEach(points) { point in
                    BulletPointRow(bulletPoint: point)
                }
            }
        }
    }
}

#Preview {
    ScrollView {
        AIMessageContent(
            content: [
                .text("Based on the latest market data and social sentiment analysis, here's what I found about Tesla (TSLA):"),
                .sentimentAnalysis(SentimentAnalysis(
                    overallSentiment: .bullish,
                    percentage: 68,
                    bulletPoints: [
                        ChatBulletPoint(text: "Strong delivery numbers exceeded expectations in Q4", indicatorType: .success),
                        ChatBulletPoint(text: "Competition intensifying in EV market", indicatorType: .warning)
                    ],
                    dataUpdatedText: "Data updated 5 minutes ago"
                ))
            ],
            timestamp: "2:37 PM"
        )
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AddAssetButton.swift
================================================================================

//
//  AddAssetButton.swift
//  ios
//
//  Molecule: Add new asset button
//

import SwiftUI

struct AddAssetButton: View {
    var onTap: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "plus")
                    .font(.system(size: 14, weight: .semibold))

                Text("Add New")
                    .font(AppTypography.bodyBold)
            }
            .foregroundColor(AppColors.textPrimary)
            .padding(.horizontal, AppSpacing.xl)
            .padding(.vertical, AppSpacing.md)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.pill)
            .overlay(
                RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                    .stroke(AppColors.cardBackgroundLight, lineWidth: 1)
            )
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    AddAssetButton()
        .padding()
        .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AddTickerButton.swift
================================================================================

//
//  AddTickerButton.swift
//  ios
//
//  Molecule: Button to add a new ticker to watchlist
//

import SwiftUI

struct AddTickerButton: View {
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            Image(systemName: "plus")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(AppColors.textSecondary)
                .frame(width: 32, height: 32)
                .background(AppColors.cardBackgroundLight)
                .clipShape(Circle())
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    AddTickerButton(action: {})
        .padding()
        .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AlertEventCard.swift
================================================================================

//
//  AlertEventCard.swift
//  ios
//
//  Molecule: Alert/Event card with icon, description and date
//

import SwiftUI

struct AlertEventCard: View {
    let alert: AlertEvent
    var onTap: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            HStack(spacing: AppSpacing.md) {
                // Icon
                AlertCategoryIcon(type: alert.type)

                // Content
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text(alert.title)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text(alert.description)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                }

                Spacer()

                // Date Badge (if available)
                if alert.hasDate {
                    EventDateBadge(
                        day: alert.formattedDay,
                        month: alert.formattedMonth
                    )
                }
            }
            .padding(AppSpacing.lg)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ForEach(AlertEvent.sampleData) { alert in
            AlertEventCard(alert: alert)
        }
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AnalysisDescriptionCard.swift
================================================================================

//
//  AnalysisDescriptionCard.swift
//  ios
//
//  Molecule: Analysis style description card
//

import SwiftUI

struct AnalysisDescriptionCard: View {
    let persona: AnalysisPersona

    private var styleTitle: String {
        let lastName = persona.rawValue.components(separatedBy: " ").last ?? ""
        return "\(lastName) Style Analysis"
    }

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Accent line
            RoundedRectangle(cornerRadius: 2)
                .fill(persona.accentColor)
                .frame(width: 4)

            // Content
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                Text(styleTitle)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(persona.description)
                    .font(AppTypography.footnote)
                    .foregroundColor(AppColors.textSecondary)
                    .lineSpacing(4)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        AnalysisDescriptionCard(persona: .warrenBuffett)
        AnalysisDescriptionCard(persona: .cathieWood)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AnalysisDisclaimerText.swift
================================================================================

//
//  AnalysisDisclaimerText.swift
//  ios
//
//  Disclaimer text for analysis sections
//

import SwiftUI

struct AnalysisDisclaimerText: View {
    let text: String

    init(text: String = "Data Disclaimer: For educational purposes only. Not financial advice. AI-generated content may be inaccurate.") {
        self.text = text
    }

    var body: some View {
        Text(text)
            .font(AppTypography.caption)
            .foregroundColor(AppColors.textMuted)
            .multilineTextAlignment(.leading)
            .fixedSize(horizontal: false, vertical: true)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        AnalysisDisclaimerText()
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AnalysisMomentumSection.swift
================================================================================

//
//  AnalysisMomentumSection.swift
//  ios
//
//  Complete momentum section with header, chart, legend, and actions
//

import SwiftUI

struct AnalysisMomentumSection: View {
    let momentumData: [AnalystMomentumMonth]
    let netPositive: Int
    let netNegative: Int
    let actionsSummary: AnalystActionsSummary
    @Binding var selectedPeriod: AnalystMomentumPeriod
    var onActionsTapped: (() -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Header with toggle
            HStack {
                Text("Analyst Momentum")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button(action: {
                    onActionsTapped?()
                }) {
                    Text("Actions")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.primaryBlue)
                }
            }

            // Period toggle - centered
            HStack {
                Spacer()
                MomentumPeriodToggle(selectedPeriod: $selectedPeriod)
                Spacer()
            }

            // Bar chart
            MomentumBarChart(data: momentumData)

            // Actions row
            AnalystActionsRow(actionsSummary: actionsSummary)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        AnalysisMomentumSection(
            momentumData: AnalystMomentumMonth.sampleData,
            netPositive: 17,
            netNegative: 7,
            actionsSummary: AnalystActionsSummary.sampleData,
            selectedPeriod: .constant(.sixMonths)
        )
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AnalystActionCard.swift
================================================================================

//
//  AnalystActionCard.swift
//  ios
//
//  Card displaying individual analyst upgrade/downgrade action
//

import SwiftUI

struct AnalystActionCard: View {
    let action: AnalystAction

    var body: some View {
        HStack(spacing: 0) {
            // Left border indicator
            Rectangle()
                .fill(action.actionType.borderColor)
                .frame(width: 3)

            // Content
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                // Header: Firm name, Badge, Date
                HStack(alignment: .top) {
                    Text(action.firmName)
                        .font(AppTypography.headline)
                        .foregroundColor(AppColors.textPrimary)

                    Spacer()

                    AnalystActionTypeBadge(actionType: action.actionType)

                    Text(action.formattedDate)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }

                // Rating change row
                if let previousRating = action.previousRating {
                    HStack(spacing: AppSpacing.sm) {
                        Text(previousRating.rawValue)
                            .font(AppTypography.subheadline)
                            .foregroundColor(AppColors.textSecondary)

                        Image(systemName: "arrow.right")
                            .font(.system(size: 10))
                            .foregroundColor(AppColors.textMuted)

                        Text(action.newRating.rawValue)
                            .font(AppTypography.subheadline)
                            .foregroundColor(action.newRating.color)
                    }
                } else {
                    // For initiated actions, just show new rating
                    Text(action.newRating.rawValue)
                        .font(AppTypography.subheadline)
                        .foregroundColor(action.newRating.color)
                }

                // Price target change row
                if let previousPrice = action.formattedPreviousPrice,
                   let newPrice = action.formattedNewPrice {
                    HStack(spacing: AppSpacing.sm) {
                        Text(previousPrice)
                            .font(AppTypography.subheadline)
                            .foregroundColor(AppColors.textSecondary)

                        Image(systemName: "arrow.right")
                            .font(.system(size: 10))
                            .foregroundColor(AppColors.textMuted)

                        Text(newPrice)
                            .font(AppTypography.subheadline)
                            .foregroundColor(action.priceChangeColor)
                    }
                } else if let newPrice = action.formattedNewPrice {
                    // For initiated/reiterated without previous price
                    Text(newPrice)
                        .font(AppTypography.subheadline)
                        .foregroundColor(AppColors.textSecondary)
                }
            }
            .padding(.leading, AppSpacing.lg)
            .padding(.trailing, AppSpacing.lg)
            .padding(.vertical, AppSpacing.lg)
        }
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            VStack(spacing: AppSpacing.md) {
                ForEach(AnalystAction.sampleData) { action in
                    AnalystActionCard(action: action)
                }
            }
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AnalystActionsRow.swift
================================================================================

//
//  AnalystActionsRow.swift
//  ios
//
//  Row of analyst action badges (Upgrades, Maintains, Downgrades)
//

import SwiftUI

struct AnalystActionsRow: View {
    let actionsSummary: AnalystActionsSummary

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            AnalystActionBadge(actionType: .upgrades, count: actionsSummary.upgrades)
            AnalystActionBadge(actionType: .maintains, count: actionsSummary.maintains)
            AnalystActionBadge(actionType: .downgrades, count: actionsSummary.downgrades)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        AnalystActionsRow(actionsSummary: AnalystActionsSummary.sampleData)
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AnalystConsensusRow.swift
================================================================================

//
//  AnalystConsensusRow.swift
//  ios
//
//  Row displaying analyst consensus and target price
//

import SwiftUI

struct AnalystConsensusRow: View {
    let consensus: AnalystConsensus
    let targetPrice: String
    let targetUpside: String

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Left side - Consensus
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text("Analyst Consensus")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)

                AnalysisConsensusBadge(consensus: consensus)
            }

            Spacer()

            // Right side - Target Price
            VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                Text("Target")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)

                Text(targetPrice)
                    .font(AppTypography.title2)
                    .fontWeight(.bold)
                    .foregroundColor(AppColors.textPrimary)

                Text(targetUpside)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.bullish)
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        AnalystConsensusRow(
            consensus: .strongBuy,
            targetPrice: "$212.60",
            targetUpside: "+17.2% upside"
        )
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ArticleActionBar.swift
================================================================================

//
//  ArticleActionBar.swift
//  ios
//
//  Molecule: Action bar with article interaction buttons
//  Integrates with AudioManager for audio playback
//

import SwiftUI

struct ArticleActionBar: View {
    @EnvironmentObject private var audioManager: AudioManager

    var audioEpisode: AudioEpisode?
    var hasAudioVersion: Bool = true
    var isBookmarked: Bool = false
    var onShareTapped: (() -> Void)?
    var onBookmarkTapped: (() -> Void)?
    var onMoreTapped: (() -> Void)?

    private var isCurrentEpisode: Bool {
        guard let episode = audioEpisode else { return false }
        return audioManager.currentEpisode?.id == episode.id
    }

    private var isPlaying: Bool {
        isCurrentEpisode && audioManager.isPlaying
    }

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Listen button (if audio available)
            if hasAudioVersion, let episode = audioEpisode {
                PlayAudioButton(episode: episode, style: .primary, size: .medium)
            }

            Spacer()

            // Right side actions
            HStack(spacing: AppSpacing.lg) {
                // Add to queue (if audio available and not currently playing)
                if hasAudioVersion, let episode = audioEpisode, !isCurrentEpisode {
                    Button(action: {
                        audioManager.addToQueue(episode)
                    }) {
                        Image(systemName: "text.badge.plus")
                            .font(.system(size: 18, weight: .medium))
                            .foregroundColor(AppColors.textSecondary)
                    }
                    .buttonStyle(PlainButtonStyle())
                }

                // Share
                Button(action: { onShareTapped?() }) {
                    Image(systemName: "square.and.arrow.up")
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                }
                .buttonStyle(PlainButtonStyle())

                // Bookmark
                Button(action: { onBookmarkTapped?() }) {
                    Image(systemName: isBookmarked ? "bookmark.fill" : "bookmark")
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(isBookmarked ? AppColors.primaryBlue : AppColors.textSecondary)
                }
                .buttonStyle(PlainButtonStyle())

                // More options
                Button(action: { onMoreTapped?() }) {
                    Image(systemName: "ellipsis")
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
        .background(
            ZStack {
                // Glassmorphism background
                Color.clear
                    .background(.thinMaterial)

                // Gradient overlay
                LinearGradient(
                    colors: [
                        Color.white.opacity(0.05),
                        Color.white.opacity(0.02)
                    ],
                    startPoint: .top,
                    endPoint: .bottom
                )
            }
        )
        .shadow(color: Color.black.opacity(0.3), radius: 8, y: -4)
    }
}

// MARK: - Preview
#Preview {
    VStack {
        Spacer()
        ArticleActionBar(
            audioEpisode: .sampleMoneyMoves,
            hasAudioVersion: true,
            isBookmarked: false
        )
        ArticleActionBar(
            audioEpisode: nil,
            hasAudioVersion: false,
            isBookmarked: true
        )
    }
    .background(AppColors.background)
    .environmentObject(AudioManager.shared)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ArticleAuthorRow.swift
================================================================================

//
//  ArticleAuthorRow.swift
//  ios
//
//  Molecule: Author information row with avatar, name, and follow button
//

import SwiftUI

struct ArticleAuthorRow: View {
    let author: ArticleAuthor
    var showFollowButton: Bool = true
    var isFollowing: Bool = false
    var onFollowTapped: (() -> Void)?
    var onAuthorTapped: (() -> Void)?

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Avatar
            Button(action: { onAuthorTapped?() }) {
                ArticleAuthorAvatar(
                    name: author.name,
                    imageName: author.avatarName,
                    size: 44,
                    showVerifiedBadge: author.isVerified
                )
            }
            .buttonStyle(PlainButtonStyle())

            // Info
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                HStack(spacing: AppSpacing.xs) {
                    Text(author.name)
                        .font(AppTypography.headline)
                        .foregroundColor(AppColors.textPrimary)

                    if author.isVerified {
                        Image(systemName: "checkmark.seal.fill")
                            .font(.system(size: 12))
                            .foregroundColor(AppColors.primaryBlue)
                    }
                }

                Text(author.title)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            Spacer()

            // Follow button
            if showFollowButton {
                Button(action: { onFollowTapped?() }) {
                    Text(isFollowing ? "Following" : "Follow")
                        .font(AppTypography.captionBold)
                        .foregroundColor(isFollowing ? AppColors.textSecondary : .white)
                        .padding(.horizontal, AppSpacing.md)
                        .padding(.vertical, AppSpacing.sm)
                        .background(
                            Capsule()
                                .fill(isFollowing ? AppColors.cardBackgroundLight : AppColors.primaryBlue)
                        )
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.xl) {
        ArticleAuthorRow(
            author: ArticleAuthor(
                name: "The Alpha",
                avatarName: nil,
                title: "Investment Research",
                isVerified: true,
                followerCount: "45.2k"
            )
        )

        ArticleAuthorRow(
            author: ArticleAuthor(
                name: "Sarah Chen",
                avatarName: nil,
                title: "Market Analyst",
                isVerified: false,
                followerCount: "12.5k"
            ),
            isFollowing: true
        )
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ArticleCalloutBox.swift
================================================================================

//
//  ArticleCalloutBox.swift
//  ios
//
//  Molecule: Styled callout box for important information
//

import SwiftUI

struct ArticleCalloutBox: View {
    let icon: String
    let text: String
    let style: CalloutStyle

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Icon
            Image(systemName: icon)
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(style.borderColor)
                .frame(width: 24)

            // Text
            Text(text)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textPrimary)
                .lineSpacing(4)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(AppSpacing.lg)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(style.backgroundColor)
                .overlay(
                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                        .strokeBorder(style.borderColor.opacity(0.5), lineWidth: 1)
                )
        )
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ArticleCalloutBox(
            icon: "lightbulb.fill",
            text: "DeFi protocols have processed over $180B in total value locked, representing a 340% increase from last year.",
            style: .highlight
        )

        ArticleCalloutBox(
            icon: "exclamationmark.triangle.fill",
            text: "Investors should remain vigilant. While opportunities abound, the regulatory landscape is still evolving.",
            style: .warning
        )

        ArticleCalloutBox(
            icon: "checkmark.circle.fill",
            text: "This approach has proven successful across multiple market cycles.",
            style: .success
        )

        ArticleCalloutBox(
            icon: "info.circle.fill",
            text: "Traditional banks are investing heavily in blockchain technology to remain competitive.",
            style: .info
        )
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ArticleCommentCard.swift
================================================================================

//
//  ArticleCommentCard.swift
//  ios
//
//  Molecule: Comment card with author info and engagement
//

import SwiftUI

struct ArticleCommentCard: View {
    let comment: ArticleComment
    var onLikeTapped: (() -> Void)?
    var onReplyTapped: (() -> Void)?
    var onAuthorTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header: Author info and time
            HStack(spacing: AppSpacing.sm) {
                // Avatar
                Button(action: { onAuthorTapped?() }) {
                    ArticleAuthorAvatar(
                        name: comment.authorName,
                        imageName: comment.authorAvatar,
                        size: 36,
                        showVerifiedBadge: comment.isVerified
                    )
                }
                .buttonStyle(PlainButtonStyle())

                VStack(alignment: .leading, spacing: 2) {
                    HStack(spacing: AppSpacing.xs) {
                        Text(comment.authorName)
                            .font(AppTypography.bodyBold)
                            .foregroundColor(AppColors.textPrimary)

                        if comment.isVerified {
                            Image(systemName: "checkmark.seal.fill")
                                .font(.system(size: 10))
                                .foregroundColor(AppColors.primaryBlue)
                        }
                    }

                    Text(comment.timeAgo)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }

                Spacer()

                // More options
                Button(action: {}) {
                    Image(systemName: "ellipsis")
                        .font(.system(size: 16))
                        .foregroundColor(AppColors.textMuted)
                }
                .buttonStyle(PlainButtonStyle())
            }

            // Comment content
            Text(comment.content)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textPrimary)
                .lineSpacing(4)
                .fixedSize(horizontal: false, vertical: true)

            // Engagement row
            HStack(spacing: AppSpacing.xl) {
                // Like button
                Button(action: { onLikeTapped?() }) {
                    HStack(spacing: AppSpacing.xs) {
                        Image(systemName: "heart")
                            .font(.system(size: 14, weight: .medium))
                        Text("\(comment.likeCount)")
                            .font(AppTypography.caption)
                    }
                    .foregroundColor(AppColors.textSecondary)
                }
                .buttonStyle(PlainButtonStyle())

                // Reply button
                Button(action: { onReplyTapped?() }) {
                    HStack(spacing: AppSpacing.xs) {
                        Image(systemName: "bubble.left")
                            .font(.system(size: 14, weight: .medium))
                        Text("\(comment.replyCount) replies")
                            .font(AppTypography.caption)
                    }
                    .foregroundColor(AppColors.textSecondary)
                }
                .buttonStyle(PlainButtonStyle())

                Spacer()
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ArticleCommentCard(
            comment: ArticleComment(
                authorName: "Alex Johnson",
                authorAvatar: nil,
                content: "Excellent breakdown of the current DeFi landscape! The data on portfolio fragility suggests wealth creation through early adoption needs more critical analysis.",
                postedAt: Calendar.current.date(byAdding: .hour, value: -5, to: Date())!,
                likeCount: 47,
                replyCount: 8,
                isVerified: false
            )
        )

        ArticleCommentCard(
            comment: ArticleComment(
                authorName: "Maya Patel",
                authorAvatar: nil,
                content: "As a traditional banker transitioning to fintech, this article perfectly captures the challenges we face.",
                postedAt: Calendar.current.date(byAdding: .hour, value: -12, to: Date())!,
                likeCount: 32,
                replyCount: 3,
                isVerified: true
            )
        )
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ArticleHighlightCard.swift
================================================================================

//
//  ArticleHighlightCard.swift
//  ios
//
//  Molecule: Key highlight card with icon and description
//

import SwiftUI

struct ArticleHighlightCard: View {
    let highlight: ArticleHighlight

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Icon
            ArticleSectionIcon(icon: highlight.icon, size: 36)

            // Content
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(highlight.title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(highlight.description)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
                    .lineSpacing(3)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.lg)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ArticleHighlightCard(
            highlight: ArticleHighlight(
                icon: "building.columns.fill",
                title: "The Alpha",
                description: "As technology becomes ubiquitous, decentralized finance (DeFi) is reshaping how we invest."
            )
        )

        ArticleHighlightCard(
            highlight: ArticleHighlight(
                icon: "chart.line.uptrend.xyaxis",
                title: "Key Trends",
                description: "The pace of banking innovation has never been faster."
            )
        )
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ArticleQuoteBlock.swift
================================================================================

//
//  ArticleQuoteBlock.swift
//  ios
//
//  Molecule: Styled quote block with attribution
//

import SwiftUI

struct ArticleQuoteBlock: View {
    let text: String
    let attribution: String?

    var body: some View {
        HStack(spacing: 0) {
            // Quote line
            Rectangle()
                .fill(
                    LinearGradient(
                        colors: [
                            AppColors.primaryBlue,
                            AppColors.alertPurple
                        ],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )
                .frame(width: 3)

            // Content
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                // Quote icon
                Image(systemName: "quote.opening")
                    .font(.system(size: 20, weight: .bold))
                    .foregroundColor(AppColors.primaryBlue.opacity(0.5))

                // Quote text
                Text(text)
                    .font(AppTypography.body)
                    .foregroundColor(AppColors.textPrimary)
                    .italic()
                    .lineSpacing(6)
                    .fixedSize(horizontal: false, vertical: true)

                // Attribution
                if let attribution = attribution {
                    Text("â€” \(attribution)")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .padding(.top, AppSpacing.xs)
                }
            }
            .padding(.leading, AppSpacing.lg)
        }
        .padding(.vertical, AppSpacing.md)
    }
}

#Preview {
    VStack(spacing: AppSpacing.xl) {
        ArticleQuoteBlock(
            text: "The future of finance isn't about going to the bankâ€”it's about banking coming to you, wherever you are.",
            attribution: "Industry Analyst"
        )

        ArticleQuoteBlock(
            text: "Price is what you pay. Value is what you get.",
            attribution: "Warren Buffett"
        )

        ArticleQuoteBlock(
            text: "In the short run, the market is a voting machine but in the long run, it is a weighing machine.",
            attribution: nil
        )
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ArticleStatisticsGrid.swift
================================================================================

//
//  ArticleStatisticsGrid.swift
//  ios
//
//  Molecule: Grid display of key statistics
//

import SwiftUI

struct ArticleStatisticsGrid: View {
    let statistics: [ArticleStatistic]
    var columns: Int = 3

    private var gridColumns: [GridItem] {
        Array(repeating: GridItem(.flexible(), spacing: AppSpacing.lg), count: columns)
    }

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Grid of statistics
            LazyVGrid(columns: gridColumns, spacing: AppSpacing.xl) {
                ForEach(statistics) { stat in
                    ArticleStatisticValue(
                        value: stat.value,
                        label: stat.label,
                        trend: stat.trend,
                        trendValue: stat.trendValue,
                        alignment: .center
                    )
                }
            }
        }
        .padding(AppSpacing.xl)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
                .overlay(
                    RoundedRectangle(cornerRadius: AppCornerRadius.large)
                        .strokeBorder(
                            LinearGradient(
                                colors: [
                                    Color(hex: "3B82F6").opacity(0.3),
                                    Color(hex: "8B5CF6").opacity(0.3),
                                    Color(hex: "06B6D4").opacity(0.3)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 1
                        )
                )
        )
    }
}

#Preview {
    ArticleStatisticsGrid(
        statistics: [
            ArticleStatistic(value: "$180B", label: "Total Value Locked", trend: .up, trendValue: "340%"),
            ArticleStatistic(value: "4.2M", label: "Daily Active Users", trend: .up, trendValue: "127%"),
            ArticleStatistic(value: "2,400+", label: "DeFi Protocols", trend: .up, trendValue: "89%")
        ]
    )
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AssetRow.swift
================================================================================

//
//  AssetRow.swift
//  ios
//
//  Molecule: Asset row displaying ticker, sparkline, price and change
//

import SwiftUI

struct AssetRow: View {
    let asset: TrackedAsset
    var onTap: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            HStack(spacing: AppSpacing.lg) {
                // Ticker Info
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text(asset.ticker)
                        .font(AppTypography.headline)
                        .foregroundColor(AppColors.textPrimary)

                    Text(asset.companyName)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .lineLimit(1)
                }
                .frame(width: 80, alignment: .leading)

                // Sparkline Chart
                SparklineView(
                    data: asset.sparklineData,
                    isPositive: asset.isPositive
                )
                .frame(height: 32)

                Spacer()

                // Price Info
                VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                    Text(asset.formattedPrice)
                        .font(AppTypography.headline)
                        .foregroundColor(AppColors.textPrimary)

                    PriceChangeLabel(changePercent: asset.changePercent)
                }
            }
            .padding(.vertical, AppSpacing.md)
            .padding(.horizontal, AppSpacing.lg)
            .background(AppColors.cardBackground)
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    VStack(spacing: 0) {
        ForEach(TrackedAsset.sampleData) { asset in
            AssetRow(asset: asset)
            if asset.id != TrackedAsset.sampleData.last?.id {
                Divider()
                    .background(AppColors.cardBackgroundLight)
            }
        }
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/AudioStatusIsland.swift
================================================================================

//
//  AudioStatusIsland.swift
//  ios
//
//  Minimal audio status indicator that hugs the Dynamic Island area
//  Shows when keyboard is active during chat - lightweight, status-only design
//

import SwiftUI

struct AudioStatusIsland: View {
    @EnvironmentObject private var audioManager: AudioManager

    // Layout constants
    private let pillHeight: CGFloat = 36
    private let pillCornerRadius: CGFloat = 18

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            // Tiny animated waveform
            WaveformIndicator(isPlaying: audioManager.isPlaying)
                .frame(width: 20, height: 16)

            // Episode title (truncated)
            if let episode = audioManager.currentEpisode {
                Text(episode.title)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(1)
                    .truncationMode(.tail)
                    .frame(maxWidth: 120)
            }

            // Play/Pause indicator (tiny)
            Button(action: {
                audioManager.togglePlayPause()
            }) {
                Image(systemName: audioManager.isPlaying ? "pause.fill" : "play.fill")
                    .font(.system(size: 10, weight: .bold))
                    .foregroundColor(AppColors.textPrimary)
                    .frame(width: 20, height: 20)
            }
            .buttonStyle(PlainButtonStyle())
        }
        .padding(.horizontal, AppSpacing.md)
        .padding(.vertical, AppSpacing.xs)
        .frame(height: pillHeight)
        .background(
            Capsule()
                .fill(Color.black)
                .shadow(color: Color.black.opacity(0.3), radius: 8, y: 4)
        )
        .overlay(
            Capsule()
                .strokeBorder(Color.white.opacity(0.1), lineWidth: 0.5)
        )
        .onTapGesture {
            // Exit compact mode and show full player
            audioManager.exitCompactMode()
        }
    }
}

// MARK: - Tiny Waveform Indicator
private struct WaveformIndicator: View {
    let isPlaying: Bool

    @State private var animationPhase: CGFloat = 0

    private let barCount = 3
    private let barWidth: CGFloat = 2
    private let barSpacing: CGFloat = 2

    var body: some View {
        HStack(spacing: barSpacing) {
            ForEach(0..<barCount, id: \.self) { index in
                WaveformBar(
                    isPlaying: isPlaying,
                    delay: Double(index) * 0.15,
                    phase: animationPhase
                )
                .frame(width: barWidth)
            }
        }
        .onAppear {
            if isPlaying {
                startAnimation()
            }
        }
        .onChange(of: isPlaying) { oldValue, newValue in
            if newValue {
                startAnimation()
            }
        }
    }

    private func startAnimation() {
        withAnimation(.linear(duration: 0.8).repeatForever(autoreverses: false)) {
            animationPhase = 1
        }
    }
}

// MARK: - Individual Waveform Bar
private struct WaveformBar: View {
    let isPlaying: Bool
    let delay: Double
    let phase: CGFloat

    @State private var height: CGFloat = 4

    var body: some View {
        RoundedRectangle(cornerRadius: 1)
            .fill(AppColors.primaryBlue)
            .frame(height: height)
            .onAppear {
                if isPlaying {
                    animateBar()
                }
            }
            .onChange(of: isPlaying) { oldValue, newValue in
                if newValue {
                    animateBar()
                } else {
                    withAnimation(.easeOut(duration: 0.2)) {
                        height = 4
                    }
                }
            }
    }

    private func animateBar() {
        let minHeight: CGFloat = 4
        let maxHeight: CGFloat = 14

        withAnimation(
            .easeInOut(duration: 0.4)
            .repeatForever(autoreverses: true)
            .delay(delay)
        ) {
            height = CGFloat.random(in: minHeight...maxHeight)
        }
    }
}

// MARK: - Preview
#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack {
            // Simulate Dynamic Island area
            AudioStatusIsland()
                .padding(.top, 60)

            Spacer()

            Text("Chat content area")
                .foregroundColor(AppColors.textSecondary)

            Spacer()
        }
    }
    .environmentObject(AudioManager.shared)
    .onAppear {
        AudioManager.shared.load(.sampleMoneyMoves)
        AudioManager.shared.resume()
    }
    .preferredColorScheme(.dark)
}

#Preview("Paused State") {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack {
            AudioStatusIsland()
                .padding(.top, 60)

            Spacer()
        }
    }
    .environmentObject(AudioManager.shared)
    .onAppear {
        AudioManager.shared.load(.sampleMoneyMoves)
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/BulletPointRow.swift
================================================================================

//
//  BulletPointRow.swift
//  ios
//
//  Molecule: Single bullet point row with indicator
//

import SwiftUI

struct BulletPointRow: View {
    let bulletPoint: ChatBulletPoint

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            BulletPointIndicator(type: bulletPoint.indicatorType)
                .frame(width: 20)

            Text(bulletPoint.text)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
    }
}

#Preview {
    VStack(alignment: .leading, spacing: AppSpacing.md) {
        BulletPointRow(bulletPoint: ChatBulletPoint(text: "Strong delivery numbers exceeded expectations in Q4", indicatorType: .success))
        BulletPointRow(bulletPoint: ChatBulletPoint(text: "Competition intensifying in EV market", indicatorType: .warning))
        BulletPointRow(bulletPoint: ChatBulletPoint(text: "Analyst price targets range from $180-$350", indicatorType: .info))
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ChatHistoryItemRow.swift
================================================================================

//
//  ChatHistoryItemRow.swift
//  ios
//
//  Molecule: Row for a single chat history item
//

import SwiftUI

struct ChatHistoryItemRow: View {
    let item: ChatHistoryItem
    var onTap: (() -> Void)?
    var onMoreOptions: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                // Top row: Type badge, time ago, more button
                HStack(alignment: .center) {
                    ChatHistoryTypeBadge(type: item.type)

                    TimeAgoLabel(text: item.timeAgo)

                    Spacer()

                    MoreOptionsButton {
                        onMoreOptions?()
                    }
                }

                // Title
                Text(item.title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(1)
                    .multilineTextAlignment(.leading)

                // Preview
                Text(item.preview)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
                    .lineLimit(2)
                    .multilineTextAlignment(.leading)
            }
            .padding(.vertical, AppSpacing.md)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack(spacing: 0) {
        ForEach(ChatHistoryItem.todayItems) { item in
            ChatHistoryItemRow(item: item)
            Divider()
                .background(AppColors.cardBackgroundLight)
        }
    }
    .padding(.horizontal, AppSpacing.lg)
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ChatHistorySectionHeader.swift
================================================================================

//
//  ChatHistorySectionHeader.swift
//  ios
//
//  Molecule: Section header for chat history (TODAY, YESTERDAY, OLDER)
//

import SwiftUI

struct ChatHistorySectionHeader: View {
    let section: ChatHistorySection
    var showChevron: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack {
                Text(section.rawValue)
                    .font(AppTypography.captionBold)
                    .foregroundColor(AppColors.textMuted)

                Spacer()

//                if showChevron {
//                    Image(systemName: "chevron.right")
//                        .font(.system(size: 12, weight: .semibold))
//                        .foregroundColor(AppColors.textMuted)
//                }
            }
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(onTap == nil)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        ChatHistorySectionHeader(section: .today, showChevron: true)
        ChatHistorySectionHeader(section: .yesterday)
        ChatHistorySectionHeader(section: .older)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}



================================================================================
FILE: frontend/ios/ios/Views/Molecules/ChatInputBar.swift
================================================================================

//
//  ChatInputBar.swift
//  ios
//
//  Molecule: Chat input bar with text field, attachment and send buttons
//

import SwiftUI

struct ChatInputBar: View {
    @Binding var text: String
    var placeholder: String = "Ask Caudex anything..."
    var onAttachmentTap: (() -> Void)?
    var onSend: (() -> Void)?
    var onFocusChange: ((Bool) -> Void)?

    @FocusState private var isTextFieldFocused: Bool

    private var canSend: Bool {
        !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Attachment button
            AttachmentButton {
                onAttachmentTap?()
            }

            // Text field
            HStack {
                TextField(placeholder, text: $text, axis: .vertical)
                    .font(AppTypography.body)
                    .foregroundColor(AppColors.textPrimary)
                    .autocapitalization(.sentences)
                    .disableAutocorrection(false)
                    .focused($isTextFieldFocused)
                    .lineLimit(1...5)
            }
            .padding(.horizontal, AppSpacing.lg)
            .padding(.vertical, AppSpacing.md)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
            .contentShape(Rectangle())
            .onTapGesture {
                isTextFieldFocused = true
            }

            // Send button
            SendButton(isEnabled: canSend) {
                if canSend {
                    onSend?()
                }
            }
        }
        .onChange(of: isTextFieldFocused) { oldValue, newValue in
            onFocusChange?(newValue)
        }
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var text = ""

        var body: some View {
            VStack {
                Spacer()
                ChatInputBar(text: $text)
                    .padding()
            }
            .background(AppColors.background)
        }
    }

    return PreviewWrapper()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ChatInputOptions.swift
================================================================================

//
//  ChatInputOptions.swift
//  ios
//
//  Molecule: Voice and Image input option buttons for chat
//

import SwiftUI

struct ChatInputOptions: View {
    var onVoiceTap: (() -> Void)?
    var onImageTap: (() -> Void)?

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            InputOptionButton(type: .voice) {
                onVoiceTap?()
            }

            InputOptionButton(type: .image) {
                onImageTap?()
            }
        }
    }
}

#Preview {
    ChatInputOptions()
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ChatWithBookPromptCard.swift
================================================================================

//
//  ChatWithBookPromptCard.swift
//  ios
//
//  Molecule: Prompt card for chatting with The Intelligent Investor
//

import SwiftUI

struct ChatWithBookPromptCard: View {
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.md) {
                // Book icon with gradient background
                ZStack {
                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color(hex: "3B82F6"),
                                    Color(hex: "8B5CF6")
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 40, height: 40)

                    Image(systemName: "book.fill")
                        .font(.system(size: 18))
                        .foregroundColor(.white)
                }

                // Text content
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text("Want to go deeper?")
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text("Chat with The Intelligent Investor")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                // Arrow
                Image(systemName: "chevron.right")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(AppColors.textMuted)
            }
            .padding(AppSpacing.lg)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ChatWithBookPromptCard()
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/CommunityDiscussionRow.swift
================================================================================

//
//  CommunityDiscussionRow.swift
//  ios
//
//  Molecule: Row showing a community discussion post
//

import SwiftUI

struct CommunityDiscussionRow: View {
    let discussion: CommunityDiscussion
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(alignment: .top, spacing: AppSpacing.md) {
                // Avatar
                Circle()
                    .fill(avatarGradient)
                    .frame(width: 40, height: 40)
                    .overlay(
                        Text(discussion.authorName.prefix(1).uppercased())
                            .font(AppTypography.bodyBold)
                            .foregroundColor(.white)
                    )

                // Content
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    // Author and time
                    HStack {
                        Text(discussion.authorName)
                            .font(AppTypography.bodyBold)
                            .foregroundColor(AppColors.textPrimary)

                        Text(discussion.timeAgo)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                    }

                    // Content
                    Text(discussion.content)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(3)
                        .multilineTextAlignment(.leading)

                    // Stats
                    HStack(spacing: AppSpacing.lg) {
                        HStack(spacing: AppSpacing.xs) {
                            Image(systemName: "bubble.left")
                                .font(.system(size: 12))

                            Text(discussion.formattedReplies)
                                .font(AppTypography.caption)
                        }
                        .foregroundColor(AppColors.textMuted)

                        HStack(spacing: AppSpacing.xs) {
                            Image(systemName: "heart")
                                .font(.system(size: 12))

                            Text(discussion.formattedLikes)
                                .font(AppTypography.caption)
                        }
                        .foregroundColor(AppColors.textMuted)
                    }
                }

                Spacer()
            }
            .padding(AppSpacing.lg)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(PlainButtonStyle())
    }

    private var avatarGradient: LinearGradient {
        // Generate consistent colors based on author name
        let hash = discussion.authorName.hashValue
        let hue1 = Double(abs(hash) % 360) / 360.0
        let hue2 = Double(abs(hash + 60) % 360) / 360.0

        return LinearGradient(
            colors: [
                Color(hue: hue1, saturation: 0.6, brightness: 0.7),
                Color(hue: hue2, saturation: 0.5, brightness: 0.5)
            ],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ForEach(CommunityDiscussion.sampleData) { discussion in
            CommunityDiscussionRow(discussion: discussion)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/CommunityInsightRow.swift
================================================================================

//
//  CommunityInsightRow.swift
//  ios
//
//  Molecule: Community insight/comment row with user info and engagement
//

import SwiftUI

struct CommunityInsightRow: View {
    let insight: CommunityInsight
    var onLike: (() -> Void)?
    var onComment: (() -> Void)?
    var onShare: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // User info header
            HStack(spacing: AppSpacing.sm) {
                UserAvatar(
                    name: insight.userName,
                    imageName: insight.userAvatarName,
                    size: 40
                )

                VStack(alignment: .leading, spacing: 0) {
                    HStack(spacing: AppSpacing.sm) {
                        Text(insight.userName)
                            .font(AppTypography.calloutBold)
                            .foregroundColor(AppColors.textPrimary)

                        Text(insight.timeAgo)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                    }
                }

                Spacer()
            }

            // Comment text
            Text(insight.comment)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(4)
                .fixedSize(horizontal: false, vertical: true)

            // Engagement buttons
            HStack(spacing: AppSpacing.xl) {
                // Like button
                Button(action: {
                    onLike?()
                }) {
                    HStack(spacing: AppSpacing.xs) {
                        Image(systemName: "heart")
                            .font(.system(size: 14))
                        Text("\(insight.likesCount)")
                            .font(AppTypography.footnote)
                    }
                    .foregroundColor(AppColors.textMuted)
                }
                .buttonStyle(PlainButtonStyle())

                // Comment button
                Button(action: {
                    onComment?()
                }) {
                    HStack(spacing: AppSpacing.xs) {
                        Image(systemName: "bubble.right")
                            .font(.system(size: 14))
                        Text("\(insight.commentsCount)")
                            .font(AppTypography.footnote)
                    }
                    .foregroundColor(AppColors.textMuted)
                }
                .buttonStyle(PlainButtonStyle())

                // Share button
                Button(action: {
                    onShare?()
                }) {
                    HStack(spacing: AppSpacing.xs) {
                        Image(systemName: "arrowshape.turn.up.right")
                            .font(.system(size: 14))
                        Text("Share")
                            .font(AppTypography.footnote)
                    }
                    .foregroundColor(AppColors.textMuted)
                }
                .buttonStyle(PlainButtonStyle())

                Spacer()
            }
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.md) {
            ForEach(CommunityInsight.mockInsights) { insight in
                CommunityInsightRow(insight: insight)
            }
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/CompanyProfileRow.swift
================================================================================

//
//  CompanyProfileRow.swift
//  ios
//
//  Molecule: Row displaying company profile information
//

import SwiftUI

struct CompanyProfileRow: View {
    let label: String
    let value: String
    var isLink: Bool = false

    var body: some View {
        HStack {
            Text(label)
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textSecondary)

            Spacer()

            Text(value)
                .font(AppTypography.footnoteBold)
                .foregroundColor(isLink ? AppColors.primaryBlue : AppColors.textPrimary)
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        CompanyProfileRow(label: "CEO", value: "Tim Cook")
        CompanyProfileRow(label: "Founded", value: "April 1, 1976")
        CompanyProfileRow(label: "Employees", value: "161,000")
        CompanyProfileRow(label: "Headquarters", value: "Cupertino, CA")
        CompanyProfileRow(label: "Website", value: "www.apple.com", isLink: true)
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/CreditsBalanceCard.swift
================================================================================

//
//  CreditsBalanceCard.swift
//  ios
//
//  Molecule: Credit balance card with gradient background
//

import SwiftUI

struct CreditsBalanceCard: View {
    let balance: CreditBalance
    var onAddCredits: (() -> Void)?

    private let gradientColors = [
        Color(hex: "F97316"),
        Color(hex: "EA580C")
    ]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            HStack {
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text("Credit Balance")
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text("Manage your research credits")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textPrimary.opacity(0.8))
                }

                Spacer()

                // Credits icon
                Image(systemName: "creditcard.fill")
                    .font(.system(size: 24))
                    .foregroundColor(AppColors.textPrimary.opacity(0.8))
            }

            // Credits Display
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                HStack(alignment: .lastTextBaseline, spacing: AppSpacing.sm) {
                    Text("\(balance.credits)")
                        .font(.system(size: 36, weight: .bold, design: .rounded))
                        .foregroundColor(AppColors.textPrimary)

                    Text("credits")
                        .font(AppTypography.body)
                        .foregroundColor(AppColors.textPrimary.opacity(0.8))
                }

                Text(balance.formattedRenewalDate)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textPrimary.opacity(0.7))
            }
            .padding(AppSpacing.md)
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                    .fill(Color.black.opacity(0.2))
            )

            // Add Credits Button
            Button(action: {
                onAddCredits?()
            }) {
                HStack(spacing: AppSpacing.sm) {
                    Image(systemName: "plus")
                        .font(.system(size: 14, weight: .semibold))

                    Text("Add More Credits")
                        .font(AppTypography.calloutBold)
                }
                .foregroundColor(Color(hex: "F97316"))
                .frame(maxWidth: .infinity)
                .padding(.vertical, AppSpacing.md)
                .background(
                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                        .fill(AppColors.textPrimary)
                )
            }
            .buttonStyle(PlainButtonStyle())
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.extraLarge)
                .fill(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
        )
    }
}

#Preview {
    CreditsBalanceCard(balance: .mock)
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/DailyBriefingRow.swift
================================================================================

//
//  DailyBriefingRow.swift
//  ios
//
//  Molecule: Individual alert row in daily briefing
//

import SwiftUI

struct DailyBriefingRow: View {
    let item: DailyBriefingItem
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.md) {
                // Icon
                AlertIconView(type: item.type)

                // Content
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text(item.title)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text(item.subtitle)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                }

                Spacer()

                // Date badge or chevron
                if item.hasDateBadge, let date = item.date {
                    DateBadge(from: date)
                } else {
                    Image(systemName: "chevron.right")
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundColor(AppColors.textMuted)
                }
            }
            .padding(AppSpacing.md)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.medium)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack(spacing: 12) {
        DailyBriefingRow(item: DailyBriefingItem(
            type: .whalesAlert,
            title: "Whales Alert",
            subtitle: "Large crypto whale just moved $50M into COIN stock",
            date: nil,
            badgeText: nil
        ))

        DailyBriefingRow(item: DailyBriefingItem(
            type: .earningsAlert,
            title: "Earnings Alert",
            subtitle: "NVDA reports earnings tomorrow after market close.",
            date: Date(),
            badgeText: "24\nFEB"
        ))

        DailyBriefingRow(item: DailyBriefingItem(
            type: .wiserTrending,
            title: "Wiser: Trending",
            subtitle: "How can I invest in OpenAI even though the company is not yet listed?",
            date: nil,
            badgeText: nil
        ))
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/DiversificationCard.swift
================================================================================

//
//  DiversificationCard.swift
//  ios
//
//  Molecule: Portfolio diversification score card
//

import SwiftUI

struct DiversificationCard: View {
    let score: DiversificationScore

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header with icon
            HStack(spacing: AppSpacing.sm) {
                ZStack {
                    Circle()
                        .fill(AppColors.primaryBlue.opacity(0.15))
                        .frame(width: 32, height: 32)

                    Image(systemName: "lightbulb.fill")
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundColor(AppColors.primaryBlue)
                }

                Text("Diversification Score")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            // Description
            Text(score.message)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)

            // Progress Bar with Score
            HStack(spacing: AppSpacing.md) {
                GradientProgressBar(
                    progress: score.progressValue,
                    height: 8,
                    gradientColors: [AppColors.bullish, AppColors.neutral]
                )

                Text(score.formattedScore)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
                    .frame(width: 40, alignment: .trailing)
            }

            // Sector Breakdown
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: AppSpacing.sm) {
                ForEach(score.allocations) { allocation in
                    HStack(spacing: AppSpacing.xs) {
                        Text("\(allocation.name):")
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)

                        Text(allocation.formattedPercentage)
                            .font(AppTypography.captionBold)
                            .foregroundColor(AppColors.textSecondary)
                    }
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    DiversificationCard(score: DiversificationScore.sampleData)
        .padding()
        .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/DividendInfoCard.swift
================================================================================

//
//  DividendInfoCard.swift
//  ios
//
//  Molecule: Card displaying dividend dates, yield, and status
//

import SwiftUI

struct DividendInfoCard: View {
    let dividendInfo: DividendInfo

    var body: some View {
        VStack(spacing: 0) {
            // Ex-Dividend Date row
            DividendInfoRow(
                label: "Ex-Dividend Date",
                value: dividendInfo.formattedExDividendDate
            )

            divider

            // Payment Date row
            DividendInfoRow(
                label: "Payment Date",
                value: dividendInfo.formattedPaymentDate
            )

            divider

            // 5Y Avg Yield row
            DividendInfoRow(
                label: "5Y Avg Yield",
                value: dividendInfo.formattedYield
            )

            divider

            // Dividend Status row
            DividendInfoRow(
                label: "Dividend Status",
                value: dividendInfo.status.rawValue,
                valueColor: dividendInfo.status.color
            )

            divider

            // Buyback Status row
            DividendInfoRow(
                label: "Buyback Status",
                value: dividendInfo.buybackStatus.rawValue,
                valueColor: dividendInfo.buybackStatus.color
            )
        }
        .padding(.vertical, AppSpacing.md)
        .padding(.horizontal, AppSpacing.lg)
        .background(AppColors.cardBackgroundLight)
        .cornerRadius(AppCornerRadius.medium)
        .overlay(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .stroke(AppColors.cardBackgroundLight.opacity(0.5), lineWidth: 1)
        )
    }

    private var divider: some View {
        Rectangle()
            .fill(AppColors.cardBackground)
            .frame(height: 1)
            .padding(.vertical, AppSpacing.md)
    }
}

// MARK: - Dividend Info Row

private struct DividendInfoRow: View {
    let label: String
    let value: String
    var valueColor: Color = AppColors.textPrimary

    var body: some View {
        HStack {
            Text(label)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)

            Spacer()

            Text(value)
                .font(AppTypography.bodyBold)
                .foregroundColor(valueColor)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.lg) {
            DividendInfoCard(dividendInfo: .sample)

            // High yield example
            DividendInfoCard(
                dividendInfo: DividendInfo(
                    exDividendDate: Date(),
                    paymentDate: Date().addingTimeInterval(86400 * 7),
                    fiveYearAvgYield: 3.45,
                    status: .high,
                    buybackStatus: .high
                )
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/EarningsChartView.swift
================================================================================

//
//  EarningsChartView.swift
//  ios
//
//  Molecule: Interactive chart displaying EPS/Revenue with estimates, actuals, and optional price overlay
//

import SwiftUI
import Charts

struct EarningsChartView: View {
    let quarters: [EarningsQuarterData]
    let priceHistory: [EarningsPricePoint]
    let showPriceLine: Bool

    // Calculate chart bounds based ONLY on EPS/Revenue data (NOT price)
    private var earningsValues: [Double] {
        var values: [Double] = []
        for quarter in quarters {
            if let actual = quarter.actualValue {
                values.append(actual)
            }
            values.append(quarter.estimateValue)
        }
        return values
    }

    private var minValue: Double {
        (earningsValues.min() ?? 0) * 0.9
    }

    private var maxValue: Double {
        (earningsValues.max() ?? 1) * 1.1
    }

    // Price bounds for independent normalization
    private var priceValues: [Double] {
        // Only include prices for quarters that have actual data (not future/pending)
        var values: [Double] = []
        for (index, quarter) in quarters.enumerated() {
            if quarter.actualValue != nil, index < priceHistory.count, priceHistory[index].price > 0 {
                values.append(priceHistory[index].price)
            }
        }
        return values
    }

    private var minPrice: Double {
        priceValues.min() ?? 0
    }

    private var maxPrice: Double {
        priceValues.max() ?? 1
    }

    private var chartHeight: CGFloat { 200 }
    private var yAxisWidth: CGFloat { 40 }

    var body: some View {
        VStack(spacing: 0) {
            HStack(alignment: .top, spacing: 0) {
                // Y-axis labels (separate from chart area)
                yAxisLabels()
                    .frame(width: yAxisWidth)

                // Chart area
                GeometryReader { geometry in
                    let width = geometry.size.width
                    let height = geometry.size.height
                    let quarterCount = quarters.count
                    let stepX = width / CGFloat(quarterCount)
                    let range = max(maxValue - minValue, 0.01)

                    ZStack {
                        // Horizontal grid lines
                        gridLines(height: height)

                        // Price line (optional, rendered first so it's behind)
                        // Only show for quarters with actual data
                        if showPriceLine && !priceValues.isEmpty {
                            priceLine(width: width, height: height, stepX: stepX)
                        }

                        // Estimate dots (gray)
                        ForEach(Array(quarters.enumerated()), id: \.element.id) { index, quarter in
                            let x = CGFloat(index) * stepX + stepX / 2
                            let y = height - normalizedY(quarter.estimateValue, height: height, range: range)

                            Circle()
                                .fill(AppColors.textSecondary)
                                .frame(width: 14, height: 14)
                                .position(x: x, y: y)
                        }

                        // Actual result dots (colored based on result)
                        ForEach(Array(quarters.enumerated()), id: \.element.id) { index, quarter in
                            if let actual = quarter.actualValue {
                                let x = CGFloat(index) * stepX + stepX / 2
                                let y = height - normalizedY(actual, height: height, range: range)

                                // Dot with appropriate styling
                                ZStack {
                                    Circle()
                                        .fill(quarter.result.dotColor)
                                        .frame(width: 14, height: 14)

                                    // Dashed border for matched results
                                    if quarter.result.hasDashedBorder {
                                        Circle()
                                            .stroke(
                                                AppColors.textPrimary,
                                                style: StrokeStyle(lineWidth: 2, dash: [3, 2])
                                            )
                                            .frame(width: 18, height: 18)
                                    }
                                }
                                .position(x: x, y: y)
                            }
                        }
                    }
                }
                .frame(height: chartHeight)
            }

            // X-axis labels (quarters)
            xAxisLabels()
        }
    }

    // MARK: - Helper Views

    private func gridLines(height: CGFloat) -> some View {
        VStack(spacing: 0) {
            ForEach(0..<4) { index in
                Rectangle()
                    .fill(AppColors.cardBackgroundLight.opacity(0.5))
                    .frame(height: 1)
                if index < 3 {
                    Spacer()
                }
            }
        }
    }

    private func yAxisLabels() -> some View {
        VStack {
            Text(formatYValue(maxValue))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
            Spacer()
            Text(formatYValue((maxValue + minValue) / 2))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
            Spacer()
            Text(formatYValue(minValue))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }
        .frame(height: chartHeight)
        .padding(.trailing, AppSpacing.sm)
    }

    private func xAxisLabels() -> some View {
        HStack(spacing: 0) {
            // Spacer for y-axis width alignment
            Spacer()
                .frame(width: yAxisWidth)

            // Display quarter labels based on count
            if quarters.count > 6 {
                // For 3Y view (more than 6 quarters), show condensed labels
                // Group by year and show Q1, Q2, Q3, Q4 with year label
                xAxisLabelsCondensed()
            } else {
                // For 1Y view (6 or fewer quarters), show full quarter labels
                ForEach(quarters) { quarter in
                    Text(quarter.quarter)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .frame(maxWidth: .infinity)
                }
            }
        }
        .padding(.top, AppSpacing.sm)
    }
    
    private func xAxisLabelsCondensed() -> some View {
        VStack(spacing: 2) {
            // Top row: Q1, Q2, Q3, Q4 labels for each quarter
            HStack(spacing: 0) {
                ForEach(quarters) { quarter in
                    Text(String(quarter.quarter.prefix(2)))
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .frame(maxWidth: .infinity)
                }
            }
            
            // Bottom row: Year labels positioned under their quarter groups
            GeometryReader { geometry in
                let totalWidth = geometry.size.width
                let totalQuarters = quarters.count
                let stepWidth = totalWidth / CGFloat(totalQuarters)
                
                // Group quarters by year, maintaining their original indices
                let groupedByYear = Dictionary(grouping: Array(quarters.enumerated())) { element in
                    let components = element.element.quarter.components(separatedBy: " ")
                    return components.count > 1 ? components[1] : ""
                }
                
                // Sort years
                let sortedYears = groupedByYear.keys.sorted()
                
                ZStack(alignment: .top) {
                    ForEach(sortedYears, id: \.self) { year in
                        if let yearData = groupedByYear[year]?.sorted(by: { $0.offset < $1.offset }),
                           let firstIndex = yearData.first?.offset,
                           let lastIndex = yearData.last?.offset {
                            
                            let centerIndex = CGFloat(firstIndex + lastIndex) / 2.0
                            let centerX = centerIndex * stepWidth + stepWidth / 2
                            
                            Text(year)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textMuted)
                                .bold()
                                .position(x: centerX, y: 6)
                        }
                    }
                }
            }
            .frame(height: 12)
        }
    }

    private func priceLine(width: CGFloat, height: CGFloat, stepX: CGFloat) -> some View {
        let priceRange = max(maxPrice - minPrice, 0.01)

        return Path { path in
            var isFirstPoint = true

            for (index, quarter) in quarters.enumerated() {
                // Only draw price for quarters with actual data (not pending/future)
                guard quarter.actualValue != nil,
                      index < priceHistory.count,
                      priceHistory[index].price > 0 else {
                    continue
                }

                let pricePoint = priceHistory[index]
                let x = CGFloat(index) * stepX + stepX / 2

                // Normalize price independently to fit within the chart area
                let normalizedPrice = (pricePoint.price - minPrice) / priceRange
                let y = height - (CGFloat(normalizedPrice) * height * 0.85 + height * 0.075)

                if isFirstPoint {
                    path.move(to: CGPoint(x: x, y: y))
                    isFirstPoint = false
                } else {
                    path.addLine(to: CGPoint(x: x, y: y))
                }
            }
        }
        .stroke(
            AppColors.accentCyan,
            style: StrokeStyle(lineWidth: 2.5, lineCap: .round, lineJoin: .round)
        )
    }

    // MARK: - Helper Functions

    private func normalizedY(_ value: Double, height: CGFloat, range: Double) -> CGFloat {
        let normalized = (value - minValue) / range
        return CGFloat(normalized) * height * 0.85 + height * 0.075
    }

    private func formatYValue(_ value: Double) -> String {
        if value >= 1000 {
            return String(format: "%.0f", value)
        } else if value >= 100 {
            return String(format: "%.0f", value)
        } else if value >= 10 {
            return String(format: "%.1f", value)
        } else {
            return String(format: "%.2f", value)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack {
            EarningsChartView(
                quarters: EarningsData.sampleData.epsQuarters,
                priceHistory: EarningsData.sampleData.priceHistory,
                showPriceLine: true
            )
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/EarningsInfoSheet.swift
================================================================================

//
//  EarningsInfoSheet.swift
//  ios
//
//  Molecule: Info sheet explaining the earnings chart and its indicators
//

import SwiftUI

struct EarningsInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xl) {
                    // Header description
                    Text("This chart displays quarterly earnings performance comparing actual results against analyst estimates.")
                        .font(AppTypography.body)
                        .foregroundColor(AppColors.textSecondary)
                        .padding(.bottom, AppSpacing.sm)

                    // Data Types Section
                    infoSection(
                        title: "Data Types",
                        items: [
                            InfoItem(
                                icon: "dollarsign.circle.fill",
                                iconColor: AppColors.primaryBlue,
                                title: "EPS (Earnings Per Share)",
                                description: "Company's profit divided by outstanding shares. Higher EPS indicates better profitability."
                            ),
                            InfoItem(
                                icon: "chart.bar.fill",
                                iconColor: AppColors.accentCyan,
                                title: "Revenue",
                                description: "Total income generated from sales before expenses. Shows business growth trajectory."
                            )
                        ]
                    )

                    // Time Range Section
                    infoSection(
                        title: "Time Range",
                        items: [
                            InfoItem(
                                icon: "calendar",
                                iconColor: AppColors.primaryBlue,
                                title: "1Y (One Year)",
                                description: "Shows the last 6 quarters for a focused view on recent performance and trends."
                            ),
                            InfoItem(
                                icon: "calendar.badge.clock",
                                iconColor: AppColors.accentCyan,
                                title: "3Y (Three Years)",
                                description: "Displays up to 14 quarters with a surprise bar chart. Use this view to see how price has changed in relation to earnings surprises over a longer period, revealing patterns in market reactions."
                            )
                        ]
                    )

                    // Indicators Section
                    infoSection(
                        title: "Chart Indicators",
                        items: [
                            InfoItem(
                                dotColor: AppColors.bullish,
                                title: "Beat",
                                description: "Actual earnings exceeded analyst estimates - a positive signal."
                            ),
                            InfoItem(
                                dotColor: AppColors.bearish,
                                title: "Missed",
                                description: "Actual earnings fell short of estimates - may indicate challenges."
                            ),
                            InfoItem(
                                dotColor: AppColors.bullish,
                                hasDashedBorder: true,
                                title: "Matched",
                                description: "Actual earnings met estimates exactly (0% surprise)."
                            ),
                            InfoItem(
                                dotColor: AppColors.textSecondary,
                                title: "Estimate",
                                description: "Analyst consensus estimate for upcoming quarters."
                            )
                        ]
                    )

                    // Surprise Percentage Section
                    infoSection(
                        title: "Surprise Percentage",
                        items: [
                            InfoItem(
                                icon: "percent",
                                iconColor: AppColors.neutral,
                                title: "Earnings Surprise",
                                description: "Shows how much actual earnings differed from estimates. Positive surprises (green) often lead to stock price increases, while negative surprises (red) may cause declines."
                            )
                        ]
                    )

                    // Price Toggle Section
                    infoSection(
                        title: "Price Overlay",
                        items: [
                            InfoItem(
                                icon: "chart.line.uptrend.xyaxis",
                                iconColor: AppColors.accentCyan,
                                title: "Price Toggle",
                                description: "Enable to overlay historical stock price movement on the earnings chart. This helps visualize how the stock reacted to earnings reports."
                            )
                        ]
                    )

                    // Tips Section
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        Text("Tips")
                            .font(AppTypography.headline)
                            .foregroundColor(AppColors.textPrimary)

                        tipRow(icon: "lightbulb.fill", text: "Consistent beats often indicate strong management execution")
                        tipRow(icon: "lightbulb.fill", text: "Compare EPS growth with revenue growth to assess quality")
                        tipRow(icon: "lightbulb.fill", text: "Use 3Y view to identify long-term earnings trends")
                    }
                    .padding(AppSpacing.lg)
                    .background(AppColors.cardBackgroundLight)
                    .cornerRadius(AppCornerRadius.medium)

                    Spacer()
                        .frame(height: AppSpacing.xl)
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("Earnings Guide")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
        .preferredColorScheme(.dark)
    }

    // MARK: - Helper Views

    private func infoSection(title: String, items: [InfoItem]) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text(title)
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                ForEach(items, id: \.title) { item in
                    infoRow(item: item)
                }
            }
        }
    }

    private func infoRow(item: InfoItem) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Icon or dot
            if let dotColor = item.dotColor {
                ZStack {
                    Circle()
                        .fill(dotColor)
                        .frame(width: 16, height: 16)

                    if item.hasDashedBorder {
                        Circle()
                            .stroke(
                                AppColors.textPrimary,
                                style: StrokeStyle(lineWidth: 2, dash: [3, 2])
                            )
                            .frame(width: 20, height: 20)
                    }
                }
                .frame(width: 32, height: 32)
            } else if let icon = item.icon {
                Image(systemName: icon)
                    .font(.system(size: 16))
                    .foregroundColor(item.iconColor ?? AppColors.textSecondary)
                    .frame(width: 32, height: 32)
                    .background(
                        Circle()
                            .fill(AppColors.cardBackgroundLight)
                    )
            }

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(item.title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(item.description)
                    .font(AppTypography.footnote)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }

            Spacer()
        }
        .padding(AppSpacing.md)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
    }

    private func tipRow(icon: String, text: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.sm) {
            Image(systemName: icon)
                .font(.system(size: 12))
                .foregroundColor(AppColors.neutral)

            Text(text)
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textSecondary)
        }
    }
}

// MARK: - Info Item Model

private struct InfoItem {
    let icon: String?
    let iconColor: Color?
    let dotColor: Color?
    let hasDashedBorder: Bool
    let title: String
    let description: String

    init(icon: String, iconColor: Color, title: String, description: String) {
        self.icon = icon
        self.iconColor = iconColor
        self.dotColor = nil
        self.hasDashedBorder = false
        self.title = title
        self.description = description
    }

    init(dotColor: Color, hasDashedBorder: Bool = false, title: String, description: String) {
        self.icon = nil
        self.iconColor = nil
        self.dotColor = dotColor
        self.hasDashedBorder = hasDashedBorder
        self.title = title
        self.description = description
    }
}

#Preview {
    EarningsInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/EarningsLegend.swift
================================================================================

//
//  EarningsLegend.swift
//  ios
//
//  Molecule: Legend row for the earnings chart showing all result types
//

import SwiftUI

struct EarningsLegend: View {
    var body: some View {
        HStack(spacing: AppSpacing.xl) {
            EarningsLegendItem(type: .surprised)
            EarningsLegendItem(type: .estimate)
            EarningsLegendItem(type: .beat)
            EarningsLegendItem(type: .missed)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        EarningsLegend()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/EarningsSurpriseRow.swift
================================================================================

//
//  EarningsSurpriseRow.swift
//  ios
//
//  Molecule: Row displaying surprise percentages for each quarter with a leading indicator
//

import SwiftUI

struct EarningsSurpriseRow: View {
    let quarters: [EarningsQuarterData]
    
    private var yAxisWidth: CGFloat { 40 }

    var body: some View {
        HStack(spacing: 0) {
            // Y-axis spacer to align with X-axis labels (NO padding, just width)
            Spacer()
                .frame(width: yAxisWidth)

            // Surprise percentages for each quarter
            // This HStack matches the xAxisLabels structure exactly
            HStack(spacing: 0) {
                ForEach(Array(quarters.enumerated()), id: \.element.id) { index, quarter in
                    if let surprise = quarter.formattedSurprise {
                        Text(surprise)
                            .font(AppTypography.footnote)
                            .foregroundColor(quarter.surpriseColor)
                            .frame(maxWidth: .infinity)
                    } else {
                        // Empty space for future quarters
                        Text("")
                            .frame(maxWidth: .infinity)
                    }
                }
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        EarningsSurpriseRow(quarters: EarningsData.sampleData.epsQuarters)
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/EducationBookCard.swift
================================================================================

//
//  EducationBookCard.swift
//  ios
//
//  Molecule: Card showing an educational book with chat and key ideas buttons
//

import SwiftUI

struct EducationBookCard: View {
    let book: EducationBook
    var onChatWithBook: (() -> Void)?
    var onReadKeyIdeas: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Most Read badge
            if book.isMostRead {
                Text("Most Read")
                    .font(AppTypography.captionBold)
                    .foregroundColor(AppColors.textSecondary)
                    .padding(.bottom, -AppSpacing.sm)
            }

            HStack(alignment: .top, spacing: AppSpacing.lg) {
                // Book cover placeholder
                ZStack {
                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                        .fill(bookCoverGradient)
                        .frame(width: 80, height: 110)

                    // Book title overlay
                    VStack {
                        Text(book.title.uppercased())
                            .font(.system(size: 8, weight: .bold))
                            .foregroundColor(.white)
                            .multilineTextAlignment(.center)
                            .lineLimit(3)
                            .padding(.horizontal, AppSpacing.xs)
                    }
                    .frame(width: 80, height: 110)
                }

                // Book details
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    // Title and rating
                    HStack(alignment: .top) {
                        Text(book.title)
                            .font(AppTypography.headline)
                            .foregroundColor(AppColors.textPrimary)
                            .lineLimit(2)

                        Spacer()

                        // Rating
                        HStack(spacing: AppSpacing.xxs) {
                            Image(systemName: "star.fill")
                                .font(.system(size: 12))
                                .foregroundColor(AppColors.neutral)

                            Text(book.formattedRating)
                                .font(AppTypography.footnoteBold)
                                .foregroundColor(AppColors.textPrimary)
                        }
                        .padding(.horizontal, AppSpacing.sm)
                        .padding(.vertical, AppSpacing.xs)
                        .background(AppColors.cardBackgroundLight)
                        .cornerRadius(AppCornerRadius.small)
                    }

                    // Author
                    Text(book.author)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)

                    // Description
                    Text(book.description)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(2)

                    // Meta info
                    HStack(spacing: AppSpacing.md) {
                        Text(book.formattedPages)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)

                        Text("â€¢")
                            .foregroundColor(AppColors.textMuted)

                        Text(book.formattedPublished)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                    }
                }
            }

            // Action buttons
            HStack(spacing: AppSpacing.md) {
                Button(action: {
                    onChatWithBook?()
                }) {
                    HStack(spacing: AppSpacing.sm) {
                        Image(systemName: "bubble.left.fill")
                            .font(.system(size: 12))

                        Text("Chat with Book")
                            .font(AppTypography.calloutBold)
                    }
                    .foregroundColor(AppColors.textPrimary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, AppSpacing.md)
                    .background(AppColors.cardBackgroundLight)
                    .cornerRadius(AppCornerRadius.medium)
                }
                .buttonStyle(PlainButtonStyle())

                Button(action: {
                    onReadKeyIdeas?()
                }) {
                    HStack(spacing: AppSpacing.sm) {
                        Image(systemName: "lightbulb.fill")
                            .font(.system(size: 12))

                        Text("Read Key Ideas")
                            .font(AppTypography.calloutBold)
                    }
                    .foregroundColor(AppColors.primaryBlue)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, AppSpacing.md)
                    .background(AppColors.primaryBlue.opacity(0.15))
                    .cornerRadius(AppCornerRadius.medium)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.extraLarge)
    }

    private var bookCoverGradient: LinearGradient {
        // Different colors for different books
        let colors: [Color]
        switch book.title {
        case "The Intelligent Investor":
            colors = [Color(hex: "1E3A5F"), Color(hex: "0F1F35")]
        case "One Up On Wall Street":
            colors = [Color(hex: "2D4A3E"), Color(hex: "1A2D25")]
        case "Common Stocks and Uncommon Profits":
            colors = [Color(hex: "4A1E1E"), Color(hex: "2D1212")]
        default:
            colors = [Color(hex: "3B3B5C"), Color(hex: "1E1E2E")]
        }

        return LinearGradient(
            colors: colors,
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.lg) {
            ForEach(EducationBook.sampleData) { book in
                EducationBookCard(book: book)
            }
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/FeatureRow.swift
================================================================================

//
//  FeatureRow.swift
//  ios
//
//  Molecule: Feature row with icon, title, and subtitle
//

import SwiftUI

struct FeatureRow: View {
    let feature: AnalysisFeature

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Feature Icon
            FeatureIcon(
                systemIconName: feature.systemIconName,
                color: feature.iconColor,
                size: 40
            )

            // Text Content
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(feature.title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(feature.subtitle)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .lineLimit(2)
            }

            Spacer()
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    VStack(spacing: AppSpacing.sm) {
        ForEach(AnalysisFeature.allFeatures) { feature in
            FeatureRow(feature: feature)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/FilterButton.swift
================================================================================

//
//  FilterButton.swift
//  ios
//
//  Molecule: Filter/settings button for news feed
//

import SwiftUI

struct FilterButton: View {
    var hasActiveFilters: Bool = false
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            ZStack(alignment: .topTrailing) {
                Image(systemName: "slider.horizontal.3")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(AppColors.textSecondary)
                    .frame(width: 32, height: 32)
                    .background(AppColors.cardBackgroundLight)
                    .clipShape(Circle())

                if hasActiveFilters {
                    Circle()
                        .fill(AppColors.primaryBlue)
                        .frame(width: 8, height: 8)
                        .offset(x: 2, y: -2)
                }
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    HStack(spacing: 20) {
        FilterButton(hasActiveFilters: false, action: {})
        FilterButton(hasActiveFilters: true, action: {})
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/GenerateAnalysisButton.swift
================================================================================

//
//  GenerateAnalysisButton.swift
//  ios
//
//  Molecule: Generate analysis button with cost indicator
//

import SwiftUI

struct GenerateAnalysisButton: View {
    let cost: AnalysisCost
    var isEnabled: Bool = true
    var isLoading: Bool = false
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            VStack(spacing: AppSpacing.xs) {
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                } else {
                    HStack(spacing: AppSpacing.sm) {
                        Image(systemName: "sparkles")
                            .font(.system(size: 16, weight: .semibold))

                        Text("Generate Analysis")
                            .font(AppTypography.headline)
                    }
                }

                Text("Uses \(cost.credits) Credits")
                    .font(AppTypography.caption)
                    .opacity(0.8)
            }
            .foregroundColor(AppColors.textPrimary)
            .frame(maxWidth: .infinity)
            .padding(.vertical, AppSpacing.lg)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.large)
                    .fill(isEnabled ? AppColors.primaryBlue : AppColors.textMuted)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(!isEnabled || isLoading)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        GenerateAnalysisButton(cost: .standard, isEnabled: true)
        GenerateAnalysisButton(cost: .standard, isEnabled: false)
        GenerateAnalysisButton(cost: .standard, isLoading: true)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/GlobalMiniPlayer.swift
================================================================================

//
//  GlobalMiniPlayer.swift
//  ios
//
//  Molecule: Floating capsule mini audio player
//  Appears above tab bar when audio is playing, expandable to full screen
//  Optimized for global use with 85-90% screen width
//

import SwiftUI

struct GlobalMiniPlayer: View {
    @EnvironmentObject private var audioManager: AudioManager
    @State private var dragOffset: CGFloat = 0

    // Layout constants
    private let playerWidthRatio: CGFloat = 0.88 // 88% of screen width
    private let playerHeight: CGFloat = 60
    private let capsuleCornerRadius: CGFloat = 36 // Full capsule effect

    // Animation constants
    private let dismissThreshold: CGFloat = 100
    private let expandThreshold: CGFloat = -50

    var body: some View {
        GeometryReader { geometry in
            VStack(spacing: 0) {
                Spacer()

                // Floating capsule mini player
                floatingCapsulePlayer(screenWidth: geometry.size.width)
                    .offset(y: dragOffset)
                    .gesture(
                        DragGesture()
                            .onChanged { value in
                                dragOffset = value.translation.height
                            }
                            .onEnded { value in
                                handleDragEnd(value)
                            }
                    )
                    .animation(.spring(response: 0.3, dampingFraction: 0.8), value: dragOffset)

                // Bottom spacing for tab bar
                Color.clear
                    .frame(height: 0)
            }
            .ignoresSafeArea(.container, edges: .bottom)
        }
        .transition(.move(edge: .bottom).combined(with: .opacity))
    }

    // MARK: - Floating Capsule Player
    private func floatingCapsulePlayer(screenWidth: CGFloat) -> some View {
        let playerWidth = screenWidth * playerWidthRatio

        return ZStack(alignment: .bottom) {
            // Main capsule content
            HStack(spacing: AppSpacing.md) {
                // Close button (X)
                closeButton

                // Waveform icon
                waveformIcon

                // Title and remaining time
                titleAndTimeSection

                // Skip back button
                skipBackButton

                // Play/Pause button
                playPauseButton

                // Speed indicator
                speedIndicator
            }
            .padding(.horizontal, AppSpacing.lg)
            .padding(.vertical, AppSpacing.md)
            .frame(width: playerWidth, height: playerHeight)
            .background(capsuleBackground)
            .overlay(
                // Blue border stroke
                RoundedRectangle(cornerRadius: capsuleCornerRadius)
                    .strokeBorder(AppColors.primaryBlue.opacity(0.5), lineWidth: 1.5)
            )
            .clipShape(RoundedRectangle(cornerRadius: capsuleCornerRadius))

            // Progress bar at bottom (inside capsule)
            progressBar(width: playerWidth)
        }
        .shadow(color: Color.black.opacity(0.4), radius: 24, y: 12)
        .padding(.bottom, AppSpacing.md)
        .contentShape(Rectangle())
        .onTapGesture {
            audioManager.expandPlayer()
        }
    }

    // MARK: - Close Button
    private var closeButton: some View {
        Button(action: {
            withAnimation(.spring(response: 0.3)) {
                audioManager.stop()
            }
        }) {
            Image(systemName: "xmark")
                .font(.system(size: 14, weight: .bold))
                .foregroundColor(AppColors.textPrimary)
                .frame(width: 28, height: 28)
        }
        .buttonStyle(PlainButtonStyle())
    }

    // MARK: - Waveform Icon
    private var waveformIcon: some View {
        Image(systemName: "chart.bar.fill")
            .font(.system(size: 18, weight: .medium))
            .foregroundColor(AppColors.textSecondary)
            .frame(width: 24, height: 24)
    }

    // MARK: - Title and Time Section
    private var titleAndTimeSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xxs) {
            if let episode = audioManager.currentEpisode {
                // Episode title (truncated)
                Text(episode.title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(1)
                    .truncationMode(.tail)

                // Remaining time
                Text(formatRemainingTime())
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .lineLimit(1)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

    // MARK: - Skip Back Button
    private var skipBackButton: some View {
        Button(action: {
            withAnimation(.spring(response: 0.2)) {
                audioManager.skipBackward()
            }
        }) {
            Image(systemName: "gobackward.15")
                .font(.system(size: 18, weight: .semibold))
                .foregroundColor(AppColors.textPrimary)
                .frame(width: 32, height: 32)
        }
        .buttonStyle(PlainButtonStyle())
    }

    // MARK: - Play/Pause Button
    private var playPauseButton: some View {
        Button(action: {
            withAnimation(.spring(response: 0.2)) {
                audioManager.togglePlayPause()
            }
        }) {
            ZStack {
                Circle()
                    .fill(AppColors.primaryBlue)
                    .frame(width: 44, height: 44)

                Image(systemName: audioManager.isPlaying ? "pause.fill" : "play.fill")
                    .font(.system(size: 16, weight: .bold))
                    .foregroundColor(.white)
                    .offset(x: audioManager.isPlaying ? 0 : 1)
            }
        }
        .buttonStyle(PlainButtonStyle())
    }

    // MARK: - Speed Indicator
    private var speedIndicator: some View {
        Button(action: {
            cyclePlaybackSpeed()
        }) {
            Text(audioManager.playbackSpeed.label)
                .font(AppTypography.footnoteBold)
                .foregroundColor(AppColors.textPrimary)
                .frame(width: 36, height: 28)
        }
        .buttonStyle(PlainButtonStyle())
    }

    // MARK: - Capsule Background
    private var capsuleBackground: some View {
        Color(hex: "1A1F2E") // Dark navy/charcoal for solid capsule look
    }

    // MARK: - Progress Bar
    private func progressBar(width: CGFloat) -> some View {
        let barWidth = width - (AppSpacing.lg * 2)
        
        return ZStack(alignment: .leading) {
            // Background track (subtle)
            Rectangle()
                .fill(Color.white.opacity(0.1))
                .frame(width: barWidth, height: 3)

            // Progress fill
            Rectangle()
                .fill(AppColors.primaryBlue)
                .frame(width: max(0, barWidth * audioManager.progress), height: 3)
                .animation(.linear(duration: 0.1), value: audioManager.progress)
        }
        .frame(height: 3)
        .padding(.horizontal, AppSpacing.lg)
        .offset(y: -6) // Position at bottom inside capsule
    }

    // MARK: - Drag Handling
    private func handleDragEnd(_ value: DragGesture.Value) {
        let velocity = value.predictedEndTranslation.height - value.translation.height

        // Swipe up to expand
        if value.translation.height < expandThreshold || velocity < -300 {
            audioManager.expandPlayer()
        }
        // Swipe down to dismiss
        else if value.translation.height > dismissThreshold || velocity > 300 {
            audioManager.stop()
        }

        // Reset offset
        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
            dragOffset = 0
        }
    }

    // MARK: - Helpers

    private func formatRemainingTime() -> String {
        let remaining = audioManager.remainingTime
        let minutes = Int(remaining) / 60
        let seconds = Int(remaining) % 60
        return String(format: "%d:%02d Remaining...", minutes, seconds)
    }

    private func cyclePlaybackSpeed() {
        let speeds = PlaybackSpeed.allCases
        if let currentIndex = speeds.firstIndex(of: audioManager.playbackSpeed) {
            let nextIndex = (currentIndex + 1) % speeds.count
            audioManager.playbackSpeed = speeds[nextIndex]
        }
    }
}

// MARK: - Preview
#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack {
            Text("Main Content")
                .foregroundColor(AppColors.textPrimary)
            Spacer()
        }

        GlobalMiniPlayer()
            .environmentObject(AudioManager.shared)
    }
    .onAppear {
        AudioManager.shared.play(.sampleMoneyMoves)
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/GrowthChartView.swift
================================================================================

//
//  GrowthChartView.swift
//  ios
//
//  Molecule: Combined bar and line chart displaying growth data using Swift Charts
//

import SwiftUI
import Charts

struct GrowthChartView: View {
    let dataPoints: [GrowthDataPoint]
    
    @State private var selectedPeriod: String?

    // Chart configuration
    private let chartHeight: CGFloat = 220
    private let yAxisWidth: CGFloat = 45
    
    // Computed property for selected data point
    private var selectedDataPoint: GrowthDataPoint? {
        guard let selectedPeriod = selectedPeriod else { return nil }
        return dataPoints.first { $0.period == selectedPeriod }
    }

    // Computed properties for chart bounds
    private var maxBarValue: Double {
        (dataPoints.map { $0.value }.max() ?? 1) * 1.15
    }

    private var minBarValue: Double {
        0 // Start from 0 for bar charts
    }

    private var yoyValues: [Double] {
        dataPoints.map { $0.yoyChangePercent }
    }

    private var sectorValues: [Double] {
        dataPoints.map { $0.sectorAverageYoY }
    }

    private var allPercentValues: [Double] {
        yoyValues + sectorValues
    }

    private var maxYoY: Double {
        max((allPercentValues.max() ?? 10) * 1.2, 20)
    }

    private var minYoY: Double {
        min((allPercentValues.min() ?? -10) * 1.2, -20)
    }

    // Grid line values (4 horizontal lines)
    private var gridValues: [Double] {
        let step = maxBarValue / 4
        return [step, step * 2, step * 3]
    }
    
    // Font sizes - Since we only show 5 labels for both annual and quarterly,
    // use larger sizes that match the original annual view
    private var labelFontSize: CGFloat {
        // Use 11pt for both since we're only showing 5 labels
        return 11
    }
    
    private var yoyFontSize: CGFloat {
        // Use 11pt (increased from 10pt) to make it more prominent
        return 11
    }

    var body: some View {
        VStack(spacing: 0) {
            // Chart with bars and lines
            chartContent

            // X-axis labels (periods)
            xAxisLabels

            // YoY percentage values below chart
            yoyPercentageLabels
        }
    }

    // MARK: - Chart Content

    private var chartContent: some View {
        HStack(alignment: .top, spacing: 0) {
            // Y-axis labels for bar values
            barYAxisLabels
                .frame(width: yAxisWidth)

            // Main chart area
            Chart {
                // Horizontal grid lines (behind everything)
                ForEach(gridValues, id: \.self) { value in
                    RuleMark(y: .value("Grid", value))
                        .foregroundStyle(AppColors.cardBackgroundLight.opacity(0.5))
                        .lineStyle(StrokeStyle(lineWidth: 0.5))
                }

                // Bar marks for absolute values
                ForEach(dataPoints) { dataPoint in
                    BarMark(
                        x: .value("Period", dataPoint.period),
                        y: .value("Value", dataPoint.value),
                        width: dataPoints.count > 10 ? .fixed(12) : (dataPoints.count > 6 ? .fixed(18) : .automatic)
                    )
                    .foregroundStyle(AppColors.growthBarBlue)
                    .cornerRadius(4)
                }

                // YoY line - single continuous line
                ForEach(dataPoints) { dataPoint in
                    LineMark(
                        x: .value("Period", dataPoint.period),
                        y: .value("YoY", normalizeYoY(dataPoint.yoyChangePercent)),
                        series: .value("Series", "YoY")
                    )
                    .foregroundStyle(AppColors.growthYoYYellow)
                    .lineStyle(StrokeStyle(lineWidth: 2.5, lineCap: .round, lineJoin: .round))
                    .interpolationMethod(.linear)
                }

                // YoY points
                ForEach(dataPoints) { dataPoint in
                    PointMark(
                        x: .value("Period", dataPoint.period),
                        y: .value("YoY", normalizeYoY(dataPoint.yoyChangePercent))
                    )
                    .foregroundStyle(AppColors.growthYoYYellow)
                    .symbolSize(50)
                }

                // Sector average line - single continuous dashed line
                ForEach(dataPoints) { dataPoint in
                    LineMark(
                        x: .value("Period", dataPoint.period),
                        y: .value("Sector", normalizeYoY(dataPoint.sectorAverageYoY)),
                        series: .value("Series", "Sector")
                    )
                    .foregroundStyle(AppColors.growthSectorGray)
                    .lineStyle(StrokeStyle(lineWidth: 2, lineCap: .round, lineJoin: .round, dash: [6, 4]))
                    .interpolationMethod(.linear)
                }

                // Sector average points
                ForEach(dataPoints) { dataPoint in
                    PointMark(
                        x: .value("Period", dataPoint.period),
                        y: .value("Sector", normalizeYoY(dataPoint.sectorAverageYoY))
                    )
                    .foregroundStyle(AppColors.growthSectorGray)
                    .symbolSize(35)
                }
                
                // Selection indicator
                if let selectedDataPoint = selectedDataPoint {
                    RuleMark(x: .value("Selected", selectedDataPoint.period))
                        .foregroundStyle(AppColors.textPrimary.opacity(0.3))
                        .lineStyle(StrokeStyle(lineWidth: 2))
                        .annotation(position: .top, spacing: 8) {
                            selectionAnnotation(for: selectedDataPoint)
                        }
                }
            }
            .chartXAxis(.hidden)
            .chartYAxis(.hidden)
            .chartYScale(domain: minBarValue...maxBarValue)
            .chartXSelection(value: $selectedPeriod)
            .chartAngleSelection(value: $selectedPeriod)
            .chartPlotStyle { plotArea in
                plotArea
                    .background(Color.clear)
            }
            .frame(height: chartHeight)
        }
    }

    // MARK: - Y-Axis Labels

    private var barYAxisLabels: some View {
        VStack {
            Text(formatLargeNumber(maxBarValue * 0.9))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text(formatLargeNumber(maxBarValue * 0.6))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text(formatLargeNumber(maxBarValue * 0.3))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text("0")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }
        .frame(height: chartHeight)
        .padding(.trailing, AppSpacing.xs)
    }

    // MARK: - X-Axis Labels

    private var xAxisLabels: some View {
        GeometryReader { geometry in
            let availableWidth = geometry.size.width - yAxisWidth
            let columnWidth = availableWidth / CGFloat(dataPoints.count)
            
            ZStack(alignment: .topLeading) {
                // Spacer for y-axis
                Color.clear
                    .frame(width: yAxisWidth, height: 1)
                    .frame(maxWidth: .infinity, alignment: .leading)
                
                // Position labels
                ForEach(Array(dataPoints.enumerated()), id: \.offset) { index, dataPoint in
                    if shouldShowLabel(for: dataPoint) {
                        Text(dataPoint.period)
                            .font(.system(size: labelFontSize, weight: .regular))
                            .foregroundColor(AppColors.textMuted)
                            .lineLimit(1)
                            .minimumScaleFactor(0.8)
                            .frame(width: columnWidth * 4, alignment: .leading)
                            .offset(x: yAxisWidth + (columnWidth * CGFloat(index)))
                    }
                }
            }
        }
        .frame(height: 20)
        .padding(.top, AppSpacing.sm)
    }

    // MARK: - YoY Percentage Labels

    private var yoyPercentageLabels: some View {
        GeometryReader { geometry in
            let availableWidth = geometry.size.width - yAxisWidth
            let columnWidth = availableWidth / CGFloat(dataPoints.count)
            
            ZStack(alignment: .topLeading) {
                // Yellow dot indicator
                GrowthLegendDot(color: AppColors.growthYoYYellow, size: 8)
                    .frame(width: yAxisWidth, alignment: .center)
                    .frame(maxWidth: .infinity, alignment: .leading)
                
                // Position YoY labels
                ForEach(Array(dataPoints.enumerated()), id: \.offset) { index, dataPoint in
                    if shouldShowLabel(for: dataPoint) {
                        Text(String(format: "%.1f%%", dataPoint.yoyChangePercent))
                            .font(.system(size: yoyFontSize, weight: .semibold))
                            .foregroundColor(dataPoint.yoyChangePercent >= 0 ? AppColors.bullish : AppColors.bearish)
                            .lineLimit(1)
                            .minimumScaleFactor(0.8)
                            .frame(width: columnWidth * 4, alignment: .leading)
                            .offset(x: yAxisWidth + (columnWidth * CGFloat(index)))
                    }
                }
            }
        }
        .frame(height: 20)
        .padding(.top, AppSpacing.sm)
    }
    
    // MARK: - Selection Annotation
    
    private func selectionAnnotation(for dataPoint: GrowthDataPoint) -> some View {
        VStack(spacing: 4) {
            Text(dataPoint.period)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textPrimary)
            
            Text(String(format: "%.1f%%", dataPoint.yoyChangePercent))
                .font(AppTypography.calloutBold)
                .foregroundColor(dataPoint.yoyChangePercent >= 0 ? AppColors.bullish : AppColors.bearish)
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(AppColors.cardBackground)
                .shadow(color: Color.black.opacity(0.2), radius: 8, x: 0, y: 4)
        )
    }
    
    // MARK: - Helper Functions - Label Display
    
    private func shouldShowLabel(for dataPoint: GrowthDataPoint) -> Bool {
        // For quarterly data (more than 10 points), show only Q1 labels
        if dataPoints.count > 10 {
            return dataPoint.period.hasPrefix("Q1'")
        }
        // For annual data (5 or fewer points), show all labels
        return true
    }

    // MARK: - Helper Functions

    /// Normalize YoY percentage to fit within the bar chart's value range
    private func normalizeYoY(_ yoyPercent: Double) -> Double {
        // Map YoY percentage range to bar value range
        // YoY typically ranges from minYoY to maxYoY
        // We want to map this to approximately 20%-80% of the bar chart height
        let yoyRange = maxYoY - minYoY
        let normalizedYoY = (yoyPercent - minYoY) / yoyRange // 0 to 1
        let targetMin = maxBarValue * 0.15
        let targetMax = maxBarValue * 0.75
        return targetMin + normalizedYoY * (targetMax - targetMin)
    }

    private func formatLargeNumber(_ number: Double) -> String {
        let absNumber = abs(number)
        if absNumber >= 1_000_000_000_000 {
            return String(format: "%.0fT", number / 1_000_000_000_000)
        } else if absNumber >= 1_000_000_000 {
            return String(format: "%.0fB", number / 1_000_000_000)
        } else if absNumber >= 1_000_000 {
            return String(format: "%.0fM", number / 1_000_000)
        } else if absNumber >= 1_000 {
            return String(format: "%.0fK", number / 1_000)
        } else if absNumber >= 1 {
            return String(format: "%.1f", number)
        }
        return String(format: "%.2f", number)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            GrowthSectionCard(
                growthData: GrowthSectionData.sampleData,
                onDetailTapped: {}
            )
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/GrowthInfoSheet.swift
================================================================================

//
//  GrowthInfoSheet.swift
//  ios
//
//  Molecule: Educational sheet explaining growth metrics for value investing
//

import SwiftUI

struct GrowthInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xxl) {
                    // Header Section
                    headerSection

                    // Understanding Growth Section
                    understandingGrowthSection

                    // Value Investing Tips
                    valueInvestingTipsSection

                    // Chart Reading Guide
                    chartReadingGuideSection
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("Understanding Growth")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "chart.line.uptrend.xyaxis")
                    .font(.system(size: 24))
                    .foregroundColor(AppColors.primaryBlue)

                Text("Growth Analysis")
                    .font(AppTypography.title2)
                    .foregroundColor(AppColors.textPrimary)
            }

            Text("Growth metrics help you understand how a company's financial performance is improving (or declining) over time. For value investors, sustainable growth at reasonable prices is key.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Understanding Growth Section

    private var understandingGrowthSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Key Metrics Explained")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                ForEach(GrowthMetricType.allCases) { metric in
                    metricExplanationRow(metric: metric)
                }
            }
        }
    }

    private func metricExplanationRow(metric: GrowthMetricType) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            Text(metric.rawValue)
                .font(AppTypography.bodyBold)
                .foregroundColor(AppColors.primaryBlue)

            Text(metric.description)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Value Investing Tips Section

    private var valueInvestingTipsSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "lightbulb.fill")
                    .foregroundColor(AppColors.neutral)

                Text("Value Investing Tips")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            VStack(spacing: AppSpacing.md) {
                ForEach(GrowthInfoItem.valueInvestingTips) { tip in
                    tipCard(tip: tip)
                }
            }
        }
    }

    private func tipCard(tip: GrowthInfoItem) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: tip.icon)
                    .font(.system(size: 16))
                    .foregroundColor(AppColors.bullish)
                    .frame(width: 24)

                Text(tip.title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
            }

            Text(tip.description)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            if let example = tip.example {
                HStack(alignment: .top, spacing: AppSpacing.sm) {
                    Text("Example:")
                        .font(AppTypography.captionBold)
                        .foregroundColor(AppColors.accentCyan)

                    Text(example)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .fixedSize(horizontal: false, vertical: true)
                }
                .padding(.top, AppSpacing.xs)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Chart Reading Guide Section

    private var chartReadingGuideSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Reading the Chart")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(alignment: .leading, spacing: AppSpacing.md) {
                chartLegendExplanation(
                    color: AppColors.growthBarBlue,
                    title: "Blue Bars (Value)",
                    description: "Shows the absolute value for each period. Taller bars mean higher values."
                )

                chartLegendExplanation(
                    color: AppColors.growthYoYYellow,
                    title: "Yellow Line (YoY %)",
                    description: "Year-over-Year growth rate. Points above the midline indicate positive growth."
                )

                chartLegendExplanation(
                    color: AppColors.growthSectorGray,
                    title: "Gray Dashed Line (Sector Avg)",
                    description: "Industry average growth. Compare to see if company outperforms peers."
                )

                chartLegendExplanation(
                    color: AppColors.bullish,
                    title: "Green Percentages",
                    description: "Positive YoY growth - the company improved from the previous year."
                )

                chartLegendExplanation(
                    color: AppColors.bearish,
                    title: "Red Percentages",
                    description: "Negative YoY growth - decline from the previous year."
                )
            }
            .padding(AppSpacing.lg)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.large)
                    .fill(AppColors.cardBackground)
            )
        }
    }

    private func chartLegendExplanation(color: Color, title: String, description: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Circle()
                .fill(color)
                .frame(width: 12, height: 12)
                .padding(.top, 4)

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
    }
}

#Preview {
    GrowthInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/GrowthLegendView.swift
================================================================================

//
//  GrowthLegendView.swift
//  ios
//
//  Molecule: Legend showing YoY, Value, and Sector Average indicators
//

import SwiftUI

struct GrowthLegendView: View {
    var body: some View {
        HStack(spacing: AppSpacing.xl) {
            // YoY Legend
            HStack(spacing: AppSpacing.xs) {
                GrowthLegendDot(color: AppColors.growthYoYYellow)
                    .offset(y: 1)
                Text("YoY")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            // Value Legend
            HStack(spacing: AppSpacing.xs) {
                GrowthLegendDot(color: AppColors.growthBarBlue)
                    .offset(y: 1)
                Text("Value")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            // Sector Average Legend
            HStack(spacing: AppSpacing.xs) {
                GrowthLegendDot(color: AppColors.growthSectorGray, style: .dashed)
                    .offset(y: 1)
                Text("Sector Average (YoY)")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        GrowthLegendView()
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/GrowthMetricSelector.swift
================================================================================

//
//  GrowthMetricSelector.swift
//  ios
//
//  Molecule: Horizontal scrolling selector for growth metric types
//

import SwiftUI

struct GrowthMetricSelector: View {
    @Binding var selectedMetric: GrowthMetricType

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: AppSpacing.sm) {
                ForEach(GrowthMetricType.allCases) { metric in
                    GrowthMetricChip(
                        metricType: metric,
                        isSelected: selectedMetric == metric,
                        action: {
                            withAnimation(.easeInOut(duration: 0.2)) {
                                selectedMetric = metric
                            }
                        }
                    )
                }
            }
            .padding(.horizontal, AppSpacing.xs)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack {
            GrowthMetricSelector(selectedMetric: .constant(.revenue))
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/HealthCheckInfoSheet.swift
================================================================================

//
//  HealthCheckInfoSheet.swift
//  ios
//
//  Molecule: Educational sheet explaining Health Check metrics for value investors
//

import SwiftUI

struct HealthCheckInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xxl) {
                    // Header Section
                    headerSection

                    // What is Health Check Section
                    whatIsHealthCheckSection

                    // Metrics Explained
                    metricsExplainedSection

                    // How Value Investors Use It
                    valueInvestingSection

                    // Rating System Explained
                    ratingSystemSection
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("Health Check Guide")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "heart.text.square.fill")
                    .font(.system(size: 24))
                    .foregroundColor(AppColors.primaryBlue)

                Text("Financial Health Check")
                    .font(AppTypography.title2)
                    .foregroundColor(AppColors.textPrimary)
            }

            Text("A quick assessment of a company's financial strength across four key dimensions that matter most to value investors.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - What is Health Check Section

    private var whatIsHealthCheckSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("What Does Health Check Tell You?")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                infoCard(
                    icon: "shield.checkered",
                    iconColor: AppColors.bullish,
                    title: "Financial Stability",
                    description: "Evaluates if a company can meet its obligations and weather economic downturns without risking bankruptcy."
                )

                infoCard(
                    icon: "chart.line.uptrend.xyaxis",
                    iconColor: AppColors.primaryBlue,
                    title: "Valuation Context",
                    description: "Shows whether the stock is cheap or expensive relative to its sector peers - crucial for finding undervalued opportunities."
                )

                infoCard(
                    icon: "dollarsign.circle.fill",
                    iconColor: AppColors.neutral,
                    title: "Capital Efficiency",
                    description: "Measures how effectively management uses shareholder capital to generate profits."
                )
            }
        }
    }

    private func infoCard(icon: String, iconColor: Color, title: String, description: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Image(systemName: icon)
                .font(.system(size: 20))
                .foregroundColor(iconColor)
                .frame(width: 28)

            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Metrics Explained Section

    private var metricsExplainedSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("The Four Key Metrics")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                ForEach(HealthCheckMetricType.allCases) { metric in
                    metricExplanationRow(metric: metric)
                }
            }
        }
    }

    private func metricExplanationRow(metric: HealthCheckMetricType) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            Text(metric.rawValue)
                .font(AppTypography.bodyBold)
                .foregroundColor(AppColors.primaryBlue)

            Text(metric.valueInvestorDescription)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            // Gauge explanation
            HStack(spacing: AppSpacing.xs) {
                Circle()
                    .fill(metric == .debtToEquity || metric == .peRatio ? AppColors.bullish : AppColors.bearish)
                    .frame(width: 8, height: 8)

                Text(metric.leftLabel)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)

                Spacer()

                Text(metric.rightLabel)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)

                Circle()
                    .fill(metric == .debtToEquity || metric == .peRatio ? AppColors.bearish : AppColors.bullish)
                    .frame(width: 8, height: 8)
            }
            .padding(.top, AppSpacing.xs)
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Value Investing Section

    private var valueInvestingSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "lightbulb.fill")
                    .foregroundColor(AppColors.neutral)

                Text("How Value Investors Use This")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            VStack(spacing: AppSpacing.md) {
                tipCard(
                    number: "1",
                    title: "Screen for Quality",
                    description: "Use Health Check as a first filter. Companies with 3+ passing metrics often have \"margin of safety\" - a core value investing principle."
                )

                tipCard(
                    number: "2",
                    title: "Compare to Sector",
                    description: "The gauge shows where a metric stands vs sector average. Being better than average in 3+ areas suggests competitive advantage."
                )

                tipCard(
                    number: "3",
                    title: "Identify Red Flags",
                    description: "High debt-to-equity or low current ratio can signal financial distress. Value investors avoid \"value traps\" by checking financial health first."
                )

                tipCard(
                    number: "4",
                    title: "Find Undervalued Gems",
                    description: "A low P/E ratio combined with strong ROE and healthy balance sheet often indicates an overlooked quality company trading at a discount."
                )
            }
        }
    }

    private func tipCard(number: String, title: String, description: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            ZStack {
                Circle()
                    .fill(AppColors.primaryBlue.opacity(0.2))
                    .frame(width: 28, height: 28)

                Text(number)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.primaryBlue)
            }

            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Rating System Section

    private var ratingSystemSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Understanding the Rating")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                ratingRow(rating: .excellent, description: "All 4 metrics pass - exceptional financial health")
                ratingRow(rating: .good, description: "3 of 4 metrics pass - solid fundamentals")
                ratingRow(rating: .mix, description: "2 of 4 metrics pass - mixed signals, investigate further")
                ratingRow(rating: .caution, description: "1 of 4 metrics pass - proceed with caution")
                ratingRow(rating: .poor, description: "0 of 4 metrics pass - significant concerns")
            }
            .padding(AppSpacing.lg)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.large)
                    .fill(AppColors.cardBackground)
            )

            // Disclaimer
            Text("Note: Health Check is one tool in your analysis toolkit. Always combine with qualitative research, industry analysis, and management assessment before making investment decisions.")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
                .fixedSize(horizontal: false, vertical: true)
                .padding(.top, AppSpacing.sm)
        }
    }

    private func ratingRow(rating: HealthCheckRating, description: String) -> some View {
        HStack(alignment: .firstTextBaseline, spacing: AppSpacing.md) {
            Image(systemName: rating.iconName)
                .font(.system(size: 16))
                .foregroundColor(rating.color)
                .frame(width: 24, alignment: .center)

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(rating.rawValue)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(rating.color)

                Text(description)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
            
            Spacer()
        }
    }
}

#Preview {
    HealthCheckInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/HealthCheckMetricCard.swift
================================================================================

//
//  HealthCheckMetricCard.swift
//  ios
//
//  Molecule: Individual metric card for Health Check display
//  Shows metric name, value, gauge, and insight text
//

import SwiftUI

struct HealthCheckMetricCard: View {
    let metric: HealthCheckMetric

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header: Metric name, subtitle, and value
            headerSection

            // Gauge bar with position indicator
            gaugeSection

            // Insight text with highlighted portion
            insightSection
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackgroundLight)
        )
    }

    // MARK: - Header Section

    private var headerSection: some View {
        HStack(alignment: .top) {
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(metric.type.rawValue)
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                Text(metric.type.subtitle)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            Spacer()

            VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                Text(metric.formattedValue)
                    .font(AppTypography.title2)
                    .foregroundColor(metric.valueColor)

                if let comparison = metric.formattedComparison {
                    Text(comparison)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }
            }
        }
    }

    // MARK: - Gauge Section

    private var gaugeSection: some View {
        VStack(spacing: AppSpacing.xs) {
            HealthCheckGaugeBar(
                position: metric.gaugePosition,
                metricType: metric.type
            )

            HStack {
                Text(metric.type.leftLabel)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)

                Spacer()

                Text(metric.type.rightLabel)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }
        }
    }

    // MARK: - Insight Section

    private var insightSection: some View {
        insightTextView
            .font(AppTypography.callout)
            .foregroundColor(AppColors.textSecondary)
            .fixedSize(horizontal: false, vertical: true)
    }

    @ViewBuilder
    private var insightTextView: some View {
        if let highlightedValue = metric.highlightedValue {
            if let highlightedLabel = metric.highlightedLabel {
                // Format: "43% lower debt than sector average." or "Trading at a 15% discount to..."
                if metric.type == .peRatio {
                    // Special format for P/E: "Trading at a 15% discount to the Tech sector..."
                    Text("\(Text(highlightedLabel).foregroundColor(AppColors.textSecondary)) \(Text(highlightedValue).foregroundColor(metric.valueColor).bold()) discount \(Text(metric.insightText).foregroundColor(AppColors.textSecondary))")
                } else if metric.type == .returnOnEquity || metric.type == .currentRatio {
                    // Format: "22% below ROE than peers..." or "21% above sector average..."
                    Text("\(Text(highlightedValue).foregroundColor(metric.valueColor).bold()) \(Text(highlightedLabel).foregroundColor(metric.valueColor).bold()) \(Text(metric.insightText).foregroundColor(AppColors.textSecondary))")
                } else {
                    // Format: "43% lower debt than sector average."
                    Text("\(Text(highlightedValue).foregroundColor(metric.valueColor).bold()) \(Text(highlightedLabel).foregroundColor(AppColors.textSecondary)) \(Text(metric.insightText).foregroundColor(AppColors.textSecondary))")
                }
            } else {
                // Format: "Above sector average..." (fallback, not used anymore)
                Text("\(Text(highlightedValue).foregroundColor(metric.valueColor).bold()) \(Text(metric.insightText).foregroundColor(AppColors.textSecondary))")
            }
        } else {
            Text(metric.insightText)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            VStack(spacing: AppSpacing.lg) {
                ForEach(HealthCheckSectionData.sampleData.metrics) { metric in
                    HealthCheckMetricCard(metric: metric)
                }
            }
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/InsiderActivityRow.swift
================================================================================

//
//  InsiderActivityRow.swift
//  ios
//
//  Molecule: Row displaying a single insider trading activity
//  Shows name, title, date, change value, transaction type, and price
//

import SwiftUI

struct InsiderActivityRow: View {
    let activity: InsiderActivity

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Left side: Name, Title, Date
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(activity.name)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(1)

                Text(activity.title)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                    .lineLimit(1)

                Text(activity.formattedDate)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }

            Spacer()

            // Right side: Change value, Transaction type, Price
            VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                Text(activity.formattedChange)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(activity.changeColor)

                Text(activity.transactionType.rawValue)
                    .font(AppTypography.caption)
                    .foregroundColor(activity.transactionType.color)

                Text(activity.formattedPrice)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.sm) {
            InsiderActivityRow(
                activity: InsiderActivity.sampleData[0]  // Tim Cook - Informative Buy
            )

            InsiderActivityRow(
                activity: InsiderActivity.sampleData[2]  // Monica Lozano - Uninformative Buy
            )

            InsiderActivityRow(
                activity: InsiderActivity.sampleData[4]  // Oscar Munoz - Informative Sell
            )

            InsiderActivityRow(
                activity: InsiderActivity.sampleData[3]  // Jeff Williams - Uninformative Sell
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/InsiderFilterSelector.swift
================================================================================

//
//  InsiderFilterSelector.swift
//  ios
//
//  Molecule: Filter selector for insider activities (All / Informative)
//  Allows filtering to show only informative transactions
//

import SwiftUI

struct InsiderFilterSelector: View {
    @Binding var selectedFilter: InsiderActivityFilterOption

    var body: some View {
        HStack(spacing: 0) {
            ForEach(InsiderActivityFilterOption.allCases, id: \.self) { filter in
                Button {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedFilter = filter
                    }
                } label: {
                    Text(filter.rawValue)
                        .font(AppTypography.callout)
                        .foregroundColor(selectedFilter == filter ? AppColors.textPrimary : AppColors.textSecondary)
                        .padding(.horizontal, AppSpacing.lg)
                        .padding(.vertical, AppSpacing.sm)
                        .background(
                            Group {
                                if selectedFilter == filter {
                                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                                        .fill(AppColors.cardBackground)
                                }
                            }
                        )
                }
                .buttonStyle(.plain)
            }
        }
        .padding(AppSpacing.xxs)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.background)
        )
    }
}

#Preview {
    ZStack {
        AppColors.cardBackground
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            InsiderFilterSelector(selectedFilter: .constant(.all))

            InsiderFilterSelector(selectedFilter: .constant(.informative))
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/InsiderFlowSummaryCard.swift
================================================================================

//
//  InsiderFlowSummaryCard.swift
//  ios
//
//  Molecule: Summary card showing Informative Buys vs Informative Sells
//  Displays totals and buyer/seller counts
//

import SwiftUI

struct InsiderFlowSummaryCard: View {
    let summary: InsiderActivitySummary

    var body: some View {
        VStack(spacing: AppSpacing.sm) {
            // Two-column layout: Informative Buys | Informative Sells
            HStack(spacing: 0) {
                // Informative Buys column
                VStack(spacing: AppSpacing.xxs) {
                    Text("INFORMATIVE BUYS")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .tracking(0.5)

                    Text(summary.formattedBuys)
                        .font(AppTypography.title3)
                        .foregroundColor(AppColors.bullish)

                    Text(summary.buyersLabel)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }
                .frame(maxWidth: .infinity)

                // Vertical divider
                Rectangle()
                    .fill(AppColors.textMuted.opacity(0.3))
                    .frame(width: 1)
                    .padding(.vertical, AppSpacing.xs)

                // Informative Sells column
                VStack(spacing: AppSpacing.xxs) {
                    Text("INFORMATIVE SELLS")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .tracking(0.5)

                    Text(summary.formattedSells)
                        .font(AppTypography.title3)
                        .foregroundColor(AppColors.bearish)

                    Text(summary.sellersLabel)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }
                .frame(maxWidth: .infinity)
            }
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
                .overlay(
                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                        .stroke(AppColors.textMuted.opacity(0.3), lineWidth: 1)
                )
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.lg) {
            InsiderFlowSummaryCard(
                summary: InsiderActivitySummary.sampleData
            )

            // Alternative with different values
            InsiderFlowSummaryCard(
                summary: InsiderActivitySummary(
                    periodDescription: "Last 6 Months",
                    informativeBuysInMillions: 5.2,
                    informativeSellsInMillions: 8.7,
                    numBuyers: 1,
                    numSellers: 3
                )
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/InsiderNetFlowBadge.swift
================================================================================

//
//  InsiderNetFlowBadge.swift
//  ios
//
//  Molecule: Badge displaying the net informative flow for insiders
//  Shows net flow value with up/down indicator and appropriate color
//

import SwiftUI

struct InsiderNetFlowBadge: View {
    let summary: InsiderActivitySummary

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            Text("Net Informative Flow:")
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)

            Text(summary.formattedNetFlow)
                .font(AppTypography.calloutBold)
                .foregroundColor(summary.netFlowColor)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.lg) {
            // Positive flow
            InsiderNetFlowBadge(
                summary: InsiderActivitySummary.sampleData
            )

            // Negative flow
            InsiderNetFlowBadge(
                summary: InsiderActivitySummary(
                    periodDescription: "Last 6 Months",
                    informativeBuysInMillions: 2.5,
                    informativeSellsInMillions: 6.8,
                    numBuyers: 1,
                    numSellers: 4
                )
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/InstitutionalActivityRow.swift
================================================================================

//
//  InstitutionalActivityRow.swift
//  ios
//
//  Molecule: Row displaying a single institutional trading activity
//  Shows institution name, category, date, change value/percent, and total held
//

import SwiftUI

struct InstitutionalActivityRow: View {
    let activity: InstitutionalActivity

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Left side: Name, Category, Date
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(activity.institutionName)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(1)

                Text(activity.category)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                    .lineLimit(1)

                Text(activity.formattedDate)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }

            Spacer()

            // Right side: Change value, Change percent, Total held
            VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                Text(activity.formattedChange)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(activity.changeColor)

                Text(activity.formattedChangePercent)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)

                Text(activity.formattedTotalHeld)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.sm) {
            InstitutionalActivityRow(
                activity: InstitutionalActivity.sampleData[0]
            )

            InstitutionalActivityRow(
                activity: InstitutionalActivity.sampleData[2]
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/InvestorPathHeader.swift
================================================================================

//
//  InvestorJourneyHeader.swift
//  ios
//
//  Molecule: Header for The Investor Journey screen with title, subtitle, and progress
//

import SwiftUI

struct InvestorJourneyHeader: View {
    let completedLessons: Int
    let totalLessons: Int
    var onBackTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Navigation bar
            HStack {
                Button(action: {
                    onBackTapped?()
                }) {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                }

                Spacer()
            }

            // Title section
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text("The Investor Journey")
                    .font(AppTypography.largeTitle)
                    .foregroundColor(AppColors.textPrimary)

                Text("From Novice to Master")
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
            }

            // Overall progress
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                HStack {
                    Text("Overall Progress")
                        .font(AppTypography.footnote)
                        .foregroundColor(AppColors.textMuted)

                    Spacer()

                    Text("\(completedLessons)/\(totalLessons) Lessons Completed")
                        .font(AppTypography.footnoteBold)
                        .foregroundColor(AppColors.textSecondary)
                }

                OverallProgressIndicator(
                    completed: completedLessons,
                    total: totalLessons,
                    segmentCount: totalLessons
                )
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.sm)
        .padding(.bottom, AppSpacing.lg)
    }
}

#Preview {
    VStack {
        InvestorJourneyHeader(completedLessons: 1, totalLessons: 27)
        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/InvestorQuoteCard.swift
================================================================================

//
//  InvestorQuoteCard.swift
//  ios
//
//  Molecule: Card displaying an inspirational investor quote
//

import SwiftUI

struct InvestorQuoteCard: View {
    let quote: InvestorQuote

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Quote icon
            Image(systemName: "quote.opening")
                .font(.system(size: 24, weight: .medium))
                .foregroundColor(AppColors.bullish)

            // Quote text
            Text("\"\(quote.text)\"")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textPrimary)
                .multilineTextAlignment(.center)
                .lineSpacing(4)

            // Author
            Text("â€” \(quote.author)")
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textMuted)
        }
        .padding(AppSpacing.xxl)
        .frame(maxWidth: .infinity)
        .background(
            LinearGradient(
                colors: [
                    AppColors.bullish.opacity(0.15),
                    AppColors.bullish.opacity(0.05)
                ],
                startPoint: .top,
                endPoint: .bottom
            )
        )
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    InvestorQuoteCard(quote: .buffettQuote)
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/JourneyItemRow.swift
================================================================================

//
//  JourneyItemRow.swift
//  ios
//
//  Molecule: Single row showing a journey step with completion status
//

import SwiftUI

struct JourneyItemRow: View {
    let item: JourneyItem
    let isLast: Bool
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.md) {
                // Step indicator with optional connector line
                VStack(spacing: 0) {
                    JourneyStepIndicator(
                        stepNumber: item.stepNumber,
                        isCompleted: item.isCompleted,
                        isActive: item.isActive
                    )

                    if !isLast {
                        Rectangle()
                            .fill(item.isCompleted ? AppColors.bullish.opacity(0.3) : AppColors.cardBackgroundLight)
                            .frame(width: 2, height: 20)
                    }
                }

                // Title with strikethrough if completed
                Text(item.title)
                    .font(AppTypography.callout)
                    .foregroundColor(item.isCompleted ? AppColors.textMuted : AppColors.textPrimary)
                    .strikethrough(item.isCompleted, color: AppColors.textMuted)

                Spacer()
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack(spacing: 0) {
        JourneyItemRow(
            item: JourneyItem(title: "It's all about mindset", isCompleted: true, isActive: false, stepNumber: 1),
            isLast: false
        )
        JourneyItemRow(
            item: JourneyItem(title: "What is a Stock?", isCompleted: true, isActive: false, stepNumber: 2),
            isLast: false
        )
        JourneyItemRow(
            item: JourneyItem(title: "Value Investing 101", isCompleted: true, isActive: false, stepNumber: 3),
            isLast: false
        )
        JourneyItemRow(
            item: JourneyItem(title: "Understanding the Market", isCompleted: false, isActive: true, stepNumber: 4),
            isLast: true
        )
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/JourneyProgressCard.swift
================================================================================

//
//  JourneyProgressCard.swift
//  ios
//
//  Molecule: Card showing current journey progress with steps
//

import SwiftUI

struct JourneyProgressCard: View {
    let track: JourneyTrack
    var onContinue: (() -> Void)?
    var onItemTap: ((JourneyItem) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header with track info and progress
            HStack {
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    HStack(spacing: AppSpacing.sm) {
                        // Level icon
                        Image(systemName: track.level.iconName)
                            .font(.system(size: 14, weight: .semibold))
                            .foregroundColor(track.level.color)

                        Text("\(track.level.rawValue) Track")
                            .font(AppTypography.headline)
                            .foregroundColor(AppColors.textPrimary)
                    }

                    Text(track.formattedProgress)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                // Progress percentage
                Text("\(track.progressPercentage)%")
                    .font(.system(size: 28, weight: .bold, design: .rounded))
                    .foregroundColor(track.level.color)
            }

            // Progress bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    RoundedRectangle(cornerRadius: 4)
                        .fill(AppColors.cardBackgroundLight)
                        .frame(height: 8)

                    RoundedRectangle(cornerRadius: 4)
                        .fill(track.level.color)
                        .frame(width: geometry.size.width * CGFloat(track.progress), height: 8)
                }
            }
            .frame(height: 8)

            // Journey items - show only active item
            VStack(spacing: 0) {
                ForEach(Array(track.items.enumerated()), id: \.element.id) { index, item in
                    if item.isActive {
                        JourneyItemRow(
                            item: item,
                            isLast: true
                        ) {
                            onItemTap?(item)
                        }
                    }
                }
            }

            // Continue Learning button
            Button(action: {
                onContinue?()
            }) {
                Text("Resume Lessons")
                    .font(AppTypography.bodyBold)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, AppSpacing.md)
                    .background(track.level.color)
                    .cornerRadius(AppCornerRadius.medium)
            }
            .buttonStyle(PlainButtonStyle())
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.extraLarge)
    }
}

#Preview {
    JourneyProgressCard(track: JourneyTrack.sampleBeginner)
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/KeyStatisticItem.swift
================================================================================

//
//  KeyStatisticItem.swift
//  ios
//
//  Molecule: Individual key statistic display cell
//

import SwiftUI

struct KeyStatisticItem: View {
    let statistic: KeyStatistic

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xs) {
            // Label
            Text(statistic.label)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
                .lineLimit(1)

            // Value
            Text(statistic.value)
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textPrimary)
                .lineLimit(1)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

#Preview {
    LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: AppSpacing.md), count: 4), spacing: AppSpacing.lg) {
        KeyStatisticItem(statistic: KeyStatistic(label: "Open", value: "262.36"))
        KeyStatisticItem(statistic: KeyStatistic(label: "P/E (TTM)", value: "35.15"))
        KeyStatisticItem(statistic: KeyStatistic(label: "P/S", value: "52.57"))
        KeyStatisticItem(statistic: KeyStatistic(label: "Short % of Float", value: "0.83%", isHighlighted: true))
        KeyStatisticItem(statistic: KeyStatistic(label: "Previous Close", value: "267.26"))
        KeyStatisticItem(statistic: KeyStatistic(label: "P/E (FWD)", value: "31.84"))
        KeyStatisticItem(statistic: KeyStatistic(label: "P/S", value: "9.31"))
        KeyStatisticItem(statistic: KeyStatistic(label: "Shares Outstanding", value: "15.638"))
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/KeyStatisticsCard.swift
================================================================================

//
//  KeyStatisticsCard.swift
//  ios
//
//  Molecule: Vertical card containing multiple key statistics for horizontal scroll
//

import SwiftUI

struct KeyStatisticsCard: View {
    let statistics: [KeyStatistic]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            ForEach(statistics) { statistic in
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    // Label
                    Text(statistic.label)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .lineLimit(1)

                    // Value
                    Text(statistic.value)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(statistic.isHighlighted ? AppColors.primaryBlue : AppColors.textPrimary)
                        .lineLimit(1)
                }
            }
        }
        .padding(AppSpacing.lg)
        .frame(width: 160)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    ScrollView(.horizontal, showsIndicators: false) {
        HStack(spacing: AppSpacing.md) {
            KeyStatisticsCard(statistics: [
                KeyStatistic(label: "Open", value: "262.36"),
                KeyStatistic(label: "Previous Close", value: "267.26"),
                KeyStatistic(label: "Volume", value: "39.43M"),
                KeyStatistic(label: "Avg. Volume (3M)", value: "45.23M"),
                KeyStatistic(label: "Market Cap", value: "3.89T")
            ])

            KeyStatisticsCard(statistics: [
                KeyStatistic(label: "P/E (TTM)", value: "35.15"),
                KeyStatistic(label: "P/E (FWD)", value: "31.84"),
                KeyStatistic(label: "EPS (TTM)", value: "7.47"),
                KeyStatistic(label: "Dividend & Yield", value: "1.04 (0.39%)"),
                KeyStatistic(label: "Ex-Dividend Date", value: "11/10/2025")
            ])
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/KeyTakeawayRow.swift
================================================================================

//
//  KeyTakeawayRow.swift
//  ios
//
//  Molecule: Single key takeaway item with numbered badge
//

import SwiftUI

struct KeyTakeawayRow: View {
    let takeaway: KeyTakeaway

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Numbered Badge
            NumberedBadge(number: takeaway.index, size: 26)
                .padding(.top, 2)

            // Takeaway Text
            Text(takeaway.text)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
                .lineSpacing(4)
        }
    }
}

#Preview {
    VStack(alignment: .leading, spacing: AppSpacing.lg) {
        KeyTakeawayRow(
            takeaway: KeyTakeaway(
                index: 1,
                text: "Despite record Q4 results, missing expectations signals slowing growth and weaker-than-hoped execution."
            )
        )

        KeyTakeawayRow(
            takeaway: KeyTakeaway(
                index: 2,
                text: "A miss in a flagship quarter raises doubts about forward demand and near-term visibility."
            )
        )

        KeyTakeawayRow(
            takeaway: KeyTakeaway(
                index: 3,
                text: "Leadership transition at this scale introduces strategic and execution risk during a critical AI cycle."
            )
        )

        KeyTakeawayRow(
            takeaway: KeyTakeaway(
                index: 4,
                text: "With expectations priced for perfection, even a small miss could trigger outsized market pressure."
            )
        )
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/LearnCreditsCard.swift
================================================================================

//
//  LearnCreditsCard.swift
//  ios
//
//  Molecule: Credit balance card specifically for Learn section
//

import SwiftUI

struct LearnCreditsCard: View {
    let balance: CreditBalance
    var onAddCredits: (() -> Void)?

    private let gradientColors = [
        Color(hex: "F97316"),
        Color(hex: "EA580C")
    ]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            Text("Credit Balance")
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textPrimary)

            Text("Manage your research credits")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textPrimary.opacity(0.8))

            // Credits Display
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                HStack(alignment: .lastTextBaseline, spacing: AppSpacing.sm) {
                    Text("\(balance.credits)")
                        .font(.system(size: 40, weight: .bold, design: .rounded))
                        .foregroundColor(AppColors.textPrimary)

                    Text("credits")
                        .font(AppTypography.body)
                        .foregroundColor(AppColors.textPrimary.opacity(0.8))
                }

                Text(balance.formattedRenewalDate)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textPrimary.opacity(0.7))
            }
            .padding(AppSpacing.lg)
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                    .fill(Color.black.opacity(0.2))
            )

            // Add Credits Button
            Button(action: {
                onAddCredits?()
            }) {
                HStack(spacing: AppSpacing.sm) {
                    Image(systemName: "plus")
                        .font(.system(size: 14, weight: .semibold))

                    Text("Add More Credits")
                        .font(AppTypography.calloutBold)
                }
                .foregroundColor(Color(hex: "F97316"))
                .frame(maxWidth: .infinity)
                .padding(.vertical, AppSpacing.md)
                .background(
                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                        .fill(AppColors.textPrimary)
                )
            }
            .buttonStyle(PlainButtonStyle())
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.extraLarge)
                .fill(
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
        )
    }
}

#Preview {
    LearnCreditsCard(balance: CreditBalance.mock)
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/LearnTabControl.swift
================================================================================

//
//  LearnTabControl.swift
//  ios
//
//  Molecule: Custom tab control for Learn/Chat tabs
//

import SwiftUI

struct LearnTabControl: View {
    @Binding var selectedTab: LearnTab

    var body: some View {
        HStack(spacing: 0) {
            ForEach(LearnTab.allCases, id: \.rawValue) { tab in
                Button {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedTab = tab
                    }
                } label: {
                    Text(tab.rawValue)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(selectedTab == tab ? AppColors.textPrimary : AppColors.textMuted)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, AppSpacing.md)
                        .background(
                            selectedTab == tab
                                ? AppColors.cardBackgroundLight
                                : Color.clear
                        )
                        .cornerRadius(AppCornerRadius.medium)
                }
                .buttonStyle(.plain)
            }
        }
        .padding(AppSpacing.xs)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var selected = LearnTab.learn

        var body: some View {
            LearnTabControl(selectedTab: $selected)
                .padding()
                .background(AppColors.background)
        }
    }

    return PreviewWrapper()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/LessonCard.swift
================================================================================

//
//  LessonCard.swift
//  ios
//
//  Molecule: Card showing individual lesson with title, description, duration, and status
//

import SwiftUI

struct LessonCard: View {
    let lesson: Lesson
    var onTap: (() -> Void)?

    private var cardOpacity: Double {
        lesson.status == .notStarted ? 0.8 : 1.0
    }

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                // Title row with category badge
                HStack(alignment: .top, spacing: AppSpacing.sm) {
                    Text(lesson.title)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)

                    if lesson.category == .crypto {
                        LessonCategoryBadge(category: lesson.category)
                    }
                }

                // Description
                Text(lesson.description)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .lineLimit(3)
                    .multilineTextAlignment(.leading)

                Spacer(minLength: AppSpacing.sm)

                // Footer with duration and status
                HStack {
                    LessonDurationLabel(durationMinutes: lesson.durationMinutes)

                    Text("â€¢")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)

                    LessonStatusBadge(status: lesson.status)
                }
            }
            .padding(AppSpacing.md)
            .frame(width: 160, height: 150)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
            .opacity(cardOpacity)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ScrollView(.horizontal, showsIndicators: false) {
        HStack(spacing: AppSpacing.md) {
            LessonCard(lesson: Lesson(
                title: "Compound Interest",
                description: "Discover why Einstein called it the eighth wonder of the world.",
                durationMinutes: 3,
                status: .completed
            ))

            LessonCard(lesson: Lesson(
                title: "Stock vs. Business",
                description: "Learn to think like an owner, not a trader. The fundamental shift.",
                durationMinutes: 4,
                status: .upNext
            ))

            LessonCard(lesson: Lesson(
                title: "Bitcoin: Digital Gold?",
                description: "Understanding the \"Store of Value\" thesis.",
                durationMinutes: 4,
                status: .notStarted,
                category: .crypto
            ))
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/LessonCompletionCard.swift
================================================================================

//
//  LessonCompletionCard.swift
//  ios
//
//  Molecule: Completion card for lesson story - displays checkmark, success message, and CTA
//

import SwiftUI

struct LessonCompletionCard: View {
    let title: String
    let subtitle: String
    let lessonNumber: Int
    let totalLessons: Int
    let estimatedMinutes: Int
    let ctaButtonTitle: String
    var onCTATapped: (() -> Void)?
    var onCloseTapped: (() -> Void)?

    // Animation state
    @State private var checkmarkScale: CGFloat = 0.5
    @State private var checkmarkOpacity: Double = 0
    @State private var cardOpacity: Double = 0
    @State private var cardOffset: CGFloat = 30

    var body: some View {
        VStack(spacing: 0) {
            Spacer()
                .frame(height: 60)

            // Completion card container
            VStack(spacing: AppSpacing.xxl) {
                // Checkmark circle
                checkmarkView
                    .scaleEffect(checkmarkScale)
                    .opacity(checkmarkOpacity)

                // Title
                Text(title)
                    .font(.system(size: 28, weight: .bold))
                    .foregroundColor(AppColors.textPrimary)

                // Subtitle
                Text(subtitle)
                    .font(.system(size: 16, weight: .regular))
                    .foregroundColor(AppColors.textSecondary)
                    .multilineTextAlignment(.center)
                    .lineSpacing(4)
                    .padding(.horizontal, AppSpacing.lg)

                // Lesson info badge
                lessonInfoBadge

                // CTA Button
                Button(action: {
                    onCTATapped?()
                }) {
                    Text(ctaButtonTitle)
                        .font(.system(size: 17, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                        .frame(maxWidth: .infinity)
                        .frame(height: 52)
                        .background(AppColors.primaryBlue)
                        .cornerRadius(26)
                }
                .padding(.top, AppSpacing.md)

                // Close button
                Button(action: {
                    onCloseTapped?()
                }) {
                    Text("Close")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                }
                .padding(.top, AppSpacing.sm)
            }
            .padding(AppSpacing.xxl)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.extraLarge)
                    .fill(AppColors.cardBackground)
            )
            .padding(.horizontal, AppSpacing.xl)
            .opacity(cardOpacity)
            .offset(y: cardOffset)

            Spacer()
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .onAppear {
            animateAppearance()
        }
    }

    // MARK: - Subviews

    private var checkmarkView: some View {
        ZStack {
            // Outer ring
            Circle()
                .stroke(AppColors.bullish, lineWidth: 4)
                .frame(width: 80, height: 80)

            // Filled circle
            Circle()
                .fill(AppColors.bullish)
                .frame(width: 70, height: 70)

            // Checkmark icon
            Image(systemName: "checkmark")
                .font(.system(size: 36, weight: .bold))
                .foregroundColor(AppColors.textPrimary)
        }
    }

    private var lessonInfoBadge: some View {
        HStack(spacing: AppSpacing.sm) {
            // Blue dot
            Circle()
                .fill(AppColors.primaryBlue)
                .frame(width: 8, height: 8)

            Text("Lesson \(lessonNumber) of \(totalLessons)")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(AppColors.textSecondary)

            // Separator dot
            Circle()
                .fill(AppColors.textMuted)
                .frame(width: 4, height: 4)

            // Clock icon and duration
            HStack(spacing: 4) {
                Image(systemName: "clock")
                    .font(.system(size: 12))
                    .foregroundColor(AppColors.textMuted)

                Text("\(estimatedMinutes) min")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(AppColors.textSecondary)
            }
        }
    }

    // MARK: - Animations

    private func animateAppearance() {
        withAnimation(.spring(response: 0.5, dampingFraction: 0.7).delay(0.1)) {
            cardOpacity = 1
            cardOffset = 0
        }

        withAnimation(.spring(response: 0.6, dampingFraction: 0.6).delay(0.3)) {
            checkmarkScale = 1.0
            checkmarkOpacity = 1.0
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        LessonCompletionCard(
            title: "You're ready.",
            subtitle: "You've learned the core idea. Practice with a real stock to reinforce it.",
            lessonNumber: 1,
            totalLessons: 5,
            estimatedMinutes: 2,
            ctaButtonTitle: "Analyze a Stock"
        )
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/LessonContentCard.swift
================================================================================

//
//  LessonContentCard.swift
//  ios
//
//  Molecule: Content card for lesson story - displays optional image and highlighted text content
//  Supports AI voice reading with word-by-word highlighting
//

import SwiftUI

struct LessonContentCard: View {
    let imageName: String?
    let contentSegments: [HighlightedTextSegment]
    let currentWordRange: NSRange
    let isReading: Bool

    // Computed full content text for reading
    var contentText: String {
        contentSegments.map { $0.text }.joined()
    }

    var body: some View {
        VStack(spacing: AppSpacing.xxxl) {
            Spacer()
                .frame(height: 40)

            // Image placeholder or actual image
            imageSection

            Spacer()
                .frame(height: AppSpacing.xl)

            // Content text with reading highlight
            ReadingHighlightSegmentedText(
                segments: contentSegments,
                currentWordRange: currentWordRange,
                isReading: isReading,
                font: .system(size: 20, weight: .regular)
            )
            .multilineTextAlignment(.leading)
            .padding(.horizontal, AppSpacing.xxl)

            Spacer()
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    @ViewBuilder
    private var imageSection: some View {
        if let imageName = imageName, !imageName.isEmpty {
            // Actual image from assets
            Image(imageName)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(maxWidth: .infinity)
                .frame(height: 200)
                .padding(.horizontal, AppSpacing.xxl)
        } else {
            // Placeholder text for image
            Text("An image here")
                .font(.system(size: 32, weight: .regular))
                .foregroundColor(AppColors.textPrimary)
                .frame(maxWidth: .infinity)
                .frame(height: 150)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        LessonContentCard(
            imageName: nil,
            contentSegments: [
                HighlightedTextSegment("Price is what the "),
                HighlightedTextSegment("market", highlighted: true),
                HighlightedTextSegment(" asks. Value is what the business is worth. The gap between them is where investing opportunities are found.")
            ],
            currentWordRange: NSRange(location: 18, length: 6), // "market"
            isReading: true
        )
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/LessonTitleCard.swift
================================================================================

//
//  LessonTitleCard.swift
//  ios
//
//  Molecule: Title card for lesson story - displays main title and highlighted subtitle
//  Supports AI voice reading with word-by-word highlighting
//

import SwiftUI

struct LessonTitleCard: View {
    let title: String
    let subtitleSegments: [HighlightedTextSegment]
    let currentWordRange: NSRange
    let isReading: Bool

    // Computed full subtitle text for reading
    var subtitleText: String {
        subtitleSegments.map { $0.text }.joined()
    }

    var body: some View {
        VStack(spacing: AppSpacing.xl) {
            Spacer()
                .frame(height: 60)

            // Main title
            Text(title)
                .font(.system(size: 42, weight: .bold))
                .foregroundColor(AppColors.textPrimary)
                .multilineTextAlignment(.center)
                .lineSpacing(4)
                .padding(.horizontal, AppSpacing.xl)

            // Subtitle with reading highlight
            ReadingHighlightSegmentedText(
                segments: subtitleSegments,
                currentWordRange: currentWordRange,
                isReading: isReading,
                font: .system(size: 20, weight: .regular)
            )
            .multilineTextAlignment(.center)
            .padding(.horizontal, AppSpacing.xxl)

            Spacer()
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        LessonTitleCard(
            title: "Buying Dollar Bills for 50 Cents",
            subtitleSegments: [
                HighlightedTextSegment("Why", highlighted: true),
                HighlightedTextSegment(" Warren Buffett never pays retail price.")
            ],
            currentWordRange: NSRange(location: 4, length: 6), // "Warren"
            isReading: true
        )
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/LevelSectionHeader.swift
================================================================================

//
//  LevelSectionHeader.swift
//  ios
//
//  Molecule: Header for a level section with icon, title, and progress
//

import SwiftUI

struct LevelSectionHeader: View {
    let level: JourneyLevel
    let completed: Int
    let total: Int

    private var progress: Double {
        guard total > 0 else { return 0 }
        return Double(completed) / Double(total)
    }

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Level icon
            Text(level.iconName)
                .font(.system(size: 18))

            // Title and tagline
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text("Level \(level.rawValue): \(level.title)")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                Text(level.tagline)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            Spacer()
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        LevelSectionHeader(level: .foundation, completed: 1, total: 7)
        LevelSectionHeader(level: .analysis, completed: 0, total: 7)
        LevelSectionHeader(level: .strategies, completed: 3, total: 7)
        LevelSectionHeader(level: .mastery, completed: 6, total: 6)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/LibraryBookCard.swift
================================================================================

//
//  LibraryBookCard.swift
//  ios
//
//  Molecule: Card showing a library book with mastered/unread states
//

import SwiftUI

struct LibraryBookCard: View {
    let book: LibraryBook
    var onChatWithBook: (() -> Void)?
    var onReadKeyIdeas: (() -> Void)?
    var onReview: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            HStack(alignment: .top, spacing: AppSpacing.lg) {
                // Book cover with optional mastered badge
                ZStack(alignment: .topTrailing) {
                    // Book cover
                    ZStack {
                        RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                            .fill(bookCoverGradient)
                            .frame(width: 80, height: 110)

                        // Book title overlay
                        VStack {
                            Text(book.title.uppercased())
                                .font(.system(size: 8, weight: .bold))
                                .foregroundColor(.white)
                                .multilineTextAlignment(.center)
                                .lineLimit(3)
                                .padding(.horizontal, AppSpacing.xs)
                        }
                        .frame(width: 80, height: 110)
                    }

                    // Mastered checkmark badge
                    if book.isMastered {
                        ZStack {
                            Circle()
                                .fill(Color(hex: "14A349"))
                                .frame(width: 24, height: 24)
                                

                            Image(systemName: "checkmark")
                                .font(.system(size: 12, weight: .bold))
                                .foregroundColor(.white)
                        }
                        .offset(x: 6, y: -6)
                    }
                }

                // Book details
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    // Curriculum order badge
                    Text("BOOK \(book.curriculumOrder)")
                        .font(AppTypography.captionBold)
                        .foregroundColor(AppColors.primaryBlue)
                        .tracking(0.5)

                    // Title and rating
                    HStack(alignment: .top) {
                        Text(book.title)
                            .font(AppTypography.headline)
                            .foregroundColor(AppColors.textPrimary)
                            .lineLimit(2)

                        Spacer()

                        // Rating
                        HStack(spacing: AppSpacing.xxs) {
                            Image(systemName: "star.fill")
                                .font(.system(size: 12))
                                .foregroundColor(AppColors.neutral)

                            Text(book.formattedRating)
                                .font(AppTypography.footnoteBold)
                                .foregroundColor(AppColors.textPrimary)
                        }
                        .padding(.horizontal, AppSpacing.sm)
                        .padding(.vertical, AppSpacing.xs)
                        .background(AppColors.cardBackgroundLight)
                        .cornerRadius(AppCornerRadius.small)
                    }

                    // Author
                    Text(book.author)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)

                    // Description
                    Text(book.description)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(2)

                    // Meta info
                    HStack(spacing: AppSpacing.md) {
                        Text(book.formattedKeyIdeas)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)

                        Text("â€¢")
                            .foregroundColor(AppColors.textMuted)

                        Text(book.formattedPages)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                    }
                }
            }

            // Action buttons
            HStack(spacing: AppSpacing.md) {
                Button(action: {
                    onChatWithBook?()
                }) {
                    HStack(spacing: AppSpacing.sm) {
                        Image(systemName: "bubble.left.fill")
                            .font(.system(size: 12))

                        Text("Chat with Book")
                            .font(AppTypography.calloutBold)
                    }
                    .foregroundColor(AppColors.textPrimary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, AppSpacing.md)
                    .background(AppColors.cardBackgroundLight)
                    .cornerRadius(AppCornerRadius.medium)
                }
                .buttonStyle(PlainButtonStyle())

                // Dynamic button based on mastered state
                if book.isMastered {
                    Button(action: {
                        onReview?()
                    }) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "checkmark.circle.fill")
                                .font(.system(size: 12))

                            Text("Review")
                                .font(AppTypography.calloutBold)
                        }
                        .foregroundColor(AppColors.bullish)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, AppSpacing.md)
                        .background(AppColors.bullish.opacity(0.15))
                        .cornerRadius(AppCornerRadius.medium)
                    }
                    .buttonStyle(PlainButtonStyle())
                } else {
                    Button(action: {
                        onReadKeyIdeas?()
                    }) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "lightbulb.fill")
                                .font(.system(size: 12))

                            Text("Read Key Ideas")
                                .font(AppTypography.calloutBold)
                        }
                        .foregroundColor(AppColors.primaryBlue)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, AppSpacing.md)
                        .background(AppColors.primaryBlue.opacity(0.15))
                        .cornerRadius(AppCornerRadius.medium)
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.extraLarge)
    }

    private var bookCoverGradient: LinearGradient {
        LinearGradient(
            colors: [
                Color(hex: book.coverGradientStart),
                Color(hex: book.coverGradientEnd)
            ],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.lg) {
            // Mastered book
            LibraryBookCard(book: LibraryBook.sampleData[0])
            // Unread book
            LibraryBookCard(book: LibraryBook.sampleData[2])
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/LiveNewsHeader.swift
================================================================================

//
//  LiveNewsHeader.swift
//  ios
//
//  Molecule: Static header for Live News section (non-scrolling)
//

import SwiftUI

struct LiveNewsHeader: View {
    var onFilterTapped: (() -> Void)?

    var body: some View {
        HStack(alignment: .center) {
            HStack(spacing: AppSpacing.sm) {
                LiveIndicator()
                    .alignmentGuide(VerticalAlignment.center) { d in d[VerticalAlignment.center] }

                Text("Live News")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)
            }

            Spacer()

            Button(action: { onFilterTapped?() }) {
                HStack(spacing: AppSpacing.xs) {
                    Image(systemName: "line.3.horizontal.decrease")
                        .font(.system(size: 12, weight: .medium))

                    Text("All")
                        .font(AppTypography.callout)
                }
                .foregroundColor(AppColors.textSecondary)
            }
            .buttonStyle(PlainButtonStyle())
        }
        .frame(height: 44) // Fixed height to prevent layout shifts
        .padding(.horizontal, AppSpacing.lg)
        .background(AppColors.background)
    }
}

#Preview {
    VStack {
        LiveNewsHeader()
        Spacer()
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ManageAssetsButton.swift
================================================================================

//
//  ManageAssetsButton.swift
//  ios
//
//  Molecule: Button to manage watchlist assets
//

import SwiftUI

struct ManageAssetsButton: View {
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            Image(systemName: "slider.horizontal.3")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(AppColors.textSecondary)
                .frame(width: 36, height: 36)
                .background(AppColors.cardBackgroundLight)
                .clipShape(Circle())
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ManageAssetsButton(action: {})
        .padding()
        .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/MarketMoodMeter.swift
================================================================================

//
//  MarketMoodMeter.swift
//  ios
//
//  Market Mood Meter with gauge and timeframe toggle
//

import SwiftUI

struct MarketMoodMeter: View {
    let sentimentData: SentimentAnalysisData
    @Binding var selectedTimeframe: SentimentTimeframe

    private var currentMood: MarketMoodLevel {
        selectedTimeframe == .last24h ? sentimentData.last24hMood : sentimentData.last7dMood
    }

    private var gaugeValue: Double {
        Double(sentimentData.moodScore) / 100.0
    }

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Header
            VStack(spacing: AppSpacing.xs) {
                Text("Market Mood Meter")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text("Real-time sentiment tracking")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }

            // Timeframe toggle
            SentimentTimeframeToggleView(selectedTimeframe: $selectedTimeframe)

            // Gauge
            SemiCircleGauge(
                value: gaugeValue,
                displayValue: "\(sentimentData.moodScore)",
                label: currentMood.rawValue,
                labelColor: currentMood.color,
                gaugeType: .sentiment,
                showLabels: true,
                size: 180
            )
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        MarketMoodMeter(
            sentimentData: SentimentAnalysisData.sampleData,
            selectedTimeframe: .constant(.last24h)
        )
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/MomentumBarChart.swift
================================================================================

//
//  MomentumBarChart.swift
//  ios
//
//  Bar chart showing analyst momentum over time
//

import SwiftUI

struct MomentumBarChart: View {
    let data: [AnalystMomentumMonth]
    let maxValue: Int

    init(data: [AnalystMomentumMonth]) {
        self.data = data
        // Calculate max for scaling (considering both positive and negative)
        let maxPositive = data.map { $0.positiveCount }.max() ?? 10
        let maxNegative = data.map { $0.negativeCount }.max() ?? 10
        self.maxValue = max(maxPositive, maxNegative, 1)
    }

    var body: some View {
        VStack(spacing: AppSpacing.sm) {
            // Y-axis labels and chart
            HStack(alignment: .bottom, spacing: AppSpacing.sm) {
                // Y-axis labels
                VStack {
                    Text("10")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                    Spacer()
                    Text("0")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                    Spacer()
                    Text("-5")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                    Spacer()
                    Text("-10")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }
                .frame(width: 24)
                .frame(height: 140)

                // Bars container
                VStack(spacing: 0) {
                    HStack(alignment: .center, spacing: 0) {
                        ForEach(data) { month in
                            MomentumBar(month: month, maxValue: maxValue)
                                .frame(maxWidth: .infinity)
                        }
                    }
                    .frame(height: 140)
                }
            }

            // X-axis labels (months)
            HStack(spacing: 0) {
                Spacer()
                    .frame(width: 24 + AppSpacing.sm)
                ForEach(data) { month in
                    Text(month.month)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .frame(maxWidth: .infinity)
                }
            }
        }
    }
}

// MARK: - Single Momentum Bar
struct MomentumBar: View {
    let month: AnalystMomentumMonth
    let maxValue: Int

    private let chartHeight: CGFloat = 140

    var body: some View {
        GeometryReader { geometry in
            let midY = geometry.size.height / 2
            let scale = (geometry.size.height / 2) / CGFloat(max(maxValue, 1))
            let barWidth: CGFloat = 24

            ZStack {
                // Zero line (implicit - bars grow from center)

                // Positive bar (grows up from center)
                if month.positiveCount > 0 {
                    RoundedRectangle(cornerRadius: 3)
                        .fill(AppColors.bullish)
                        .frame(
                            width: barWidth,
                            height: CGFloat(month.positiveCount) * scale
                        )
                        .position(
                            x: geometry.size.width / 2,
                            y: midY - (CGFloat(month.positiveCount) * scale / 2)
                        )
                }

                // Negative bar (grows down from center)
                if month.negativeCount > 0 {
                    RoundedRectangle(cornerRadius: 3)
                        .fill(AppColors.bearish)
                        .frame(
                            width: barWidth,
                            height: CGFloat(month.negativeCount) * scale
                        )
                        .position(
                            x: geometry.size.width / 2,
                            y: midY + (CGFloat(month.negativeCount) * scale / 2)
                        )
                }
            }
        }
        .frame(height: chartHeight)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        MomentumBarChart(data: AnalystMomentumMonth.sampleData)
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/MoneyMoveCard.swift
================================================================================

//
//  MoneyMoveCard.swift
//  ios
//
//  Molecule: Card showing a money move with bookmark functionality
//

import SwiftUI

struct MoneyMoveCard: View {
    let moneyMove: MoneyMove
    var showIcon: Bool = true
    var onTap: (() -> Void)?
    var onBookmark: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            VStack(alignment: .leading, spacing: AppSpacing.md) {
                // Header with optional icon and bookmark
                HStack(alignment: .top) {
                    // Icon (conditional)
                    if showIcon {
                        ZStack {
                            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                                .fill(moneyMove.iconBackgroundColor)
                                .frame(width: 40, height: 40)

                            Image(systemName: moneyMove.iconName)
                                .font(.system(size: 18, weight: .semibold))
                                .foregroundColor(.white)
                        }
                    }

                    Spacer()

                    // Bookmark button
                    BookmarkButton(isBookmarked: moneyMove.isBookmarked) {
                        onBookmark?()
                    }
                }

                // Title
                Text(moneyMove.title)
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(3)
                    .multilineTextAlignment(.leading)

                // Subtitle
                Text(moneyMove.subtitle)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .lineLimit(3)
                    .multilineTextAlignment(.leading)

                Spacer(minLength: 0)

                // Meta info
                HStack(spacing: AppSpacing.lg) {
                    ReadTimeLabel(minutes: moneyMove.estimatedMinutes)
                    LearnerCountBadge(count: moneyMove.learnerCount)
                }
            }
            .padding(AppSpacing.lg)
            .frame(width: 200)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.extraLarge)
            .contentShape(RoundedRectangle(cornerRadius: AppCornerRadius.extraLarge))
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    ScrollView(.horizontal, showsIndicators: false) {
        HStack(spacing: AppSpacing.lg) {
            ForEach(MoneyMove.sampleData) { moneyMove in
                MoneyMoveCard(moneyMove: moneyMove)
            }
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/NewsDetailHeader.swift
================================================================================

//
//  NewsDetailHeader.swift
//  ios
//
//  Molecule: Header bar for news detail screen with back button and source
//

import SwiftUI

struct NewsDetailHeader: View {
    let source: NewsSource
    var onBackTapped: (() -> Void)?
    var onMoreTapped: (() -> Void)?

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Back Button
            Button(action: {
                onBackTapped?()
            }) {
                Image(systemName: "chevron.left")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(AppColors.textPrimary)
                    .frame(width: 32, height: 32)
                    .contentShape(Rectangle())
            }
            .buttonStyle(PlainButtonStyle())

            // Source Icon and Name
            HStack(spacing: AppSpacing.sm) {
                NewsSourceBrandIcon(source: source, size: 28, cornerRadius: 6)

                Text(source.name)
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            Spacer()

            // More Options Button
            Button(action: {
                onMoreTapped?()
            }) {
                Image(systemName: "ellipsis")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(AppColors.textPrimary)
                    .frame(width: 32, height: 32)
                    .contentShape(Rectangle())
            }
            .buttonStyle(PlainButtonStyle())
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
    }
}

#Preview {
    VStack {
        NewsDetailHeader(
            source: NewsSource(name: "CNBC", iconName: nil),
            onBackTapped: { print("Back tapped") },
            onMoreTapped: { print("More tapped") }
        )

        Divider()
            .background(AppColors.cardBackgroundLight)

        NewsDetailHeader(
            source: NewsSource(name: "Reuters", iconName: nil)
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/NewsDetailHeroImage.swift
================================================================================

//
//  NewsDetailHeroImage.swift
//  ios
//
//  Molecule: Full-width hero image for news article
//

import SwiftUI

struct NewsDetailHeroImage: View {
    let imageName: String?
    var height: CGFloat = 220
    var cornerRadius: CGFloat = AppCornerRadius.large

    var body: some View {
        Group {
            if let imageName = imageName {
                // Try to load custom image first, fall back to placeholder
                Image(imageName)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .frame(height: height)
                    .frame(maxWidth: .infinity)
                    .clipped()
                    .cornerRadius(cornerRadius)
            } else {
                // Placeholder with gradient
                placeholderView
            }
        }
    }

    private var placeholderView: some View {
        ZStack {
            // Gradient background
            LinearGradient(
                gradient: Gradient(colors: [
                    AppColors.cardBackgroundLight,
                    AppColors.cardBackground
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )

            // Pattern overlay for visual interest
            GeometryReader { geometry in
                Path { path in
                    let width = geometry.size.width
                    let height = geometry.size.height
                    let spacing: CGFloat = 30

                    // Draw diagonal lines pattern
                    var x: CGFloat = -height
                    while x < width + height {
                        path.move(to: CGPoint(x: x, y: height))
                        path.addLine(to: CGPoint(x: x + height, y: 0))
                        x += spacing
                    }
                }
                .stroke(AppColors.textMuted.opacity(0.1), lineWidth: 1)
            }

            // Center icon
            VStack(spacing: AppSpacing.sm) {
                Image(systemName: "photo.fill")
                    .font(.system(size: 40, weight: .light))
                    .foregroundColor(AppColors.textMuted.opacity(0.5))

                Text("Image unavailable")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .frame(height: height)
        .frame(maxWidth: .infinity)
        .cornerRadius(cornerRadius)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        NewsDetailHeroImage(imageName: "news_nvidia_hero")

        NewsDetailHeroImage(imageName: nil)

        NewsDetailHeroImage(imageName: nil, height: 160)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/NewsDetailMetaRow.swift
================================================================================

//
//  NewsDetailMetaRow.swift
//  ios
//
//  Molecule: Meta information row showing date, read time, and sentiment
//

import SwiftUI

struct NewsDetailMetaRow: View {
    let date: String
    let readTimeMinutes: Int
    let sentiment: NewsSentiment

    var body: some View {
        HStack(spacing: AppSpacing.lg) {
            // Calendar Icon and Date
            HStack(spacing: AppSpacing.xs) {
                Image(systemName: "calendar")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(AppColors.textSecondary)

                Text(date)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textSecondary)
            }

            // Read Time
            HStack(spacing: AppSpacing.xs) {
                Image(systemName: "clock")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(AppColors.textSecondary)

                Text("\(readTimeMinutes) min read")
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textSecondary)
            }

            Spacer()

            // Sentiment Badge
            NewsSentimentBadge(sentiment: sentiment)
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        NewsDetailMetaRow(
            date: "Dec 15, 2024",
            readTimeMinutes: 4,
            sentiment: .negative
        )

        NewsDetailMetaRow(
            date: "Dec 14, 2024",
            readTimeMinutes: 6,
            sentiment: .positive
        )

        NewsDetailMetaRow(
            date: "Dec 13, 2024",
            readTimeMinutes: 3,
            sentiment: .neutral
        )
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/NewsSectionHeader.swift
================================================================================

//
//  NewsSectionHeader.swift
//  ios
//
//  Molecule: Sticky section header for news date groups
//

import SwiftUI

struct NewsSectionHeader: View {
    let title: String

    var body: some View {
        HStack {
            Text(title)
                .font(AppTypography.footnoteBold)
                .foregroundColor(AppColors.primaryBlue)

            Spacer()
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.sm)
        .background(AppColors.background)
    }
}

#Preview {
    VStack(spacing: 0) {
        NewsSectionHeader(title: "TODAY")
        NewsSectionHeader(title: "YESTERDAY")
        NewsSectionHeader(title: "Dec 28, 2025")
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/NewsThumbnail.swift
================================================================================

//
//  NewsThumbnail.swift
//  ios
//
//  Molecule: Thumbnail image for news articles
//

import SwiftUI

struct NewsThumbnail: View {
    let imageName: String?
    var width: CGFloat = 100
    var height: CGFloat = 70

    var body: some View {
        Group {
            if let name = imageName {
                Image(name)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .frame(width: width, height: height)
                    .clipped()
            } else {
                // Placeholder
                ZStack {
                    AppColors.cardBackgroundLight

                    Image(systemName: "photo")
                        .font(.system(size: 24))
                        .foregroundColor(AppColors.textMuted)
                }
                .frame(width: width, height: height)
            }
        }
        .cornerRadius(AppCornerRadius.medium)
    }
}

#Preview {
    VStack(spacing: 20) {
        NewsThumbnail(imageName: nil)
        NewsThumbnail(imageName: "news_placeholder", width: 120, height: 80)
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/NewsTimelineItem.swift
================================================================================

//
//  NewsTimelineItem.swift
//  ios
//
//  Molecule: Individual news item in the timeline feed
//

import SwiftUI

struct NewsTimelineItem: View {
    let article: NewsArticle
    var onTapped: (() -> Void)?

    var body: some View {
        Button(action: { onTapped?() }) {
            HStack(alignment: .top, spacing: AppSpacing.md) {
                // Content
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    // Headline
                    Text(article.headline)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(3)
                        .multilineTextAlignment(.leading)
                        .fixedSize(horizontal: false, vertical: true)

                    // Footer: Source and Sentiment
                    HStack(spacing: AppSpacing.md) {
                        SourceLabel(source: article.source)

                        NewsSentimentBadge(sentiment: article.sentiment)
                    }
                }

                Spacer()

                // Thumbnail
                NewsThumbnail(imageName: article.thumbnailName)
            }
            .padding(AppSpacing.md)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.medium)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack(spacing: 16) {
        NewsTimelineItem(
            article: NewsArticle(
                headline: "Oil prices stabilize as OPEC + members agreed to maintain current production levels.",
                summary: nil,
                source: NewsSource(name: "Reuters", iconName: nil),
                sentiment: .neutral,
                publishedAt: Date(),
                thumbnailName: nil,
                relatedTickers: ["XOM"]
            )
        )

        NewsTimelineItem(
            article: NewsArticle(
                headline: "NVIDIA Announces Record Q4 Earnings, Missed Expectations and CEO step down",
                summary: nil,
                source: NewsSource(name: "CNBC", iconName: nil),
                sentiment: .negative,
                publishedAt: Date(),
                thumbnailName: nil,
                relatedTickers: ["NVDA"]
            )
        )
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/NextEarningsDateCard.swift
================================================================================

//
//  NextEarningsDateCard.swift
//  ios
//
//  Molecule: Card displaying the next earnings date with calendar icon
//

import SwiftUI

struct NextEarningsDateCard: View {
    let nextEarningsDate: NextEarningsDate

    var body: some View {
        HStack(spacing: AppSpacing.lg) {
            // Calendar icon
            calendarIcon

            // Date info
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text("Next Earnings Date")
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                HStack(spacing: AppSpacing.xs) {
                    Text(nextEarningsDate.formattedDate)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)

                    Text("(\(nextEarningsDate.statusText))")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textMuted)
                }

                Text(nextEarningsDate.timing.rawValue)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.primaryBlue)
            }

            Spacer()
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackgroundLight)
        .cornerRadius(AppCornerRadius.medium)
        .overlay(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .stroke(AppColors.cardBackgroundLight.opacity(0.5), lineWidth: 1)
        )
    }

    // MARK: - Calendar Icon
    private var calendarIcon: some View {
        ZStack {
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.primaryBlue.opacity(0.2))
                .frame(width: 48, height: 48)

            Image(systemName: "calendar")
                .font(.system(size: 22, weight: .medium))
                .foregroundColor(AppColors.primaryBlue)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.lg) {
            NextEarningsDateCard(nextEarningsDate: .sample)

            // Confirmed version
            NextEarningsDateCard(
                nextEarningsDate: NextEarningsDate(
                    date: Date(),
                    isConfirmed: true,
                    timing: .beforeMarketOpen
                )
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/NextLessonCard.swift
================================================================================

//
//  NextLessonCard.swift
//  ios
//
//  Molecule: Card showing the next lesson preview
//

import SwiftUI

struct NextLessonCard: View {
    let lesson: NextLesson
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.lg) {
                // Left side - content
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    // Badge
                    HStack(spacing: AppSpacing.xs) {
                        Text("Next Up")
                            .font(AppTypography.captionBold)
                            .foregroundColor(AppColors.primaryBlue)

                        Text("Journey \(lesson.journeyNumber): \(lesson.journeyTitle)")
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)
                    }

                    // Title
                    Text(lesson.lessonTitle)
                        .font(AppTypography.headline)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)

                    // Description
                    Text(lesson.lessonDescription)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)

                    // Meta info
                    HStack(spacing: AppSpacing.lg) {
                        ReadTimeLabel(minutes: lesson.estimatedMinutes)
                        ChapterCountBadge(count: lesson.chapterCount)
                    }
                }

                Spacer()

                // Right side - arrow
                Image(systemName: "chevron.right")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(AppColors.textMuted)
            }
            .padding(AppSpacing.lg)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.extraLarge)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    NextLessonCard(lesson: NextLesson.sampleData)
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/PerformanceItem.swift
================================================================================

//
//  PerformanceItem.swift
//  ios
//
//  Molecule: Individual performance period display with label and percentage
//

import SwiftUI

struct PerformanceItem: View {
    let period: PerformancePeriod

    private var color: Color {
        period.isPositive ? AppColors.bullish : AppColors.bearish
    }

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xs) {
            // Period label
            Text(period.label)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            // Percentage change
            Text(period.formattedChange)
                .font(AppTypography.calloutBold)
                .foregroundColor(color)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(.vertical, AppSpacing.sm)
        .padding(.horizontal, AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.small)
                .fill(color.opacity(0.1))
        )
    }
}

#Preview {
    LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: AppSpacing.sm), count: 3), spacing: AppSpacing.sm) {
        PerformanceItem(period: PerformancePeriod(label: "1 Month", changePercent: 8.42))
        PerformanceItem(period: PerformancePeriod(label: "3 Months", changePercent: -3.15))
        PerformanceItem(period: PerformancePeriod(label: "6 Months", changePercent: 18.67))
        PerformanceItem(period: PerformancePeriod(label: "YTD", changePercent: 42.89))
        PerformanceItem(period: PerformancePeriod(label: "1 Year", changePercent: 38.24))
        PerformanceItem(period: PerformancePeriod(label: "5 Years", changePercent: 287.45))
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/PersonaCard.swift
================================================================================

//
//  PersonaCard.swift
//  ios
//
//  Molecule: Persona selection card with icon, name, and tagline
//

import SwiftUI

struct PersonaCard: View {
    let persona: AnalysisPersona
    var isSelected: Bool = false
    var onTap: (() -> Void)?

    // Fixed card dimensions for consistent sizing
    private let cardWidth: CGFloat = 100
    private let cardHeight: CGFloat = 150

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            VStack(spacing: AppSpacing.sm) {
                // Persona Icon
                PersonaIcon(
                    persona: persona,
                    size: 48,
                    isSelected: isSelected
                )

                // Name (split into two lines)
                VStack(spacing: 0) {
                    Text(persona.rawValue.components(separatedBy: " ").first ?? "")
                        .font(AppTypography.footnote)
                        .fontWeight(.semibold)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(1)

                    Text(persona.rawValue.components(separatedBy: " ").last ?? "")
                        .font(AppTypography.footnote)
                        .fontWeight(.semibold)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(1)
                }

                // Tagline - fixed height area
                Text(persona.tagline)
                    .font(AppTypography.caption)
                    .foregroundColor(persona.accentColor)
                    .multilineTextAlignment(.center)
                    .lineLimit(2)
                    .frame(height: 28) // Fixed height for tagline

                Spacer(minLength: 0)

                // Selection indicator
                Group {
                    if isSelected {
                        HStack(spacing: AppSpacing.xs) {
                            Image(systemName: "checkmark.circle.fill")
                                .font(.system(size: 10))
                            Text("Selected")
                                .font(AppTypography.caption)
                        }
                        .foregroundColor(AppColors.primaryBlue)
                    } else {
                        Text("Tap to select")
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                    }
                }
            }
            .frame(width: cardWidth, height: cardHeight)
            .padding(.vertical, AppSpacing.md)
            .padding(.horizontal, AppSpacing.sm)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.large)
                    .fill(isSelected ? persona.accentColor.opacity(0.15) : AppColors.cardBackground)
                    .overlay(
                        RoundedRectangle(cornerRadius: AppCornerRadius.large)
                            .stroke(
                                isSelected ? persona.accentColor : Color.clear,
                                lineWidth: 2
                            )
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ScrollView(.horizontal, showsIndicators: false) {
        HStack(spacing: AppSpacing.md) {
            ForEach(AnalysisPersona.allCases) { persona in
                PersonaCard(
                    persona: persona,
                    isSelected: persona == .warrenBuffett
                )
            }
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/PriceActionSparkline.swift
================================================================================

//
//  PriceActionSparkline.swift
//  ios
//
//  Molecule: Lightweight sparkline (Path) with gradient fill and an optional
//  event dot marking when a catalyst occurred.
//

import SwiftUI

struct PriceActionSparkline: View {
    let data: [Double]
    let eventIndex: Int?
    let trendColor: Color

    var body: some View {
        GeometryReader { geo in
            let w = geo.size.width
            let h = geo.size.height
            let minVal = data.min() ?? 0
            let maxVal = data.max() ?? 1
            let range = max(maxVal - minVal, 0.01)

            // Gradient fill under the line
            sparklineFill(w: w, h: h, minVal: minVal, range: range)

            // Line stroke
            sparklinePath(w: w, h: h, minVal: minVal, range: range)
                .stroke(trendColor, style: StrokeStyle(lineWidth: 2, lineCap: .round, lineJoin: .round))

            // Event dot
            if let idx = eventIndex, idx >= 0, idx < data.count {
                let pos = point(for: idx, w: w, h: h, minVal: minVal, range: range)
                Circle()
                    .fill(Color.white)
                    .frame(width: 8, height: 8)
                    .shadow(color: trendColor.opacity(0.8), radius: 6)
                    .position(x: pos.x, y: pos.y)
            }
        }
        .frame(height: 60)
    }

    // MARK: - Helpers

    private func sparklinePath(w: CGFloat, h: CGFloat, minVal: Double, range: Double) -> Path {
        Path { path in
            for (i, _) in data.enumerated() {
                let pt = point(for: i, w: w, h: h, minVal: minVal, range: range)
                if i == 0 { path.move(to: pt) }
                else { path.addLine(to: pt) }
            }
        }
    }

    private func sparklineFill(w: CGFloat, h: CGFloat, minVal: Double, range: Double) -> some View {
        Path { path in
            for (i, _) in data.enumerated() {
                let pt = point(for: i, w: w, h: h, minVal: minVal, range: range)
                if i == 0 { path.move(to: pt) }
                else { path.addLine(to: pt) }
            }
            // Close to bottom-right â†’ bottom-left
            path.addLine(to: CGPoint(x: w, y: h))
            path.addLine(to: CGPoint(x: 0, y: h))
            path.closeSubpath()
        }
        .fill(
            LinearGradient(
                colors: [trendColor.opacity(0.25), trendColor.opacity(0.0)],
                startPoint: .top,
                endPoint: .bottom
            )
        )
    }

    private func point(for index: Int, w: CGFloat, h: CGFloat, minVal: Double, range: Double) -> CGPoint {
        let x = w * CGFloat(index) / CGFloat(max(data.count - 1, 1))
        let y = h - (h * CGFloat((data[index] - minVal) / range))
        return CGPoint(x: x, y: y)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        // Event-driven decline
        PriceActionSparkline(
            data: [163.2, 162.8, 164.1, 159.2, 155.3, 150.1, 148.6, 145.2, 143.8, 142.8],
            eventIndex: 2,
            trendColor: AppColors.bearish
        )

        // Rally, no event
        PriceActionSparkline(
            data: [100, 102, 105, 108, 112, 118, 122],
            eventIndex: nil,
            trendColor: AppColors.bullish
        )
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/PriceTargetRange.swift
================================================================================

//
//  PriceTargetRange.swift
//  ios
//
//  Price target range bar with current price indicator
//

import SwiftUI

struct PriceTargetRange: View {
    let priceTarget: AnalystPriceTarget

    var body: some View {
        VStack(spacing: AppSpacing.md) {
            // Labels row
            HStack {
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text("Low")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                    Text(priceTarget.formattedLow)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.bearish)
                }

                Spacer()

                VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                    Text("High")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                    Text(priceTarget.formattedHigh)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.bullish)
                }
            }

            // Price range bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Gradient background bar
                    LinearGradient(
                        colors: [AppColors.bearish, AppColors.neutral, AppColors.bullish],
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                    .frame(height: 8)
                    .cornerRadius(4)

                    // Current price indicator
                    let position = priceTarget.currentPricePosition
                    let indicatorX = geometry.size.width * position

                    VStack(spacing: AppSpacing.xxs) {
                        // Current price label
                        Text("Current: \(priceTarget.formattedCurrent)")
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)
                            .offset(x: clampedOffset(for: indicatorX, in: geometry.size.width, labelWidth: 90))

                        // Triangle indicator
                        Triangle()
                            .fill(AppColors.textPrimary)
                            .frame(width: 10, height: 6)
                            .offset(y: -2)
                    }
                    .position(x: indicatorX, y: -12)
                    
                    // Average price indicator
                    let averagePosition = priceTarget.averagePricePosition
                    let averageX = geometry.size.width * averagePosition

                    VStack(spacing: AppSpacing.xxs) {
                        // Triangle indicator (pointing down)
                        Triangle()
                            .fill(AppColors.textMuted)
                            .frame(width: 10, height: 6)
                            .rotationEffect(.degrees(180))
                            .offset(y: 2)
                        
                        // Average price label
                        Text("Average: \(priceTarget.formattedAverage)")
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                            .offset(x: clampedOffset(for: averageX, in: geometry.size.width, labelWidth: 90))
                    }
                    .position(x: averageX, y: 20)
                }
            }
            .frame(height: 8)
            .padding(.top, AppSpacing.xxl)
            .padding(.bottom, AppSpacing.lg)
        }
    }

    private func clampedOffset(for x: CGFloat, in width: CGFloat, labelWidth: CGFloat) -> CGFloat {
        let halfLabel = labelWidth / 2
        if x < halfLabel {
            return halfLabel - x
        } else if x > width - halfLabel {
            return (width - halfLabel) - x
        }
        return 0
    }
}

// MARK: - Triangle Shape
struct Triangle: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: CGPoint(x: rect.midX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.minX, y: rect.minY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.minY))
        path.closeSubpath()
        return path
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        PriceTargetRange(priceTarget: AnalystPriceTarget.sampleData)
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ProfitPowerChartView.swift
================================================================================

//
//  ProfitPowerChartView.swift
//  ios
//
//  Molecule: Multi-line chart displaying profit margin metrics over time
//  Uses native Swift Charts framework
//

import SwiftUI
import Charts

struct ProfitPowerChartView: View {
    let dataPoints: [ProfitPowerDataPoint]
    @Binding var selectedDataPoint: ProfitPowerDataPoint?

    // Chart configuration
    private let chartHeight: CGFloat = 240
    private let yAxisWidth: CGFloat = 40

    // Computed properties for chart bounds
    private var maxMargin: Double {
        let allValues = dataPoints.flatMap { [
            $0.grossMargin, $0.operatingMargin, $0.fcfMargin,
            $0.netMargin, $0.sectorAverageNetMargin
        ] }
        // Round up to nearest 10 for cleaner axis
        let maxValue = allValues.max() ?? 50
        return ceil(maxValue / 10) * 10
    }

    private var minMargin: Double {
        0 // Start from 0 for margin charts
    }

    // Grid line values (5 horizontal lines at 0%, 10%, 20%, 30%, 40%, 50%)
    private var gridValues: [Double] {
        let step = maxMargin / 5
        return stride(from: step, to: maxMargin, by: step).map { $0 }
    }

    var body: some View {
        VStack(spacing: 0) {
            // Chart with all margin lines
            chartContent

            // X-axis labels (periods)
            xAxisLabels
        }
        // Overlay tooltip when a data point is selected
        .overlay(alignment: .top) {
            if let selectedDataPoint {
                ProfitPowerTooltipView(dataPoint: selectedDataPoint)
                    .padding(.horizontal, AppSpacing.md)
                    .padding(.top, AppSpacing.xs)
                    .transition(.scale.combined(with: .opacity))
            }
        }
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: selectedDataPoint?.id)
    }

    // MARK: - Chart Content

    private var chartContent: some View {
        GeometryReader { geometry in
            HStack(alignment: .top, spacing: 0) {
                // Y-axis labels for percentages
                yAxisLabels
                    .frame(width: yAxisWidth)

                // Main chart area
                Chart {
                    // Horizontal grid lines
                    ForEach(gridValues, id: \.self) { value in
                        RuleMark(y: .value("Grid", value))
                            .foregroundStyle(AppColors.cardBackgroundLight.opacity(0.6))
                            .lineStyle(StrokeStyle(lineWidth: 0.5))
                    }

                    // Gross Margin Line (Blue - highest)
                    marginLineMark(for: .grossMargin)
                    marginPointMark(for: .grossMargin)

                    // Net Margin Line (Green)
                    marginLineMark(for: .netMargin)
                    marginPointMark(for: .netMargin)

                    // Sector Average Line (Gray - dashed)
                    sectorAverageLineMark
                    sectorAveragePointMark

                    // Operating Margin Line (Orange)
                    marginLineMark(for: .operatingMargin)
                    marginPointMark(for: .operatingMargin)

                    // FCF Margin Line (Purple)
                    marginLineMark(for: .fcfMargin)
                    marginPointMark(for: .fcfMargin)
                }
                .chartXAxis(.hidden)
                .chartYAxis(.hidden)
                .chartYScale(domain: minMargin...maxMargin)
                .chartPlotStyle { plotArea in
                    plotArea
                        .background(Color.clear)
                }
                .frame(height: chartHeight)
                .contentShape(Rectangle())
                .gesture(
                    DragGesture(minimumDistance: 0)
                        .onChanged { value in
                            updateSelection(at: value.location, chartWidth: geometry.size.width)
                        }
                        .onEnded { _ in
                            // Keep selection visible for a moment, then hide
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                                selectedDataPoint = nil
                            }
                        }
                )
            }
        }
        .frame(height: chartHeight)
    }

    // MARK: - Line Marks

    @ChartContentBuilder
    private func marginLineMark(for type: ProfitMarginType) -> some ChartContent {
        ForEach(dataPoints) { dataPoint in
            LineMark(
                x: .value("Period", dataPoint.period),
                y: .value("Margin", dataPoint.margin(for: type)),
                series: .value("Series", type.rawValue)
            )
            .foregroundStyle(type.color)
            .lineStyle(StrokeStyle(lineWidth: 2.5, lineCap: .round, lineJoin: .round))
        }
    }

    @ChartContentBuilder
    private func marginPointMark(for type: ProfitMarginType) -> some ChartContent {
        ForEach(dataPoints) { dataPoint in
            PointMark(
                x: .value("Period", dataPoint.period),
                y: .value("Margin", dataPoint.margin(for: type))
            )
            .foregroundStyle(type.color)
            .symbolSize(40)
        }
    }

    @ChartContentBuilder
    private var sectorAverageLineMark: some ChartContent {
        ForEach(dataPoints) { dataPoint in
            LineMark(
                x: .value("Period", dataPoint.period),
                y: .value("Sector", dataPoint.sectorAverageNetMargin),
                series: .value("Series", "SectorAverage")
            )
            .foregroundStyle(AppColors.profitSectorAverage)
            .lineStyle(StrokeStyle(lineWidth: 2, lineCap: .round, lineJoin: .round, dash: [6, 4]))
        }
    }

    @ChartContentBuilder
    private var sectorAveragePointMark: some ChartContent {
        ForEach(dataPoints) { dataPoint in
            PointMark(
                x: .value("Period", dataPoint.period),
                y: .value("Sector", dataPoint.sectorAverageNetMargin)
            )
            .foregroundStyle(AppColors.profitSectorAverage)
            .symbolSize(30)
        }
    }

    // MARK: - Y-Axis Labels

    private var yAxisLabels: some View {
        VStack {
            Text(String(format: "%.0f%%", maxMargin))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text(String(format: "%.0f%%", maxMargin * 0.8))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text(String(format: "%.0f%%", maxMargin * 0.6))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text(String(format: "%.0f%%", maxMargin * 0.4))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text(String(format: "%.0f%%", maxMargin * 0.2))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text("0%")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }
        .frame(height: chartHeight)
        .padding(.trailing, AppSpacing.xs)
    }

    // MARK: - X-Axis Labels

    private var xAxisLabels: some View {
        HStack(spacing: 0) {
            Spacer()
                .frame(width: yAxisWidth)

            ForEach(dataPoints) { dataPoint in
                Text(dataPoint.period)
                    .font(.system(size: dataPoints.count > 6 ? 9 : 11))
                    .foregroundColor(AppColors.textMuted)
                    .frame(maxWidth: .infinity)
                    .lineLimit(1)
                    .minimumScaleFactor(0.7)
            }
        }
        .padding(.top, AppSpacing.sm)
    }

    // MARK: - Selection Helper

    private func updateSelection(at location: CGPoint, chartWidth: CGFloat) {
        // Calculate which data point is closest to the tap location
        // Account for the y-axis width offset
        let adjustedX = location.x - yAxisWidth
        let availableChartWidth = chartWidth - yAxisWidth
        let pointWidth = availableChartWidth / CGFloat(dataPoints.count)

        let index = Int(adjustedX / pointWidth)
        if index >= 0 && index < dataPoints.count {
            selectedDataPoint = dataPoints[index]
        }
    }
}

// MARK: - Profit Power Tooltip View

struct ProfitPowerTooltipView: View {
    let dataPoint: ProfitPowerDataPoint

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xs) {
            // Period header
            Text(dataPoint.period)
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textPrimary)
                .padding(.bottom, AppSpacing.xxs)

            // All margin values
            tooltipRow(
                title: "Gross Margin",
                value: dataPoint.grossMargin,
                color: AppColors.profitGrossMargin
            )

            tooltipRow(
                title: "Operating Margin",
                value: dataPoint.operatingMargin,
                color: AppColors.profitOperatingMargin
            )

            tooltipRow(
                title: "FCF Margin",
                value: dataPoint.fcfMargin,
                color: AppColors.profitFCFMargin
            )

            tooltipRow(
                title: "Net Margin",
                value: dataPoint.netMargin,
                color: AppColors.profitNetMargin
            )

            tooltipRow(
                title: "Sector Avg",
                value: dataPoint.sectorAverageNetMargin,
                color: AppColors.profitSectorAverage
            )
        }
        .padding(.horizontal, AppSpacing.md)
        .padding(.vertical, AppSpacing.sm)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
                .shadow(color: Color.black.opacity(0.15), radius: 8, x: 0, y: 4)
        )
        .overlay(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .strokeBorder(AppColors.cardBackgroundLight, lineWidth: 1)
        )
    }

    private func tooltipRow(title: String, value: Double, color: Color) -> some View {
        HStack(spacing: AppSpacing.sm) {
            // Color indicator
            Circle()
                .fill(color)
                .frame(width: 8, height: 8)

            // Title
            Text(title)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)

            Spacer()

            // Value
            Text(String(format: "%.1f%%", value))
                .font(AppTypography.captionBold)
                .foregroundColor(AppColors.textPrimary)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack {
            ProfitPowerChartView(
                dataPoints: ProfitPowerSectionData.sampleData.annualData,
                selectedDataPoint: .constant(nil)
            )
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ProfitPowerInfoSheet.swift
================================================================================

//
//  ProfitPowerInfoSheet.swift
//  ios
//
//  Molecule: Educational sheet explaining profit power metrics and value investing tips
//

import SwiftUI

struct ProfitPowerInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xxl) {
                    // Introduction
                    introductionSection

                    // Margin Types Explained
                    marginTypesSection

                    // Value Investing Tips
                    investingTipsSection
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("Profit Power")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
            .toolbarBackground(AppColors.cardBackground, for: .navigationBar)
            .toolbarBackground(.visible, for: .navigationBar)
        }
        .presentationDetents([.large])
        .presentationDragIndicator(.visible)
    }

    // MARK: - Introduction Section

    private var introductionSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("Understanding Profit Power")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            Text("Profit Power shows multiple profitability margins over time, helping you assess a company's ability to convert revenue into profit at different stages of operations.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
    }

    // MARK: - Margin Types Section

    private var marginTypesSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Margin Types")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            ForEach(ProfitMarginType.allCases) { marginType in
                marginTypeCard(marginType)
            }
        }
    }

    private func marginTypeCard(_ marginType: ProfitMarginType) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Color indicator
            Circle()
                .fill(marginType.color)
                .frame(width: 12, height: 12)
                .padding(.top, 4)

            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(marginType.rawValue)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(marginType.description)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Investing Tips Section

    private var investingTipsSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Value Investing Tips")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            ForEach(ProfitPowerInfoItem.valueInvestingTips) { tip in
                investingTipCard(tip)
            }
        }
    }

    private func investingTipCard(_ tip: ProfitPowerInfoItem) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: tip.icon)
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(AppColors.primaryBlue)

                Text(tip.title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
            }

            Text(tip.description)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            if let example = tip.example {
                HStack(alignment: .top, spacing: AppSpacing.xs) {
                    Image(systemName: "lightbulb.fill")
                        .font(.system(size: 11))
                        .foregroundColor(AppColors.neutral)

                    Text(example)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .italic()
                        .fixedSize(horizontal: false, vertical: true)
                }
                .padding(.top, AppSpacing.xs)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    ProfitPowerInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ProfitPowerLegendView.swift
================================================================================

//
//  ProfitPowerLegendView.swift
//  ios
//
//  Molecule: Complete legend showing all margin types for Profit Power chart
//  Displays in a two-row layout matching the design reference
//

import SwiftUI

struct ProfitPowerLegendView: View {
    var body: some View {
        VStack(spacing: AppSpacing.md) {
            // First row: Gross Margin, Operating Margin, FCF Margin
            HStack(spacing: AppSpacing.xl) {
                ProfitPowerLegendItem(marginType: .grossMargin)
                ProfitPowerLegendItem(marginType: .operatingMargin)
                ProfitPowerLegendItem(marginType: .fcfMargin)
            }

            // Second row: Net Margin, Sector Average
            HStack(spacing: AppSpacing.xl) {
                ProfitPowerLegendItem(marginType: .netMargin)
                ProfitPowerLegendItem(marginType: .sectorAverage)
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ProfitPowerLegendView()
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RatingDistributionList.swift
================================================================================

//
//  RatingDistributionList.swift
//  ios
//
//  List of rating distribution bars
//

import SwiftUI

struct RatingDistributionList: View {
    let distributions: [AnalystRatingDistribution]

    private var maxCount: Int {
        distributions.map { $0.count }.max() ?? 1
    }

    var body: some View {
        VStack(spacing: AppSpacing.sm) {
            ForEach(distributions) { distribution in
                RatingDistributionBar(
                    label: distribution.label,
                    count: distribution.count,
                    color: distribution.color,
                    maxCount: maxCount
                )
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        RatingDistributionList(distributions: AnalystRatingDistribution.sampleData)
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RecentActivitiesFlowBar.swift
================================================================================

//
//  RecentActivitiesFlowBar.swift
//  ios
//
//  Molecule: Horizontal bar showing In Flow vs Out Flow
//  Green portion represents buying, red portion represents selling
//

import SwiftUI

struct RecentActivitiesFlowBar: View {
    let inFlowPercent: Double  // 0.0 to 1.0
    let formattedInFlow: String
    let formattedOutFlow: String

    private let barHeight: CGFloat = 36
    private let cornerRadius: CGFloat = 8

    var body: some View {
        GeometryReader { geometry in
            HStack(spacing: 0) {
                // In Flow (Green)
                ZStack(alignment: .leading) {
                    Rectangle()
                        .fill(AppColors.bullish)

                    Text(formattedInFlow)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(.white)
                        .padding(.leading, AppSpacing.md)
                }
                .frame(width: geometry.size.width * inFlowPercent)

                // Out Flow (Red)
                ZStack(alignment: .trailing) {
                    Rectangle()
                        .fill(AppColors.bearish)

                    Text(formattedOutFlow)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(.white)
                        .padding(.trailing, AppSpacing.md)
                }
                .frame(width: geometry.size.width * (1 - inFlowPercent))
            }
            .frame(height: barHeight)
            .clipShape(RoundedRectangle(cornerRadius: cornerRadius))
        }
        .frame(height: barHeight)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            RecentActivitiesFlowBar(
                inFlowPercent: 0.54,
                formattedInFlow: "$2.1B",
                formattedOutFlow: "$1.8B"
            )

            RecentActivitiesFlowBar(
                inFlowPercent: 0.7,
                formattedInFlow: "$3.5B",
                formattedOutFlow: "$1.5B"
            )

            RecentActivitiesFlowBar(
                inFlowPercent: 0.3,
                formattedInFlow: "$0.8B",
                formattedOutFlow: "$1.9B"
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RecentActivitiesFlowLegend.swift
================================================================================

//
//  RecentActivitiesFlowLegend.swift
//  ios
//
//  Molecule: Legend for the In Flow / Out Flow bar
//  Shows green for In Flow and red for Out Flow
//

import SwiftUI

struct RecentActivitiesFlowLegend: View {
    var body: some View {
        HStack(spacing: AppSpacing.lg) {
            // In Flow: dot on left
            legendItem(color: AppColors.bullish, label: "In Flow", dotOnRight: false)
            Spacer()
            // Out Flow: dot on right
            legendItem(color: AppColors.bearish, label: "Out Flow", dotOnRight: true)
        }
    }

    private func legendItem(color: Color, label: String, dotOnRight: Bool) -> some View {
        HStack(spacing: AppSpacing.xs) {
            if !dotOnRight {
                Circle()
                    .fill(color)
                    .frame(width: 8, height: 8)
            }

            Text(label)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            if dotOnRight {
                Circle()
                    .fill(color)
                    .frame(width: 8, height: 8)
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        RecentActivitiesFlowLegend()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RecentActivitiesInfoSheet.swift
================================================================================

//
//  RecentActivitiesInfoSheet.swift
//  ios
//
//  Molecule: Educational sheet explaining recent institutional and insider activities
//  Provides guidance for novice investors on interpreting trading data
//

import SwiftUI

struct RecentActivitiesInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xl) {
                    // Header
                    headerSection

                    // Institutions Section
                    institutionsSectionHeader

                    // What is This Section
                    whatIsThisSection

                    // Understanding the Flow Bar
                    flowBarSection

                    // Insiders Section
                    insidersSectionHeader

                    // What are Insider Activities
                    whatAreInsiderActivitiesSection

                    // Informative vs Uninformative
                    informativeVsUninformativeSection

                    // Key Insights
                    keyInsightsSection

                    // Important Considerations
                    considerationsSection
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("Recent Activities")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "chart.bar.doc.horizontal")
                    .font(.system(size: 24))
                    .foregroundColor(AppColors.primaryBlue)

                Text("Understanding Recent Activities")
                    .font(AppTypography.title2)
                    .foregroundColor(AppColors.textPrimary)
            }

            Text("This section tracks recent buying and selling activity by institutional investors and company insidersâ€”two key groups whose actions can signal future stock performance.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
        }
        .padding(AppSpacing.lg)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Section Headers

    private var institutionsSectionHeader: some View {
        HStack(spacing: AppSpacing.sm) {
            Image(systemName: "building.columns.fill")
                .font(.system(size: 18))
                .foregroundColor(AppColors.primaryBlue)

            Text("Institutions Tab")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)
        }
        .padding(.top, AppSpacing.md)
    }

    private var insidersSectionHeader: some View {
        HStack(spacing: AppSpacing.sm) {
            Image(systemName: "person.fill.checkmark")
                .font(.system(size: 18))
                .foregroundColor(AppColors.primaryBlue)

            Text("Insiders Tab")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)
        }
        .padding(.top, AppSpacing.md)
    }

    // MARK: - What is This Section (Institutions)

    private var whatIsThisSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("What Are Institutional Activities?")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            Text("Institutional investorsâ€”like mutual funds, pension funds, and hedge fundsâ€”must disclose their stock holdings quarterly through SEC Form 13F filings. This data shows you what the \"big money\" is doing.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            Text("The most recent quarter's filings are summarized here, showing which institutions increased or decreased their positions.")
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textMuted)
                .fixedSize(horizontal: false, vertical: true)
        }
    }

    // MARK: - Flow Bar Section

    private var flowBarSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Understanding the Flow Bar")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                flowBarExplanation(
                    color: AppColors.bullish,
                    title: "In Flow (Green)",
                    description: "Total value of shares purchased by institutions this quarter. Represents new money flowing into the stock."
                )

                flowBarExplanation(
                    color: AppColors.bearish,
                    title: "Out Flow (Red)",
                    description: "Total value of shares sold by institutions this quarter. Represents money exiting the stock."
                )

                flowBarExplanation(
                    color: AppColors.primaryBlue,
                    title: "Net Flow",
                    description: "The difference between In Flow and Out Flow. Positive means more buying; negative means more selling."
                )
            }
            .padding(AppSpacing.lg)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.large)
                    .fill(AppColors.cardBackground)
            )
        }
    }

    private func flowBarExplanation(color: Color, title: String, description: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Circle()
                .fill(color)
                .frame(width: 12, height: 12)
                .padding(.top, 4)

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
    }

    // MARK: - What Are Insider Activities Section

    private var whatAreInsiderActivitiesSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("What Are Insider Activities?")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            Text("Company insidersâ€”executives, directors, and major shareholdersâ€”must report their stock trades to the SEC within 2 business days via Form 4. These filings reveal when people with deep company knowledge are buying or selling.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            Text("Unlike institutional filings, insider trades are reported almost immediately, giving you a more timely view of activity.")
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textMuted)
                .fixedSize(horizontal: false, vertical: true)
        }
    }

    // MARK: - Informative vs Uninformative Section

    private var informativeVsUninformativeSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Informative vs. Uninformative Trades")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            Text("Not all insider trades carry the same weight. We classify trades based on their likely motivation:")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            VStack(spacing: AppSpacing.md) {
                tradeTypeCard(
                    color: AppColors.bullish,
                    title: "Informative Buy",
                    description: "An insider voluntarily purchases shares on the open market with their own money. This is one of the strongest bullish signalsâ€”they believe the stock will rise.",
                    example: "CEO uses personal funds to buy $500K in shares"
                )

                tradeTypeCard(
                    color: AppColors.bearish,
                    title: "Informative Sell",
                    description: "An insider voluntarily sells shares not related to scheduled plans. May indicate concerns about the stock, though could also be diversification.",
                    example: "CFO sells shares outside of a 10b5-1 plan"
                )

                tradeTypeCard(
                    color: AppColors.textSecondary,
                    title: "Uninformative Buy",
                    description: "Shares acquired through compensation, stock options, or grants. Not a signal of conviction since they didn't use their own money.",
                    example: "Director receives annual stock grant"
                )

                tradeTypeCard(
                    color: AppColors.textSecondary,
                    title: "Uninformative Sell",
                    description: "Scheduled sales (10b5-1 plans), tax-related sales, or option exercises. These are routine and don't indicate sentiment.",
                    example: "Automatic quarterly sale per preset plan"
                )
            }
            .padding(AppSpacing.lg)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.large)
                    .fill(AppColors.cardBackground)
            )
        }
    }

    private func tradeTypeCard(color: Color, title: String, description: String, example: String) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.sm) {
                Circle()
                    .fill(color)
                    .frame(width: 10, height: 10)

                Text(title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(color == AppColors.textSecondary ? AppColors.textPrimary : color)
            }

            Text(description)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            HStack(spacing: AppSpacing.xs) {
                Text("Example:")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                    .italic()

                Text(example)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                    .italic()
            }
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.small)
                .fill(AppColors.background)
        )
    }

    // MARK: - Key Insights Section

    private var keyInsightsSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Key Insights")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                insightCard(
                    number: "1",
                    title: "Informative Buying is the Strongest Signal",
                    description: "When insiders spend their own money to buy shares, they're putting skin in the game. Multiple insiders buying is especially bullish."
                )

                insightCard(
                    number: "2",
                    title: "Focus on the Net Flow",
                    description: "Positive net informative flow (more buying than selling) suggests insiders are confident. Persistent negative flow may be a warning sign."
                )

                insightCard(
                    number: "3",
                    title: "Filter to \"Informative\" for Clarity",
                    description: "Use the filter to see only meaningful trades. Uninformative trades add noise but don't indicate sentiment."
                )

                insightCard(
                    number: "4",
                    title: "Consider the Role",
                    description: "CEO and CFO trades often carry more weight than directors, as they have the deepest knowledge of the company's prospects."
                )
            }
        }
    }

    private func insightCard(number: String, title: String, description: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Text(number)
                .font(AppTypography.headline)
                .foregroundColor(AppColors.primaryBlue)
                .frame(width: 24, height: 24)
                .background(
                    Circle()
                        .fill(AppColors.primaryBlue.opacity(0.15))
                )

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Considerations Section

    private var considerationsSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "exclamationmark.triangle.fill")
                    .font(.system(size: 18))
                    .foregroundColor(AppColors.neutral)

                Text("Important Considerations")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                considerationRow("Institutional 13F filings are delayed 45 days after quarter end.")
                considerationRow("Insider Form 4 filings are reported within 2 business days.")
                considerationRow("Index funds buy automatically, not based on conviction.")
                considerationRow("Insiders may sell for personal reasons (taxes, diversification, home purchase).")
                considerationRow("Always combine with other researchâ€”activity data is just one signal.")
            }
        }
        .padding(AppSpacing.lg)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
                .overlay(
                    RoundedRectangle(cornerRadius: AppCornerRadius.large)
                        .stroke(AppColors.neutral.opacity(0.3), lineWidth: 1)
                )
        )
    }

    private func considerationRow(_ text: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.sm) {
            Image(systemName: "arrow.right.circle.fill")
                .font(.system(size: 12))
                .foregroundColor(AppColors.textMuted)
                .padding(.top, 2)

            Text(text)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
    }
}

#Preview {
    RecentActivitiesInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RecentActivitiesNetFlowBadge.swift
================================================================================

//
//  RecentActivitiesNetFlowBadge.swift
//  ios
//
//  Molecule: Badge displaying the net flow summary
//  Shows quarter and net flow value with appropriate color
//

import SwiftUI

struct RecentActivitiesNetFlowBadge: View {
    let summary: RecentActivitiesFlowSummary

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            Text("\(summary.quarterDescription) Net Flow:")
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)

            Text(summary.formattedNetFlow)
                .font(AppTypography.calloutBold)
                .foregroundColor(summary.netFlowColor)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.lg) {
            RecentActivitiesNetFlowBadge(
                summary: RecentActivitiesFlowSummary(
                    periodDescription: "Oct - Dec 2025",
                    quarterDescription: "Q4",
                    inFlowInBillions: 2.1,
                    outFlowInBillions: 1.8
                )
            )

            RecentActivitiesNetFlowBadge(
                summary: RecentActivitiesFlowSummary(
                    periodDescription: "Jul - Sep 2025",
                    quarterDescription: "Q3",
                    inFlowInBillions: 1.2,
                    outFlowInBillions: 1.8
                )
            )
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RecentActivitiesSortSelector.swift
================================================================================

//
//  RecentActivitiesSortSelector.swift
//  ios
//
//  Molecule: Sort option selector for Recent Activities
//  Allows switching between By Value and By Date sorting
//

import SwiftUI

struct RecentActivitiesSortSelector: View {
    @Binding var selectedSort: RecentActivitiesSortOption

    var body: some View {
        HStack(spacing: 0) {
            ForEach(RecentActivitiesSortOption.allCases, id: \.rawValue) { option in
                Button {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedSort = option
                    }
                } label: {
                    Text(option.rawValue)
                        .font(AppTypography.callout)
                        .foregroundColor(selectedSort == option ? AppColors.textPrimary : AppColors.textSecondary)
                        .padding(.horizontal, AppSpacing.lg)
                        .padding(.vertical, AppSpacing.sm)
                        .background(
                            Group {
                                if selectedSort == option {
                                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                                        .fill(AppColors.cardBackground)
                                }
                            }
                        )
                }
                .buttonStyle(.plain)
            }
        }
        .padding(AppSpacing.xxs)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.background)
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            RecentActivitiesSortSelector(
                selectedSort: .constant(.byValue)
            )

            RecentActivitiesSortSelector(
                selectedSort: .constant(.byDate)
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RecentActivitiesTabSelector.swift
================================================================================

//
//  RecentActivitiesTabSelector.swift
//  ios
//
//  Molecule: Tab selector for Recent Activities section
//  Switches between Institutions and Insiders tabs
//

import SwiftUI

struct RecentActivitiesTabSelector: View {
    @Binding var selectedTab: RecentActivitiesTab
    let disabledTabs: Set<RecentActivitiesTab>

    init(selectedTab: Binding<RecentActivitiesTab>, disabledTabs: Set<RecentActivitiesTab> = []) {
        self._selectedTab = selectedTab
        self.disabledTabs = disabledTabs
    }

    var body: some View {
        HStack(spacing: 0) {
            ForEach(RecentActivitiesTab.allCases, id: \.rawValue) { tab in
                let isDisabled = disabledTabs.contains(tab)

                Button {
                    if !isDisabled {
                        withAnimation(.easeInOut(duration: 0.2)) {
                            selectedTab = tab
                        }
                    }
                } label: {
                    Text(tab.rawValue)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(tabForegroundColor(for: tab, isDisabled: isDisabled))
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, AppSpacing.sm)
                        .background(
                            selectedTab == tab && !isDisabled
                                ? AppColors.cardBackgroundLight
                                : Color.clear
                        )
                        .cornerRadius(AppCornerRadius.medium)
                }
                .buttonStyle(.plain)
                .disabled(isDisabled)
            }
        }
        .padding(AppSpacing.xs)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }

    private func tabForegroundColor(for tab: RecentActivitiesTab, isDisabled: Bool) -> Color {
        if isDisabled {
            return AppColors.textMuted.opacity(0.5)
        }
        return selectedTab == tab ? AppColors.textPrimary : AppColors.textMuted
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            RecentActivitiesTabSelector(
                selectedTab: .constant(.institutions)
            )

            RecentActivitiesTabSelector(
                selectedTab: .constant(.institutions),
                disabledTabs: [.insiders]
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RelatedMoneyMoveCard.swift
================================================================================

//
//  RelatedMoneyMoveCard.swift
//  ios
//
//  Molecule: Compact card for related articles
//

import SwiftUI

struct RelatedMoneyMoveCard: View {
    let article: RelatedArticle
    var onTap: (() -> Void)?

    private var gradientColors: [Color] {
        article.gradientColors.map { Color(hex: $0) }
    }

    var body: some View {
        Button(action: { onTap?() }) {
            VStack(alignment: .leading, spacing: 0) {
                // Gradient header
                ZStack(alignment: .topLeading) {
                    // Background gradient
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                    .frame(height: 80)

                    // Category icon
                    ZStack {
                        Circle()
                            .fill(Color.white.opacity(0.2))
                            .frame(width: 32, height: 32)

                        Image(systemName: article.category.iconName)
                            .font(.system(size: 14, weight: .semibold))
                            .foregroundColor(.white)
                    }
                    .padding(AppSpacing.md)
                }

                // Content
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    Text(article.title)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(2)

                    Text(article.subtitle)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(2)

                    Spacer(minLength: 0)

                    // Meta
                    HStack(spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.xxs) {
                            Image(systemName: "clock")
                                .font(.system(size: 10, weight: .medium))
                            Text("\(article.readTimeMinutes) min")
                                .font(AppTypography.caption)
                        }
                        .foregroundColor(AppColors.textMuted)

                        HStack(spacing: AppSpacing.xxs) {
                            Image(systemName: "eye")
                                .font(.system(size: 10, weight: .medium))
                            Text(article.viewCount)
                                .font(AppTypography.caption)
                        }
                        .foregroundColor(AppColors.textMuted)
                    }
                }
                .padding(AppSpacing.md)
            }
            .frame(width: 200, height: 200)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ScrollView(.horizontal, showsIndicators: false) {
        HStack(spacing: AppSpacing.md) {
            RelatedMoneyMoveCard(
                article: RelatedArticle(
                    title: "The FTX Collapse",
                    subtitle: "What the failure tells us about the future.",
                    category: .valueTraps,
                    readTimeMinutes: 14,
                    viewCount: "2.8M",
                    gradientColors: ["DC2626", "991B1B"]
                )
            )

            RelatedMoneyMoveCard(
                article: RelatedArticle(
                    title: "How Amazon Built Its Moat",
                    subtitle: "The strategy behind unstoppable dominance.",
                    category: .blueprints,
                    readTimeMinutes: 12,
                    viewCount: "3.1M",
                    gradientColors: ["059669", "047857"]
                )
            )
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RelatedTickerCard.swift
================================================================================

//
//  RelatedTickerCard.swift
//  ios
//
//  Molecule: Card for related/similar tickers in horizontal scroll
//

import SwiftUI

struct RelatedTickerCard: View {
    let ticker: RelatedTicker
    var onTap: (() -> Void)?

    private var changeColor: Color {
        ticker.isPositive ? AppColors.bullish : AppColors.bearish
    }

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                // Symbol and chevron
                HStack {
                    Text(ticker.symbol)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.textPrimary)

                    Spacer()

                    Image(systemName: "chevron.right")
                        .font(.system(size: 10, weight: .semibold))
                        .foregroundColor(AppColors.textMuted)
                }

                // Company name
                Text(ticker.name)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .lineLimit(1)

                Spacer()

                // Price
                Text(ticker.formattedPrice)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                // Change percentage
                Text(ticker.formattedChange)
                    .font(AppTypography.footnote)
                    .fontWeight(.semibold)
                    .foregroundColor(changeColor)
            }
            .padding(AppSpacing.md)
            .frame(width: 100, height: 120)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.medium)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ScrollView(.horizontal, showsIndicators: false) {
        HStack(spacing: AppSpacing.md) {
            ForEach(RelatedTicker.sampleData) { ticker in
                RelatedTickerCard(ticker: ticker)
            }
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RelatedTickersRow.swift
================================================================================

//
//  RelatedTickersRow.swift
//  ios
//
//  Molecule: Horizontal row of related ticker tags with icon
//

import SwiftUI

struct RelatedTickersRow: View {
    let tickers: [String]
    var onTickerTapped: ((String) -> Void)?

    var body: some View {
        HStack(alignment: .center, spacing: AppSpacing.sm) {
            // Tag Icon
            Image(systemName: "tag.fill")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(AppColors.neutral)
                .rotationEffect(.degrees(-90))

            // Ticker Tags
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.sm) {
                    ForEach(tickers, id: \.self) { ticker in
                        RelatedTickerTag(ticker: ticker) {
                            onTickerTapped?(ticker)
                        }
                    }
                }
            }
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        RelatedTickersRow(
            tickers: ["APPL", "ORCL", "TSLA"],
            onTickerTapped: { ticker in
                print("Tapped: \(ticker)")
            }
        )

        RelatedTickersRow(
            tickers: ["NVDA", "AMD", "INTC", "GOOGL", "META"]
        )

        RelatedTickersRow(
            tickers: ["AAPL"]
        )
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportAgentBadge.swift
================================================================================

//
//  ReportAgentBadge.swift
//  ios
//
//  Molecule: Agent persona badge with star rating (e.g. "BUFFETT AGENT â˜…â˜…â˜…â˜…â˜†")
//

import SwiftUI

struct ReportAgentBadge: View {
    let agent: ReportAgentPersona

    var body: some View {
        Text(agent.rawValue)
            .font(AppTypography.captionBold)
            .foregroundColor(AppColors.textSecondary)
            .tracking(1.2)
    }
}

#Preview {
    ReportAgentBadge(agent: .buffett)
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportCard.swift
================================================================================

//
//  ReportCard.swift
//  ios
//
//  Molecule: Analysis report card showing status, persona, and details
//

import SwiftUI

struct ReportCard: View {
    let report: AnalysisReport
    var onTap: (() -> Void)?
    var onRetry: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            VStack(alignment: .leading, spacing: AppSpacing.md) {
                // Header: Company name + Status
                HStack(alignment: .top) {
                    VStack(alignment: .leading, spacing: AppSpacing.xs) {
                        Text(report.companyName)
                            .font(AppTypography.headline)
                            .foregroundColor(AppColors.textPrimary)

                        Text(report.tickerAndIndustry)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)
                    }

                    Spacer()

                    VStack(alignment: .trailing, spacing: AppSpacing.xs) {
                        ReportStatusBadge(status: report.status)

                        if report.status == .failed && report.isRefunded {
                            Text("[Refunded]")
                                .font(AppTypography.caption)
                                .foregroundColor(report.status.color)
                        }
                    }
                }

                // Persona info with score gauge on the right (for ready status)
                if report.status == .ready, let rating = report.rating {
                    HStack(spacing: AppSpacing.sm) {
                        // Left: Persona info
                        HStack(spacing: AppSpacing.sm) {
                            PersonaIcon(
                                persona: report.persona,
                                size: 32,
                                isSelected: true
                            )

                            VStack(alignment: .leading, spacing: 0) {
                                Text(report.persona.rawValue)
                                    .font(AppTypography.footnote)
                                    .fontWeight(.semibold)
                                    .foregroundColor(AppColors.textPrimary)

                                Text(report.persona.tagline)
                                    .font(AppTypography.caption)
                                    .foregroundColor(AppColors.textSecondary)
                            }
                        }

                        Spacer()

                        // Right: Score Gauge
                        ReportScoreGauge(
                            score: rating,
                            maxScore: 100,
                            label: "",
                            size: .small
                        )
                    }
                } else {
                    // Persona info without gauge (for processing/failed)
                    HStack(spacing: AppSpacing.sm) {
                        PersonaIcon(
                            persona: report.persona,
                            size: 32,
                            isSelected: true
                        )

                        VStack(alignment: .leading, spacing: 0) {
                            Text(report.persona.rawValue)
                                .font(AppTypography.footnote)
                                .fontWeight(.semibold)
                                .foregroundColor(AppColors.textPrimary)

                            Text(report.persona.tagline)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textSecondary)
                        }
                    }

                    // Status-specific content for non-ready reports
                    switch report.status {
                    case .processing:
                        // Progress bar
                        ProgressBar(
                            progress: report.progress ?? 0,
                            color: AppColors.primaryBlue
                        )

                    case .failed:
                        // Retry button
                        Button(action: {
                            onRetry?()
                        }) {
                            HStack(spacing: AppSpacing.xs) {
                                Image(systemName: "arrow.clockwise")
                                    .font(.system(size: 12, weight: .semibold))
                                Text("Retry Analysis")
                                    .font(AppTypography.footnote)
                                    .fontWeight(.semibold)
                            }
                            .foregroundColor(report.status.color)
                        }
                        .buttonStyle(PlainButtonStyle())

                    case .ready:
                        EmptyView()
                    }
                }

                // Date (for ready and failed)
                if report.status != .processing || report.status == .processing {
                    HStack {
                        if report.status == .processing {
                            Spacer()
                        }
                        Text(report.formattedDate)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                        if report.status != .processing {
                            Spacer()
                        }
                    }
                }
            }
            .padding(AppSpacing.lg)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.large)
                    .fill(AppColors.cardBackground)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(report.status == .processing)
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.md) {
            ForEach(AnalysisReport.mockReports) { report in
                ReportCard(report: report)
            }
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportChatBar.swift
================================================================================

//
//  ReportChatBar.swift
//  ios
//
//  Molecule: Bottom floating chat bar for interacting with the report
//

import SwiftUI

struct ReportChatBar: View {
    let onTapped: () -> Void

    var body: some View {
        Button(action: onTapped) {
            HStack(spacing: AppSpacing.md) {
                Image(systemName: "bubble.left.fill")
                    .font(.system(size: 16))
                    .foregroundColor(AppColors.primaryBlue)

                Text("Chat with the report")
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)

                Spacer()

                Image(systemName: "mic.fill")
                    .font(.system(size: 14))
                    .foregroundColor(AppColors.textMuted)
            }
            .padding(.horizontal, AppSpacing.lg)
            .padding(.vertical, AppSpacing.md)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                    .fill(AppColors.cardBackground)
                    .shadow(color: .black.opacity(0.2), radius: 8, y: -2)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack {
        Spacer()
        ReportChatBar(onTapped: {})
            .padding(.horizontal, AppSpacing.lg)
            .padding(.bottom, AppSpacing.lg)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportConsensusBar.swift
================================================================================

//
//  ReportConsensusBar.swift
//  ios
//
//  Molecule: Wall Street consensus rating bar with price targets
//

import SwiftUI

struct ReportConsensusBar: View {
    let consensus: ReportWallStreetConsensus

    private var pricePosition: Double {
        guard consensus.highTarget > consensus.lowTarget else { return 0.5 }
        return (consensus.currentPrice - consensus.lowTarget) / (consensus.highTarget - consensus.lowTarget)
    }

    private var minPrice: Double {
        let targetPrices = [consensus.lowTarget, consensus.targetPrice, consensus.highTarget, consensus.currentPrice]
        let historicalPrices = consensus.hedgeFundPriceData.map { $0.price }
        let allPrices = targetPrices + historicalPrices
        // Add extra padding at the bottom to push content up
        let minValue = allPrices.min() ?? consensus.lowTarget
        let maxValue = allPrices.max() ?? consensus.highTarget
        let range = maxValue - minValue
        return minValue - (range * 0.3) // Add 30% padding below
    }

    private var maxPrice: Double {
        let targetPrices = [consensus.lowTarget, consensus.targetPrice, consensus.highTarget, consensus.currentPrice]
        let historicalPrices = consensus.hedgeFundPriceData.map { $0.price }
        let allPrices = targetPrices + historicalPrices
        // Add less padding at the top
        let maxValue = allPrices.max() ?? consensus.highTarget
        let minValue = allPrices.min() ?? consensus.lowTarget
        let range = maxValue - minValue
        return maxValue + (range * 0.1) // Add 10% padding above
    }

    /// Format month string from "MM/YYYY" to "MM/YY"
    private func formatMonthLabel(_ month: String) -> String {
        // Convert "02/2025" to "02/25"
        let components = month.split(separator: "/")
        guard components.count == 2,
              let year = components.last,
              year.count == 4 else {
            return month // Return as-is if format is unexpected
        }
        let shortYear = year.suffix(2)
        return "\(components[0])/\(shortYear)"
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Title and Description
            analystPriceTargetHeader
                .padding(.bottom, AppSpacing.lg)

            // Price Chart with Target Zones
            analystPriceChart

            // Momentum
            momentumSection
                .padding(.top, -20)
                .padding(.bottom, AppSpacing.lg)

            // Hedge Funds
            hedgeFundsSection
        }
    }

    // MARK: - Analyst Price Target Header

    private var analystPriceTargetHeader: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            Text("Analyst Price Target")
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textSecondary)

            Text("One-year price forecast: \(consensus.rating.rawValue.uppercased()) consensus. Target \(consensus.formattedTargetPrice) (range \(consensus.formattedLowTarget) - \(consensus.formattedHighTarget)). Current price: \(consensus.formattedCurrentPrice).")
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(4)
                .fixedSize(horizontal: false, vertical: true)
        }
    }

    // MARK: - Analyst Price Chart

    private var analystPriceChart: some View {
        GeometryReader { geometry in
            let leadingPadding: CGFloat = 20 // Align with Swift Charts leading space
            let chartWidth = geometry.size.width - 50 - leadingPadding // Reserve 50pts for badges and 20pts for leading

            ZStack(alignment: .leading) {
                // Price line chart
                if !consensus.hedgeFundPriceData.isEmpty {
                    priceLineChart(chartWidth: chartWidth, in: geometry)
                        .offset(x: leadingPadding, y: -120) // Move up 10 more points
                }

                // Current price indicator and dashed line
                currentPriceIndicator(chartWidth: chartWidth, in: geometry)
                    .offset(x: leadingPadding, y: -120) // Move up 10 more points

                // Target pole with points (far right)
                targetPole(chartWidth: chartWidth, in: geometry)
                    .offset(x: leadingPadding, y: -120) // Move up 10 more points

                // Target badges on the right
                targetBadges(chartWidth: chartWidth, in: geometry)
                    .offset(x: leadingPadding, y: -120) // Move up 10 more points
            }
        }
        .frame(height: 260)
    }

    // MARK: - Chart Components

    private func priceLineChart(chartWidth: CGFloat, in geometry: GeometryProxy) -> some View {
        Path { path in
            let points = consensus.hedgeFundPriceData
            guard !points.isEmpty else { return }

            let xStep = chartWidth / CGFloat(max(points.count - 1, 1))

            // Start path
            let firstY = yPosition(for: points[0].price, in: geometry)
            path.move(to: CGPoint(x: 0, y: firstY))

            // Draw line through all points
            for (index, point) in points.enumerated() {
                let x = CGFloat(index) * xStep
                let y = yPosition(for: point.price, in: geometry)
                path.addLine(to: CGPoint(x: x, y: y))
            }
        }
        .stroke(AppColors.primaryBlue, style: StrokeStyle(lineWidth: 2, lineCap: .round, lineJoin: .round))
    }

    private func currentPriceIndicator(chartWidth: CGFloat, in geometry: GeometryProxy) -> some View {
        let yPos = yPosition(for: consensus.currentPrice, in: geometry)

        return Group {
            // Dashed horizontal line
            Path { path in
                path.move(to: CGPoint(x: 0, y: yPos))
                path.addLine(to: CGPoint(x: chartWidth, y: yPos))
            }
            .stroke(AppColors.primaryBlue, style: StrokeStyle(lineWidth: 1.5, dash: [5, 3]))

            // Current price badge - positioned at the end of the price line
            if let lastPrice = consensus.hedgeFundPriceData.last {
                let lastIndex = consensus.hedgeFundPriceData.count - 1
                let xStep = chartWidth / CGFloat(max(consensus.hedgeFundPriceData.count - 1, 1))
                let xPos = CGFloat(lastIndex) * xStep

                Text(consensus.formattedCurrentPrice)
                    .font(.system(size: 12, weight: .bold))
                    .foregroundColor(.white)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(
                        Capsule()
                            .fill(AppColors.primaryBlue)
                    )
                    .offset(x: max(0, min(xPos - 20, chartWidth - 50)), y: yPos - 16)
            }
        }
    }

    private func targetPole(chartWidth: CGFloat, in geometry: GeometryProxy) -> some View {
        let xPos = chartWidth - 3 // Position slightly left of the edge
        let highY = yPosition(for: consensus.highTarget, in: geometry)
        let avgY = yPosition(for: consensus.targetPrice, in: geometry)
        let lowY = yPosition(for: consensus.lowTarget, in: geometry)
        
        // Extend the pole beyond the points
        let poleExtension: CGFloat = 20
        let extendedHighY = highY - poleExtension
        let extendedLowY = lowY + poleExtension

        return ZStack(alignment: .leading) {
            // Thick vertical pole from low to high (extended)
            RoundedRectangle(cornerRadius: 2)
                .fill(AppColors.textMuted.opacity(0.4))
                .frame(width: 6, height: extendedLowY - extendedHighY)
                .offset(x: xPos - 3, y: extendedHighY + (extendedLowY - extendedHighY) / 2)

            // High target point (green) - smaller
            Circle()
                .fill(AppColors.bullish)
                .frame(width: 10, height: 10)
                .offset(x: xPos - 5, y: highY)

            // Average target point (blue) - smaller
            Circle()
                .fill(AppColors.primaryBlue)
                .frame(width: 10, height: 10)
                .offset(x: xPos - 5, y: avgY)

            // Low target point (red) - smaller
            Circle()
                .fill(AppColors.bearish)
                .frame(width: 10, height: 10)
                .offset(x: xPos - 5, y: lowY)
        }
    }

    private func targetBadges(chartWidth: CGFloat, in geometry: GeometryProxy) -> some View {
        let xPos = chartWidth + 5 // Position badges closer to pole
        let highY = yPosition(for: consensus.highTarget, in: geometry)
        let avgY = yPosition(for: consensus.targetPrice, in: geometry)
        let lowY = yPosition(for: consensus.lowTarget, in: geometry)

        return Group {
            // High target badge - centered vertically with the point
            targetBadge(
                label: "Max",
                price: consensus.formattedHighTarget,
                percent: consensus.formattedHighTargetPercent,
                color: AppColors.bullish
            )
            .offset(x: xPos, y: highY + 1)

            // Average target badge - centered vertically with the point
            targetBadge(
                label: "Avg",
                price: consensus.formattedTargetPrice,
                percent: consensus.formattedAvgTargetPercent,
                color: AppColors.primaryBlue
            )
            .offset(x: xPos, y: avgY + 1)

            // Low target badge - centered vertically with the point
            targetBadge(
                label: "Min",
                price: consensus.formattedLowTarget,
                percent: consensus.formattedLowTargetPercent,
                color: AppColors.bearish
            )
            .offset(x: xPos, y: lowY + 1)
        }
    }

    private func targetBadge(label: String, price: String, percent: String, color: Color) -> some View {
        VStack(alignment: .center, spacing: 2) {
            Text(label)
                .font(.system(size: 9, weight: .semibold))
                .foregroundColor(AppColors.textMuted)

            Text(price)
                .font(.system(size: 11, weight: .bold))
                .foregroundColor(AppColors.textPrimary)

            Text(percent)
                .font(.system(size: 10, weight: .bold))
                .foregroundColor(color)
        }
    }

    private func yPosition(for price: Double, in geometry: GeometryProxy) -> CGFloat {
        let priceRange = maxPrice - minPrice
        guard priceRange > 0 else { return geometry.size.height / 2 }

        let normalizedValue = (price - minPrice) / priceRange
        return geometry.size.height * (1 - normalizedValue)
    }

    // MARK: - Momentum Section

    private var momentumSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            Text("Momentum")
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textSecondary)

            HStack(spacing: AppSpacing.lg) {
                HStack(spacing: AppSpacing.xs) {
                    Image(systemName: "arrow.up")
                        .font(.system(size: 10, weight: .bold))
                        .foregroundColor(AppColors.bullish)
                    Text("\(consensus.momentumUpgrades)")
                        .font(AppTypography.subheadline)
                        .foregroundColor(AppColors.textPrimary)
                    Text("Upgrades")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }

                HStack(spacing: AppSpacing.xs) {
                    Image(systemName: "arrow.down")
                        .font(.system(size: 10, weight: .bold))
                        .foregroundColor(AppColors.bearish)
                    Text("\(consensus.momentumDowngrades)")
                        .font(AppTypography.subheadline)
                        .foregroundColor(AppColors.textPrimary)
                    Text("Downgrades")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }
            }
        }
    }

    // MARK: - Hedge Funds Section

    private var hedgeFundsSection: some View {
        Group {
            if let hedgeFundNote = consensus.hedgeFundNote {
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    Text("Hedge Funds")
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.textSecondary)

                    // Hedge Fund Flow Chart (Price on top, Buy/Sell volume below)
                    if !consensus.hedgeFundPriceData.isEmpty && !consensus.hedgeFundFlowData.isEmpty {
                        VStack(alignment: .leading, spacing: AppSpacing.sm) {
                            Text("12-Month Flow")
                                .font(AppTypography.footnote)
                                .foregroundColor(AppColors.textMuted)
                                .padding(.top, AppSpacing.md)

                            SmartMoneyFlowChart(
                                priceData: consensus.hedgeFundPriceData,
                                flowData: consensus.hedgeFundFlowData
                            )

                            SmartMoneyFlowLegend()
                                .padding(.top, AppSpacing.xs)
                        }
                    }

                    Text(hedgeFundNote)
                        .font(AppTypography.subheadline)
                        .foregroundColor(AppColors.textSecondary)
                        .padding(.top, AppSpacing.sm)
                }
            }
        }
    }
}

#Preview {
    ReportConsensusBar(consensus: TickerReportData.sampleOracle.wallStreetConsensus)
        .padding()
        .background(AppColors.cardBackground)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportCoreThesisCard.swift
================================================================================

//
//  ReportCoreThesisCard.swift
//  ios
//
//  Molecule: Bull case or Bear case thesis card with bullet points
//

import SwiftUI

struct ReportCoreThesisCard: View {
    let isBullCase: Bool
    let bullets: [CoreThesisBullet]

    private var title: String {
        isBullCase ? "Bull Case" : "Bear Case"
    }

    private var iconName: String {
        isBullCase ? "arrow.up.forward.circle.fill" : "arrow.down.forward.circle.fill"
    }

    private var accentColor: Color {
        isBullCase ? AppColors.bullish : AppColors.bearish
    }

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: iconName)
                    .font(.system(size: 16))
                    .foregroundColor(accentColor)

                Text(title)
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            // Bullets
            VStack(alignment: .leading, spacing: AppSpacing.md) {
                ForEach(bullets) { bullet in
                    HStack(alignment: .top, spacing: AppSpacing.sm) {
                        Circle()
                            .fill(accentColor)
                            .frame(width: 5, height: 5)
                            .padding(.top, 6)

                        Text(bullet.text)
                            .font(AppTypography.subheadline)
                            .foregroundColor(AppColors.textSecondary)
                            .lineSpacing(3)
                    }
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    let sample = TickerReportData.sampleOracle
    VStack(spacing: AppSpacing.md) {
        ReportCoreThesisCard(isBullCase: true, bullets: sample.coreThesis.bullCase)
        ReportCoreThesisCard(isBullCase: false, bullets: sample.coreThesis.bearCase)
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportCriticalFactorRow.swift
================================================================================

//
//  ReportCriticalFactorRow.swift
//  ios
//
//  Molecule: Individual critical factor warning row
//

import SwiftUI

struct ReportCriticalFactorRow: View {
    let factor: CriticalFactor

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Severity icon
            Image(systemName: factor.severity.iconName)
                .font(.system(size: 16))
                .foregroundColor(factor.severity.color)
                .frame(width: 24, height: 24)

            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(factor.title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(factor.description)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textSecondary)
                    .lineSpacing(2)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ForEach(TickerReportData.sampleOracle.criticalFactors) { factor in
            ReportCriticalFactorRow(factor: factor)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportDeepDiveMetricCard.swift
================================================================================

//
//  ReportDeepDiveMetricCard.swift
//  ios
//
//  Molecule: Individual metric card for deep dive (Profitability, Valuation, Growth, Health)
//

import SwiftUI

struct ReportDeepDiveMetricCard: View {
    let data: DeepDiveMetricCard

    private var ratingColor: Color {
        switch data.starRating {
        case 4...5: return AppColors.bullish
        case 3: return AppColors.neutral
        default: return AppColors.bearish
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            // Title row with stars
            HStack {
                Text(data.title)
                    .font(AppTypography.subheadline)
                    .fontWeight(.semibold)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(1)
                    .minimumScaleFactor(0.8)

                Spacer(minLength: 4)

                // Star display
                HStack(spacing: 2) {
                    ForEach(0..<5, id: \.self) { index in
                        Image(systemName: index < data.starRating ? "star.fill" : "star")
                            .font(.system(size: 8))
                            .foregroundColor(index < data.starRating ? Color(hex: "F59E0B") : AppColors.textMuted)
                    }
                }
            }

            Divider()
                .background(AppColors.textMuted.opacity(0.2))

            // Metrics
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                ForEach(data.metrics) { metric in
                    HStack {
                        Text(metric.label)
                            .font(AppTypography.footnote)
                            .foregroundColor(AppColors.textMuted)
                            .lineLimit(1)
                        Spacer()
                        HStack(spacing: 2) {
                            if let trend = metric.trend {
                                Image(systemName: trend.iconName)
                                    .font(.system(size: 8, weight: .bold))
                                    .foregroundColor(trend.color)
                            }
                            Text(metric.value)
                                .font(AppTypography.footnote)
                                .fontWeight(.semibold)
                                .foregroundColor(AppColors.textPrimary)
                        }
                    }
                }
            }

            Spacer(minLength: 0)

            // Quality label
            Text(data.qualityLabel)
                .font(AppTypography.footnote)
                .foregroundColor(ratingColor)
                .lineLimit(2)
                .minimumScaleFactor(0.9)
                .italic()
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackgroundLight)
        )
    }
}

#Preview {
    let sample = TickerReportData.sampleOracle.fundamentalMetrics
    LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: AppSpacing.md) {
        ForEach(sample) { metric in
            ReportDeepDiveMetricCard(data: metric)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportExecutiveSummaryCard.swift
================================================================================

//
//  ReportExecutiveSummaryCard.swift
//  ios
//
//  Molecule: Executive summary section with description and categorized bullets
//

import SwiftUI

struct ReportExecutiveSummaryCard: View {
    let summaryText: String
    let bullets: [ExecutiveSummaryBullet]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Section header
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "doc.text.fill")
                    .font(.system(size: 14))
                    .foregroundColor(AppColors.primaryBlue)

                Text("Executive Summary")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            // Summary text
            Text(summaryText)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(4)

            // Bullet points
            VStack(alignment: .leading, spacing: AppSpacing.md) {
                ForEach(bullets) { bullet in
                    HStack(alignment: .top, spacing: AppSpacing.sm) {
                        Circle()
                            .fill(bullet.sentiment.color)
                            .frame(width: 6, height: 6)
                            .padding(.top, 6)

                        VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                            Text("\(bullet.category): \(bullet.text)")
                                .font(AppTypography.footnote)
                                .foregroundColor(AppColors.textSecondary)
                        }
                    }
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    ReportExecutiveSummaryCard(
        summaryText: TickerReportData.sampleOracle.executiveSummaryText,
        bullets: TickerReportData.sampleOracle.executiveSummaryBullets
    )
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportForecastChart.swift
================================================================================

//
//  ReportForecastChart.swift
//  ios
//
//  Molecule: Revenue forecast bar chart with EPS line overlay and management guidance
//

import SwiftUI
import Charts

struct ReportForecastChart: View {
    let forecast: ReportRevenueForecast

    /// Scale EPS values into the revenue axis range so dots sit inside the bars
    private var epsScaleFactor: Double {
        let maxRevenue = forecast.projections.map(\.revenue).max() ?? 1
        let maxEPS = forecast.projections.map(\.eps).max() ?? 1
        // Place highest EPS dot at ~70% of max bar height
        return (maxRevenue * 0.70) / maxEPS
    }

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Chart
            Chart {
                // Revenue bars
                ForEach(forecast.projections) { projection in
                    BarMark(
                        x: .value("Period", projection.period),
                        y: .value("Revenue", projection.revenue),
                        width: .ratio(0.5)
                    )
                    .foregroundStyle(
                        projection.isForecast
                            ? AppColors.primaryBlue.opacity(0.6)
                            : AppColors.primaryBlue
                    )
                    .cornerRadius(AppCornerRadius.small)
                    .annotation(position: .top, spacing: 4) {
                        Text(projection.revenueLabel)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)
                    }
                }
                
                // EPS line (scaled to revenue axis) - as a continuous series
                ForEach(forecast.projections) { projection in
                    LineMark(
                        x: .value("Period", projection.period),
                        y: .value("EPS", projection.eps * epsScaleFactor)
                    )
                    .foregroundStyle(AppColors.accentYellow)
                    .lineStyle(StrokeStyle(lineWidth: 2))
                    .interpolationMethod(.linear)
                }
                
                // EPS dots
                ForEach(forecast.projections) { projection in
                    PointMark(
                        x: .value("Period", projection.period),
                        y: .value("EPS", projection.eps * epsScaleFactor)
                    )
                    .foregroundStyle(AppColors.accentYellow)
                    .symbolSize(40)
                    .annotation(position: .bottom, spacing: 4) {
                        Text(projection.epsLabel)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.accentYellow)
                    }
                }
            }
            .chartYAxis(.hidden)
            .chartXAxis {
                AxisMarks(values: .automatic) { _ in
                    AxisValueLabel()
                        .font(AppTypography.caption)
                        .foregroundStyle(AppColors.textSecondary)
                }
            }
            .frame(height: 140)

            // Legend row
            HStack(spacing: AppSpacing.lg) {
                HStack(spacing: AppSpacing.xs) {
                    RoundedRectangle(cornerRadius: 2)
                        .fill(AppColors.primaryBlue)
                        .frame(width: 12, height: 12)
                    Text("Revenue: \(forecast.formattedCAGR)")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                HStack(spacing: AppSpacing.xs) {
                    Circle()
                        .fill(AppColors.accentYellow)
                        .frame(width: 8, height: 8)
                    Text("EPS: \(forecast.formattedEPSGrowth)")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }
            }
            .frame(maxWidth: .infinity)

            // Management Guidance
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                HStack(spacing: AppSpacing.sm) {
                    Text("Management Guidance")
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.textSecondary)
                }

                ReportSentimentBadge(
                    text: forecast.managementGuidance.rawValue,
                    textColor: forecast.managementGuidance.color,
                    backgroundColor: forecast.managementGuidance.backgroundColor
                )

                if let quote = forecast.guidanceQuote {
                    HStack(alignment: .top, spacing: AppSpacing.sm) {
                        Rectangle()
                            .fill(AppColors.primaryBlue)
                            .frame(width: 2)

                        Text("\"\(quote)\"")
                            .font(AppTypography.subheadline)
                            .foregroundColor(AppColors.textSecondary)
                            .italic()
                    }
                    .padding(.top, AppSpacing.xs)
                }
            }
        }
    }
}

#Preview {
    ReportForecastChart(forecast: TickerReportData.sampleOracle.revenueForecast)
        .padding()
        .background(AppColors.cardBackground)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportHeaderBar.swift
================================================================================

//
//  ReportHeaderBar.swift
//  ios
//
//  Molecule: Top navigation bar for the report with back, company info, and share
//

import SwiftUI

struct ReportHeaderBar: View {
    let companyName: String
    let ticker: String
    let exchange: String
    let onBack: () -> Void
    let onShare: () -> Void

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Back button
            Button(action: onBack) {
                Image(systemName: "chevron.left")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(AppColors.textPrimary)
                    .frame(width: 36, height: 36)
            }

            // Company logo placeholder + info
            HStack(spacing: AppSpacing.md) {
                // Logo placeholder
                RoundedRectangle(cornerRadius: AppCornerRadius.small)
                    .fill(AppColors.cardBackgroundLight)
                    .frame(width: 36, height: 36)
                    .overlay(
                        Text(String(companyName.prefix(1)))
                            .font(AppTypography.headline)
                            .foregroundColor(AppColors.textPrimary)
                    )

                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text(companyName)
                        .font(AppTypography.headline)
                        .foregroundColor(AppColors.textPrimary)

                    HStack(spacing: AppSpacing.xs) {
                        Text(ticker)
                            .font(AppTypography.footnote)
                            .foregroundColor(AppColors.textSecondary)

                        Text("â€¢")
                            .font(AppTypography.footnote)
                            .foregroundColor(AppColors.textMuted)

                        Text(exchange)
                            .font(AppTypography.footnote)
                            .foregroundColor(AppColors.textSecondary)
                    }
                }
            }

            Spacer()

            // Share button
            Button(action: onShare) {
                Image(systemName: "square.and.arrow.up")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(AppColors.textPrimary)
                    .frame(width: 36, height: 36)
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
    }
}

#Preview {
    ReportHeaderBar(
        companyName: "Oracle",
        ticker: "ORCL",
        exchange: "Nasdaq",
        onBack: {},
        onShare: {}
    )
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportInsiderActivityTable.swift
================================================================================

//
//  ReportInsiderActivityTable.swift
//  ios
//
//  Molecule: Insider activity table showing buy/sell transactions
//

import SwiftUI

struct ReportInsiderActivityTable: View {
    let insiderData: ReportInsiderData

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header with sentiment badge
            HStack {
                Text("Insider Activity")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textSecondary)

                Spacer()

                ReportSentimentBadge(
                    text: insiderData.sentiment.rawValue,
                    textColor: insiderData.sentiment.color,
                    backgroundColor: insiderData.sentiment.backgroundColor
                )
            }

            // Timeframe
            Text(insiderData.timeframe)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            // Table header
            HStack {
                Text("")
                    .frame(maxWidth: .infinity, alignment: .leading)
                Text("Count")
                    .frame(width: 50, alignment: .center)
                Text("Shares")
                    .frame(width: 50, alignment: .center)
                Text("Value")
                    .frame(width: 60, alignment: .trailing)
            }
            .font(AppTypography.caption)
            .foregroundColor(AppColors.textMuted)

            // Table rows
            ForEach(insiderData.transactions) { transaction in
                HStack {
                    Text(transaction.type)
                        .font(AppTypography.subheadline)
                        .foregroundColor(transaction.type == "Buys" ? AppColors.bullish : AppColors.bearish)
                        .frame(maxWidth: .infinity, alignment: .leading)

                    Text("\(transaction.count)")
                        .font(AppTypography.subheadline)
                        .foregroundColor(AppColors.textPrimary)
                        .frame(width: 50, alignment: .center)

                    Text(transaction.shares)
                        .font(AppTypography.subheadline)
                        .foregroundColor(AppColors.textPrimary)
                        .frame(width: 50, alignment: .center)

                    Text(transaction.value)
                        .font(AppTypography.subheadline)
                        .foregroundColor(AppColors.textPrimary)
                        .frame(width: 60, alignment: .trailing)
                }
            }

            // Ownership note
            if let note = insiderData.ownershipNote {
                Text(note)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.bearish)
                    .padding(AppSpacing.sm)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .background(
                        RoundedRectangle(cornerRadius: AppCornerRadius.small)
                            .fill(AppColors.bearish.opacity(0.1))
                    )
            }
        }
    }
}

#Preview {
    ReportInsiderActivityTable(insiderData: TickerReportData.sampleOracle.insiderData)
        .padding()
        .background(AppColors.cardBackground)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportKeyManagementTable.swift
================================================================================

//
//  ReportKeyManagementTable.swift
//  ios
//
//  Molecule: Key management table showing executives and ownership
//

import SwiftUI

struct ReportKeyManagementTable: View {
    let management: ReportKeyManagement

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("Key Management")
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textSecondary)

            // Table header
            HStack {
                Text("")
                    .frame(maxWidth: .infinity, alignment: .leading)
                Text("Ownership")
                    .frame(width: 80, alignment: .trailing)
            }
            .font(AppTypography.caption)
            .foregroundColor(AppColors.textMuted)

            // Manager rows
            ForEach(management.managers) { manager in
                VStack(spacing: AppSpacing.xs) {
                    HStack(alignment: .top) {
                        VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                            Text(manager.name)
                                .font(AppTypography.subheadline)
                                .foregroundColor(AppColors.textPrimary)
                            Text(manager.title)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textMuted)
                                .lineLimit(1)
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)

                        VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                            Text(manager.ownership)
                                .font(AppTypography.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(AppColors.textPrimary)
                            Text(manager.ownershipValue)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textMuted)
                        }
                        .frame(width: 80, alignment: .trailing)
                    }

                    Divider()
                        .background(AppColors.textMuted.opacity(0.15))
                }
            }

            // Ownership insight
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                HStack(spacing: AppSpacing.xs) {
                    Image(systemName: "sparkles.2")
                        .foregroundStyle(
                            LinearGradient(
                                colors: [.indigo],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .font(.system(size: 16, weight: .semibold))

                    Text("Insight")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundStyle(LinearGradient(
                            colors: [.indigo, .cyan],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ))
                }

                Text(management.ownershipInsight)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textSecondary)
                    .lineSpacing(3)
            }
            .padding(AppSpacing.md)
        }
    }
}

#Preview {
    ReportKeyManagementTable(management: TickerReportData.sampleOracle.keyManagement)
        .padding()
        .background(AppColors.cardBackground)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportKeyVitalCard.swift
================================================================================

//
//  ReportKeyVitalCard.swift
//  ios
//
//  Molecule: Individual Key Vital card (Valuation, Moat, or Financial Health)
//

import SwiftUI

// MARK: - Valuation Vital Card

struct ReportValuationVitalCard: View {
    let data: ReportValuationData

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Title + badge
            HStack {
                Text("Valuation")
                    .font(AppTypography.footnoteBold)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                ReportSentimentBadge(
                    text: data.status.rawValue,
                    textColor: data.status.color,
                    backgroundColor: data.status.backgroundColor
                )
            }

            Divider()
                .background(AppColors.textMuted.opacity(0.3))

            // Current Price
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text("Current Price")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                Text(data.formattedCurrentPrice)
                    .font(AppTypography.calloutBold)
                    .fontWeight(.semibold)
                    .foregroundColor(AppColors.textPrimary)
            }

            // Fair Value
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text("Analyst Fair Value")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                    .lineLimit(1)
                    .fixedSize(horizontal: true, vertical: false)
                Text(data.formattedFairValue)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.primaryBlue)
            }
            
            // Upside Potential
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text("Upside Potential")
                    .font(AppTypography.footnote)
                    .foregroundColor(AppColors.textMuted)
                    .lineLimit(1)
                    .fixedSize(horizontal: true, vertical: false)
                Text(data.formattedUpside)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(data.upsideColor)
            }
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

// MARK: - Moat Vital Card

struct ReportMoatVitalCard: View {
    let data: ReportMoatData

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Title + Wide Moat badge
            HStack {
                Text("Moat")
                    .font(AppTypography.footnoteBold)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                ReportSentimentBadge(
                    text: data.overallRating.rawValue,
                    textColor: data.overallRating.color,
                    backgroundColor: data.overallRating.color.opacity(0.15)
                )
            }

            Divider()
                .background(AppColors.textMuted.opacity(0.3))

            // Trend Badge
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text("Trend Badge")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                
                HStack(spacing: AppSpacing.xs) {
                    
                    Text(data.stabilityLabel)
                        .font(AppTypography.subheadline)
                        .foregroundColor(AppColors.textPrimary)
                        .fontWeight(.semibold)
                }
            }

            // Primary Source
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text("Primary Source")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                Text(data.primarySource)
                    .font(AppTypography.subheadline)
                    .fontWeight(.semibold)
                    .foregroundColor(AppColors.textPrimary)
            }

            Spacer()
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

// MARK: - Financial Health Vital Card

struct ReportFinancialHealthVitalCard: View {
    let data: ReportFinancialHealthData

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Title + level badge
            HStack {
                Text("Financial Health")
                    .font(AppTypography.footnoteBold)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                ReportSentimentBadge(
                    text: data.level.rawValue,
                    textColor: data.level.color,
                    backgroundColor: data.level.color.opacity(0.15)
                )
            }

            Divider()
                .background(AppColors.textMuted.opacity(0.3))

            // Altman Z-Score with Progress Bar
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text("Altman Z-Score")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)

                HStack(alignment: .center, spacing: AppSpacing.xs) {
                    Text(data.formattedZScore)
                        .font(AppTypography.title3)
                        .fontWeight(.bold)
                        .foregroundColor(data.level.color)
                }

                // Z-Score Progress Bar
                ZScoreProgressBar(score: data.altmanZScore)
                    .frame(height: 12)
                
                Text(data.altmanZLabel)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }

            // Additional metric - Rising Expenses
            HStack(spacing: AppSpacing.xs) {
                Image(systemName: "exclamationmark.triangle.fill")
                    .font(.system(size: 10))
                    .foregroundColor(data.additionalMetricStatus.color)
                Text(data.additionalMetricDisplayText)
                    .font(AppTypography.caption)
                    .foregroundColor(data.additionalMetricStatus.color)
            }

            // FCF note
            Text(data.fcfNote)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
                .lineLimit(2)
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

// MARK: - Z-Score Progress Bar

struct ZScoreProgressBar: View {
    let score: Double
    
    // Z-Score ranges
    private let distressThreshold: CGFloat = 1.8
    private let greyZoneThreshold: CGFloat = 3.0
    private let maxScore: CGFloat = 5.0
    
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Background bar with color zones
                HStack(spacing: 0) {
                    // Red zone (0 to 1.8)
                    Rectangle()
                        .fill(AppColors.bearish.opacity(0.2))
                        .frame(width: geometry.size.width * (distressThreshold / maxScore))
                    
                    // Grey zone (1.8 to 3.0)
                    Rectangle()
                        .fill(Color.gray.opacity(0.3))
                        .frame(width: geometry.size.width * ((greyZoneThreshold - distressThreshold) / maxScore))
                    
                    // Green zone (3.0+)
                    Rectangle()
                        .fill(AppColors.bullish.opacity(0.2))
                        .frame(width: geometry.size.width * ((maxScore - greyZoneThreshold) / maxScore))
                }
                .cornerRadius(4)
                
                // Score marker
                Circle()
                    .fill(scoreColor)
                    .frame(width: 12, height: 12)
                    .overlay(
                        Circle()
                            .stroke(AppColors.cardBackground, lineWidth: 2)
                    )
                    .offset(x: markerPosition(in: geometry.size.width) - 6)
            }
        }
    }
    
    private var scoreColor: Color {
        if score < Double(distressThreshold) {
            return AppColors.bearish
        } else if score < Double(greyZoneThreshold) {
            return Color.gray
        } else {
            return AppColors.bullish
        }
    }
    
    private func markerPosition(in width: CGFloat) -> CGFloat {
        let clampedScore = min(max(CGFloat(score), 0), maxScore)
        return width * (clampedScore / maxScore)
    }
}

#Preview {
    let sample = TickerReportData.sampleOracle
    ScrollView(.horizontal) {
        HStack(spacing: AppSpacing.md) {
            ReportValuationVitalCard(data: sample.keyVitals.valuation)
                .frame(width: 160)
            ReportMoatVitalCard(data: sample.keyVitals.moat)
                .frame(width: 160)
            ReportFinancialHealthVitalCard(data: sample.keyVitals.financialHealth)
                .frame(width: 160)
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportMoatRadarChart.swift
================================================================================

//
//  ReportMoatRadarChart.swift
//  ios
//
//  Molecule: Custom pentagon radar chart for competitive moat dimensions.
//  Draws two overlapping polygons: company (filled) and peers (outline).
//

import SwiftUI

struct ReportMoatRadarChart: View {
    let dimensions: [MoatDimension]

    private let chartSize: CGFloat = 200
    private let rings = 5

    var body: some View {
        ZStack {
            // Grid rings + axis lines
            radarGrid

            // Peer polygon (outline)
            radarPolygon(
                values: dimensions.map(\.normalizedPeerScore),
                fillColor: AppColors.textMuted.opacity(0.08),
                strokeColor: AppColors.textMuted.opacity(0.4),
                strokeStyle: StrokeStyle(lineWidth: 1, dash: [4, 3])
            )

            // Company polygon (filled)
            radarPolygon(
                values: dimensions.map(\.normalizedScore),
                fillColor: AppColors.primaryBlue.opacity(0.2),
                strokeColor: AppColors.primaryBlue,
                strokeStyle: StrokeStyle(lineWidth: 2)
            )

            // Score dots on company polygon
            scoreDots

            // Axis labels
            axisLabels
        }
        .frame(width: chartSize + 80, height: chartSize + 80)
    }

    // MARK: - Grid

    private var radarGrid: some View {
        Canvas { context, size in
            let center = CGPoint(x: size.width / 2, y: size.height / 2)
            let radius = chartSize / 2

            // Concentric rings
            for ring in 1...rings {
                let r = radius * CGFloat(ring) / CGFloat(rings)
                let ringPath = polygonPath(
                    center: center,
                    radius: r,
                    sides: dimensions.count
                )
                context.stroke(
                    ringPath,
                    with: .color(AppColors.textMuted.opacity(0.12)),
                    lineWidth: 0.5
                )
            }

            // Axis spokes
            for i in 0..<dimensions.count {
                let angle = angleForIndex(i, total: dimensions.count) - .pi / 2
                let endPoint = CGPoint(
                    x: center.x + radius * cos(angle),
                    y: center.y + radius * sin(angle)
                )
                var spoke = Path()
                spoke.move(to: center)
                spoke.addLine(to: endPoint)
                context.stroke(
                    spoke,
                    with: .color(AppColors.textMuted.opacity(0.12)),
                    lineWidth: 0.5
                )
            }
        }
        .frame(width: chartSize + 80, height: chartSize + 80)
    }

    // MARK: - Polygon

    private func radarPolygon(
        values: [Double],
        fillColor: Color,
        strokeColor: Color,
        strokeStyle: StrokeStyle
    ) -> some View {
        Canvas { context, size in
            let center = CGPoint(x: size.width / 2, y: size.height / 2)
            let radius = chartSize / 2
            let path = dataPolygonPath(center: center, radius: radius, values: values)

            context.fill(path, with: .color(fillColor))
            context.stroke(path, with: .color(strokeColor), style: strokeStyle)
        }
        .frame(width: chartSize + 80, height: chartSize + 80)
    }

    // MARK: - Score Dots

    private var scoreDots: some View {
        let center = CGPoint(x: (chartSize + 80) / 2, y: (chartSize + 80) / 2)
        let radius = chartSize / 2

        return ForEach(Array(dimensions.enumerated()), id: \.element.id) { index, dimension in
            let angle = angleForIndex(index, total: dimensions.count) - .pi / 2
            let r = radius * CGFloat(dimension.normalizedScore)
            let x = center.x + r * cos(angle)
            let y = center.y + r * sin(angle)

            Circle()
                .fill(AppColors.primaryBlue)
                .frame(width: 6, height: 6)
                .shadow(color: AppColors.primaryBlue.opacity(0.6), radius: 4)
                .position(x: x, y: y)
        }
    }

    // MARK: - Axis Labels

    private var axisLabels: some View {
        let center = CGPoint(x: (chartSize + 80) / 2, y: (chartSize + 80) / 2)
        let labelRadius = chartSize / 2 + 32

        return ForEach(Array(dimensions.enumerated()), id: \.element.id) { index, dimension in
            let angle = angleForIndex(index, total: dimensions.count) - .pi / 2
            let x = center.x + labelRadius * cos(angle)
            let y = center.y + labelRadius * sin(angle)

            VStack(spacing: 1) {
                Text(dimension.name)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .multilineTextAlignment(.center)
                Text(String(format: "%.1f", dimension.score))
                    .font(AppTypography.captionBold)
                    .foregroundColor(AppColors.primaryBlue)
            }
            .frame(width: 72)
            .position(x: x, y: y)
        }
    }

    // MARK: - Geometry Helpers

    private func angleForIndex(_ index: Int, total: Int) -> CGFloat {
        CGFloat(index) * (2 * .pi / CGFloat(total))
    }

    private func polygonPath(center: CGPoint, radius: CGFloat, sides: Int) -> Path {
        var path = Path()
        for i in 0...sides {
            let angle = angleForIndex(i % sides, total: sides) - .pi / 2
            let point = CGPoint(
                x: center.x + radius * cos(angle),
                y: center.y + radius * sin(angle)
            )
            if i == 0 { path.move(to: point) } else { path.addLine(to: point) }
        }
        path.closeSubpath()
        return path
    }

    private func dataPolygonPath(center: CGPoint, radius: CGFloat, values: [Double]) -> Path {
        var path = Path()
        for i in 0...values.count {
            let idx = i % values.count
            let angle = angleForIndex(idx, total: values.count) - .pi / 2
            let r = radius * min(max(values[idx], 0), 1.0)
            let point = CGPoint(
                x: center.x + r * cos(angle),
                y: center.y + r * sin(angle)
            )
            if i == 0 { path.move(to: point) } else { path.addLine(to: point) }
        }
        path.closeSubpath()
        return path
    }
}

#Preview {
    ReportMoatRadarChart(
        dimensions: TickerReportData.sampleOracle.moatCompetition.dimensions
    )
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportPeerComparisonRow.swift
================================================================================

//
//  ReportPeerComparisonRow.swift
//  ios
//
//  Molecule: Single competitor row with visual score bar for moat comparison
//

import SwiftUI

struct ReportPeerComparisonRow: View {
    let competitor: CompetitorComparison
    let maxScore: Double = 10.0

    var body: some View {
        VStack(spacing: AppSpacing.sm) {
            HStack {
                // Name + Ticker
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text(competitor.name)
                        .font(AppTypography.subheadline)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(1)
                    Text(competitor.ticker)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }

                Spacer()

                // Threat badge
                Text(competitor.threatLevel.rawValue)
                    .font(AppTypography.caption)
                    .fontWeight(.semibold)
                    .foregroundColor(competitor.threatLevel.color)
                    .padding(.horizontal, AppSpacing.sm)
                    .padding(.vertical, AppSpacing.xxs)
                    .background(
                        RoundedRectangle(cornerRadius: AppCornerRadius.small)
                            .fill(competitor.threatLevel.color.opacity(0.12))
                    )
            }

            // Score bar
            HStack(spacing: AppSpacing.sm) {
                GeometryReader { geo in
                    ZStack(alignment: .leading) {
                        // Track
                        RoundedRectangle(cornerRadius: 3)
                            .fill(AppColors.cardBackgroundLight)
                            .frame(height: 6)

                        // Fill
                        RoundedRectangle(cornerRadius: 3)
                            .fill(barColor)
                            .frame(
                                width: geo.size.width * (competitor.moatScore / maxScore),
                                height: 6
                            )
                    }
                }
                .frame(height: 6)

                Text(String(format: "%.1f", competitor.moatScore))
                    .font(AppTypography.captionBold)
                    .foregroundColor(AppColors.textSecondary)
                    .frame(width: 28, alignment: .trailing)
            }

            // Market share
            HStack {
                Text("Market Share")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                Spacer()
                Text(String(format: "%.0f%%", competitor.marketSharePercent))
                    .font(AppTypography.captionBold)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackgroundLight)
        )
    }

    private var barColor: Color {
        switch competitor.threatLevel {
        case .high: return AppColors.bearish
        case .moderate: return AppColors.neutral
        case .low: return AppColors.bullish
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        ForEach(TickerReportData.sampleOracle.moatCompetition.competitors) { comp in
            ReportPeerComparisonRow(competitor: comp)
        }
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportPriceChart.swift
================================================================================

//
//  ReportPriceChart.swift
//  ios
//
//  Molecule: Area line chart with gradient fill for price movement visualization.
//  Uses native Swift Charts. Color-coded green/red based on trend direction.
//

import SwiftUI
import Charts

struct ReportPriceChart: View {
    let points: [PricePoint]
    let stats: PriceMovementStats

    private var trendColor: Color { stats.trendColor }

    private var yMin: Double {
        (points.map(\.price).min() ?? 0) * 0.998
    }

    private var yMax: Double {
        (points.map(\.price).max() ?? 0) * 1.002
    }

    var body: some View {
        VStack(spacing: 0) {
            // Price chart
            Chart {
                ForEach(points) { point in
                    // Area fill
                    AreaMark(
                        x: .value("Time", point.index),
                        yStart: .value("Min", yMin),
                        yEnd: .value("Price", point.price)
                    )
                    .foregroundStyle(
                        LinearGradient(
                            colors: [trendColor.opacity(0.3), trendColor.opacity(0.0)],
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
                    .interpolationMethod(.catmullRom)

                    // Line
                    LineMark(
                        x: .value("Time", point.index),
                        y: .value("Price", point.price)
                    )
                    .foregroundStyle(trendColor)
                    .lineStyle(StrokeStyle(lineWidth: 2))
                    .interpolationMethod(.catmullRom)
                }
            }
            .chartYScale(domain: yMin...yMax)
            .chartXAxis(.hidden)
            .chartYAxis {
                AxisMarks(position: .trailing, values: .automatic(desiredCount: 3)) { value in
                    AxisGridLine(stroke: StrokeStyle(lineWidth: 0.5, dash: [4, 4]))
                        .foregroundStyle(AppColors.textMuted.opacity(0.2))
                    AxisValueLabel()
                        .foregroundStyle(AppColors.textMuted)
                        .font(AppTypography.caption)
                }
            }
            .frame(height: 160)

            // Volume bars
            if points.contains(where: { $0.volume != nil }) {
                Chart {
                    ForEach(points) { point in
                        if let volume = point.volume {
                            BarMark(
                                x: .value("Time", point.index),
                                y: .value("Volume", volume),
                                width: .ratio(0.6)
                            )
                            .foregroundStyle(trendColor.opacity(0.25))
                        }
                    }
                }
                .chartXAxis(.hidden)
                .chartYAxis(.hidden)
                .frame(height: 32)
            }
        }
    }
}

#Preview {
    let points = [145.1, 144.5, 143.9, 143.1, 142.8, 142.4, 141.8, 142.0, 142.8]
        .enumerated()
        .map { PricePoint(index: $0.offset, price: $0.element, volume: Double.random(in: 500_000...2_000_000)) }
    let stats = PriceMovementStats(
        currentPrice: 142.82, priceChange: -2.34, percentChange: -1.61,
        periodHigh: 145.90, periodLow: 141.20, avgVolume: "18.2M"
    )
    ReportPriceChart(points: points, stats: stats)
        .padding()
        .background(AppColors.cardBackground)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportRiskFactorCard.swift
================================================================================

//
//  ReportRiskFactorCard.swift
//  ios
//
//  Molecule: Individual macro risk factor card with impact gauge, trend arrow, and severity badge.
//  Designed with an intelligence-briefing aesthetic.
//

import SwiftUI

struct ReportRiskFactorCard: View {
    let factor: MacroRiskFactor

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            // Top row: icon + severity badge
            HStack {
                // Category icon
                Image(systemName: factor.category.iconName)
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(factor.severity.color)
                    .frame(width: 28, height: 28)
                    .background(
                        RoundedRectangle(cornerRadius: AppCornerRadius.small)
                            .fill(factor.severity.color.opacity(0.12))
                    )

                Spacer()

                // Severity tag
                Text(factor.severity.rawValue)
                    .font(.system(size: 9, weight: .bold))
                    .foregroundColor(factor.severity.color)
                    .tracking(0.5)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 3)
                    .background(
                        RoundedRectangle(cornerRadius: 4)
                            .fill(factor.severity.color.opacity(0.12))
                    )
            }

            // Title
            Text(factor.title)
                .font(AppTypography.footnoteBold)
                .foregroundColor(AppColors.textPrimary)
                .lineLimit(2)

            // Impact gauge
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                HStack {
                    Text("Impact")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                    Spacer()
                    Text("\(Int(factor.impact * 100))%")
                        .font(AppTypography.captionBold)
                        .foregroundColor(gaugeColor)
                }

                GeometryReader { geo in
                    ZStack(alignment: .leading) {
                        // Track
                        RoundedRectangle(cornerRadius: 2.5)
                            .fill(AppColors.background)
                            .frame(height: 5)

                        // Fill with gradient
                        RoundedRectangle(cornerRadius: 2.5)
                            .fill(
                                LinearGradient(
                                    colors: [gaugeColor.opacity(0.7), gaugeColor],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .frame(width: geo.size.width * factor.impact, height: 5)
                    }
                }
                .frame(height: 5)
            }

            // Description
            Text(factor.description)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
                .lineSpacing(2)
                .lineLimit(3)

            // Trend indicator
            HStack(spacing: AppSpacing.xs) {
                Image(systemName: factor.trend.iconName)
                    .font(.system(size: 10, weight: .semibold))
                    .foregroundColor(factor.trend.color)

                Text(factor.trend.rawValue)
                    .font(AppTypography.caption)
                    .foregroundColor(factor.trend.color)
            }
            .padding(.top, AppSpacing.xxs)
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackgroundLight)
                .overlay(
                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                        .stroke(factor.severity.color.opacity(0.15), lineWidth: 1)
                )
        )
    }

    private var gaugeColor: Color {
        switch factor.impact {
        case 0..<0.35: return AppColors.bullish
        case 0.35..<0.60: return AppColors.neutral
        case 0.60..<0.80: return AppColors.alertOrange
        default: return AppColors.bearish
        }
    }
}

#Preview {
    LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: AppSpacing.md) {
        ForEach(TickerReportData.sampleOracle.macroData.riskFactors) { factor in
            ReportRiskFactorCard(factor: factor)
        }
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ReportThreatLevelBar.swift
================================================================================

//
//  ReportThreatLevelBar.swift
//  ios
//
//  Molecule: DEFCON-style horizontal threat level indicator.
//  Shows all 5 levels with the active one highlighted and pulsing.
//

import SwiftUI

struct ReportThreatLevelBar: View {
    let level: ThreatLevel

    private let allLevels = ThreatLevel.allCases

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // THREAT LEVEL header
            HStack(spacing: AppSpacing.sm) {
                Text("THREAT LEVEL")
                    .font(AppTypography.captionBold)
                    .foregroundColor(AppColors.textMuted)
                    .tracking(1.5)
            }

            // Level segments
            HStack(spacing: 3) {
                ForEach(allLevels, id: \.rawValue) { lvl in
                    VStack(spacing: AppSpacing.xs) {
                        RoundedRectangle(cornerRadius: 2)
                            .fill(segmentFill(for: lvl))
                            .frame(height: 8)
                            .overlay(
                                RoundedRectangle(cornerRadius: 2)
                                    .stroke(
                                        lvl == level ? level.color : Color.clear,
                                        lineWidth: 1
                                    )
                            )

                        Text(lvl.rawValue)
                            .font(.system(size: 8, weight: lvl == level ? .bold : .regular))
                            .foregroundColor(lvl == level ? level.color : AppColors.textMuted)
                    }
                }
            }
        }
    }

    private func segmentFill(for lvl: ThreatLevel) -> Color {
        if lvl.numericLevel <= level.numericLevel {
            return lvl.numericLevel == level.numericLevel ? level.color : level.color.opacity(0.5)
        }
        return AppColors.cardBackgroundLight
    }
}

#Preview {
    VStack(spacing: AppSpacing.xxl) {
        ReportThreatLevelBar(level: .elevated)
        ReportThreatLevelBar(level: .severe)
        ReportThreatLevelBar(level: .low)
    }
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ResearchCard.swift
================================================================================

//
//  ResearchCard.swift
//  ios
//
//  Molecule: Research report card for horizontal carousel
//

import SwiftUI

struct ResearchCard: View {
    let report: ResearchReport
    var onTap: (() -> Void)?
    var onAskOrRead: (() -> Void)?

    private var gradient: LinearGradient {
        LinearGradient(
            colors: report.gradientColors.map { Color(hex: $0) },
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            VStack(alignment: .leading, spacing: 0) {
                // Header with gradient and logo
                ZStack {
                    gradient
                        .frame(height: 80)

                    // Company Logo Placeholder
                    companyLogoPlaceholder
                }

                // Content
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    // Persona badge and time
                    HStack {
                        PersonaBadge(persona: report.persona)
                        Spacer()
                        Text(report.timeAgo)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                    }

                    // Headline
                    Text(report.headline)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)

                    // Summary
                    Text(report.summary)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(3)
                        .multilineTextAlignment(.leading)

                    Spacer()

                    // Footer
                    HStack {
                        RatingBadge(rating: report.rating)

                        Text("Target: \(report.formattedTargetPrice)")
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)

                        Spacer()

                        Button(action: {
                            onAskOrRead?()
                        }) {
                            Text("Ask or Read")
                                .font(AppTypography.calloutBold)
                                .foregroundColor(AppColors.primaryBlue)
                        }
                    }
                }
                .padding(AppSpacing.md)
                .background(AppColors.cardBackground)
            }
            .frame(width: 260, height: 280)
            .clipShape(RoundedRectangle(cornerRadius: AppCornerRadius.large))
        }
        .buttonStyle(PlainButtonStyle())
    }

    @ViewBuilder
    private var companyLogoPlaceholder: some View {
        // Using system symbols as placeholders for company logos
        switch report.stockTicker {
        case "MSFT":
            Image(systemName: "square.grid.2x2.fill")
                .font(.system(size: 32, weight: .bold))
                .foregroundColor(.white.opacity(0.9))
        case "GOOGL":
            Text("G")
                .font(.system(size: 40, weight: .bold))
                .foregroundColor(.white.opacity(0.9))
        case "AMD":
            Image(systemName: "cpu.fill")
                .font(.system(size: 32, weight: .bold))
                .foregroundColor(.white.opacity(0.9))
        default:
            Text(String(report.stockTicker.prefix(1)))
                .font(.system(size: 40, weight: .bold))
                .foregroundColor(.white.opacity(0.9))
        }
    }
}

#Preview {
    ScrollView(.horizontal, showsIndicators: false) {
        HStack(spacing: 16) {
            ResearchCard(report: ResearchReport(
                stockTicker: "MSFT",
                stockName: "Microsoft",
                companyLogoName: "icon_microsoft",
                persona: .warrenBuffett,
                headline: "Microsoft: The AI Moat Deepens",
                summary: "Azure's AI services and UX Pilot AI partnership position MSFT as a dominant force in enterprise AI.",
                rating: 4.6,
                targetPrice: 425,
                createdAt: Date().addingTimeInterval(-10800),
                gradientColors: ["0078D4", "00BCF2"]
            ))

            ResearchCard(report: ResearchReport(
                stockTicker: "GOOGL",
                stockName: "Google",
                companyLogoName: "icon_google",
                persona: .peterLynch,
                headline: "Google: Gemini's Market Impact",
                summary: "Gemini AI integration across products shows promise. Search market share stable.",
                rating: 4.2,
                targetPrice: 155,
                createdAt: Date().addingTimeInterval(-345600),
                gradientColors: ["4285F4", "34A853"]
            ))
        }
        .padding()
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RevenueBreakdownChartView.swift
================================================================================

//
//  RevenueBreakdownChartView.swift
//  ios
//
//  Molecule: Waterfall chart showing revenue sources and cost breakdown
//  Costs descend from top of revenue; loss companies show negative values
//

import SwiftUI

struct RevenueBreakdownChartView: View {
    let data: RevenueBreakdownData

    private let chartHeight: CGFloat = 320
    private let leftAxisWidth: CGFloat = 50
    private let rightAxisWidth: CGFloat = 50

    // Calculate chart bounds
    private var chartTopValue: Double {
        // Top is always total revenue (or slightly above)
        data.totalRevenue * 1.1
    }

    private var chartBottomValue: Double {
        if data.isProfit {
            // Profitable: bottom is 0
            0
        } else {
            // Loss: bottom extends to show net loss (negative)
            data.netProfit * 1.2 // netProfit is negative, so this goes below 0
        }
    }

    private var chartRange: Double {
        chartTopValue - chartBottomValue
    }

    // Where is the zero line (as fraction from bottom)
    private var zeroLinePosition: CGFloat {
        if data.isProfit {
            return 0 // Zero is at bottom
        } else {
            return CGFloat(abs(chartBottomValue) / chartRange)
        }
    }

    // Grid values for Y-axis
    private var gridValues: [Double] {
        if data.isProfit {
            let maxVal = chartTopValue
            return [0, maxVal * 0.25, maxVal * 0.5, maxVal * 0.75, maxVal]
        } else {
            // Include negative values
            let step = chartRange / 4
            return [
                chartBottomValue,
                chartBottomValue + step,
                chartBottomValue + step * 2,
                chartBottomValue + step * 3,
                chartTopValue
            ]
        }
    }

    // Percentage labels
    private var percentageLabels: [String] {
        if data.isProfit {
            return ["0%", "25%", "50%", "75%", "100%"]
        } else {
            // Calculate percentage relative to revenue
            let bottomPercent = Int((chartBottomValue / data.totalRevenue) * 100)
            return [
                "\(bottomPercent)%",
                "\(bottomPercent / 4 * 3)%",
                "\(bottomPercent / 2)%",
                "\(bottomPercent / 4)%",
                "100%"
            ]
        }
    }

    var body: some View {
        HStack(alignment: .top, spacing: 0) {
            // Left Y-axis (absolute values)
            leftYAxis
                .frame(width: leftAxisWidth)

            // Main chart
            chartContent
                .frame(height: chartHeight)

            // Right Y-axis (percentages)
            rightYAxis
                .frame(width: rightAxisWidth)
        }
    }

    // MARK: - Left Y-Axis

    private var leftYAxis: some View {
        VStack {
            ForEach(gridValues.reversed(), id: \.self) { value in
                Text(formatLargeNumber(value))
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                if value != gridValues.first {
                    Spacer()
                }
            }
        }
        .frame(height: chartHeight)
        .padding(.trailing, AppSpacing.xs)
    }

    // MARK: - Right Y-Axis

    private var rightYAxis: some View {
        VStack {
            ForEach(percentageLabels.reversed(), id: \.self) { label in
                Text(label)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                if label != percentageLabels.first {
                    Spacer()
                }
            }
        }
        .frame(height: chartHeight)
        .padding(.leading, AppSpacing.xs)
    }

    // MARK: - Chart Content

    private var chartContent: some View {
        GeometryReader { geometry in
            let width = geometry.size.width
            let height = geometry.size.height
            let barWidth: CGFloat = 55  // Reduced from 70 to 55

            ZStack(alignment: .topLeading) {
                // Grid lines
                gridLines(height: height)

                // Zero line for loss companies
                if !data.isProfit {
                    zeroLine(height: height)
                }

                // Revenue stacked bar (left side) - grows UP from zero/bottom
                revenueStackedBar(height: height, barWidth: barWidth)
                    .position(x: width * 0.22, y: height / 2)

                // Cost waterfall bar (center) - descends FROM TOP
                costWaterfallBar(height: height, barWidth: barWidth)
                    .position(x: width * 0.50, y: height / 2)

                // Net profit/loss bar (right side)
                netProfitBar(height: height, barWidth: barWidth)
                    .position(x: width * 0.78, y: height / 2)
            }
        }
    }

    // MARK: - Grid Lines

    private func gridLines(height: CGFloat) -> some View {
        VStack(spacing: 0) {
            ForEach(0..<5) { index in
                Rectangle()
                    .fill(AppColors.cardBackgroundLight.opacity(0.5))
                    .frame(height: 0.5)
                if index < 4 {
                    Spacer()
                }
            }
        }
        .frame(height: height)
    }

    // MARK: - Zero Line (for loss companies)

    private func zeroLine(height: CGFloat) -> some View {
        let zeroY = height * (1 - zeroLinePosition)

        return Rectangle()
            .fill(AppColors.textMuted.opacity(0.8))
            .frame(height: 1)
            .offset(y: zeroY)
    }

    // MARK: - Revenue Stacked Bar

    private func revenueStackedBar(height: CGFloat, barWidth: CGFloat) -> some View {
        let revenueBarHeight = CGFloat(data.totalRevenue / chartRange) * height
        let zeroOffset = zeroLinePosition * height // Distance from bottom to zero line

        // Calculate segment heights proportionally within the revenue bar
        let segments: [(color: Color, height: CGFloat)] = data.revenueSources.map { source in
            (source.color, CGFloat(source.value / data.totalRevenue) * revenueBarHeight)
        }

        return VStack(spacing: 0) {
            Spacer()

            VStack(spacing: 0) {
                ForEach(0..<segments.count, id: \.self) { index in
                    Rectangle()
                        .fill(segments[index].color)
                        .frame(width: barWidth, height: segments[index].height)
                }
            }
            .clipShape(
                UnevenRoundedRectangle(
                    topLeadingRadius: 6,
                    bottomLeadingRadius: 0,
                    bottomTrailingRadius: 0,
                    topTrailingRadius: 6
                )
            )

            // Offset for zero line position
            if !data.isProfit {
                Spacer().frame(height: zeroOffset)
            }
        }
        .frame(height: height)
    }

    // MARK: - Cost Waterfall Bar (descends from top)

    private func costWaterfallBar(height: CGFloat, barWidth: CGFloat) -> some View {
        let pixelsPerUnit = height / chartRange

        // Calculate heights
        let costOfSalesHeight = CGFloat(data.costOfSales) * pixelsPerUnit
        let opExpenseHeight = CGFloat(data.operatingExpense) * pixelsPerUnit
        let taxHeight = CGFloat(data.tax) * pixelsPerUnit

        // Top of cost bar aligns with top of revenue bar
        let revenueTopY = CGFloat(chartTopValue - data.totalRevenue) * pixelsPerUnit

        return VStack(spacing: 0) {
            // Space above the cost bar (aligns with revenue top)
            Spacer().frame(height: revenueTopY)

            // Cost segments descending from revenue top
            VStack(spacing: 0) {
                // Cost of Sales (starts at top, where revenue ends)
                Rectangle()
                    .fill(Color(hex: "EF4444"))
                    .frame(width: barWidth, height: costOfSalesHeight)

                // Operating Expense
                Rectangle()
                    .fill(Color(hex: "F87171"))
                    .frame(width: barWidth, height: opExpenseHeight)

                // Tax
                Rectangle()
                    .fill(Color(hex: "FCA5A5"))
                    .frame(width: barWidth, height: taxHeight)
            }
            .clipShape(
                UnevenRoundedRectangle(
                    topLeadingRadius: 6,
                    bottomLeadingRadius: data.isProfit ? 0 : 6,
                    bottomTrailingRadius: data.isProfit ? 0 : 6,
                    topTrailingRadius: 6
                )
            )

            Spacer()
        }
        .frame(height: height)
    }

    // MARK: - Net Profit/Loss Bar

    private func netProfitBar(height: CGFloat, barWidth: CGFloat) -> some View {
        let pixelsPerUnit = height / chartRange
        let netProfitHeight = CGFloat(abs(data.netProfit)) * pixelsPerUnit

        if data.isProfit {
            // Profit bar - grows up from zero (bottom)
            return AnyView(
                VStack(spacing: 0) {
                    Spacer()

                    VStack(spacing: 2) {
                        Text("Net Profit")
                            .font(.system(size: 10))
                            .foregroundColor(AppColors.textMuted)

                        Rectangle()
                            .fill(AppColors.bullish)
                            .frame(width: barWidth, height: netProfitHeight)
                            .clipShape(
                                UnevenRoundedRectangle(
                                    topLeadingRadius: 6,
                                    bottomLeadingRadius: 0,
                                    bottomTrailingRadius: 0,
                                    topTrailingRadius: 6
                                )
                            )
                    }
                }
                .frame(height: height)
            )
        } else {
            // Loss bar - goes below zero line
            let zeroY = height * (1 - zeroLinePosition)

            return AnyView(
                VStack(spacing: 0) {
                    Spacer().frame(height: zeroY)

                    VStack(spacing: 2) {
                        Rectangle()
                            .fill(Color(hex: "8B0000"))
                            .frame(width: barWidth, height: netProfitHeight)
                            .clipShape(
                                UnevenRoundedRectangle(
                                    topLeadingRadius: 0,
                                    bottomLeadingRadius: 6,
                                    bottomTrailingRadius: 6,
                                    topTrailingRadius: 0
                                )
                            )

                        Text("-Net Loss")
                            .font(.system(size: 10))
                            .foregroundColor(AppColors.textMuted)
                    }

                    Spacer()
                }
                .frame(height: height)
            )
        }
    }

    // MARK: - Helper Functions

    private func formatLargeNumber(_ number: Double) -> String {
        let absNumber = abs(number)
        let sign = number < 0 ? "-" : ""

        if absNumber >= 1_000_000_000_000 {
            return sign + String(format: "%.0fT", absNumber / 1_000_000_000_000)
        } else if absNumber >= 1_000_000_000 {
            return sign + String(format: "%.0fB", absNumber / 1_000_000_000)
        } else if absNumber >= 1_000_000 {
            return sign + String(format: "%.0fM", absNumber / 1_000_000)
        } else if absNumber >= 1_000 {
            return sign + String(format: "%.0fK", absNumber / 1_000)
        }
        return String(format: "%.0f", number)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            VStack(spacing: AppSpacing.xxl) {
                Text("Profitable Company (Apple)")
                    .foregroundColor(.white)
                    .font(AppTypography.headline)

                RevenueBreakdownChartView(data: RevenueBreakdownData.sampleApple)
                    .padding()
                    .background(AppColors.cardBackground)
                    .cornerRadius(AppCornerRadius.large)

                Divider()
                    .background(AppColors.textMuted)

                Text("Loss-Making Company (Rivian)")
                    .foregroundColor(.white)
                    .font(AppTypography.headline)

                RevenueBreakdownChartView(data: RevenueBreakdownData.sampleLossCompany)
                    .padding()
                    .background(AppColors.cardBackground)
                    .cornerRadius(AppCornerRadius.large)
            }
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RevenueBreakdownInfoSheet.swift
================================================================================

//
//  RevenueBreakdownInfoSheet.swift
//  ios
//
//  Molecule: Info sheet explaining revenue breakdown for value investors
//

import SwiftUI

struct RevenueBreakdownInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xl) {
                    // Header explanation
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        Text("Understanding Revenue Breakdown")
                            .font(AppTypography.title2)
                            .foregroundColor(AppColors.textPrimary)

                        Text("This chart shows how a company generates revenue and where the money goes. Understanding these flows helps assess business quality and profitability.")
                            .font(AppTypography.body)
                            .foregroundColor(AppColors.textSecondary)
                    }
                    .padding(.bottom, AppSpacing.md)

                    // Chart explanation
                    chartExplanation

                    Divider()
                        .background(AppColors.cardBackgroundLight)

                    // Educational content
                    ForEach(RevenueBreakdownInfoItem.educationalContent) { item in
                        infoCard(item: item)
                    }

                    // Key ratios section
                    keyRatiosSection

                    Spacer()
                        .frame(height: AppSpacing.xxxl)
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
    }

    // MARK: - Chart Explanation

    private var chartExplanation: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("Reading the Chart")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                explanationRow(
                    color: RevenueSource.iPhoneColor,
                    title: "Left Bar (Stacked)",
                    description: "Shows all revenue sources stacked. Height represents total revenue."
                )

                explanationRow(
                    color: Color(hex: "EF4444"),
                    title: "Middle Bars (Waterfall)",
                    description: "Shows costs being subtracted from revenue: Cost of Sales, Operating Expenses, and Taxes."
                )

                explanationRow(
                    color: AppColors.bullish,
                    title: "Right Bar (Result)",
                    description: "Green = Net Profit (what's left after all costs). Red = Net Loss (costs exceeded revenue)."
                )
            }
        }
    }

    private func explanationRow(color: Color, title: String, description: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Circle()
                .fill(color)
                .frame(width: 12, height: 12)
                .padding(.top, 4)

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.footnote)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
    }

    // MARK: - Info Card

    private func infoCard(item: RevenueBreakdownInfoItem) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Image(systemName: item.icon)
                .font(.system(size: 24))
                .foregroundColor(AppColors.primaryBlue)
                .frame(width: 32)

            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(item.title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(item.description)
                    .font(AppTypography.footnote)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Key Ratios Section

    private var keyRatiosSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("Key Profitability Ratios")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.sm) {
                ratioRow(
                    name: "Gross Margin",
                    formula: "(Revenue - Cost of Sales) / Revenue",
                    benchmark: "Tech: 50-70%, Retail: 20-40%"
                )

                ratioRow(
                    name: "Operating Margin",
                    formula: "Operating Profit / Revenue",
                    benchmark: "Tech: 20-35%, Manufacturing: 5-15%"
                )

                ratioRow(
                    name: "Net Profit Margin",
                    formula: "Net Profit / Revenue",
                    benchmark: "Healthy: 10-20%, Excellent: >20%"
                )
            }
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    private func ratioRow(name: String, formula: String, benchmark: String) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.xxs) {
            Text(name)
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textPrimary)

            Text(formula)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
                .italic()

            Text(benchmark)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.accentCyan)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(.vertical, AppSpacing.xs)
    }
}

#Preview {
    RevenueBreakdownInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RevenueBreakdownLegendView.swift
================================================================================

//
//  RevenueBreakdownLegendView.swift
//  ios
//
//  Molecule: Two-column legend showing revenue sources and costs/profit
//

import SwiftUI

struct RevenueBreakdownLegendView: View {
    let data: RevenueBreakdownData

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.xl) {
            // Revenue Sources Column
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                Text("Revenue Sources")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)
                    .padding(.bottom, AppSpacing.xs)

                ForEach(data.revenueSources) { source in
                    RevenueBreakdownLegendItem(
                        color: source.color,
                        name: source.name,
                        value: source.formattedValue,
                        percentage: source.formattedPercentage(of: data.totalRevenue)
                    )
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)

            // Costs & Profit Column
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                Text("Costs & Profit")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)
                    .padding(.bottom, AppSpacing.xs)

                ForEach(data.costItems) { item in
                    RevenueBreakdownLegendItem(
                        color: item.color,
                        name: item.name,
                        value: item.formattedValue,
                        percentage: item.formattedPercentage(of: data.totalRevenue)
                    )
                }

                // Net Profit/Loss
                RevenueBreakdownLegendItem(
                    color: data.netProfitColor,
                    name: data.netProfitLabel,
                    value: data.formattedNetProfit,
                    percentage: String(format: "%.0f%%", data.netProfitPercentage())
                )
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xxl) {
            RevenueBreakdownLegendView(data: RevenueBreakdownData.sampleApple)
                .padding()

            Divider()

            RevenueBreakdownLegendView(data: RevenueBreakdownData.sampleLossCompany)
                .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RiskFactorRow.swift
================================================================================

//
//  RiskFactorRow.swift
//  ios
//
//  Molecule: Single risk factor row with icon, description, and impact badge
//

import SwiftUI

struct RiskFactorRow: View {
    let factor: RiskFactor

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            // Header with icon and title
            HStack(alignment: .top, spacing: AppSpacing.md) {
                // Icon
                ZStack {
                    Circle()
                        .fill(factor.iconColor.opacity(0.15))
                        .frame(width: 36, height: 36)

                    Image(systemName: factor.iconName)
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(factor.iconColor)
                }

                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text(factor.title)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text(factor.description)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .fixedSize(horizontal: false, vertical: true)
                }
            }

            // Impact badge
            ImpactBadge(level: factor.impactLevel)
                .padding(.leading, 36 + AppSpacing.md)
        }
        .padding(AppSpacing.md)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        RiskFactorRow(factor: RiskFactor(
            iconName: "exclamationmark.triangle.fill",
            iconColor: AppColors.bearish,
            title: "Market Competition",
            description: "Traditional automakers and new EV startups intensifying competition globally",
            impactLevel: .high
        ))

        RiskFactorRow(factor: RiskFactor(
            iconName: "doc.text.fill",
            iconColor: AppColors.neutral,
            title: "Regulatory Changes",
            description: "Potential changes in EV subsidies and environmental regulations",
            impactLevel: .medium
        ))

        RiskFactorRow(factor: RiskFactor(
            iconName: "dollarsign.circle.fill",
            iconColor: AppColors.primaryBlue,
            title: "Valuation Concerns",
            description: "High P/E ratio compared to traditional automakers",
            impactLevel: .variable
        ))
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/RiskFactorsCard.swift
================================================================================

//
//  RiskFactorsCard.swift
//  ios
//
//  Molecule: Card containing multiple risk factors
//

import SwiftUI

struct RiskFactorsCard: View {
    let data: RiskFactorsData

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            ForEach(data.factors) { factor in
                RiskFactorRow(factor: factor)
            }
        }
    }
}

#Preview {
    RiskFactorsCard(
        data: RiskFactorsData(
            introText: "",
            factors: [
                RiskFactor(
                    iconName: "exclamationmark.triangle.fill",
                    iconColor: AppColors.bearish,
                    title: "Market Competition",
                    description: "Traditional automakers and new EV startups intensifying competition globally",
                    impactLevel: .high
                ),
                RiskFactor(
                    iconName: "doc.text.fill",
                    iconColor: AppColors.neutral,
                    title: "Regulatory Changes",
                    description: "Potential changes in EV subsidies and environmental regulations",
                    impactLevel: .medium
                )
            ]
        )
    )
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SearchBar.swift
================================================================================

//
//  SearchBar.swift
//  ios
//
//  Molecule: Search bar component
//

import SwiftUI

struct SearchBar: View {
    @Binding var text: String
    var placeholder: String = "Search ticker or ask AI..."
    var onSubmit: (() -> Void)?

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            Image(systemName: "magnifyingglass")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(AppColors.textMuted)

            TextField("", text: $text, prompt: Text(placeholder)
                .foregroundColor(AppColors.textMuted))
                .font(AppTypography.body)
                .foregroundColor(AppColors.textPrimary)
                .autocorrectionDisabled()
                .textInputAutocapitalization(.never)
                .onSubmit {
                    onSubmit?()
                }
        }
        .padding(.horizontal, AppSpacing.md)
        .padding(.vertical, AppSpacing.md)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    VStack {
        SearchBar(text: .constant(""))
        SearchBar(text: .constant("AAPL"))
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SearchBookCard.swift
================================================================================

//
//  SearchBookCard.swift
//  ios
//
//  Molecule: Card displaying a book in search results with AI actions
//

import SwiftUI

struct SearchBookCard: View {
    let book: SearchBookItem
    var onChatWithBook: (() -> Void)?
    var onReadKeyIdeas: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            HStack(alignment: .top, spacing: AppSpacing.lg) {
                // Book cover
                ZStack {
                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                        .fill(bookCoverGradient)
                        .frame(width: 80, height: 110)

                    // Book image overlay
                    Image(book.coverImageName)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: 80, height: 110)
                        .clipShape(RoundedRectangle(cornerRadius: AppCornerRadius.medium))

                    // Fallback title if no image
                    VStack {
                        Text(book.title.uppercased())
                            .font(.system(size: 8, weight: .bold))
                            .foregroundColor(.white)
                            .multilineTextAlignment(.center)
                            .lineLimit(3)
                            .padding(.horizontal, AppSpacing.xs)
                    }
                    .frame(width: 80, height: 110)
                    .opacity(0) // Hidden when image loads
                }

                // Book details
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    // Title and rating
                    HStack(alignment: .top) {
                        Text(book.title)
                            .font(AppTypography.headline)
                            .foregroundColor(AppColors.textPrimary)
                            .lineLimit(2)

                        Spacer()

                        // Rating badge
                        HStack(spacing: AppSpacing.xxs) {
                            Image(systemName: "star.fill")
                                .font(.system(size: 12))
                                .foregroundColor(AppColors.neutral)

                            Text(book.formattedRating)
                                .font(AppTypography.footnoteBold)
                                .foregroundColor(AppColors.textPrimary)
                        }
                        .padding(.horizontal, AppSpacing.sm)
                        .padding(.vertical, AppSpacing.xs)
                        .background(AppColors.cardBackgroundLight)
                        .cornerRadius(AppCornerRadius.small)
                    }

                    // Author
                    Text(book.author)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)

                    // Description
                    Text(book.description)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(2)

                    // Meta info
                    HStack(spacing: AppSpacing.md) {
                        Image(systemName: "book.closed.fill")
                            .font(.system(size: 10))
                            .foregroundColor(AppColors.textMuted)

                        Text(book.formattedPages)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)

                        Text("â€¢")
                            .foregroundColor(AppColors.textMuted)

                        Text(book.formattedPublished)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                    }
                }
            }

            // Action buttons
            HStack(spacing: AppSpacing.md) {
                Button(action: {
                    onChatWithBook?()
                }) {
                    HStack(spacing: AppSpacing.sm) {
                        Image(systemName: "bubble.left.fill")
                            .font(.system(size: 12))

                        Text("Chat with Book")
                            .font(AppTypography.calloutBold)
                    }
                    .foregroundColor(AppColors.textPrimary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, AppSpacing.md)
                    .background(AppColors.cardBackgroundLight)
                    .cornerRadius(AppCornerRadius.medium)
                }
                .buttonStyle(PlainButtonStyle())

                Button(action: {
                    onReadKeyIdeas?()
                }) {
                    HStack(spacing: AppSpacing.sm) {
                        Image(systemName: "lightbulb.fill")
                            .font(.system(size: 12))

                        Text("Read Key Ideas")
                            .font(AppTypography.calloutBold)
                    }
                    .foregroundColor(AppColors.primaryBlue)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, AppSpacing.md)
                    .background(AppColors.primaryBlue.opacity(0.15))
                    .cornerRadius(AppCornerRadius.medium)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.extraLarge)
    }

    private var bookCoverGradient: LinearGradient {
        let colors: [Color]
        switch book.title {
        case "The Intelligent Investor":
            colors = [Color(hex: "1E3A5F"), Color(hex: "0F1F35")]
        case "One Up On Wall Street":
            colors = [Color(hex: "2D4A3E"), Color(hex: "1A2D25")]
        case "Common Stocks and Uncommon Profits":
            colors = [Color(hex: "4A1E1E"), Color(hex: "2D1212")]
        default:
            colors = [Color(hex: "3B3B5C"), Color(hex: "1E1E2E")]
        }

        return LinearGradient(
            colors: colors,
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.lg) {
            ForEach(SearchBookItem.sampleData) { book in
                SearchBookCard(book: book)
            }
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SearchNewsCard.swift
================================================================================

//
//  SearchNewsCard.swift
//  ios
//
//  Molecule: Card displaying a news item in search results
//

import SwiftUI

struct SearchNewsCard: View {
    let item: SearchNewsItem
    var onTap: (() -> Void)?
    var onReadMore: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            VStack(alignment: .leading, spacing: AppSpacing.md) {
                HStack(alignment: .top, spacing: AppSpacing.md) {
                    // News thumbnail
                    ZStack {
                        RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                            .fill(AppColors.cardBackgroundLight)
                            .frame(width: 80, height: 80)

                        Image(item.imageName)
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: 80, height: 80)
                            .clipShape(RoundedRectangle(cornerRadius: AppCornerRadius.medium))
                    }

                    VStack(alignment: .leading, spacing: AppSpacing.xs) {
                        // Source and time
                        HStack(spacing: AppSpacing.sm) {
                            Text(item.source)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textSecondary)

                            Text(item.timeAgo)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textMuted)
                        }

                        // Headline
                        Text(item.headline)
                            .font(AppTypography.bodyBold)
                            .foregroundColor(AppColors.textPrimary)
                            .lineLimit(2)
                            .multilineTextAlignment(.leading)

                        // Summary
                        Text(item.summary)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)
                            .lineLimit(3)
                            .multilineTextAlignment(.leading)
                    }
                }

                // Read More link
                Button(action: {
                    onReadMore?()
                }) {
                    Text(item.readMoreAction)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.bearish)
                }
                .buttonStyle(PlainButtonStyle())
            }
            .padding(AppSpacing.lg)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.md) {
            ForEach(SearchNewsItem.sampleData) { item in
                SearchNewsCard(item: item)
            }
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SearchQueryChip.swift
================================================================================

//
//  SearchQueryChip.swift
//  ios
//
//  Molecule: Chip showing a search query suggestion
//

import SwiftUI

struct SearchQueryChip: View {
    let suggestion: SearchQuerySuggestion
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.sm) {
                if let iconName = suggestion.iconName {
                    Image(systemName: iconName)
                        .font(.system(size: 12))
                        .foregroundColor(AppColors.textSecondary)
                }

                Text(suggestion.text)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
            }
            .padding(.horizontal, AppSpacing.md)
            .padding(.vertical, AppSpacing.sm)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.pill)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ScrollView(.horizontal, showsIndicators: false) {
        HStack(spacing: AppSpacing.sm) {
            ForEach(SearchQuerySuggestion.sampleData) { suggestion in
                SearchQueryChip(suggestion: suggestion)
            }
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SearchResultRow.swift
================================================================================

//
//  SearchResultRow.swift
//  ios
//
//  Molecule: Row displaying a search result item (stock or person)
//

import SwiftUI

struct SearchResultRow: View {
    let item: SearchResultItem
    var onTap: (() -> Void)?
    var onFollowTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.md) {
                // Leading icon or image
                leadingView

                // Name and subtitle
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text(item.name)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text(item.subtitle)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                // Trailing action
                trailingView
            }
            .padding(.vertical, AppSpacing.md)
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
    }

    @ViewBuilder
    private var leadingView: some View {
        if item.hasProfileImage {
            // Person avatar
            ZStack {
                Circle()
                    .fill(AppColors.cardBackgroundLight)
                    .frame(width: 44, height: 44)

                if let imageName = item.imageName {
                    Image(imageName)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: 44, height: 44)
                        .clipShape(Circle())
                } else {
                    Image(systemName: "person.fill")
                        .font(.system(size: 20))
                        .foregroundColor(AppColors.textSecondary)
                }
            }
        } else if let ticker = item.ticker {
            // Stock ticker badge
            ZStack {
                RoundedRectangle(cornerRadius: AppCornerRadius.small)
                    .fill(tickerBackgroundColor(for: ticker))
                    .frame(width: 44, height: 44)

                Text(ticker)
                    .font(AppTypography.captionBold)
                    .foregroundColor(.white)
            }
        }
    }

    @ViewBuilder
    private var trailingView: some View {
        if item.isFollowable {
            FollowButton(isFollowing: item.isFollowing) {
                onFollowTap?()
            }
        } else {
            Image(systemName: "chevron.right")
                .font(.system(size: 14, weight: .semibold))
                .foregroundColor(AppColors.textMuted)
        }
    }

    private func tickerBackgroundColor(for ticker: String) -> Color {
        switch ticker {
        case "AAPL":
            return Color(hex: "1E1E1E") // Dark gray/black for Apple
        case "TSLA":
            return Color(hex: "CC0000") // Tesla red
        case "MSFT":
            return Color(hex: "00A4EF") // Microsoft blue
        case "GOOGL", "GOOG":
            return Color(hex: "4285F4") // Google blue
        case "AMZN":
            return Color(hex: "FF9900") // Amazon orange
        case "NVDA":
            return Color(hex: "76B900") // Nvidia green
        default:
            return AppColors.primaryBlue
        }
    }
}

#Preview {
    VStack(spacing: 0) {
        ForEach(SearchResultItem.sampleData) { item in
            SearchResultRow(item: item)
            Divider()
                .background(AppColors.cardBackgroundLight)
        }
    }
    .padding(.horizontal, AppSpacing.lg)
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SectorIndustryRow.swift
================================================================================

//
//  SectorIndustryRow.swift
//  ios
//
//  Molecule: Row displaying sector/industry information
//

import SwiftUI

struct SectorIndustryRow: View {
    let label: String
    let value: String
    var valueColor: Color? = nil
    var isLink: Bool = false

    var body: some View {
        HStack {
            Text(label)
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textSecondary)

            Spacer()

            Text(value)
                .font(AppTypography.footnoteBold)
                .foregroundColor(valueColor ?? AppColors.textPrimary)
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.md) {
        SectorIndustryRow(label: "Sector", value: "Technology")
        SectorIndustryRow(label: "Industry", value: "Consumer Electronics")
        SectorIndustryRow(label: "Sector Performance", value: "+2.87%", valueColor: AppColors.bullish)
        SectorIndustryRow(label: "Industry Rank", value: "#1 of 42")
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SentimentAnalysisCard.swift
================================================================================

//
//  SentimentAnalysisCard.swift
//  ios
//
//  Molecule: Sentiment analysis card with overall score and bullet points
//

import SwiftUI

struct SentimentAnalysisCard: View {
    let analysis: SentimentAnalysis

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header row
            HStack {
                Text("OVERALL SENTIMENT")
                    .font(AppTypography.captionBold)
                    .foregroundColor(AppColors.textSecondary)

                Spacer()

                SentimentPercentageBadge(
                    sentiment: analysis.overallSentiment,
                    percentage: analysis.percentage
                )
            }

            // Bullet points
            VStack(alignment: .leading, spacing: AppSpacing.md) {
                ForEach(analysis.bulletPoints) { bulletPoint in
                    BulletPointRow(bulletPoint: bulletPoint)
                }
            }

            // Data updated text
            Text(analysis.dataUpdatedText)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    SentimentAnalysisCard(
        analysis: SentimentAnalysis(
            overallSentiment: .bullish,
            percentage: 68,
            bulletPoints: [
                ChatBulletPoint(text: "Strong delivery numbers exceeded expectations in Q4", indicatorType: .success),
                ChatBulletPoint(text: "Cybertruck production ramping up successfully", indicatorType: .success),
                ChatBulletPoint(text: "Competition intensifying in EV market", indicatorType: .warning),
                ChatBulletPoint(text: "Analyst price targets range from $180-$350", indicatorType: .info)
            ],
            dataUpdatedText: "Data updated 5 minutes ago"
        )
    )
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SentimentMetricsRow.swift
================================================================================

//
//  SentimentMetricsRow.swift
//  ios
//
//  Row displaying social mentions and news articles metrics
//

import SwiftUI

struct SentimentMetricsRow: View {
    let sentimentData: SentimentAnalysisData

    var body: some View {
        HStack(spacing: AppSpacing.lg) {
            // Social Mentions
            SentimentMetricCard(
                iconName: "bubble.left.and.bubble.right.fill",
                title: "Social Mentions",
                value: sentimentData.formattedSocialMentions,
                change: sentimentData.formattedSocialChange,
                changeColor: sentimentData.socialChangeColor
            )

            // News Articles
            SentimentMetricCard(
                iconName: "newspaper.fill",
                title: "News Articles",
                value: sentimentData.formattedNewsArticles,
                change: sentimentData.formattedNewsChange,
                changeColor: sentimentData.newsChangeColor
            )
        }
    }
}

// MARK: - Single Metric Card
struct SentimentMetricCard: View {
    let iconName: String
    let title: String
    let value: String
    let change: String
    let changeColor: Color

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.xs) {
                Image(systemName: iconName)
                    .font(.system(size: 12))
                    .foregroundColor(AppColors.textSecondary)

                Text(title)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            Text(value)
                .font(AppTypography.title2)
                .fontWeight(.bold)
                .foregroundColor(AppColors.textPrimary)

            Text(change)
                .font(AppTypography.caption)
                .foregroundColor(changeColor)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(AppSpacing.md)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
        .overlay(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .stroke(AppColors.cardBackgroundLight, lineWidth: 1)
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        SentimentMetricsRow(sentimentData: SentimentAnalysisData.sampleData)
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ShareholderBreakdownBar.swift
================================================================================

//
//  ShareholderBreakdownBar.swift
//  ios
//
//  Molecule: Horizontal stacked bar chart showing shareholder breakdown
//  Displays insiders, institutions, and public/other ownership percentages
//

import SwiftUI

struct ShareholderBreakdownBar: View {
    let insidersPercent: Double
    let institutionsPercent: Double
    let publicOtherPercent: Double

    // Configuration
    private let barHeight: CGFloat = 14
    private let cornerRadius: CGFloat = 7

    var body: some View {
        GeometryReader { geometry in
            HStack(spacing: 0) {
                // Insiders segment (Orange)
                if insidersPercent > 0 {
                    RoundedRectangle(cornerRadius: 0)
                        .fill(HoldersColors.insiders)
                        .frame(width: segmentWidth(for: insidersPercent, totalWidth: geometry.size.width))
                }

                // Institutions segment (Blue)
                if institutionsPercent > 0 {
                    Rectangle()
                        .fill(HoldersColors.institutions)
                        .frame(width: segmentWidth(for: institutionsPercent, totalWidth: geometry.size.width))
                }

                // Public/Other segment (Gray)
                if publicOtherPercent > 0 {
                    Rectangle()
                        .fill(HoldersColors.publicOther)
                        .frame(width: segmentWidth(for: publicOtherPercent, totalWidth: geometry.size.width))
                }
            }
            .frame(height: barHeight)
            .clipShape(RoundedRectangle(cornerRadius: cornerRadius))
        }
        .frame(height: barHeight)
    }

    private func segmentWidth(for percent: Double, totalWidth: CGFloat) -> CGFloat {
        let total = insidersPercent + institutionsPercent + publicOtherPercent
        guard total > 0 else { return 0 }
        return (percent / total) * totalWidth
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            // Sample from design
            ShareholderBreakdownBar(
                insidersPercent: 12,
                institutionsPercent: 55,
                publicOtherPercent: 33
            )

            // More insider-heavy
            ShareholderBreakdownBar(
                insidersPercent: 45,
                institutionsPercent: 35,
                publicOtherPercent: 20
            )

            // Institution-dominated
            ShareholderBreakdownBar(
                insidersPercent: 5,
                institutionsPercent: 85,
                publicOtherPercent: 10
            )
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/ShareholderBreakdownInfoSheet.swift
================================================================================

//
//  ShareholderBreakdownInfoSheet.swift
//  ios
//
//  Molecule: Educational sheet explaining shareholder breakdown
//  Helps novice investors understand ownership distribution
//

import SwiftUI

struct ShareholderBreakdownInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xl) {
                    // Header
                    headerSection

                    // Ownership Types
                    ownershipTypesSection

                    // What to Look For
                    whatToLookForSection

                    // Examples
                    examplesSection
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("Shareholder Breakdown")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "person.3.fill")
                    .font(.system(size: 24))
                    .foregroundColor(AppColors.primaryBlue)

                Text("Who Owns the Company?")
                    .font(AppTypography.title2)
                    .foregroundColor(AppColors.textPrimary)
            }

            Text("Understanding who owns a company's stock can reveal important insights about stability, confidence, and potential price movements.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(AppSpacing.lg)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Ownership Types Section

    private var ownershipTypesSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Ownership Types")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                ownershipCard(
                    color: HoldersColors.insiders,
                    title: "Insiders",
                    percentage: "Typically 5-20%",
                    description: "Company executives, directors, and employees who own shares.",
                    bullish: "High insider ownership signals management believes in the company's future.",
                    bearish: "Very low insider ownership may indicate lack of confidence."
                )

                ownershipCard(
                    color: HoldersColors.institutions,
                    title: "Institutions",
                    percentage: "Typically 40-80%",
                    description: "Large investment firms like mutual funds, pension funds, and hedge funds.",
                    bullish: "High institutional ownership means professionals see value.",
                    bearish: "Too high (>90%) can mean crowded trade with limited upside."
                )

                ownershipCard(
                    color: HoldersColors.publicOther,
                    title: "Public/Other",
                    percentage: "Typically 10-40%",
                    description: "Individual retail investors and smaller holders.",
                    bullish: "Balanced retail interest provides liquidity.",
                    bearish: "Very high retail can mean more volatility."
                )
            }
        }
    }

    private func ownershipCard(
        color: Color,
        title: String,
        percentage: String,
        description: String,
        bullish: String,
        bearish: String
    ) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.sm) {
                Circle()
                    .fill(color)
                    .frame(width: 12, height: 12)

                Text(title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Text(percentage)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }

            Text(description)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                HStack(alignment: .top, spacing: AppSpacing.xs) {
                    Image(systemName: "arrow.up.circle.fill")
                        .font(.system(size: 12))
                        .foregroundColor(AppColors.bullish)
                    Text(bullish)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .fixedSize(horizontal: false, vertical: true)
                }

                HStack(alignment: .top, spacing: AppSpacing.xs) {
                    Image(systemName: "arrow.down.circle.fill")
                        .font(.system(size: 12))
                        .foregroundColor(AppColors.bearish)
                    Text(bearish)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .fixedSize(horizontal: false, vertical: true)
                }
            }
            .padding(.top, AppSpacing.xs)
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - What to Look For Section

    private var whatToLookForSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("What to Look For")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                tipRow(
                    icon: "checkmark.circle.fill",
                    iconColor: AppColors.bullish,
                    title: "Healthy Balance",
                    description: "A mix of insider (10-15%), institutional (50-70%), and public ownership often indicates a stable, well-regarded company."
                )

                tipRow(
                    icon: "exclamationmark.triangle.fill",
                    iconColor: AppColors.neutral,
                    title: "Watch for Extremes",
                    description: "Very high or very low ownership in any category can be a warning sign worth investigating further."
                )

                tipRow(
                    icon: "arrow.triangle.2.circlepath",
                    iconColor: AppColors.primaryBlue,
                    title: "Track Changes Over Time",
                    description: "Rising institutional ownership is often bullish. Declining insider ownership may warrant attention."
                )
            }
        }
    }

    private func tipRow(icon: String, iconColor: Color, title: String, description: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Image(systemName: icon)
                .font(.system(size: 20))
                .foregroundColor(iconColor)
                .frame(width: 24)

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Examples Section

    private var examplesSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Real-World Examples")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                exampleCard(
                    company: "Apple (AAPL)",
                    breakdown: "Insiders: 0.1% | Institutions: 60% | Public: 40%",
                    insight: "Very low insider ownership is normal for mega-caps where founders have diversified over decades."
                )

                exampleCard(
                    company: "Berkshire Hathaway",
                    breakdown: "Insiders: 38% | Institutions: 30% | Public: 32%",
                    insight: "High insider ownership (Warren Buffett) signals strong alignment with shareholders."
                )
            }
        }
    }

    private func exampleCard(company: String, breakdown: String, insight: String) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            Text(company)
                .font(AppTypography.bodyBold)
                .foregroundColor(AppColors.textPrimary)

            Text(breakdown)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Text(insight)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    ShareholderBreakdownInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SignalOfConfidenceChartView.swift
================================================================================

//
//  SignalOfConfidenceChartView.swift
//  ios
//
//  Molecule: Combined bar and line chart for Signal of Confidence using Swift Charts
//  Displays dividends (bars), buybacks (bars), and shares outstanding (line)
//

import SwiftUI
import Charts

struct SignalOfConfidenceChartView: View {
    let dataPoints: [SignalOfConfidenceDataPoint]
    let viewType: SignalOfConfidenceViewType

    // Chart configuration
    private let chartHeight: CGFloat = 280
    private let yAxisWidth: CGFloat = 40
    private let rightYAxisWidth: CGFloat = 45

    // MARK: - Computed Properties

    private var maxBarValue: Double {
        switch viewType {
        case .yield:
            let maxDividend = dataPoints.map { $0.dividendYield }.max() ?? 1
            let maxBuyback = dataPoints.map { $0.buybackYield }.max() ?? 1
            return max(maxDividend, maxBuyback) * 1.15
        case .capital:
            let maxDividend = dataPoints.map { $0.dividendAmount }.max() ?? 1
            let maxBuyback = dataPoints.map { $0.buybackAmount }.max() ?? 1
            return max(maxDividend, maxBuyback) * 1.15
        }
    }

    private var sharesRange: (min: Double, max: Double) {
        let shares = dataPoints.map { $0.sharesOutstanding }
        let minShares = (shares.min() ?? 0) * 0.9
        let maxShares = (shares.max() ?? 1) * 1.1
        return (minShares, maxShares)
    }

    // Grid line values (4 horizontal lines)
    private var gridValues: [Double] {
        let step = maxBarValue / 4
        return [step, step * 2, step * 3]
    }

    var body: some View {
        VStack(spacing: 0) {
            // Chart with dual Y-axes
            HStack(alignment: .top, spacing: 0) {
                // Left Y-axis labels (yield % or capital $)
                leftYAxisLabels
                    .frame(width: yAxisWidth)

                // Main chart area
                chartContent
                    .frame(height: chartHeight)

                // Right Y-axis labels (shares outstanding)
                rightYAxisLabels
                    .frame(width: rightYAxisWidth)
            }

            // X-axis labels (periods)
            xAxisLabels
        }
    }

    // MARK: - Chart Content

    private var chartContent: some View {
        Chart {
            // Horizontal grid lines
            ForEach(gridValues, id: \.self) { value in
                RuleMark(y: .value("Grid", value))
                    .foregroundStyle(AppColors.cardBackgroundLight.opacity(0.5))
                    .lineStyle(StrokeStyle(lineWidth: 0.5))
            }

            // Dividend bars
            ForEach(dataPoints) { dataPoint in
                BarMark(
                    x: .value("Period", dataPoint.period),
                    y: .value("Dividends", viewType == .yield ? dataPoint.dividendYield : dataPoint.dividendAmount),
                    width: .fixed(18)
                )
                .foregroundStyle(AppColors.confidenceDividends)
                .cornerRadius(3)
                .position(by: .value("Type", "Dividends"))
            }

            // Buyback bars
            ForEach(dataPoints) { dataPoint in
                BarMark(
                    x: .value("Period", dataPoint.period),
                    y: .value("Buybacks", viewType == .yield ? dataPoint.buybackYield : dataPoint.buybackAmount),
                    width: .fixed(18)
                )
                .foregroundStyle(AppColors.confidenceBuybacks)
                .cornerRadius(3)
                .position(by: .value("Type", "Buybacks"))
            }

            // Shares outstanding line
            ForEach(dataPoints) { dataPoint in
                LineMark(
                    x: .value("Period", dataPoint.period),
                    y: .value("Shares", normalizeShares(dataPoint.sharesOutstanding))
                )
                .foregroundStyle(AppColors.confidenceSharesOutstanding)
                .lineStyle(StrokeStyle(lineWidth: 2.5, lineCap: .round, lineJoin: .round))
                .interpolationMethod(.linear)
            }

            // Shares outstanding points
            ForEach(dataPoints) { dataPoint in
                PointMark(
                    x: .value("Period", dataPoint.period),
                    y: .value("Shares", normalizeShares(dataPoint.sharesOutstanding))
                )
                .foregroundStyle(AppColors.confidenceSharesOutstanding)
                .symbolSize(50)
            }
        }
        .chartXAxis(.hidden)
        .chartYAxis(.hidden)
        .chartYScale(domain: 0...maxBarValue)
        .chartPlotStyle { plotArea in
            plotArea
                .background(Color.clear)
        }
    }

    // MARK: - Y-Axis Labels

    private var leftYAxisLabels: some View {
        VStack {
            Text(formatLeftAxisValue(maxBarValue * 0.9))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text(formatLeftAxisValue(maxBarValue * 0.6))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text(formatLeftAxisValue(maxBarValue * 0.3))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text(viewType == .yield ? "0%" : "$0")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }
        .frame(height: chartHeight)
        .padding(.trailing, AppSpacing.xs)
    }

    private var rightYAxisLabels: some View {
        VStack {
            Text(formatSharesValue(sharesRange.max))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            let midValue = (sharesRange.max + sharesRange.min) / 2
            Text(formatSharesValue(midValue))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Spacer()

            Text(formatSharesValue(sharesRange.min))
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }
        .frame(height: chartHeight)
        .padding(.leading, AppSpacing.xs)
    }

    // MARK: - X-Axis Labels

    private var xAxisLabels: some View {
        HStack(spacing: 0) {
            Spacer()
                .frame(width: yAxisWidth)

            ForEach(dataPoints) { dataPoint in
                Text(dataPoint.period)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                    .frame(maxWidth: .infinity)
                    .lineLimit(1)
            }

            Spacer()
                .frame(width: rightYAxisWidth)
        }
        .padding(.top, AppSpacing.sm)
    }

    // MARK: - Helper Functions

    /// Normalize shares outstanding to fit within the bar chart's value range
    private func normalizeShares(_ shares: Double) -> Double {
        let range = sharesRange.max - sharesRange.min
        guard range > 0 else { return maxBarValue * 0.5 }

        let normalizedShares = (shares - sharesRange.min) / range // 0 to 1
        let targetMin = maxBarValue * 0.15
        let targetMax = maxBarValue * 0.85
        return targetMin + normalizedShares * (targetMax - targetMin)
    }

    private func formatLeftAxisValue(_ value: Double) -> String {
        switch viewType {
        case .yield:
            return String(format: "%.1f%%", value)
        case .capital:
            return formatLargeNumber(value)
        }
    }

    private func formatSharesValue(_ value: Double) -> String {
        if value >= 1000 {
            return String(format: "%.0fB", value / 1000)
        } else {
            return String(format: "%.0fM", value)
        }
    }

    private func formatLargeNumber(_ number: Double) -> String {
        let absNumber = abs(number)
        if absNumber >= 1_000_000 {
            return String(format: "$%.0fT", number / 1_000_000)
        } else if absNumber >= 1_000 {
            return String(format: "$%.0fB", number / 1_000)
        } else {
            return String(format: "$%.0fM", number)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            Text("Yield View")
                .foregroundColor(.white)
            SignalOfConfidenceChartView(
                dataPoints: SignalOfConfidenceSectionData.sampleData.dataPoints,
                viewType: .yield
            )

            Divider()

            Text("Capital View")
                .foregroundColor(.white)
            SignalOfConfidenceChartView(
                dataPoints: SignalOfConfidenceSectionData.sampleData.dataPoints,
                viewType: .capital
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SignalOfConfidenceInfoSheet.swift
================================================================================

//
//  SignalOfConfidenceInfoSheet.swift
//  ios
//
//  Molecule: Educational sheet explaining Signal of Confidence metrics and value investing tips
//

import SwiftUI

struct SignalOfConfidenceInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xxl) {
                    // Introduction
                    introductionSection

                    // Metric Types Explained
                    metricTypesSection

                    // Value Investing Tips
                    investingTipsSection
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("Signal of Confidence")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
            .toolbarBackground(AppColors.cardBackground, for: .navigationBar)
            .toolbarBackground(.visible, for: .navigationBar)
        }
        .presentationDetents([.large])
        .presentationDragIndicator(.visible)
    }

    // MARK: - Introduction Section

    private var introductionSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("Understanding Signal of Confidence")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            Text("Signal of Confidence shows how a company returns capital to shareholders through dividends and share buybacks. These actions demonstrate management's confidence in the business and commitment to shareholder value.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            Text("Why Buybacks Matter")
                .font(AppTypography.bodyBold)
                .foregroundColor(AppColors.textPrimary)
                .padding(.top, AppSpacing.sm)

            Text("Share buybacks are a powerful signal of management's confidence. When a company repurchases its own shares, it reduces the total shares outstanding, which increases earnings per share (EPS) and ownership percentage for remaining shareholders. Buybacks are most effective when executed at attractive valuations, as they represent management's belief that the stock is undervalued. Unlike dividends, buybacks offer tax efficiency and flexibility, making them an increasingly popular method of returning capital to shareholders.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
    }

    // MARK: - Metric Types Section

    private var metricTypesSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Metric Types")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            ForEach(SignalOfConfidenceMetricType.allCases) { metricType in
                metricTypeCard(metricType)
            }
        }
    }

    private func metricTypeCard(_ metricType: SignalOfConfidenceMetricType) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Color indicator
            Circle()
                .fill(metricType.color)
                .frame(width: 12, height: 12)
                .padding(.top, 4)

            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(metricType.rawValue)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(metricType.description)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Investing Tips Section

    private var investingTipsSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Value Investing Tips")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            ForEach(SignalOfConfidenceInfoItem.valueInvestingTips) { tip in
                investingTipCard(tip)
            }
        }
    }

    private func investingTipCard(_ tip: SignalOfConfidenceInfoItem) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: tip.icon)
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(AppColors.primaryBlue)

                Text(tip.title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
            }

            Text(tip.description)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            if let example = tip.example {
                HStack(alignment: .top, spacing: AppSpacing.xs) {
                    Image(systemName: "lightbulb.fill")
                        .font(.system(size: 11))
                        .foregroundColor(AppColors.neutral)

                    Text(example)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                        .italic()
                        .fixedSize(horizontal: false, vertical: true)
                }
                .padding(.top, AppSpacing.xs)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    SignalOfConfidenceInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SignalOfConfidenceLegendView.swift
================================================================================

//
//  SignalOfConfidenceLegendView.swift
//  ios
//
//  Molecule: Legend view displaying all Signal of Confidence metrics
//

import SwiftUI

struct SignalOfConfidenceLegendView: View {
    var body: some View {
        HStack(spacing: AppSpacing.xl) {
            ForEach(SignalOfConfidenceMetricType.allCases) { metricType in
                SignalOfConfidenceLegendItem(metricType: metricType)
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        SignalOfConfidenceLegendView()
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SignalOfConfidenceSummaryView.swift
================================================================================

//
//  SignalOfConfidenceSummaryView.swift
//  ios
//
//  Molecule: Summary text view for Signal of Confidence section
//

import SwiftUI

struct SignalOfConfidenceSummaryView: View {
    let summary: SignalOfConfidenceSummary

    var body: some View {
        Text(summary.formattedSummary)
            .font(AppTypography.subheadline)
            .foregroundColor(AppColors.textSecondary)
            .multilineTextAlignment(.leading)
            .fixedSize(horizontal: false, vertical: true)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        SignalOfConfidenceSummaryView(
            summary: SignalOfConfidenceSectionData.sampleData.summary
        )
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SmartMoneyCard.swift
================================================================================

//
//  SmartMoneyCard.swift
//  ios
//
//  Molecule: Smart money following alert card
//

import SwiftUI

struct SmartMoneyCard: View {
    let alert: SmartMoneyAlert
    var onTap: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            HStack(spacing: AppSpacing.md) {
                // Icon
                ZStack {
                    Circle()
                        .fill(AppColors.alertOrange.opacity(0.15))
                        .frame(width: 40, height: 40)

                    Image(systemName: "lightbulb.fill")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(AppColors.alertOrange)
                }

                // Content
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text(alert.title)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text(alert.description)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                }

                Spacer()

                // Chevron
                Image(systemName: "chevron.right")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(AppColors.textMuted)
            }
            .padding(AppSpacing.lg)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    SmartMoneyCard(alert: SmartMoneyAlert.sampleData)
        .padding()
        .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SmartMoneyFlowChart.swift
================================================================================

//
//  SmartMoneyFlowChart.swift
//  ios
//
//  Molecule: Two-chart view for Smart Money tracking
//  Top: Stock price line chart to show price movement
//  Bottom: Buy/Sell volume bar chart to show smart money activity
//  Users can compare when smart money bought/sold relative to price movements
//

import SwiftUI
import Charts

struct SmartMoneyFlowChart: View {
    let priceData: [StockPriceDataPoint]
    let flowData: [SmartMoneyFlowDataPoint]

    // Chart configuration
    private let priceChartHeight: CGFloat = 80
    private let volumeChartHeight: CGFloat = 120
    private let barWidth: CGFloat = 12

    /// All month labels from the data
    private var allMonths: [String] {
        flowData.map { $0.month }
    }

    /// Only show 3 x-axis labels: first, middle, last
    private var xAxisLabels: [String] {
        guard flowData.count >= 3 else { return allMonths }
        let first = flowData.first?.month ?? ""
        let middle = flowData[flowData.count / 2].month
        let last = flowData.last?.month ?? ""
        return [first, middle, last]
    }
    
    /// Format month string from "MM/YYYY" to "MM/YY"
    private func formatMonthLabel(_ month: String) -> String {
        // Convert "02/2025" to "02/25"
        let components = month.split(separator: "/")
        guard components.count == 2,
              let year = components.last,
              year.count == 4 else {
            return month // Return as-is if format is unexpected
        }
        let shortYear = year.suffix(2)
        return "\(components[0])/\(shortYear)"
    }

    var body: some View {
        VStack(spacing: 0) {
            // Top: Stock Price Line Chart
            priceChart

            // Bottom: Buy/Sell Volume Bar Chart
            volumeChart
        }
    }

    // MARK: - Price Chart (Top)

    private var priceChart: some View {
        Chart {
            // Area under the line (draw first so line is on top)
            ForEach(priceData) { point in
                AreaMark(
                    x: .value("Month", point.month),
                    yStart: .value("Base", priceRange.min),
                    yEnd: .value("Price", point.price)
                )
                .foregroundStyle(
                    LinearGradient(
                        colors: [
                            HoldersColors.flowLine.opacity(0.4),
                            HoldersColors.flowLine.opacity(0.1)
                        ],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )
                .interpolationMethod(.catmullRom)
            }

            // Price line
            ForEach(priceData) { point in
                LineMark(
                    x: .value("Month", point.month),
                    y: .value("Price", point.price)
                )
                .foregroundStyle(HoldersColors.flowLine)
                .lineStyle(StrokeStyle(lineWidth: 2, lineCap: .round, lineJoin: .round))
                .interpolationMethod(.catmullRom)
            }
        }
        .chartXAxis(.hidden)
        .chartXScale(domain: allMonths, range: .plotDimension(padding: barWidth / 2))
        .chartYAxis {
            AxisMarks(position: .trailing, values: .automatic(desiredCount: 3)) { value in
                AxisGridLine()
                    .foregroundStyle(AppColors.cardBackgroundLight.opacity(0.3))
                AxisValueLabel {
                    if let doubleValue = value.as(Double.self) {
                        Text(formatPriceValue(doubleValue))
                            .font(AppTypography.caption)
                            .foregroundStyle(AppColors.textMuted)
                    }
                }
            }
        }
        .chartYScale(domain: priceRange.min...priceRange.max)
        .chartPlotStyle { plotArea in
            plotArea.background(Color.clear)
        }
        .frame(height: priceChartHeight)
    }

    // MARK: - Volume Chart (Bottom)

    private var volumeChart: some View {
        Chart {
            // Buy volume bars (positive, green) - above zero line
            ForEach(flowData) { point in
                BarMark(
                    x: .value("Month", point.month),
                    y: .value("Buy", point.buyVolume),
                    width: .fixed(barWidth)
                )
                .foregroundStyle(HoldersColors.buyVolume)
                .cornerRadius(2)
            }

            // Sell volume bars (negative, red) - below zero line
            ForEach(flowData) { point in
                BarMark(
                    x: .value("Month", point.month),
                    y: .value("Sell", -point.sellVolume),
                    width: .fixed(barWidth)
                )
                .foregroundStyle(HoldersColors.sellVolume)
                .cornerRadius(2)
            }

            // Zero line
            RuleMark(y: .value("Zero", 0))
                .foregroundStyle(AppColors.cardBackgroundLight)
                .lineStyle(StrokeStyle(lineWidth: 0.5))
        }
        .chartXScale(domain: allMonths, range: .plotDimension(padding: barWidth / 2))
        .chartXAxis {
            AxisMarks(values: xAxisLabels) { value in
                AxisValueLabel {
                    if let stringValue = value.as(String.self) {
                        Text(formatMonthLabel(stringValue))
                            .font(AppTypography.caption)
                            .foregroundStyle(AppColors.textMuted)
                    }
                }
            }
        }
        .chartYAxis {
            AxisMarks(position: .trailing, values: .automatic(desiredCount: 4)) { value in
                AxisGridLine()
                    .foregroundStyle(AppColors.cardBackgroundLight.opacity(0.3))
                AxisValueLabel {
                    if let doubleValue = value.as(Double.self) {
                        Text(formatVolumeValue(doubleValue))
                            .font(AppTypography.caption)
                            .foregroundStyle(AppColors.textMuted)
                    }
                }
            }
        }
        .chartYScale(domain: -maxVolume...maxVolume)
        .chartPlotStyle { plotArea in
            plotArea.background(Color.clear)
        }
        .frame(height: volumeChartHeight)
    }

    // MARK: - Computed Properties

    private var priceRange: (min: Double, max: Double) {
        let prices = priceData.map { $0.price }
        let minPrice = (prices.min() ?? 0)
        let maxPrice = (prices.max() ?? 1)
        // Add padding for visual breathing room
        let padding = (maxPrice - minPrice) * 0.1
        return (minPrice - padding, maxPrice + padding)
    }

    private var maxVolume: Double {
        let maxBuy = flowData.map { $0.buyVolume }.max() ?? 1
        let maxSell = flowData.map { $0.sellVolume }.max() ?? 1
        return max(maxBuy, maxSell) * 1.15
    }

    // MARK: - Formatting

    private func formatPriceValue(_ value: Double) -> String {
        if value >= 1000 {
            return String(format: "$%.0fK", value / 1000)
        }
        return String(format: "$%.0f", value)
    }

    private func formatVolumeValue(_ value: Double) -> String {
        let absValue = abs(value)
        if absValue >= 1000 {
            return String(format: "%.0fB", value / 1000)
        } else if absValue >= 1 {
            return String(format: "%.0f", value)
        } else if absValue > 0 {
            return String(format: "%.1f", value)
        }
        return "0"
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            Text("Smart Money vs Price")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            SmartMoneyFlowChart(
                priceData: StockPriceDataPoint.sampleData,
                flowData: SmartMoneyFlowDataPoint.insiderSampleData
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SmartMoneyFlowLegend.swift
================================================================================

//
//  SmartMoneyFlowLegend.swift
//  ios
//
//  Molecule: Legend component for Smart Money flow chart
//  Shows Buy Volume and Sell Volume indicators
//

import SwiftUI

struct SmartMoneyFlowLegend: View {
    var body: some View {
        HStack(spacing: AppSpacing.lg) {
            SmartMoneyFlowLegendItem(
                color: HoldersColors.buyVolume,
                label: "Buy Volume"
            )

            SmartMoneyFlowLegendItem(
                color: HoldersColors.sellVolume,
                label: "Sell Volume"
            )
        }
        .frame(maxWidth: .infinity)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        SmartMoneyFlowLegend()
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SmartMoneyInfoSheet.swift
================================================================================

//
//  SmartMoneyInfoSheet.swift
//  ios
//
//  Molecule: Educational sheet explaining smart money tracking
//  Includes Peter Lynch quote and guidance for novice investors
//

import SwiftUI

struct SmartMoneyInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xl) {
                    // Peter Lynch Quote
                    quoteSection

                    // What is Smart Money
                    whatIsSmartMoneySection

                    // Types of Smart Money
                    smartMoneyTypesSection

                    // Key Takeaways
                    keyTakeawaysSection
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("Smart Money")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
    }

    // MARK: - Quote Section

    private var quoteSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Image(systemName: "quote.opening")
                .font(.system(size: 24))
                .foregroundColor(AppColors.primaryBlue)

            Text("Insiders might sell their shares for any number of reasons (taxes, divorce, buying a house), but they buy them for only one: they think the price will rise.")
                .font(AppTypography.body)
                .italic()
                .foregroundColor(AppColors.textPrimary)
                .fixedSize(horizontal: false, vertical: true)

            Text("â€” Peter Lynch")
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.primaryBlue)
        }
        .padding(AppSpacing.lg)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
                .overlay(
                    RoundedRectangle(cornerRadius: AppCornerRadius.large)
                        .stroke(AppColors.primaryBlue.opacity(0.3), lineWidth: 1)
                )
        )
    }

    // MARK: - What is Smart Money

    private var whatIsSmartMoneySection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("What is Smart Money?")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            Text("\"Smart Money\" refers to capital invested by those with deep knowledge of the market or a specific company. Tracking their buying and selling patterns can provide valuable signals about a stock's future direction.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            Text("The chart shows stock price (top) alongside buy/sell activity (bottom), letting you see when smart money acted relative to price movements.")
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textMuted)
                .fixedSize(horizontal: false, vertical: true)
        }
    }

    // MARK: - Smart Money Types

    private var smartMoneyTypesSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Types of Smart Money")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                smartMoneyTypeCard(
                    icon: "person.fill.checkmark",
                    title: "Insider Trading",
                    description: "Legal trades by company executives, directors, and employees. They have the deepest knowledge of the company.",
                    signal: "Insider buying is one of the strongest bullish signals. Selling is less meaningful (they may need cash).",
                    signalType: .bullish
                )

                smartMoneyTypeCard(
                    icon: "building.columns.fill",
                    title: "Hedge Funds",
                    description: "Professional money managers who actively research stocks. Disclosed quarterly in 13F filings.",
                    signal: "Large position increases by respected funds often precede gains. Watch for coordinated buying.",
                    signalType: .neutral
                )

                smartMoneyTypeCard(
                    icon: "building.2.fill",
                    title: "Congress",
                    description: "U.S. lawmakers must disclose their stock trades. Some have access to non-public information.",
                    signal: "Trades by members on relevant committees (e.g., tech committee buying tech stocks) can be informative.",
                    signalType: .neutral
                )
            }
        }
    }

    private enum SignalType {
        case bullish, neutral, bearish

        var color: Color {
            switch self {
            case .bullish: return AppColors.bullish
            case .neutral: return AppColors.neutral
            case .bearish: return AppColors.bearish
            }
        }
    }

    private func smartMoneyTypeCard(
        icon: String,
        title: String,
        description: String,
        signal: String,
        signalType: SignalType
    ) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: icon)
                    .font(.system(size: 18))
                    .foregroundColor(AppColors.primaryBlue)
                    .frame(width: 24)

                Text(title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
            }

            Text(description)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)

            HStack(alignment: .top, spacing: AppSpacing.sm) {
                Image(systemName: "lightbulb.fill")
                    .font(.system(size: 12))
                    .foregroundColor(signalType.color)

                Text(signal)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                    .fixedSize(horizontal: false, vertical: true)
            }
            .padding(.top, AppSpacing.xs)
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }

    // MARK: - Key Takeaways

    private var keyTakeawaysSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Key Takeaways")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                takeawayRow(
                    number: "1",
                    title: "Buying > Selling",
                    description: "Pay more attention to buying activity. Selling has many innocent explanations."
                )

                takeawayRow(
                    number: "2",
                    title: "Look for Patterns",
                    description: "Consistent buying over months is more meaningful than a single large purchase."
                )

                takeawayRow(
                    number: "3",
                    title: "Compare to Price",
                    description: "Smart money buying during dips suggests they see value. Buying at highs shows strong conviction."
                )

                takeawayRow(
                    number: "4",
                    title: "Don't Follow Blindly",
                    description: "Smart money can be wrong. Use this as one data point among many in your research."
                )
            }
        }
    }

    private func takeawayRow(number: String, title: String, description: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Text(number)
                .font(AppTypography.headline)
                .foregroundColor(AppColors.primaryBlue)
                .frame(width: 24, height: 24)
                .background(
                    Circle()
                        .fill(AppColors.primaryBlue.opacity(0.15))
                )

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    SmartMoneyInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SmartMoneyNetFlowBadge.swift
================================================================================

//
//  SmartMoneyNetFlowBadge.swift
//  ios
//
//  Molecule: Badge showing net informative flow for Smart Money
//  Displays the total net flow with directional indicator
//

import SwiftUI

struct SmartMoneyNetFlowBadge: View {
    let summary: SmartMoneyFlowSummary

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            // AI/Smart Money icon
            Image(systemName: "brain.head.profile")
                .font(.system(size: 16))
                .foregroundColor(AppColors.primaryBlue)
                .frame(width: 28, height: 28)
                .background(
                    Circle()
                        .fill(AppColors.primaryBlue.opacity(0.15))
                )

            Text("Net Informative Flow:")
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)

            HStack(spacing: AppSpacing.xxs) {
                Image(systemName: summary.flowIcon)
                    .font(.system(size: 12, weight: .bold))
                    .foregroundColor(summary.flowColor)

                Text(summary.formattedNetFlow)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(summary.flowColor)
            }
        }
        .frame(maxWidth: .infinity)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: AppSpacing.xl) {
            SmartMoneyNetFlowBadge(
                summary: SmartMoneyFlowSummary(
                    totalNetFlow: 8.27,
                    isPositive: true,
                    periodDescription: "12-Month"
                )
            )

            SmartMoneyNetFlowBadge(
                summary: SmartMoneyFlowSummary(
                    totalNetFlow: -15.5,
                    isPositive: false,
                    periodDescription: "12-Month"
                )
            )

            SmartMoneyNetFlowBadge(
                summary: SmartMoneyFlowSummary(
                    totalNetFlow: 1250,
                    isPositive: true,
                    periodDescription: "12-Month"
                )
            )
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SmartMoneyTabSelector.swift
================================================================================

//
//  SmartMoneyTabSelector.swift
//  ios
//
//  Molecule: Tab pills selector for Smart Money section
//  Allows switching between Insider, Hedge Funds, and Congress data
//

import SwiftUI

struct SmartMoneyTabSelector: View {
    @Binding var selectedTab: SmartMoneyTab

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            ForEach(SmartMoneyTab.allCases, id: \.rawValue) { tab in
                tabPill(for: tab)
            }

            Spacer()
        }
    }

    private func tabPill(for tab: SmartMoneyTab) -> some View {
        Button {
            withAnimation(.easeInOut(duration: 0.2)) {
                selectedTab = tab
            }
        } label: {
            Text(tab.rawValue)
                .font(AppTypography.calloutBold)
                .foregroundColor(selectedTab == tab ? AppColors.textPrimary : AppColors.textMuted)
                .padding(.horizontal, AppSpacing.md)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                        .fill(selectedTab == tab ? AppColors.cardBackgroundLight : Color.clear)
                        .overlay(
                            RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                                .stroke(
                                    selectedTab == tab ? Color.clear : AppColors.cardBackgroundLight,
                                    lineWidth: 1
                                )
                        )
                )
        }
        .buttonStyle(.plain)
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var selectedTab = SmartMoneyTab.insider

        var body: some View {
            ZStack {
                AppColors.background
                    .ignoresSafeArea()

                VStack(spacing: AppSpacing.xl) {
                    SmartMoneyTabSelector(selectedTab: $selectedTab)

                    Text("Selected: \(selectedTab.rawValue)")
                        .foregroundColor(AppColors.textPrimary)
                }
                .padding()
            }
        }
    }

    return PreviewWrapper()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SnapshotCard.swift
================================================================================

//
//  SnapshotCard.swift
//  ios
//
//  Molecule: Expandable snapshot card showing rating category with metrics
//

import SwiftUI

struct SnapshotCard: View {
    let snapshot: SnapshotItem
    @State private var isExpanded: Bool = true

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header row
            Button(action: {
                withAnimation(.easeInOut(duration: 0.2)) {
                    isExpanded.toggle()
                }
            }) {
                HStack(spacing: AppSpacing.md) {
                    // Rating indicator icon
                    SnapshotRatingIndicator(
                        category: snapshot.category,
                        rating: snapshot.rating
                    )

                    // Rating label and category
                    VStack(alignment: .leading, spacing: 2) {
                        HStack(spacing: AppSpacing.xs) {
                            Text(snapshot.rating.displayName)
                                .font(AppTypography.calloutBold)
                                .foregroundColor(snapshot.rating.color)

                            Text(snapshot.category.rawValue)
                                .font(AppTypography.callout)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        // Star rating
                        SnapshotStarRating(rating: snapshot.rating, starSize: 10)
                    }

                    Spacer()

                    // Expand/collapse chevron
                    Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                        .font(.system(size: 12, weight: .semibold))
                        .foregroundColor(AppColors.textMuted)
                }
                .padding(.vertical, AppSpacing.md)
            }
            .buttonStyle(PlainButtonStyle())

            // Metrics list (when expanded)
            if isExpanded {
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    ForEach(snapshot.metrics) { metric in
                        HStack {
                            Text(metric.name)
                                .font(AppTypography.footnote)
                                .foregroundColor(AppColors.textSecondary)

                            Spacer()

                            Text(metric.value)
                                .font(AppTypography.footnoteBold)
                                .foregroundColor(AppColors.textPrimary)
                        }
                    }

                }
                .padding(.bottom, AppSpacing.md)
            }

            // Divider (except for last item)
            Rectangle()
                .fill(AppColors.cardBackgroundLight)
                .frame(height: 1)
        }
    }
}

#Preview {
    ScrollView {
        VStack(spacing: 0) {
            ForEach(SnapshotItem.sampleData) { snapshot in
                SnapshotCard(snapshot: snapshot)
            }
        }
        .padding(.horizontal, AppSpacing.lg)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/StickyTickerHeader.swift
================================================================================

//
//  StickyTickerHeader.swift
//  ios
//
//  Compact header for sticky display showing only ticker name and price
//

import SwiftUI

struct StickyTickerHeader: View {
    let companyName: String
    let price: String

    var body: some View {
        HStack {
            Text(companyName)
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            Spacer()

            Text(price)
                .font(AppTypography.headline)
                .fontWeight(.bold)
                .foregroundColor(AppColors.textPrimary)
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.sm)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        StickyTickerHeader(
            companyName: "Apple Inc.",
            price: "$178.42"
        )

        StickyTickerHeader(
            companyName: "Tesla, Inc.",
            price: "$252.18"
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/StockPerformanceCard.swift
================================================================================

//
//  StockPerformanceCard.swift
//  ios
//
//  Molecule: Stock performance card with price, chart, and stats
//

import SwiftUI

struct StockPerformanceCard: View {
    let performance: StockPerformance

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Price display
            StockPriceDisplay(
                price: performance.formattedPrice,
                change: performance.formattedChange,
                period: performance.period,
                isPositive: performance.isPositive
            )

            // Chart
            MiniStockChart(
                data: performance.chartData,
                isPositive: performance.isPositive
            )

            // Chart date range
            HStack {
                Text("Dec 15")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)

                Spacer()

                Text("Jan 15")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }

            // Stats grid
            VStack(spacing: AppSpacing.md) {
                HStack {
                    StatItem(label: "Day High", value: performance.formattedDayHigh)
                    Spacer()
                    StatItem(label: "Day Low", value: performance.formattedDayLow)
                }

                HStack {
                    StatItem(label: "Volume", value: performance.volume)
                    Spacer()
                    StatItem(label: "Avg Volume", value: performance.avgVolume)
                }
            }

            // Follow-up question
            if let question = performance.followUpQuestion {
                Text(question)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
                    .italic()
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

// MARK: - Stat Item
private struct StatItem: View {
    let label: String
    let value: String

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xxs) {
            Text(label)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Text(value)
                .font(AppTypography.bodyBold)
                .foregroundColor(AppColors.textPrimary)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

#Preview {
    StockPerformanceCard(
        performance: StockPerformance(
            currentPrice: 242.84,
            changePercent: 8.7,
            period: "1 Month",
            dayHigh: 245.12,
            dayLow: 238.45,
            volume: "124.5M",
            avgVolume: "98.2M",
            chartData: [220, 225, 218, 230, 235, 228, 240, 238, 245, 242],
            followUpQuestion: "Would you like me to analyze any specific timeframe or technical indicators?"
        )
    )
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/StorageCard.swift
================================================================================

//
//  StorageCard.swift
//  ios
//
//  Molecule: Card displaying storage usage with progress bar and upgrade option
//

import SwiftUI

// MARK: - StorageInfo Model
struct StorageInfo {
    let usedGB: Double
    let totalGB: Double
    
    var progress: Double {
        guard totalGB > 0 else { return 0 }
        return min(usedGB / totalGB, 1.0)
    }
    
    var formattedPercentage: String {
        let percentage = Int(progress * 100)
        return "\(percentage)%"
    }
    
    var formattedUsed: String {
        return String(format: "%.1f GB of %.1f GB used", usedGB, totalGB)
    }
}

struct StorageCard: View {
    let storageInfo: StorageInfo
    var onUpgrade: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header row: Title + Percentage
            HStack {
                Text("Storage")
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Text(storageInfo.formattedPercentage)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
            }

            // Progress bar
            StorageProgressBar(progress: storageInfo.progress)

            // Bottom row: Usage text + Upgrade button
            HStack {
                Text(storageInfo.formattedUsed)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)

                Spacer()

                Button(action: {
                    onUpgrade?()
                }) {
                    Text("Upgrade")
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.primaryBlue)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        StorageCard(storageInfo: StorageInfo(usedGB: 3.2, totalGB: 4.4))
        StorageCard(storageInfo: StorageInfo(usedGB: 1.5, totalGB: 5.0))
        StorageCard(storageInfo: StorageInfo(usedGB: 4.8, totalGB: 5.0))
    }
    .padding(.horizontal, AppSpacing.lg)
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/StudyScheduleRow.swift
================================================================================

//
//  StudyScheduleRow.swift
//  ios
//
//  Molecule: Row in study schedule section with title, subtitle, and time/toggle
//

import SwiftUI

struct StudyScheduleRow: View {
    let title: String
    let subtitle: String

    // For toggle style
    var isToggle: Bool = false
    @Binding var isEnabled: Bool

    // For time style
    var time: String? = nil
    var timeColor: Color = AppColors.primaryBlue

    init(
        title: String,
        subtitle: String,
        isEnabled: Binding<Bool>
    ) {
        self.title = title
        self.subtitle = subtitle
        self.isToggle = true
        self._isEnabled = isEnabled
        self.time = nil
    }

    init(
        title: String,
        subtitle: String,
        time: String,
        timeColor: Color = AppColors.primaryBlue
    ) {
        self.title = title
        self.subtitle = subtitle
        self.isToggle = false
        self._isEnabled = .constant(false)
        self.time = time
        self.timeColor = timeColor
    }

    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.body)
                    .foregroundColor(AppColors.textPrimary)

                Text(subtitle)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }

            Spacer()

            if isToggle {
                Toggle("", isOn: $isEnabled)
                    .labelsHidden()
                    .tint(AppColors.bullish)
            } else if let time = time {
                StudyScheduleTimeLabel(time: time, color: timeColor)
            }
        }
        .padding(.vertical, AppSpacing.sm)
    }
}

#Preview {
    VStack(spacing: 0) {
        StudyScheduleRow(
            title: "Daily Reminder",
            subtitle: "",
            isEnabled: .constant(true)
        )

        Divider()
            .background(AppColors.cardBackgroundLight)

        StudyScheduleRow(
            title: "Morning Session",
            subtitle: "Best for focus",
            time: "9:00 AM"
        )

        Divider()
            .background(AppColors.cardBackgroundLight)

        StudyScheduleRow(
            title: "Review Time",
            subtitle: "Reinforce learning",
            time: "8:00 PM",
            timeColor: AppColors.textSecondary
        )
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/SuggestionChipsRow.swift
================================================================================

//
//  SuggestionChipsRow.swift
//  ios
//
//  Molecule: Horizontal row of suggestion chips that wraps
//

import SwiftUI

struct SuggestionChipsRow: View {
    let chips: [SuggestionChip]
    var onChipTap: ((SuggestionChip) -> Void)?

    var body: some View {
        // Use a flow layout approach with multiple rows
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // First row - first 3 chips
            HStack(spacing: AppSpacing.md) {
                ForEach(Array(chips.prefix(3))) { chip in
                    SuggestionChipView(chip: chip) {
                        onChipTap?(chip)
                    }
                }
            }

            // Second row - remaining chips
            if chips.count > 3 {
                HStack(spacing: AppSpacing.md) {
                    ForEach(Array(chips.dropFirst(3))) { chip in
                        SuggestionChipView(chip: chip) {
                            onChipTap?(chip)
                        }
                    }
                }
            }
        }
    }
}

#Preview {
    SuggestionChipsRow(chips: SuggestionChip.sampleData)
        .padding()
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TabBarItem.swift
================================================================================

//
//  TabBarItem.swift
//  ios
//
//  Molecule: Individual tab bar item
//

import SwiftUI

struct TabBarItem: View {
    let tab: HomeTab
    let isSelected: Bool
    var onTap: (() -> Void)?

    private var iconColor: Color {
        isSelected ? AppColors.tabBarSelected : AppColors.tabBarUnselected
    }

    private var textColor: Color {
        isSelected ? AppColors.tabBarSelected : AppColors.tabBarUnselected
    }

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            VStack(spacing: AppSpacing.xs) {
                Image(systemName: tab.systemIconName)
                    .font(.system(size: 20, weight: isSelected ? .semibold : .regular))
                    .foregroundColor(iconColor)

                Text(tab.rawValue)
                    .font(AppTypography.caption)
                    .foregroundColor(textColor)
            }
            .frame(maxWidth: .infinity)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    HStack {
        ForEach(HomeTab.allCases, id: \.self) { tab in
            TabBarItem(tab: tab, isSelected: tab == .home)
        }
    }
    .padding()
    .background(AppColors.tabBarBackground)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TechnicalDetailSections.swift
================================================================================

//
//  TechnicalDetailSections.swift
//  ios
//
//  Section cards for Technical Analysis Detail view
//

import SwiftUI

// MARK: - Moving Averages Section
struct MovingAveragesSection: View {
    let indicators: [MovingAverageIndicator]
    let summary: IndicatorSummary

    var body: some View {
        TechnicalSectionCard(title: "Moving Averages") {
            VStack(spacing: 0) {
                // Summary badges
                HStack {
                    IndicatorSummaryBadges(summary: summary)
                    Spacer()
                }
                .padding(.bottom, AppSpacing.md)

                // Indicator rows
                ForEach(indicators) { indicator in
                    TechnicalIndicatorRow(
                        name: indicator.name,
                        value: indicator.formattedValue,
                        signal: indicator.signal
                    )

                    if indicator.id != indicators.last?.id {
                        Divider()
                            .background(AppColors.cardBackgroundLight)
                    }
                }
            }
        }
    }
}

// MARK: - Oscillators Section
struct OscillatorsSection: View {
    let indicators: [OscillatorIndicator]
    let summary: IndicatorSummary

    var body: some View {
        TechnicalSectionCard(title: "Oscillators") {
            VStack(spacing: 0) {
                // Summary badges
                HStack {
                    IndicatorSummaryBadges(summary: summary)
                    Spacer()
                }
                .padding(.bottom, AppSpacing.md)

                // Indicator rows
                ForEach(indicators) { indicator in
                    TechnicalIndicatorRow(
                        name: indicator.name,
                        value: indicator.formattedValue,
                        signal: indicator.signal
                    )

                    if indicator.id != indicators.last?.id {
                        Divider()
                            .background(AppColors.cardBackgroundLight)
                    }
                }
            }
        }
    }
}

// MARK: - Pivot Points Section
struct PivotPointsSection: View {
    let pivotData: PivotPointsData

    var body: some View {
        TechnicalSectionCard(title: "Pivot Points", subtitle: pivotData.method) {
            VStack(spacing: 0) {
                ForEach(pivotData.levels) { level in
                    PivotPointRow(
                        name: level.name,
                        value: level.formattedValue,
                        valueColor: level.valueColor
                    )

                    if level.id != pivotData.levels.last?.id {
                        Divider()
                            .background(AppColors.cardBackgroundLight)
                    }
                }
            }
        }
    }
}

// MARK: - Volume Analysis Section
struct VolumeAnalysisSection: View {
    let volumeData: VolumeAnalysisData

    var body: some View {
        TechnicalSectionCard(title: "Volume Analysis") {
            VStack(spacing: AppSpacing.md) {
                // Volume cards
                HStack(spacing: AppSpacing.md) {
                    VolumeCard(
                        title: "Current Volume",
                        value: volumeData.formattedCurrentVolume,
                        subtitle: volumeData.formattedVolumeChange,
                        subtitleColor: volumeData.volumeChangeColor
                    )

                    VolumeCard(
                        title: "Avg Volume (30d)",
                        value: volumeData.formattedAvgVolume,
                        subtitle: "Daily Average",
                        subtitleColor: AppColors.textMuted
                    )
                }

                Divider()
                    .background(AppColors.cardBackgroundLight)

                // Volume metrics
                VolumeMetricRow(
                    label: "Volume Trend",
                    value: volumeData.volumeTrend.rawValue,
                    valueColor: volumeData.volumeTrend.color,
                    showArrow: volumeData.volumeTrend != .stable,
                    isUp: volumeData.volumeTrend == .increasing
                )

                Divider()
                    .background(AppColors.cardBackgroundLight)

                VolumeMetricRow(
                    label: "OBV",
                    value: volumeData.formattedOBV,
                    valueColor: volumeData.obvColor
                )

                Divider()
                    .background(AppColors.cardBackgroundLight)

                VolumeMetricRow(
                    label: "Money Flow Index",
                    value: volumeData.formattedMFI,
                    valueColor: AppColors.textPrimary
                )
            }
        }
    }
}

// MARK: - Volume Card
struct VolumeCard: View {
    let title: String
    let value: String
    let subtitle: String
    let subtitleColor: Color

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xs) {
            Text(title)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            Text(value)
                .font(AppTypography.title2)
                .fontWeight(.bold)
                .foregroundColor(AppColors.textPrimary)

            Text(subtitle)
                .font(AppTypography.caption)
                .foregroundColor(subtitleColor)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(AppSpacing.md)
        .background(AppColors.cardBackgroundLight)
        .cornerRadius(AppCornerRadius.medium)
    }
}

// MARK: - Fibonacci Retracement Section
struct FibonacciRetracementSection: View {
    let fibData: FibonacciRetracementData

    var body: some View {
        TechnicalSectionCard(title: "Fibonacci Retracement", subtitle: fibData.timeframe) {
            VStack(spacing: 0) {
                ForEach(fibData.levels) { level in
                    FibonacciLevelRow(
                        percentage: level.percentage,
                        value: level.formattedValue,
                        isKeyLevel: level.isKey
                    )

                    if level.id != fibData.levels.last?.id {
                        Divider()
                            .background(AppColors.cardBackgroundLight)
                    }
                }
            }
        }
    }
}

// MARK: - Key Support & Resistance Section
struct SupportResistanceSection: View {
    let srData: SupportResistanceData

    var body: some View {
        TechnicalSectionCard(title: "Key Support & Resistance") {
            VStack(spacing: AppSpacing.md) {
                // Resistance levels
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text("Resistance Levels")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)

                    ForEach(srData.resistanceLevels) { level in
                        SupportResistanceLevelRow(
                            name: level.name,
                            value: level.value,
                            strength: level.strength
                        )

                        if level.id != srData.resistanceLevels.last?.id {
                            Divider()
                                .background(AppColors.cardBackgroundLight)
                        }
                    }
                }

                // Current price
                HStack {
                    Spacer()
                    VStack(spacing: AppSpacing.xxs) {
                        Text(srData.formattedCurrentPrice)
                            .font(AppTypography.title2)
                            .fontWeight(.bold)
                            .foregroundColor(AppColors.textPrimary)

                        Text("Current Price")
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                    }
                    Spacer()
                }
                .padding(.vertical, AppSpacing.md)
                .background(AppColors.cardBackgroundLight)
                .cornerRadius(AppCornerRadius.medium)

                // Support levels
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text("Support Levels")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)

                    ForEach(srData.supportLevels) { level in
                        SupportResistanceLevelRow(
                            name: level.name,
                            value: level.value,
                            strength: level.strength
                        )

                        if level.id != srData.supportLevels.last?.id {
                            Divider()
                                .background(AppColors.cardBackgroundLight)
                        }
                    }
                }
            }
        }
    }
}

// MARK: - Generic Section Card
struct TechnicalSectionCard<Content: View>: View {
    let title: String
    let subtitle: String?
    let content: Content

    init(title: String, subtitle: String? = nil, @ViewBuilder content: () -> Content) {
        self.title = title
        self.subtitle = subtitle
        self.content = content()
    }

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header
            HStack {
                Text(title)
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                if let subtitle = subtitle {
                    Text(subtitle)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }
            }

            content
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            VStack(spacing: AppSpacing.lg) {
                MovingAveragesSection(
                    indicators: Array(MovingAverageIndicator.sampleData.prefix(3)),
                    summary: MovingAverageIndicator.sampleSummary
                )

                OscillatorsSection(
                    indicators: Array(OscillatorIndicator.sampleData.prefix(3)),
                    summary: OscillatorIndicator.sampleSummary
                )

                PivotPointsSection(pivotData: PivotPointsData.sampleData)

                VolumeAnalysisSection(volumeData: VolumeAnalysisData.sampleData)

                FibonacciRetracementSection(fibData: FibonacciRetracementData.sampleData)

                SupportResistanceSection(srData: SupportResistanceData.sampleData)
            }
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TechnicalIndicatorRow.swift
================================================================================

//
//  TechnicalIndicatorRow.swift
//  ios
//
//  Row displaying a single technical indicator with name, value, and signal
//

import SwiftUI

struct TechnicalIndicatorRow: View {
    let name: String
    let value: String
    let signal: IndicatorSignal

    var body: some View {
        HStack {
            Text(name)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)

            Spacer()

            Text(value)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textPrimary)

            IndicatorSignalBadge(signal: signal)
                .frame(width: 60, alignment: .trailing)
        }
        .padding(.vertical, AppSpacing.sm)
    }
}

// MARK: - Pivot Point Row (different styling)
struct PivotPointRow: View {
    let name: String
    let value: String
    let valueColor: Color

    var body: some View {
        HStack {
            Text(name)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)

            Spacer()

            Text(value)
                .font(AppTypography.subheadline)
                .fontWeight(.medium)
                .foregroundColor(valueColor)
        }
        .padding(.vertical, AppSpacing.sm)
    }
}

// MARK: - Volume Metric Row
struct VolumeMetricRow: View {
    let label: String
    let value: String
    let valueColor: Color
    let showArrow: Bool
    let isUp: Bool

    init(label: String, value: String, valueColor: Color = AppColors.textPrimary, showArrow: Bool = false, isUp: Bool = true) {
        self.label = label
        self.value = value
        self.valueColor = valueColor
        self.showArrow = showArrow
        self.isUp = isUp
    }

    var body: some View {
        HStack {
            Text(label)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)

            Spacer()

            HStack(spacing: AppSpacing.xxs) {
                Text(value)
                    .font(AppTypography.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(valueColor)

                if showArrow {
                    Image(systemName: isUp ? "arrow.up" : "arrow.down")
                        .font(.system(size: 10, weight: .bold))
                        .foregroundColor(valueColor)
                }
            }
        }
        .padding(.vertical, AppSpacing.sm)
    }
}

// MARK: - Fibonacci Level Row
struct FibonacciLevelRow: View {
    let percentage: String
    let value: String
    let isKeyLevel: Bool

    var body: some View {
        HStack {
            HStack(spacing: AppSpacing.xs) {
                Text(percentage)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textSecondary)

                if isKeyLevel {
                    Text(percentage == "0.0%" ? "(High)" : "(Low)")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }
            }

            Spacer()

            Text(value)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textPrimary)
        }
        .padding(.vertical, AppSpacing.sm)
    }
}

// MARK: - Support/Resistance Level Row
struct SupportResistanceLevelRow: View {
    let name: String
    let value: Double
    let strength: LevelStrength

    var body: some View {
        HStack {
            Text(name)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)

            Spacer()

            Text(String(format: "%.2f", value))
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textPrimary)

            Text(strength.rawValue)
                .font(AppTypography.caption)
                .foregroundColor(strength.color)
                .frame(width: 60, alignment: .trailing)
        }
        .padding(.vertical, AppSpacing.sm)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        VStack(spacing: 0) {
            TechnicalIndicatorRow(name: "MA(5)", value: "172.34", signal: .buy)
            TechnicalIndicatorRow(name: "RSI(14)", value: "58.34", signal: .neutral)
            PivotPointRow(name: "R1", value: "180.67", valueColor: AppColors.bullish)
            VolumeMetricRow(label: "Volume Trend", value: "Increasing", valueColor: AppColors.bullish, showArrow: true, isUp: true)
            FibonacciLevelRow(percentage: "0.0%", value: "182.45", isKeyLevel: true)
            SupportResistanceLevelRow(name: "R1", value: 180.67, strength: .weak)
        }
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TechnicalMeter.swift
================================================================================

//
//  TechnicalMeter.swift
//  ios
//
//  Technical analysis meter with gauge and signal indicators
//

import SwiftUI

struct TechnicalMeter: View {
    let technicalData: TechnicalAnalysisData
    @State private var selectedPeriod: TechnicalPeriod = .daily
    
    enum TechnicalPeriod {
        case daily
        case weekly
    }

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Header
            VStack(spacing: AppSpacing.xs) {
                Text("Technical Meter")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text("Aggregated technical indicators")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }

            // Signal badges row (now toggleable)
            HStack(spacing: AppSpacing.md) {
                TechnicalSignalBadge(
                    title: "Daily Signal",
                    signal: technicalData.dailySignal.signal,
                    indicatorCount: technicalData.dailySignal.formattedCount,
                    isSelected: selectedPeriod == .daily
                )
                .onTapGesture {
                    selectedPeriod = .daily
                }

                TechnicalSignalBadge(
                    title: "Weekly Signal",
                    signal: technicalData.weeklySignal.signal,
                    indicatorCount: technicalData.weeklySignal.formattedCount,
                    isSelected: selectedPeriod == .weekly
                )
                .onTapGesture {
                    selectedPeriod = .weekly
                }
            }
            .padding(.horizontal, AppSpacing.lg)

            // Gauge
            TechnicalGauge(
                signal: technicalData.overallSignal,
                gaugeValue: technicalData.gaugeValue
            )

            // Level indicators
            TechnicalLevelIndicatorsRow(
                activeLevel: technicalData.gaugeLevel,
                labels: ["Strong\nSell", "Sell", "Neutral", "Buy", "Strong\nBuy"]
            )
        }
    }
}

// MARK: - Technical Gauge (Semi-circle style with 5 zones)
struct TechnicalGauge: View {
    let signal: TechnicalSignal
    let gaugeValue: Double

    private var needleAngle: Double {
        // Convert value (0-1) to angle (-180 to 0 degrees)
        return -180 + (gaugeValue * 180)
    }

    var body: some View {
        ZStack {
            // Background arc
            TechnicalArc()
                .stroke(AppColors.cardBackgroundLight, lineWidth: 24)
                .frame(width: 220, height: 110)

            // 5 distinct zone arcs
            TechnicalGaugeZones(size: 220)

            // Needle
            TechnicalNeedle(angle: needleAngle)
                .frame(width: 220, height: 110)

            // Center display
            VStack(spacing: 2) {
                Text(signal.rawValue)
                    .font(AppTypography.title2)
                    .fontWeight(.bold)
                    .foregroundColor(signal.color)
            }
            .offset(y: 20)
        }
        .frame(width: 220, height: 130)
    }
}

// MARK: - Technical Gauge Zones (5 colored segments)
struct TechnicalGaugeZones: View {
    let size: CGFloat

    var body: some View {

        
            ZStack {
                // Strong sell â€“ red
                TechnicalArcSegment(startAngle: 36, endAngle: 0)
                    .stroke(Color(hex: "991B1B"), style: StrokeStyle(lineWidth: 24, lineCap: .butt))
                    .frame(width: size, height: size / 2)
                // Sell â€“ light red
                TechnicalArcSegment(startAngle: 72, endAngle: 36)
                    .stroke(Color.red.opacity(0.8), style: StrokeStyle(lineWidth: 24, lineCap: .butt))
                    .frame(width: size, height: size / 2)

                // Neutral â€“ Yellow
                TechnicalArcSegment(startAngle: 108, endAngle: 72)
                    .stroke(Color.yellow, style: StrokeStyle(lineWidth: 24, lineCap: .butt))
                    .frame(width: size, height: size / 2)
                
                // Buy â€“ Light Green
                TechnicalArcSegment(startAngle: 144, endAngle: 108)
                    .stroke(Color.green.opacity(0.8), style: StrokeStyle(lineWidth: 24, lineCap: .butt))
                    .frame(width: size, height: size / 2)
                
                // Strong Buy â€“ Green
                TechnicalArcSegment(startAngle: 180, endAngle: 144)
                
                    .stroke(Color(hex: "15803D"), style: StrokeStyle(lineWidth: 24, lineCap: .butt))
                    .frame(width: size, height: size / 2)

            }
        
    }
}

// MARK: - Technical Arc Segment Shape
struct TechnicalArcSegment: Shape {
    let startAngle: Double
    let endAngle: Double

    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.maxY)
        let radius = min(rect.width, rect.height * 2) / 2 - 12

        path.addArc(
            center: center,
            radius: radius,
            startAngle: .degrees(startAngle + 180),
            endAngle: .degrees(endAngle + 180),
            clockwise: true
        )

        return path
    }
}

// MARK: - Technical Arc Shape
struct TechnicalArc: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.maxY)
        let radius = min(rect.width, rect.height * 2) / 2 - 12

        path.addArc(
            center: center,
            radius: radius,
            startAngle: .degrees(180),
            endAngle: .degrees(0),
            clockwise: false
        )

        return path
    }
}

// MARK: - Technical Needle
struct TechnicalNeedle: View {
    let angle: Double

    var body: some View {
        GeometryReader { geometry in
            let center = CGPoint(x: geometry.size.width / 2, y: geometry.size.height)
            let needleLength = min(geometry.size.width, geometry.size.height * 2) / 2 - 35

            Path { path in
                path.move(to: center)
                let endX = center.x + needleLength * cos(angle * .pi / 180)
                let endY = center.y + needleLength * sin(angle * .pi / 180)
                path.addLine(to: CGPoint(x: endX, y: endY))
            }
            .stroke(AppColors.textPrimary, style: StrokeStyle(lineWidth: 3, lineCap: .round))

            // Center circle
            Circle()
                .fill(AppColors.textPrimary)
                .frame(width: 10, height: 10)
                .position(center)
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        TechnicalMeter(technicalData: TechnicalAnalysisData.sampleData)
            .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerAISuggestionChip.swift
================================================================================

//
//  TickerAISuggestionChip.swift
//  ios
//
//  Molecule: AI suggestion chip for ticker-specific questions
//

import SwiftUI

struct TickerAISuggestionChip: View {
    let suggestion: TickerAISuggestion
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            Text(suggestion.text)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)
                .padding(.horizontal, AppSpacing.md)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                        .fill(AppColors.cardBackground)
                )
                .overlay(
                    RoundedRectangle(cornerRadius: AppCornerRadius.pill)
                        .stroke(AppColors.cardBackgroundLight, lineWidth: 1)
                )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ScrollView(.horizontal, showsIndicators: false) {
        HStack(spacing: AppSpacing.sm) {
            ForEach(TickerAISuggestion.defaultSuggestions) { suggestion in
                TickerAISuggestionChip(suggestion: suggestion)
            }
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerCard.swift
================================================================================

//
//  TickerCard.swift
//  ios
//
//  Molecule: Market ticker card with price and sparkline
//

import SwiftUI

struct TickerCard: View {
    let ticker: MarketTicker

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xs) {
            // Ticker Name
            Text(ticker.name)
                .font(AppTypography.tickerName)
                .foregroundColor(AppColors.textSecondary)
                .lineLimit(1)

            // Price
            Text(ticker.formattedPrice)
                .font(AppTypography.tickerPrice)
                .foregroundColor(AppColors.textPrimary)
                .lineLimit(1)
                .minimumScaleFactor(0.8)

            // Sparkline
            SparklineView(data: ticker.sparklineData, isPositive: ticker.isPositive)
                .frame(height: 20)

            // Change Percentage
            Text(ticker.formattedChange)
                .font(AppTypography.tickerChange)
                .foregroundColor(ticker.isPositive ? AppColors.bullish : AppColors.bearish)
        }
        .padding(AppSpacing.sm)
        .frame(width: 80, height: 80)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
    }
}

#Preview {
    HStack(spacing: 12) {
        TickerCard(ticker: MarketTicker(
            name: "S&P 500",
            price: 6783.45,
            changePercent: 0.85,
            sparklineData: [100, 102, 98, 105, 103, 108, 110, 107, 112, 115]
        ))

        TickerCard(ticker: MarketTicker(
            name: "Bitcoin",
            price: 89394.43,
            changePercent: -2.34,
            sparklineData: [115, 112, 108, 105, 110, 103, 100, 98, 95, 92]
        ))
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerChartView.swift
================================================================================

//
//  TickerChartView.swift
//  ios
//
//  Molecule: Price chart with time range selector for Ticker Detail
//

import SwiftUI

struct TickerChartView: View {
    let chartData: [Double]
    let isPositive: Bool
    @Binding var selectedRange: ChartTimeRange

    private var lineColor: Color {
        isPositive ? AppColors.bullish : AppColors.bearish
    }

    private var gradientColor: LinearGradient {
        LinearGradient(
            colors: [lineColor.opacity(0.3), lineColor.opacity(0.05)],
            startPoint: .top,
            endPoint: .bottom
        )
    }

    var body: some View {
        VStack(spacing: AppSpacing.md) {
            // Chart
            GeometryReader { geometry in
                let width = geometry.size.width
                let height = geometry.size.height

                if chartData.count > 1 {
                    let minValue = chartData.min() ?? 0
                    let maxValue = chartData.max() ?? 1
                    let range = max(maxValue - minValue, 0.01)
                    let stepX = width / CGFloat(chartData.count - 1)

                    ZStack {
                        // Grid lines (horizontal)
                        VStack(spacing: 0) {
                            ForEach(0..<4) { index in
                                Rectangle()
                                    .fill(AppColors.cardBackgroundLight.opacity(0.5))
                                    .frame(height: 1)
                                if index < 3 {
                                    Spacer()
                                }
                            }
                        }

                        // Gradient fill under line
                        Path { path in
                            path.move(to: CGPoint(x: 0, y: height))

                            for (index, value) in chartData.enumerated() {
                                let x = CGFloat(index) * stepX
                                let y = height - (CGFloat((value - minValue) / range) * height * 0.9) - height * 0.05
                                path.addLine(to: CGPoint(x: x, y: y))
                            }

                            path.addLine(to: CGPoint(x: width, y: height))
                            path.closeSubpath()
                        }
                        .fill(gradientColor)

                        // Line chart
                        Path { path in
                            for (index, value) in chartData.enumerated() {
                                let x = CGFloat(index) * stepX
                                let y = height - (CGFloat((value - minValue) / range) * height * 0.9) - height * 0.05

                                if index == 0 {
                                    path.move(to: CGPoint(x: x, y: y))
                                } else {
                                    path.addLine(to: CGPoint(x: x, y: y))
                                }
                            }
                        }
                        .stroke(lineColor, style: StrokeStyle(lineWidth: 2, lineCap: .round, lineJoin: .round))

                        // Current price dot at end
                        if let lastValue = chartData.last {
                            let x = width
                            let y = height - (CGFloat((lastValue - minValue) / range) * height * 0.9) - height * 0.05

                            Circle()
                                .fill(lineColor)
                                .frame(width: 8, height: 8)
                                .position(x: x, y: y)
                        }
                    }
                }
            }
            .frame(height: 140)
            .padding(.horizontal, AppSpacing.lg)

            // Time range selector
            HStack(spacing: 2) {
                ForEach(ChartTimeRange.allCases, id: \.rawValue) { range in
                    TimeRangeButton(range: range, isSelected: selectedRange == range) {
                        withAnimation(.easeInOut(duration: 0.2)) {
                            selectedRange = range
                        }
                    }
                }

                Spacer()

                // Chart type icon
                Button(action: {
                    // Toggle chart type
                }) {
                    Image(systemName: "chart.xyaxis.line")
                        .font(.system(size: 16, weight: .regular))
                        .foregroundColor(AppColors.textMuted)
                        .padding(.leading, 4)
                        .padding(.trailing, 8)
                }
                .buttonStyle(PlainButtonStyle())

                // Settings icon
                Button(action: {
                    // Open chart settings
                }) {
                    Image(systemName: "gearshape")
                        .font(.system(size: 16, weight: .regular))
                        .foregroundColor(AppColors.textMuted)
                }
                .buttonStyle(PlainButtonStyle())
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var selectedRange: ChartTimeRange = .threeMonths

        var body: some View {
            TickerChartView(
                chartData: [165, 168, 170, 172, 169, 174, 171, 175, 173, 178, 176, 180, 177, 182, 178],
                isPositive: true,
                selectedRange: $selectedRange
            )
            .padding(.vertical)
            .background(AppColors.background)
        }
    }

    return PreviewWrapper()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerDetailAIBar.swift
================================================================================

//
//  TickerDetailAIBar.swift
//  ios
//
//  Molecule: Bottom AI chat bar for Ticker Detail with suggestions
//

import SwiftUI

struct TickerDetailAIBar: View {
    @Binding var inputText: String
    let tickerSymbol: String
    let suggestions: [TickerAISuggestion]
    var onSuggestionTap: ((TickerAISuggestion) -> Void)?
    var onSend: (() -> Void)?

    private var canSend: Bool {
        !inputText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }

    var body: some View {
        VStack(spacing: AppSpacing.md) {
            // Suggestion chips row
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.sm) {
                    ForEach(suggestions) { suggestion in
                        TickerAISuggestionChip(suggestion: suggestion) {
                            onSuggestionTap?(suggestion)
                        }
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }

            // Input bar
            HStack(spacing: AppSpacing.md) {
                // Sparkle icon
                Image(systemName: "sparkles")
                    .font(.system(size: 18, weight: .medium))
                    .foregroundColor(AppColors.primaryBlue)

                // Text field
                TextField("Ask Caudex AI...", text: $inputText)
                    .font(AppTypography.body)
                    .foregroundColor(AppColors.textPrimary)

                // Send button
                Button(action: {
                    if canSend {
                        onSend?()
                    }
                }) {
                    Image(systemName: "arrow.up.circle.fill")
                        .font(.system(size: 28))
                        .foregroundColor(canSend ? AppColors.primaryBlue : AppColors.textMuted)
                }
                .buttonStyle(PlainButtonStyle())
                .disabled(!canSend)
            }
            .padding(.horizontal, AppSpacing.lg)
            .padding(.vertical, AppSpacing.md)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.extraLarge)
            .padding(.horizontal, AppSpacing.lg)
        }
        .padding(.bottom, AppSpacing.md)
        .background(
            AppColors.background
                .shadow(color: Color.black.opacity(0.3), radius: 10, x: 0, y: -5)
        )
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var text = ""

        var body: some View {
            VStack {
                Spacer()
                TickerDetailAIBar(
                    inputText: $text,
                    tickerSymbol: "AAPL",
                    suggestions: TickerAISuggestion.defaultSuggestions
                )
            }
            .background(AppColors.background)
        }
    }

    return PreviewWrapper()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerDetailHeader.swift
================================================================================

//
//  TickerDetailHeader.swift
//  ios
//
//  Molecule: Navigation header for Ticker Detail screen
//

import SwiftUI

struct TickerDetailHeader: View {
    var onBackTapped: (() -> Void)?
    var onNotificationTapped: (() -> Void)?
    var onFavoriteTapped: (() -> Void)?
    var onMoreTapped: (() -> Void)?
    var isFavorite: Bool = false

    // Optional ticker info to show when scrolled (pinned state)
    var tickerSymbol: String? = nil
    var tickerPrice: String? = nil

    var body: some View {
        HStack {
            // Back button and optional ticker info
            HStack(spacing: AppSpacing.sm) {
                Button(action: {
                    onBackTapped?()
                }) {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                        .frame(width: 40, height: 40)
                }
                .buttonStyle(PlainButtonStyle())

                // Ticker symbol and price (shown when pinned)
                if let symbol = tickerSymbol, let price = tickerPrice {
                    HStack(spacing: AppSpacing.xs) {
                        Text(symbol)
                            .font(AppTypography.bodyBold)
                            .foregroundColor(AppColors.textPrimary)

                        Text(price)
                            .font(AppTypography.body)
                            .foregroundColor(AppColors.textSecondary)
                    }
                    .transition(.opacity.combined(with: .move(edge: .leading)))
                }
            }

            Spacer()

            // Right side buttons
            HStack(spacing: AppSpacing.md) {
                // Notification bell
                Button(action: {
                    onNotificationTapped?()
                }) {
                    Image(systemName: "bell")
                        .font(.system(size: 18, weight: .regular))
                        .foregroundColor(AppColors.textPrimary)
                        .frame(width: 40, height: 40)
                }
                .buttonStyle(PlainButtonStyle())

                // Favorite star
                Button(action: {
                    onFavoriteTapped?()
                }) {
                    Image(systemName: isFavorite ? "star.fill" : "star")
                        .font(.system(size: 18, weight: .regular))
                        .foregroundColor(isFavorite ? AppColors.neutral : AppColors.textPrimary)
                        .frame(width: 40, height: 40)
                }
                .buttonStyle(PlainButtonStyle())

                // More options
                Button(action: {
                    onMoreTapped?()
                }) {
                    Image(systemName: "ellipsis")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                        .frame(width: 40, height: 40)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(.horizontal, AppSpacing.sm)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        TickerDetailHeader(isFavorite: false)
        TickerDetailHeader(isFavorite: true)
        TickerDetailHeader(
            isFavorite: false,
            tickerSymbol: "AAPL",
            tickerPrice: "$178.42"
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerDetailTabBar.swift
================================================================================

//
//  TickerDetailTabBar.swift
//  ios
//
//  Molecule: Horizontal scrollable tab bar for Ticker Detail sections
//

import SwiftUI

struct TickerDetailTabBar: View {
    @Binding var selectedTab: TickerDetailTab

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 0) {
                ForEach(TickerDetailTab.allCases, id: \.rawValue) { tab in
                    TickerDetailTabButton(
                        tab: tab,
                        isSelected: selectedTab == tab,
                        onTap: {
                            withAnimation(.easeInOut(duration: 0.2)) {
                                selectedTab = tab
                            }
                        }
                    )
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

struct TickerDetailTabButton: View {
    let tab: TickerDetailTab
    let isSelected: Bool
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            VStack(spacing: AppSpacing.sm) {
                Text(tab.rawValue)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(isSelected ? AppColors.primaryBlue : AppColors.textMuted)
                    .padding(.horizontal, AppSpacing.md)

                // Selection indicator
                Rectangle()
                    .fill(isSelected ? AppColors.primaryBlue : Color.clear)
                    .frame(height: 2)
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var selectedTab: TickerDetailTab = .overview

        var body: some View {
            VStack {
                TickerDetailTabBar(selectedTab: $selectedTab)
                Spacer()
            }
            .background(AppColors.background)
        }
    }

    return PreviewWrapper()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerNewsCard.swift
================================================================================

//
//  TickerNewsCard.swift
//  ios
//
//  Molecule: Complete news card for ticker detail news tab
//

import SwiftUI

struct TickerNewsCard: View {
    let article: TickerNewsArticle
    var currentTicker: String?
    var onCardTap: (() -> Void)?
    var onExternalLinkTap: (() -> Void)?
    var onTickerTap: ((String) -> Void)?

    @State private var isExpanded: Bool = false

    private var hasExpandableContent: Bool {
        article.hasSummary
    }

    var body: some View {
        Button(action: {
            if hasExpandableContent {
                withAnimation(.easeInOut(duration: 0.25)) {
                    isExpanded.toggle()
                }
            } else {
                onCardTap?()
            }
        }) {
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                // Header row: Sentiment + Time (left) and Source (right)
                HStack(spacing: AppSpacing.sm) {
                    // Left side: Sentiment badge + Time
                    HStack(spacing: AppSpacing.sm) {
                        NewsSentimentBadge(sentiment: article.sentiment)
                        
                        Text(article.timeAgo)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                    }
                    
                    Spacer()
                    
                    // Right side: Source name (not too far right, leaving space for image)
                    Text(article.source.name)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                        .padding(.trailing, 80) // Leave space for the thumbnail
                }

                // Main content: Headline + Thumbnail
                HStack(alignment: .top, spacing: AppSpacing.xs) {
                    // Headline
                    Text(article.headline)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(nil)
                        .multilineTextAlignment(.leading)
                        .fixedSize(horizontal: false, vertical: true)

                    Spacer(minLength: 0)

                    // Thumbnail
                    NewsThumbnail(
                        imageName: article.thumbnailName,
                        width: 72,
                        height: 40
                        
                    )
                }

                // Related tickers
                if !article.relatedTickers.isEmpty {
                    TickerNewsRelatedTickers(
                        tickers: article.relatedTickers,
                        currentTicker: currentTicker,
                        onTickerTap: onTickerTap
                    )
                }

                // Expanded content (bullet points)
                if isExpanded && hasExpandableContent {
                    TickerNewsExpandedContent(bullets: article.summaryBullets)
                        .padding(.top, AppSpacing.xs)
                        .transition(.opacity.combined(with: .move(edge: .top)))
                }

                // Footer: External link + Expand toggle
                TickerNewsCardFooter(
                    hasExpandableContent: hasExpandableContent,
                    isExpanded: isExpanded,
                    onExternalLinkTap: onExternalLinkTap,
                    onExpandToggle: {
                        withAnimation(.easeInOut(duration: 0.25)) {
                            isExpanded.toggle()
                        }
                    }
                )
            }
            .padding(AppSpacing.md)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.md) {
            // Sample cards
            ForEach(TickerNewsArticle.sampleDataForTicker("AAPL")) { article in
                TickerNewsCard(
                    article: article,
                    currentTicker: "AAPL"
                )
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerNewsCardFooter.swift
================================================================================

//
//  TickerNewsCardFooter.swift
//  ios
//
//  Molecule: Footer with external link and expand/collapse for news card
//

import SwiftUI

struct TickerNewsCardFooter: View {
    let hasExpandableContent: Bool
    let isExpanded: Bool
    var onExternalLinkTap: (() -> Void)?
    var onExpandToggle: (() -> Void)?

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Show both icons when expanded, on the left side
            if hasExpandableContent && isExpanded {
                // External link button (first)
                Button(action: {
                    onExternalLinkTap?()
                }) {
                    NewsExternalLinkIcon()
                }
                .buttonStyle(PlainButtonStyle())
                
                // Collapse button (second)
                Button(action: {
                    onExpandToggle?()
                }) {
                    NewsCardExpandIcon(isExpanded: isExpanded)
                }
                .buttonStyle(PlainButtonStyle())
            }
            
            Spacer()
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.xl) {
        // With expandable content - collapsed
//        TickerNewsCardFooter(
//            hasExpandableContent: true,
//            isExpanded: false
//        )

        // With expandable content - expanded
        TickerNewsCardFooter(
            hasExpandableContent: true,
            isExpanded: true
        )

//        // Without expandable content
//        TickerNewsCardFooter(
//            hasExpandableContent: false,
//            isExpanded: false
//        )
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerNewsCardHeader.swift
================================================================================

//
//  TickerNewsCardHeader.swift
//  ios
//
//  Molecule: Header row for ticker news card with sentiment, time, and source
//

import SwiftUI

struct TickerNewsCardHeader: View {
    let sentiment: NewsSentiment
    let timeAgo: String
    let sourceName: String

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            // Sentiment badge
            NewsSentimentBadge(sentiment: sentiment)

            // Time ago
            Text(timeAgo)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            // Source name
            Text(sourceName)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textSecondary)

            Spacer()
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        TickerNewsCardHeader(
            sentiment: .positive,
            timeAgo: "2h ago",
            sourceName: "Bloomberg"
        )

        TickerNewsCardHeader(
            sentiment: .neutral,
            timeAgo: "4h ago",
            sourceName: "TechCrunch"
        )

        TickerNewsCardHeader(
            sentiment: .negative,
            timeAgo: "8h ago",
            sourceName: "Financial Times"
        )
    }
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerNewsExpandedContent.swift
================================================================================

//
//  TickerNewsExpandedContent.swift
//  ios
//
//  Molecule: Expanded content section for news card with bullet points
//

import SwiftUI

struct TickerNewsExpandedContent: View {
    let bullets: [String]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            ForEach(Array(bullets.enumerated()), id: \.offset) { _, bullet in
                NewsCardBulletPoint(text: bullet)
            }
        }
    }
}

#Preview {
    TickerNewsExpandedContent(
        bullets: [
            "High Pre-Orders Abroad: Apple is seeing unusually strong pre-order numbers in Europe and Asia, indicating strong international interest before the official launch.",
            "Supply Chain Scaling: Apple is ramping up production and logistics overseas to meet anticipated demand and prevent stock shortages.",
            "Premium Market Appeal: Early excitement suggests that Apple's Vision Pro is resonating with tech enthusiasts and luxury consumers globally."
        ]
    )
    .padding()
    .background(AppColors.cardBackground)
    .cornerRadius(AppCornerRadius.large)
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerNewsRelatedTickers.swift
================================================================================

//
//  TickerNewsRelatedTickers.swift
//  ios
//
//  Molecule: Row of related ticker chips for news card
//

import SwiftUI

struct TickerNewsRelatedTickers: View {
    let tickers: [String]
    var currentTicker: String?
    var onTickerTap: ((String) -> Void)?

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            ForEach(tickers, id: \.self) { ticker in
                Button(action: {
                    onTickerTap?(ticker)
                }) {
                    RelatedTickerChip(
                        symbol: ticker,
                        isHighlighted: false
                    )
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        TickerNewsRelatedTickers(
            tickers: ["AAPL", "MSFT"],
            currentTicker: "AAPL"
        )

        TickerNewsRelatedTickers(
            tickers: ["AAPL", "META"],
            currentTicker: "AAPL"
        )

        TickerNewsRelatedTickers(
            tickers: ["AAPL", "GOOGL"],
            currentTicker: "AAPL"
        )
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerPriceHeader.swift
================================================================================

//
//  TickerPriceHeader.swift
//  ios
//
//  Molecule: Ticker price display with company name, symbol, price and change
//

import SwiftUI

struct TickerPriceHeader: View {
    let companyName: String
    let symbol: String
    let price: String
    let priceChange: String
    let priceChangePercent: String
    let isPositive: Bool
    let marketStatus: MarketStatus

    private var changeColor: Color {
        isPositive ? AppColors.bullish : AppColors.bearish
    }

    private var arrowIcon: String {
        isPositive ? "arrowtriangle.up.fill" : "arrowtriangle.down.fill"
    }

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xs) {
            // Company name and price row
            HStack(alignment: .top) {
                // Left side - Company info
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text(symbol)
                        .font(AppTypography.title2)
                        .foregroundColor(AppColors.textPrimary)

                    Text(companyName)
                        .font(AppTypography.subheadline)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                // Right side - Price info
                VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                    Text(price)
                        .font(.system(size: 24, weight: .bold))
                        .foregroundColor(AppColors.textPrimary)

                    // Price change
                    HStack(spacing: 4) {
                        Image(systemName: arrowIcon)
                            .font(.system(size: 10, weight: .semibold))
                            .foregroundColor(changeColor)

                        Text("\(priceChange) \(priceChangePercent)")
                            .font(AppTypography.footnote)
                            .fontWeight(.semibold)
                            .foregroundColor(changeColor)
                    }
                }
            }

            // Market status
            MarketStatusBadge(status: marketStatus)
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    VStack(spacing: AppSpacing.xl) {
        TickerPriceHeader(
            companyName: "Apple Inc.",
            symbol: "AAPL",
            price: "$178.42",
            priceChange: "+$2.34",
            priceChangePercent: "(+1.33%)",
            isPositive: true,
            marketStatus: .closed(date: Date(), time: "4:00 PM", timezone: "EST")
        )

        TickerPriceHeader(
            companyName: "Tesla, Inc.",
            symbol: "TSLA",
            price: "$252.18",
            priceChange: "-$3.45",
            priceChangePercent: "(-1.35%)",
            isPositive: false,
            marketStatus: .open
        )
    }
    .padding(.vertical)
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TickerStickyHeader.swift
================================================================================

//
//  TickerStickyHeader.swift
//  ios
//
//  Molecule: Compact sticky header for Ticker Detail when scrolling
//  Shows ticker name, price, and tab bar - becomes the ceiling when scrolling
//

import SwiftUI

struct TickerStickyHeader: View {
    let companyName: String
    let symbol: String
    let price: String
    let priceChange: String
    let priceChangePercent: String
    let isPositive: Bool
    @Binding var selectedTab: TickerDetailTab

    private var changeColor: Color {
        isPositive ? AppColors.bullish : AppColors.bearish
    }

    private var arrowIcon: String {
        isPositive ? "arrowtriangle.up.fill" : "arrowtriangle.down.fill"
    }

    var body: some View {
        VStack(spacing: 0) {
            // Compact price row
            HStack {
                // Left side - Company name only (compact)
                Text(companyName)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(1)

                Spacer()

                // Right side - Price and change inline
                HStack(spacing: AppSpacing.sm) {
                    Text(price)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    HStack(spacing: 2) {
                        Image(systemName: arrowIcon)
                            .font(.system(size: 8, weight: .semibold))
                            .foregroundColor(changeColor)

                        Text(priceChangePercent)
                            .font(AppTypography.caption)
                            .fontWeight(.semibold)
                            .foregroundColor(changeColor)
                    }
                }
            }
            .padding(.horizontal, AppSpacing.lg)
            .padding(.vertical, AppSpacing.sm)

            // Tab Bar
            TickerDetailTabBar(selectedTab: $selectedTab)

            // Bottom divider
            Rectangle()
                .fill(AppColors.cardBackgroundLight)
                .frame(height: 1)
        }
        .background(AppColors.background)
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var selectedTab: TickerDetailTab = .overview

        var body: some View {
            VStack {
                TickerStickyHeader(
                    companyName: "Apple Inc.",
                    symbol: "AAPL",
                    price: "$178.42",
                    priceChange: "+$2.34",
                    priceChangePercent: "(+1.33%)",
                    isPositive: true,
                    selectedTab: $selectedTab
                )

                Spacer()
            }
            .background(AppColors.background)
        }
    }

    return PreviewWrapper()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TimelineRow.swift
================================================================================

//
//  TimelineRow.swift
//  ios
//
//  Molecule: Combines timeline indicator with timestamp and news item
//

import SwiftUI

struct TimelineRow: View {
    let article: NewsArticle
    let isFirst: Bool
    let isLast: Bool
    var onTapped: (() -> Void)?

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Timeline Column
            VStack(spacing: 0) {
                // Top connector (hidden for first item)
                if !isFirst {
                    TimelineConnector(height: 8)
                } else {
                    Spacer().frame(height: 8)
                }

                // Dot
                TimelineDot()

                // Bottom connector (extends to content)
                if !isLast {
                    TimelineConnector(height: 120)
                }
            }
            .frame(width: 20)

            // Content Column
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                // Timestamp
                Text(article.formattedTime)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)

                // News Item
                NewsTimelineItem(article: article, onTapped: onTapped)
            }
        }
    }
}

#Preview {
    VStack(spacing: 0) {
        TimelineRow(
            article: NewsArticle(
                headline: "Oil prices stabilize as OPEC + members agreed to maintain current production levels.",
                summary: nil,
                source: NewsSource(name: "Reuters", iconName: nil),
                sentiment: .neutral,
                publishedAt: Date(),
                thumbnailName: nil,
                relatedTickers: []
            ),
            isFirst: true,
            isLast: false
        )

        TimelineRow(
            article: NewsArticle(
                headline: "NVIDIA Announces Record Q4 Earnings",
                summary: nil,
                source: NewsSource(name: "CNBC", iconName: nil),
                sentiment: .negative,
                publishedAt: Date(),
                thumbnailName: nil,
                relatedTickers: []
            ),
            isFirst: false,
            isLast: true
        )
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TipCard.swift
================================================================================

//
//  TipCard.swift
//  ios
//
//  Molecule: Tip/recommendation card
//

import SwiftUI

struct TipCard: View {
    let tip: TipData

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            Text(tip.title)
                .font(AppTypography.captionBold)
                .foregroundColor(AppColors.textSecondary)

            Text(tip.content)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(AppSpacing.lg)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    TipCard(
        tip: TipData(
            title: "RISK MITIGATION TIP",
            content: "Consider diversifying your portfolio and maintaining a long-term investment horizon to weather short-term volatility."
        )
    )
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/Top10OwnersSheet.swift
================================================================================

//
//  Top10OwnersSheet.swift
//  ios
//
//  Molecule: Sheet displaying top 10 institutional and insider owners
//  Shows ranked list with name, category/title, value, and ownership percentage
//

import SwiftUI

struct Top10OwnersSheet: View {
    @Environment(\.dismiss) private var dismiss

    let data: Top10OwnersData

    @State private var selectedTab: Top10OwnerTab = .institutions
    @State private var showInfoSheet: Bool = false

    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Tab Selector
                Top10OwnerTabSelector(selectedTab: $selectedTab)
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.top, AppSpacing.md)
                    .padding(.bottom, AppSpacing.lg)

                // List Content
                ScrollView {
                    LazyVStack(spacing: AppSpacing.sm) {
                        switch selectedTab {
                        case .institutions:
                            ForEach(data.institutions) { institution in
                                Top10InstitutionRow(institution: institution)
                            }
                        case .insiders:
                            ForEach(data.insiders) { insider in
                                Top10InsiderRow(insider: insider)
                            }
                        }
                    }
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.bottom, AppSpacing.xxxl)
                }
            }
            .background(AppColors.background)
            .navigationTitle("Top 10 Owner")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button {
                        showInfoSheet = true
                    } label: {
                        Image(systemName: "info.circle")
                            .font(.system(size: 16))
                            .foregroundColor(AppColors.textMuted)
                    }
                }

                ToolbarItem(placement: .topBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
        .sheet(isPresented: $showInfoSheet) {
            Top10OwnersInfoSheet()
        }
    }
}

// MARK: - Tab Selector

struct Top10OwnerTabSelector: View {
    @Binding var selectedTab: Top10OwnerTab

    var body: some View {
        HStack(spacing: 0) {
            ForEach(Top10OwnerTab.allCases, id: \.rawValue) { tab in
                Button {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedTab = tab
                    }
                } label: {
                    Text(tab.rawValue)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(selectedTab == tab ? AppColors.textPrimary : AppColors.textMuted)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, AppSpacing.sm)
                        .background(
                            selectedTab == tab
                                ? AppColors.cardBackgroundLight
                                : Color.clear
                        )
                        .cornerRadius(AppCornerRadius.medium)
                }
                .buttonStyle(.plain)
            }
        }
        .padding(AppSpacing.xs)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

// MARK: - Institution Row

struct Top10InstitutionRow: View {
    let institution: TopInstitution

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Rank
            Text("#\(institution.rank)")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
                .frame(width: 28, alignment: .leading)

            // Name and Category
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(institution.name)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(1)

                Text(institution.category)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                    .lineLimit(1)
            }

            Spacer()

            // Value and Percentage
            VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                Text(institution.formattedValue)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(institution.formattedPercent)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

// MARK: - Insider Row

struct Top10InsiderRow: View {
    let insider: TopInsider

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Rank
            Text("#\(insider.rank)")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
                .frame(width: 28, alignment: .leading)

            // Name and Title
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(insider.name)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(1)

                Text(insider.title)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                    .lineLimit(1)
            }

            Spacer()

            // Value and Percentage
            VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                Text(insider.formattedValue)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(insider.formattedPercent)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

// MARK: - Info Sheet

struct Top10OwnersInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xl) {
                    // Header
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "building.2.fill")
                                .font(.system(size: 24))
                                .foregroundColor(AppColors.primaryBlue)

                            Text("Understanding Top Owners")
                                .font(AppTypography.title2)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        Text("This list shows the largest shareholders of the company, ranked by the dollar value of their holdings.")
                            .font(AppTypography.body)
                            .foregroundColor(AppColors.textSecondary)
                    }
                    .padding(AppSpacing.lg)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .background(
                        RoundedRectangle(cornerRadius: AppCornerRadius.large)
                            .fill(AppColors.cardBackground)
                    )

                    // Institutions Section
                    infoSection(
                        icon: "building.columns.fill",
                        title: "Institutional Owners",
                        description: "Large investment firms that manage money for others. High institutional ownership often indicates professional confidence in the company.",
                        tips: [
                            "Watch for increasing positions by respected funds",
                            "Diversified ownership is healthier than concentration",
                            "Quarterly 13F filings reveal position changes"
                        ]
                    )

                    // Insiders Section
                    infoSection(
                        icon: "person.fill.checkmark",
                        title: "Insider Owners",
                        description: "Company executives and directors who own shares. Their ownership aligns their interests with shareholders.",
                        tips: [
                            "CEO ownership shows skin in the game",
                            "Directors owning shares signals confidence",
                            "Watch for recent buying activity"
                        ]
                    )

                    // What the Numbers Mean
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        Text("What the Numbers Mean")
                            .font(AppTypography.headline)
                            .foregroundColor(AppColors.textPrimary)

                        VStack(spacing: AppSpacing.sm) {
                            numberExplanation(
                                title: "Value ($14.5B)",
                                description: "The total market value of shares owned, based on current stock price."
                            )

                            numberExplanation(
                                title: "Percentage (5.2%)",
                                description: "The portion of all outstanding shares owned by this entity."
                            )
                        }
                    }
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("About Top Owners")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
    }

    private func infoSection(icon: String, title: String, description: String, tips: [String]) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: icon)
                    .font(.system(size: 18))
                    .foregroundColor(AppColors.primaryBlue)

                Text(title)
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            Text(description)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)

            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                ForEach(tips, id: \.self) { tip in
                    HStack(alignment: .top, spacing: AppSpacing.sm) {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.system(size: 14))
                            .foregroundColor(AppColors.bullish)

                        Text(tip)
                            .font(AppTypography.callout)
                            .foregroundColor(AppColors.textMuted)
                    }
                }
            }
        }
        .padding(AppSpacing.lg)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }

    private func numberExplanation(title: String, description: String) -> some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Image(systemName: "number.circle.fill")
                .font(.system(size: 20))
                .foregroundColor(AppColors.primaryBlue)

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackground)
        )
    }
}

// MARK: - Preview

#Preview {
    Top10OwnersSheet(data: Top10OwnersData.sampleData)
}

#Preview("Info Sheet") {
    Top10OwnersInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/TrendingAnalysisRow.swift
================================================================================

//
//  TrendingAnalysisRow.swift
//  ios
//
//  Molecule: Trending analysis item with icon, title, and stats
//

import SwiftUI

struct TrendingAnalysisRow: View {
    let analysis: TrendingAnalysis
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.md) {
                // Category Icon
                ZStack {
                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                        .fill(analysis.iconBackgroundColor)
                        .frame(width: 44, height: 44)

                    Image(systemName: analysis.systemIconName)
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                }

                // Text Content
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text(analysis.title)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(1)

                    Text(analysis.formattedCompaniesCount)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)

                    TrendingInterestBadge(interestPercent: analysis.interestPercent)
                }

                Spacer()

                // Chevron
                Image(systemName: "chevron.right")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(AppColors.textMuted)
            }
            .padding(AppSpacing.md)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.large)
                    .fill(AppColors.cardBackground)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack(spacing: AppSpacing.sm) {
        ForEach(TrendingAnalysis.mockTrending) { analysis in
            TrendingAnalysisRow(analysis: analysis)
        }
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/UpdatesTabButton.swift
================================================================================

//
//  UpdatesTabButton.swift
//  ios
//
//  Molecule: Tab button for Updates screen filter tabs
//

import SwiftUI

struct UpdatesTabButton: View {
    let tab: NewsFilterTab
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack(spacing: AppSpacing.xs) {
                if tab.isMarketTab {
                    Image(systemName: "globe.americas.fill")
                        .font(.system(size: 12, weight: .medium))
                        .foregroundColor(isSelected ? AppColors.textPrimary : AppColors.textSecondary)
                }

                Text(tab.title)
                    .font(isSelected ? AppTypography.calloutBold : AppTypography.callout)
                    .foregroundColor(isSelected ? AppColors.textPrimary : AppColors.textSecondary)

                if let change = tab.formattedChange {
                    Text(change)
                        .font(AppTypography.caption)
                        .foregroundColor(tab.isPositive ? AppColors.bullish : AppColors.bearish)
                }
            }
            .padding(.horizontal, AppSpacing.md)
            .padding(.vertical, AppSpacing.sm)
            .background(
                isSelected
                    ? AppColors.primaryBlue
                    : AppColors.cardBackgroundLight
            )
            .clipShape(Capsule())
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    HStack(spacing: 10) {
        UpdatesTabButton(
            tab: NewsFilterTab(title: "Market", ticker: nil, changePercent: nil, isMarketTab: true),
            isSelected: true,
            action: {}
        )
        UpdatesTabButton(
            tab: NewsFilterTab(title: "AAPL", ticker: "AAPL", changePercent: 2.4, isMarketTab: false),
            isSelected: false,
            action: {}
        )
        UpdatesTabButton(
            tab: NewsFilterTab(title: "TSLA", ticker: "TSLA", changePercent: -1.2, isMarketTab: false),
            isSelected: false,
            action: {}
        )
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Molecules/UserMessageBubble.swift
================================================================================

//
//  UserMessageBubble.swift
//  ios
//
//  Molecule: User message bubble (right-aligned)
//

import SwiftUI

struct UserMessageBubble: View {
    let text: String
    let timestamp: String

    var body: some View {
        VStack(alignment: .trailing, spacing: AppSpacing.xs) {
            Text(text)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)
                .padding(.vertical, AppSpacing.md)
                .background(AppColors.cardBackgroundLight)
                .cornerRadius(AppCornerRadius.large)

            MessageTimestamp(time: timestamp)
        }
        .frame(maxWidth: .infinity, alignment: .trailing)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        UserMessageBubble(
            text: "What's the current sentiment around Tesla stock?",
            timestamp: "2:36 PM"
        )
        UserMessageBubble(
            text: "How's Tesla's stock performance?",
            timestamp: "2:38 PM"
        )
    }
    .padding()
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/AIBooksSection.swift
================================================================================

//
//  AIBooksSection.swift
//  ios
//
//  Organism: Section showing AI-enabled educational books
//

import SwiftUI

struct AIBooksSection: View {
    let books: [EducationBook]
    var onSeeAll: (() -> Void)?
    var onChatWithBook: ((EducationBook) -> Void)?
    var onReadKeyIdeas: ((EducationBook) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            HStack {
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text("AI-Enabled Books")
                        .font(AppTypography.title3)
                        .foregroundColor(AppColors.textPrimary)

                    Text("Most Read")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                Button(action: {
                    onSeeAll?()
                }) {
                    Text("See All")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
            }
            .padding(.horizontal, AppSpacing.lg)

            // Book cards
            VStack(spacing: AppSpacing.md) {
                ForEach(books) { book in
                    EducationBookCard(
                        book: book,
                        onChatWithBook: { onChatWithBook?(book) },
                        onReadKeyIdeas: { onReadKeyIdeas?(book) }
                    )
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    ScrollView {
        AIBooksSection(books: EducationBook.sampleData)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/AlertsEventsSection.swift
================================================================================

//
//  AlertsEventsSection.swift
//  ios
//
//  Organism: Alerts & Upcoming Events section
//

import SwiftUI

struct AlertsEventsSection: View {
    let alerts: [AlertEvent]
    let smartMoneyAlert: SmartMoneyAlert?
    var onAlertTapped: ((AlertEvent) -> Void)?
    var onSmartMoneyTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section Header
            Text("Alerts & Upcoming Events")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)

            // Alert Cards
            VStack(spacing: AppSpacing.md) {
                ForEach(alerts) { alert in
                    AlertEventCard(alert: alert) {
                        onAlertTapped?(alert)
                    }
                }

                // Smart Money Card
                if let smartMoney = smartMoneyAlert {
                    SmartMoneyCard(alert: smartMoney) {
                        onSmartMoneyTapped?()
                    }
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    ScrollView {
        AlertsEventsSection(
            alerts: AlertEvent.sampleData,
            smartMoneyAlert: SmartMoneyAlert.sampleData
        )
        .padding(.top, AppSpacing.lg)
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/AnalystRatingsSection.swift
================================================================================

//
//  AnalystRatingsSection.swift
//  ios
//
//  Complete Analyst Ratings section for the Analysis tab
//

import SwiftUI

struct AnalystRatingsSection: View {
    let ratingsData: AnalystRatingsData
    @Binding var selectedMomentumPeriod: AnalystMomentumPeriod
    var onMoreTapped: (() -> Void)?
    var onActionsTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            AnalysisSectionHeader(
                title: "Analyst Ratings",
                subtitle: "Total Analysts \(ratingsData.totalAnalysts)\nUpdated On \(ratingsData.formattedUpdatedDate) ET",
                onAction: { onMoreTapped?() }
            )

            // Consensus and Target
            AnalystConsensusRow(
                consensus: ratingsData.consensus,
                targetPrice: ratingsData.formattedTargetPrice,
                targetUpside: ratingsData.formattedUpside
            )

            // Rating distribution bars
            RatingDistributionList(distributions: ratingsData.distributions)

            // Divider
            Rectangle()
                .fill(AppColors.cardBackgroundLight)
                .frame(height: 1)
                .padding(.vertical, AppSpacing.sm)

            // Price target range
            PriceTargetRange(priceTarget: ratingsData.priceTarget)

            // Divider
            Rectangle()
                .fill(AppColors.cardBackgroundLight)
                .frame(height: 1)
                .padding(.vertical, AppSpacing.sm)

            // Momentum section
            AnalysisMomentumSection(
                momentumData: ratingsData.momentumData,
                netPositive: ratingsData.netPositive,
                netNegative: ratingsData.netNegative,
                actionsSummary: ratingsData.actionsSummary,
                selectedPeriod: $selectedMomentumPeriod,
                onActionsTapped: onActionsTapped
            )

            // Disclaimer
            AnalysisDisclaimerText()
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            AnalystRatingsSection(
                ratingsData: AnalystRatingsData.sampleData,
                selectedMomentumPeriod: .constant(.sixMonths),
                onMoreTapped: {}
            )
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/AssetsListSection.swift
================================================================================

//
//  AssetsListSection.swift
//  ios
//
//  Organism: Assets list with sort and add functionality
//

import SwiftUI

struct AssetsListSection: View {
    let assets: [TrackedAsset]
    var onSortTapped: (() -> Void)?
    var onAddTapped: (() -> Void)?
    var onAssetTapped: ((TrackedAsset) -> Void)?

    var body: some View {
        VStack(spacing: 0) {
            // Sort Button Row
            HStack {
                SortButton(onTap: onSortTapped)
                Spacer()
            }
            .padding(.horizontal, AppSpacing.lg)
            .padding(.bottom, AppSpacing.md)

            // Assets List
            VStack(spacing: 0) {
                ForEach(assets) { asset in
                    AssetRow(asset: asset) {
                        onAssetTapped?(asset)
                    }

                    // Divider between items
                    if asset.id != assets.last?.id {
                        Divider()
                            .background(AppColors.cardBackgroundLight)
                            .padding(.leading, AppSpacing.lg)
                    }
                }
            }
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
            .padding(.horizontal, AppSpacing.lg)

            // Add New Button
            AddAssetButton(onTap: onAddTapped)
                .padding(.top, AppSpacing.lg)
        }
    }
}

#Preview {
    ScrollView {
        AssetsListSection(assets: TrackedAsset.sampleData)
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ChatHistoryHeader.swift
================================================================================

//
//  ChatHistoryHeader.swift
//  ios
//
//  Organism: Header with history button for chat tab
//

import SwiftUI

struct ChatHistoryHeader: View {
    var showingHistory: Bool = false
    var onHistoryTap: (() -> Void)?
    var onChevronTap: (() -> Void)?

    var body: some View {
        HStack {
            HistoryButton {
                onHistoryTap?()
            }

            Spacer()

            // Show chevron when viewing history
            if showingHistory {
                Button(action: {
                    onChevronTap?()
                }) {
                    Image(systemName: "chevron.right")
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(AppColors.textSecondary)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.sm)
    }
}

#Preview {
    VStack(spacing: AppSpacing.lg) {
        ChatHistoryHeader(showingHistory: false)
        ChatHistoryHeader(showingHistory: true)
        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ChatHistoryList.swift
================================================================================

//
//  ChatHistoryList.swift
//  ios
//
//  Organism: Full chat history list grouped by sections
//

import SwiftUI

struct ChatHistoryList: View {
    let groups: [ChatHistoryGroup]
    var onItemTap: ((ChatHistoryItem) -> Void)?
    var onItemMoreOptions: ((ChatHistoryItem) -> Void)?
    var onSectionTap: ((ChatHistorySection) -> Void)?

    var body: some View {
        ScrollView(showsIndicators: false) {
            LazyVStack(spacing: 0, pinnedViews: []) {
                ForEach(groups) { group in
                    // Section header
                    ChatHistorySectionHeader(
                        section: group.section,
                        showChevron: group.section == .today
                    ) {
                        onSectionTap?(group.section)
                    }
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.top, group.section == .today ? AppSpacing.md : AppSpacing.xl)
                    .padding(.bottom, AppSpacing.sm)

                    // Items in section
                    ForEach(group.items) { item in
                        VStack(spacing: 0) {
                            ChatHistoryItemRow(
                                item: item,
                                onTap: { onItemTap?(item) },
                                onMoreOptions: { onItemMoreOptions?(item) }
                            )
                            .padding(.horizontal, AppSpacing.lg)

                            // Divider between items (not after last item in section)
                            if item.id != group.items.last?.id {
                                Divider()
                                    .background(AppColors.cardBackgroundLight)
                                    .padding(.horizontal, AppSpacing.lg)
                            }
                        }
                    }
                }

                // Bottom padding
                Color.clear.frame(height: AppSpacing.xxxl)
            }
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ChatHistoryList(groups: ChatHistoryItem.sampleGroups)
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ChatInputSection.swift
================================================================================

//
//  ChatInputSection.swift
//  ios
//
//  Organism: Complete chat input section with input bar and options
//

import SwiftUI

struct ChatInputSection: View {
    @Binding var inputText: String
    var onAttachmentTap: (() -> Void)?
    var onSend: (() -> Void)?
    var onVoiceTap: (() -> Void)?
    var onImageTap: (() -> Void)?
    var onFocusChange: ((Bool) -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.md) {
            // Input bar
            ChatInputBar(
                text: $inputText,
                onAttachmentTap: onAttachmentTap,
                onSend: onSend,
                onFocusChange: onFocusChange
            )

            // Voice and Image options
//            ChatInputOptions(
//                onVoiceTap: onVoiceTap,
//                onImageTap: onImageTap
//            )
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.bottom, AppSpacing.md)
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var text = ""

        var body: some View {
            VStack {
                Spacer()
                ChatInputSection(inputText: $text)
            }
            .background(AppColors.background)
        }
    }

    return PreviewWrapper()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ChatMessagesList.swift
================================================================================

//
//  ChatMessagesList.swift
//  ios
//
//  Organism: Scrollable list of chat messages
//

import SwiftUI

struct ChatMessagesList: View {
    let messages: [RichChatMessage]

    var body: some View {
        ScrollViewReader { proxy in
            ScrollView(showsIndicators: false) {
                LazyVStack(spacing: AppSpacing.xl) {
                    ForEach(messages) { message in
                        ChatMessageRow(message: message)
                            .id(message.id)
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
                .padding(.vertical, AppSpacing.md)
            }
            .onChange(of: messages.count) { oldValue, newValue in
                // Scroll to bottom when new message is added
                if let lastMessage = messages.last {
                    withAnimation {
                        proxy.scrollTo(lastMessage.id, anchor: .bottom)
                    }
                }
            }
        }
    }
}

// MARK: - Chat Message Row
struct ChatMessageRow: View {
    let message: RichChatMessage

    var body: some View {
        switch message.role {
        case .user:
            userMessage
        case .assistant:
            assistantMessage
        }
    }

    private var userMessage: some View {
        Group {
            if case .text(let text) = message.content.first {
                UserMessageBubble(text: text, timestamp: message.formattedTime)
            }
        }
    }

    private var assistantMessage: some View {
        AIMessageContent(content: message.content, timestamp: message.formattedTime)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ChatMessagesList(messages: RichChatMessage.sampleConversation)
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ChatSuggestionsSection.swift
================================================================================

//
//  ChatSuggestionsSection.swift
//  ios
//
//  Organism: Section with suggestion chips for chat
//

import SwiftUI

struct ChatSuggestionsSection: View {
    let suggestions: [SuggestionChip]
    var onSuggestionTap: ((SuggestionChip) -> Void)?

    var body: some View {
        SuggestionChipsRow(chips: suggestions) { chip in
            onSuggestionTap?(chip)
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    VStack {
        Spacer()
        ChatSuggestionsSection(suggestions: SuggestionChip.sampleData)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/CommunityDiscussionsSection.swift
================================================================================

//
//  CommunityDiscussionsSection.swift
//  ios
//
//  Organism: Section showing community discussions
//

import SwiftUI

struct CommunityDiscussionsSection: View {
    let discussions: [CommunityDiscussion]
    var onSeeAll: (() -> Void)?
    var onDiscussionTap: ((CommunityDiscussion) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            HStack {
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text("Community Discussions")
                        .font(AppTypography.title3)
                        .foregroundColor(AppColors.textPrimary)

                    Text("Join the conversation")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                Button(action: {
                    onSeeAll?()
                }) {
                    Text("See All")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
            }
            .padding(.horizontal, AppSpacing.lg)

            // Discussion rows
            VStack(spacing: AppSpacing.md) {
                ForEach(discussions) { discussion in
                    CommunityDiscussionRow(discussion: discussion) {
                        onDiscussionTap?(discussion)
                    }
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    ScrollView {
        CommunityDiscussionsSection(discussions: CommunityDiscussion.sampleData)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/CommunityInsightsSection.swift
================================================================================

//
//  CommunityInsightsSection.swift
//  ios
//
//  Organism: Community insights section with discussion link
//

import SwiftUI

struct CommunityInsightsSection: View {
    let insights: [CommunityInsight]
    var onJoinDiscussion: (() -> Void)?
    var onLike: ((CommunityInsight) -> Void)?
    var onComment: ((CommunityInsight) -> Void)?
    var onShare: ((CommunityInsight) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section header
            HStack {
                Text("Community Insights")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button(action: {
                    onJoinDiscussion?()
                }) {
                    Text("Join Discussion")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
                .buttonStyle(PlainButtonStyle())
            }

            // Insights list
            VStack(spacing: AppSpacing.md) {
                ForEach(insights) { insight in
                    CommunityInsightRow(
                        insight: insight,
                        onLike: { onLike?(insight) },
                        onComment: { onComment?(insight) },
                        onShare: { onShare?(insight) }
                    )
                }
            }
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    ScrollView {
        CommunityInsightsSection(insights: CommunityInsight.mockInsights)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/CustomTabBar.swift
================================================================================

//
//  CustomTabBar.swift
//  ios
//
//  Organism: Custom bottom tab bar
//

import SwiftUI

struct CustomTabBar: View {
    @Binding var selectedTab: HomeTab

    var body: some View {
        HStack(spacing: 0) {
            ForEach(HomeTab.allCases, id: \.self) { tab in
                TabBarItem(tab: tab, isSelected: selectedTab == tab) {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedTab = tab
                    }
                }
            }
        }
        .padding(.top, AppSpacing.md)
        .padding(.bottom, AppSpacing.xl)
        .background(
            AppColors.tabBarBackground
                .shadow(color: Color.black.opacity(0.3), radius: 10, x: 0, y: -5)
        )
    }
}

#Preview {
    VStack {
        Spacer()
        CustomTabBar(selectedTab: .constant(.home))
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/DailyBriefingSection.swift
================================================================================

//
//  DailyBriefingSection.swift
//  ios
//
//  Organism: Daily briefing section with list of alerts
//

import SwiftUI

struct DailyBriefingSection: View {
    let items: [DailyBriefingItem]
    var onItemTapped: ((DailyBriefingItem) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section Header
            SectionHeader(title: "Daily Briefing")
                .padding(.horizontal, AppSpacing.lg)

            // Alert Items
            VStack(spacing: AppSpacing.sm) {
                ForEach(items) { item in
                    DailyBriefingRow(item: item) {
                        onItemTapped?(item)
                    }
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    ScrollView {
        DailyBriefingSection(items: [
            DailyBriefingItem(
                type: .whalesAlert,
                title: "Whales Alert",
                subtitle: "Large crypto whale just moved $50M into COIN stock",
                date: nil,
                badgeText: nil
            ),
            DailyBriefingItem(
                type: .earningsAlert,
                title: "Earnings Alert",
                subtitle: "NVDA reports earnings tomorrow after market close.",
                date: Date(),
                badgeText: "24\nFEB"
            ),
            DailyBriefingItem(
                type: .whalesFollowing,
                title: "Whales Your Following",
                subtitle: "3 hedge funds you follow bought GOOGL this week. Avg. position size: $1.2B",
                date: nil,
                badgeText: nil
            ),
            DailyBriefingItem(
                type: .wiserTrending,
                title: "Wiser: Trending",
                subtitle: "How can I invest in OpenAI even though the company is not yet listed?",
                date: nil,
                badgeText: nil
            )
        ])
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/EarningsSectionCard.swift
================================================================================

//
//  EarningsSectionCard.swift
//  ios
//
//  Organism: Complete earnings section card with chart, toggles, and legend
//

import SwiftUI

struct EarningsSectionCard: View {
    let earningsData: EarningsData
    let onDetailTap: (() -> Void)?

    @State private var selectedDataType: EarningsDataType = .eps
    @State private var selectedTimeRange: EarningsTimeRange = .oneYear
    @State private var showPriceLine: Bool = false
    @State private var showInfoSheet: Bool = false

    init(
        earningsData: EarningsData,
        onDetailTap: (() -> Void)? = nil,
        onInfoTap: (() -> Void)? = nil
    ) {
        self.earningsData = earningsData
        self.onDetailTap = onDetailTap
    }

    // Get quarters based on selected data type and time range
    private var displayQuarters: [EarningsQuarterData] {
        let allQuarters = earningsData.quarters(for: selectedDataType)
        
        switch selectedTimeRange {
        case .oneYear:
            // Show last 6 quarters (4 historical + 2 future estimates for 1Y view)
            return Array(allQuarters.suffix(6))
        case .threeYears:
            // Show all quarters (up to 14 for 3 years + future)
            return allQuarters
        }
    }
    
    // Get price history filtered to match displayed quarters
    private var displayPriceHistory: [EarningsPricePoint] {
        let allPriceHistory = earningsData.priceHistory
        
        switch selectedTimeRange {
        case .oneYear:
            // Show last 6 price points (1 year + future)
            return Array(allPriceHistory.suffix(6))
        case .threeYears:
            // Show all price history
            return allPriceHistory
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            headerSection

            // Toggle controls row
            controlsRow

            // Main EPS/Revenue chart
            EarningsChartView(
                quarters: displayQuarters,
                priceHistory: displayPriceHistory,
                showPriceLine: showPriceLine
            )
            
            // Surprise bar chart (3Y only)
            if selectedTimeRange == .threeYears {
                EarningsSurpriseBarChart(quarters: displayQuarters)
            }

            // Surprise percentages row (1Y only - replaced by bar chart in 3Y)
            if selectedTimeRange == .oneYear {
                EarningsSurpriseRow(quarters: displayQuarters)
            }

            // Spacer before legend
            Spacer()
                .frame(height: AppSpacing.md)

            // Legend
            EarningsLegend()
                .frame(maxWidth: .infinity)

            // Next Earnings Date
            if let nextEarnings = earningsData.nextEarningsDate {
                NextEarningsDateCard(nextEarningsDate: nextEarnings)
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
        .sheet(isPresented: $showInfoSheet) {
            EarningsInfoSheet()
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        HStack {
            HStack(spacing: AppSpacing.sm) {
                Text("Earnings")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                // Info button
                Button {
                    showInfoSheet = true
                } label: {
                    ZStack {
                        Circle()
                            .stroke(AppColors.textMuted, lineWidth: 1.5)
                            .frame(width: 20, height: 20)

                        Text("i")
                            .font(.system(size: 12, weight: .semibold))
                            .foregroundColor(AppColors.textMuted)
                    }
                }
                .buttonStyle(PlainButtonStyle())
            }

            Spacer()

            // Detail link
            Button {
                onDetailTap?()
            } label: {
                Text("Detail")
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.primaryBlue)
            }
            .buttonStyle(PlainButtonStyle())
        }
    }

    // MARK: - Controls Row

    private var controlsRow: some View {
        HStack {
            // EPS / Revenue toggle
            EarningsDataTypeToggle(selectedType: $selectedDataType)

            Spacer()
                .frame(width: AppSpacing.lg)

            // 1Y / 3Y toggle
            EarningsTimeRangeToggle(selectedRange: $selectedTimeRange)

            Spacer()

            // Price toggle
            EarningsPriceToggle(isEnabled: $showPriceLine)
        }
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            EarningsSectionCard(
                earningsData: EarningsData.sampleData,
                onDetailTap: {
                    print("Detail tapped")
                }
            )
            .padding(AppSpacing.lg)
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/EarningsSurpriseBarChart.swift
================================================================================

//
//  EarningsSurpriseBarChart.swift
//  ios
//
//  Molecule: Vertical bar chart displaying quarterly EPS surprise percentages
//  Background chart for 3Y view only - shows historical beat/miss trends
//

import SwiftUI

struct EarningsSurpriseBarChart: View {
    let quarters: [EarningsQuarterData]
    
    // Calculate Y-axis range based on surprise percentages
    // Range is symmetric to ensure 0% line is centered
    private var surpriseRange: (min: Double, max: Double) {
        let surprises = quarters.compactMap { $0.surprisePercent }
        guard !surprises.isEmpty else {
            return (min: -10, max: 10)
        }
        
        let minSurprise = surprises.min() ?? -10
        let maxSurprise = surprises.max() ?? 10
        
        // Find the maximum absolute value to make range symmetric
        let absMax = max(abs(minSurprise), abs(maxSurprise))
        
        // Round up to closest clean value (1, 5, 10, 20, 50, etc.)
        let roundedMax = ceil(absMax)
        
        return (min: -roundedMax, max: roundedMax)
    }
    
    private var chartHeight: CGFloat { 100 }
    private var yAxisWidth: CGFloat { 40 }
    private var barWidthRatio: CGFloat { 0.5 } // Bar takes 50% of available space per quarter
    
    var body: some View {
        HStack(alignment: .top, spacing: 0) {
            // Left spacer to align with main chart (matches Y-axis width)
            yAxisLabels()
                .frame(width: yAxisWidth)
            
            // Chart area with manual bar positioning
            GeometryReader { geometry in
                let width = geometry.size.width
                let height = geometry.size.height
                let quarterCount = quarters.count
                let stepX = width / CGFloat(quarterCount)
                let barWidth = stepX * barWidthRatio
                let range = max(surpriseRange.max - surpriseRange.min, 0.01)
                
                ZStack {
                    // Zero line (horizontal line at 0%)
                    let zeroY = normalizedY(0, height: height, range: range)
                    Path { path in
                        path.move(to: CGPoint(x: 0, y: height - zeroY))
                        path.addLine(to: CGPoint(x: width, y: height - zeroY))
                    }
                    .stroke(style: StrokeStyle(lineWidth: 1.5, dash: [5, 3]))
                    .foregroundColor(AppColors.textMuted.opacity(0.6))
                    
                    // Surprise bars
                    ForEach(Array(quarters.enumerated()), id: \.element.id) { index, quarter in
                        if let surprise = quarter.surprisePercent {
                            let x = CGFloat(index) * stepX + stepX / 2
                            let surpriseY = normalizedY(surprise, height: height, range: range)
                            let barHeight = abs(surpriseY - zeroY)
                            
                            // Calculate bar's Y position
                            // For positive: bar extends from zero upward
                            // For negative: bar extends from zero downward
                            let barCenterY: CGFloat = if surprise >= 0 {
                                // Positive: bar center is above zero line
                                height - zeroY - barHeight / 2
                            } else {
                                // Negative: bar center is below zero line
                                height - zeroY + barHeight / 2
                            }
                            
                            RoundedRectangle(cornerRadius: 3)
                                .fill(surprise >= 0 ? AppColors.bullish : AppColors.bearish)
                                .frame(width: barWidth, height: barHeight)
                                .position(x: x, y: barCenterY)
                        }
                    }
                }
            }
            .frame(height: chartHeight)
        }
    }
    
    // MARK: - Helper Views
    
    private func yAxisLabels() -> some View {
        GeometryReader { geometry in
            let height = geometry.size.height
            let range = max(surpriseRange.max - surpriseRange.min, 0.01)
            
            // Calculate Y positions using the same normalization as the chart
            let maxY = normalizedY(surpriseRange.max, height: height, range: range)
            let zeroY = normalizedY(0, height: height, range: range)
            let minY = normalizedY(surpriseRange.min, height: height, range: range)
            
            ZStack(alignment: .trailing) {
                // Max label at top
                Text(formatYValue(surpriseRange.max))
                    .font(.system(size: 11))
                    .foregroundColor(AppColors.textMuted)
                    .position(x: geometry.size.width / 2, y: height - maxY)
                
                // Zero label at calculated position
                Text("0%")
                    .font(.system(size: 11))
                    .foregroundColor(AppColors.textMuted)
                    .position(x: geometry.size.width / 2, y: height - zeroY)
                
                // Min label at bottom
                Text(formatYValue(surpriseRange.min))
                    .font(.system(size: 11))
                    .foregroundColor(AppColors.textMuted)
                    .position(x: geometry.size.width / 2, y: height - minY)
            }
        }
        .frame(height: chartHeight)
        .padding(.trailing, AppSpacing.sm)
    }
    
    // MARK: - Helper Functions
    
    private func normalizedY(_ value: Double, height: CGFloat, range: Double) -> CGFloat {
        let normalized = (value - surpriseRange.min) / range
        return CGFloat(normalized) * height * 0.85 + height * 0.075
    }
    
    private func formatYValue(_ value: Double) -> String {
        return "\(Int(value))%"
    }
}


// MARK: - Preview

#Preview("1Y View - Limited Data") {
    ZStack {
        AppColors.background
            .ignoresSafeArea()
        
        VStack(spacing: AppSpacing.lg) {
            // 1Y view with last 6 quarters
            EarningsSurpriseBarChart(
                quarters: Array(EarningsData.sampleData.epsQuarters.suffix(6))
            )
            .padding(AppSpacing.lg)
        }
    }
}

#Preview("3Y View - Full Data") {
    ZStack {
        AppColors.background
            .ignoresSafeArea()
        
        ScrollView {
            VStack(spacing: AppSpacing.lg) {
                // 3Y view with all historical quarters
                EarningsSurpriseBarChart(
                    quarters: EarningsData.sampleData.epsQuarters
                )
                .padding(AppSpacing.lg)
                
                // Sample with more extreme values
                EarningsSurpriseBarChart(
                    quarters: [
                        EarningsQuarterData(quarter: "Q1 '22", actualValue: 0.45, estimateValue: 0.42, surprisePercent: 7.1),
                        EarningsQuarterData(quarter: "Q2 '22", actualValue: 0.52, estimateValue: 0.50, surprisePercent: 15.5),
                        EarningsQuarterData(quarter: "Q3 '22", actualValue: 0.48, estimateValue: 0.52, surprisePercent: -7.7),
                        EarningsQuarterData(quarter: "Q4 '22", actualValue: 0.55, estimateValue: 0.55, surprisePercent: 0),
                        EarningsQuarterData(quarter: "Q1 '23", actualValue: 0.58, estimateValue: 0.55, surprisePercent: 5.5),
                        EarningsQuarterData(quarter: "Q2 '23", actualValue: 0.62, estimateValue: 0.60, surprisePercent: -12.3),
                        EarningsQuarterData(quarter: "Q3 '23", actualValue: 0.55, estimateValue: 0.58, surprisePercent: 8.2),
                        EarningsQuarterData(quarter: "Q4 '23", actualValue: 0.68, estimateValue: 0.65, surprisePercent: 18.6),
                    ]
                )
                .padding(AppSpacing.lg)
            }
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/GenerateAnalysisSection.swift
================================================================================

//
//  GenerateAnalysisSection.swift
//  ios
//
//  Organism: Generate analysis button with credits indicator
//

import SwiftUI

struct GenerateAnalysisSection: View {
    let cost: AnalysisCost
    let remainingCredits: Int
    var isEnabled: Bool = true
    var isLoading: Bool = false
    var onGenerate: (() -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.md) {
            // Generate button
            GenerateAnalysisButton(
                cost: cost,
                isEnabled: isEnabled,
                isLoading: isLoading,
                onTap: onGenerate
            )

            // Credits remaining
            CreditsBadge(credits: remainingCredits, style: .compact)
        }
        .padding(.horizontal, AppSpacing.lg)
        
    }
}

#Preview {
    VStack(spacing: AppSpacing.xxl) {
        GenerateAnalysisSection(
            cost: .standard,
            remainingCredits: 47,
            isEnabled: true
        )

        GenerateAnalysisSection(
            cost: .standard,
            remainingCredits: 3,
            isEnabled: false
        )
    }
    .padding(.vertical)
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/GrowthSectionCard.swift
================================================================================

//
//  GrowthSectionCard.swift
//  ios
//
//  Organism: Complete Growth Section card for the Financial tab
//  Displays growth metrics with selectable metric types and time periods
//

import SwiftUI

struct GrowthSectionCard: View {
    // MARK: - Properties

    let growthData: GrowthSectionData
    let onDetailTapped: () -> Void

    // MARK: - State

    @State private var selectedMetric: GrowthMetricType = .eps
    @State private var selectedPeriod: GrowthPeriodType = .annual
    @State private var showInfoSheet: Bool = false

    // MARK: - Computed Properties

    private var currentDataPoints: [GrowthDataPoint] {
        growthData.dataPoints(for: selectedMetric, period: selectedPeriod)
    }

    // MARK: - Body

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header with title, info icon, and detail link
            headerSection

            // Metric type selector (EPS, Revenue, etc.)
            GrowthMetricSelector(selectedMetric: $selectedMetric)

            // Period toggle (Annual / Quarterly)
            GrowthPeriodToggle(selectedPeriod: $selectedPeriod)
                .padding(.leading, AppSpacing.xs)

            // Main chart
            GrowthChartView(dataPoints: currentDataPoints)
                .id("\(selectedMetric.rawValue)-\(selectedPeriod.rawValue)")
                .padding(.top, AppSpacing.sm)
                .animation(.easeInOut(duration: 0.3), value: selectedMetric)
                .animation(.easeInOut(duration: 0.3), value: selectedPeriod)

            // Legend
            GrowthLegendView()
                .frame(maxWidth: .infinity)
                .padding(.top, AppSpacing.md)
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
        .sheet(isPresented: $showInfoSheet) {
            GrowthInfoSheet()
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        HStack {
            HStack(spacing: AppSpacing.sm) {
                Text("Growth")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                GrowthInfoIcon {
                    showInfoSheet = true
                }
            }

            Spacer()

            Button(action: onDetailTapped) {
                Text("Detail")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.primaryBlue)
            }
            .buttonStyle(.plain)
        }
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            GrowthSectionCard(
                growthData: GrowthSectionData.sampleData,
                onDetailTapped: {}
            )
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/HealthCheckSectionCard.swift
================================================================================

//
//  HealthCheckSectionCard.swift
//  ios
//
//  Organism: Complete Health Check Section card for the Financial tab
//  Displays financial health metrics with gauges showing position vs sector averages
//

import SwiftUI

struct HealthCheckSectionCard: View {
    // MARK: - Properties

    let healthCheckData: HealthCheckSectionData
    let onDetailTapped: () -> Void

    // MARK: - State

    @State private var showInfoSheet: Bool = false

    // MARK: - Body

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header with title, status badge, info icon, and detail link
            headerSection

            // Metric cards in horizontal scroll
            metricsSection
        }
        .padding(.vertical, AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
        .sheet(isPresented: $showInfoSheet) {
            HealthCheckInfoSheet()
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        HStack(alignment: .center, spacing: AppSpacing.sm) {
            // Title
            Text("Health Check")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            // Status badge (e.g., "[2/4] Mix")
            HealthCheckStatusBadge(
                rating: healthCheckData.overallRating,
                passedCount: healthCheckData.passedCount,
                totalCount: healthCheckData.totalCount
            )

            // Info icon
            HealthCheckInfoIcon {
                showInfoSheet = true
            }

            Spacer()

            // Detail link
            Button(action: onDetailTapped) {
                Text("Detail")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.primaryBlue)
            }
            .buttonStyle(.plain)
        }
        .padding(.horizontal, AppSpacing.lg)
    }

    // MARK: - Metrics Section

    private var metricsSection: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(alignment: .top, spacing: AppSpacing.md) {
                ForEach(healthCheckData.metrics) { metric in
                    HealthCheckMetricCard(metric: metric)
                        .frame(width: 280)
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            VStack(spacing: AppSpacing.lg) {
                HealthCheckSectionCard(
                    healthCheckData: HealthCheckSectionData.sampleData,
                    onDetailTapped: {}
                )

                HealthCheckSectionCard(
                    healthCheckData: HealthCheckSectionData.sampleApple,
                    onDetailTapped: {}
                )
            }
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/HomeHeader.swift
================================================================================

//
//  HomeHeader.swift
//  ios
//
//  Organism: Home screen header with logo, search, and profile
//

import SwiftUI

struct HomeHeader: View {
    var onProfileTapped: (() -> Void)?
    var onSearchTapped: (() -> Void)?

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Logo placeholder
            LogoView()

            // Tappable Search Bar - navigates to SearchView
            TappableSearchBar(
                placeholder: "Search ticker or ask AI...",
                onTap: onSearchTapped
            )

            // Profile Button
            Button(action: {
                onProfileTapped?()
            }) {
                Image(systemName: "person.crop.circle.fill")
                    .font(.system(size: 32))
                    .foregroundColor(AppColors.primaryBlue)
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.sm)
    }
}

// MARK: - Logo View
struct LogoView: View {
    var body: some View {
        ZStack {
            Circle()
                .fill(AppColors.cardBackground)
                .frame(width: 36, height: 36)

            Text("logo")
                .font(.system(size: 8, weight: .medium))
                .foregroundColor(AppColors.textMuted)
        }
    }
}

#Preview {
    VStack {
        HomeHeader()
        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/InsightsSummaryCard.swift
================================================================================

//
//  InsightsSummaryCard.swift
//  ios
//
//  Organism: AI-generated insights summary card for Updates screen
//

import SwiftUI

struct InsightsSummaryCard: View {
    let summary: NewsInsightSummary

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header
            HStack {
                HStack(spacing: AppSpacing.sm) {
                    Image(systemName: "bolt.fill")
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundColor(AppColors.neutral)

                    Text("Insights")
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)
                }

                Spacer()

                AIBadge(text: summary.summaryBadgeText)
            }

            // Headline
            Text(summary.headline)
                .font(AppTypography.title2)
                .foregroundColor(AppColors.textPrimary)
                .fixedSize(horizontal: false, vertical: true)

            // Bullet Points
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                ForEach(summary.bulletPoints, id: \.self) { point in
                    HStack(alignment: .top, spacing: AppSpacing.sm) {
                        Circle()
                            .fill(AppColors.textSecondary)
                            .frame(width: 5, height: 5)
                            .padding(.top, 6)

                        Text(point)
                            .font(AppTypography.callout)
                            .foregroundColor(AppColors.textSecondary)
                            .fixedSize(horizontal: false, vertical: true)
                    }
                }
            }

            // Footer
            HStack {
                SentimentBadge(sentiment: summary.sentiment)

                Spacer()

                Text(summary.timeAgo)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    InsightsSummaryCard(
        summary: NewsInsightSummary(
            headline: "Tech Stocks Rally on Strong AI Earnings",
            bulletPoints: [
                "Major technology companies posted impressive Q4 results driven by AI infrastructure investments.",
                "Cloud computing revenue exceeded expectations, with Microsoft and Google leading the charge. Market sentiment remains bullish heading into 2024."
            ],
            sentiment: .bullish,
            updatedAt: Date().addingTimeInterval(-3600),
            summaryType: "24h - AI Summary"
        )
    )
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/InvestorJourneyLevelSection.swift
================================================================================

//
//  InvestorJourneyLevelSection.swift
//  ios
//
//  Organism: Complete level section with header, progress bar, and horizontal lesson cards
//

import SwiftUI

struct InvestorJourneyLevelSection: View {
    let levelProgress: LevelProgress
    var onLessonTap: ((Lesson) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Level header
            LevelSectionHeader(
                level: levelProgress.level,
                completed: levelProgress.completedCount,
                total: levelProgress.totalCount
            )
            .padding(.horizontal, AppSpacing.lg)

            // Horizontal scrolling lesson cards
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.md) {
                    ForEach(levelProgress.lessons) { lesson in
                        LessonCard(lesson: lesson) {
                            onLessonTap?(lesson)
                        }
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }

            // Level progress bar
            HStack {
                Spacer()
                
                LevelProgressBar(
                    progress: levelProgress.progress,
                    completed: levelProgress.completedCount,
                    total: levelProgress.totalCount,
                    color: levelProgress.level.color
                )
                .frame(maxWidth: 120)
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.xxl) {
            InvestorJourneyLevelSection(
                levelProgress: InvestorJourneyData.sampleData.levels[0]
            )

            InvestorJourneyLevelSection(
                levelProgress: InvestorJourneyData.sampleData.levels[1]
            )
        }
        .padding(.vertical)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/InvestorJourneySection.swift
================================================================================

//
//  InvestorJourneySection.swift
//  ios
//
//  Organism: Section showing investor journey level progression
//

import SwiftUI

struct InvestorJourneySection: View {
    let currentLevel: InvestorLevel
    let journeyTrack: JourneyTrack?
    var onSeeAll: (() -> Void)?
    var onContinue: (() -> Void)?
    var onItemTap: ((JourneyItem) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            SectionHeader(title: "Investor Journey", showSeeAll: true) {
                onSeeAll?()
            }

            // Merged Card: Journey Progress and Level badges combined
            VStack(spacing: 0) {
                // Journey Progress content (if available)
                if let track = journeyTrack {
                    VStack(alignment: .leading, spacing: AppSpacing.lg) {
                        // Header with track info and progress
                        HStack {
                            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                                HStack(spacing: AppSpacing.sm) {
                                    // Level icon
                                    Image(systemName: track.level.iconName)
                                        .font(.system(size: 14, weight: .semibold))
                                        .foregroundColor(track.level.color)

                                    Text("\(track.level.rawValue) Track")
                                        .font(AppTypography.headline)
                                        .foregroundColor(AppColors.textPrimary)
                                }

                                Text(track.formattedProgress)
                                    .font(AppTypography.caption)
                                    .foregroundColor(AppColors.textSecondary)
                            }

                            Spacer()

                            // Progress percentage
                            Text("\(track.progressPercentage)%")
                                .font(.system(size: 28, weight: .bold, design: .rounded))
                                .foregroundColor(track.level.color)
                        }

                        // Progress bar
                        GeometryReader { geometry in
                            ZStack(alignment: .leading) {
                                RoundedRectangle(cornerRadius: 4)
                                    .fill(AppColors.cardBackgroundLight)
                                    .frame(height: 8)

                                RoundedRectangle(cornerRadius: 4)
                                    .fill(track.level.color)
                                    .frame(width: geometry.size.width * CGFloat(track.progress), height: 8)
                            }
                        }
                        .frame(height: 8)

                        // Journey items - show only active item
                        VStack(spacing: 0) {
                            ForEach(Array(track.items.enumerated()), id: \.element.id) { index, item in
                                if item.isActive {
                                    JourneyItemRow(
                                        item: item,
                                        isLast: true
                                    ) {
                                        onItemTap?(item)
                                    }
                                }
                            }
                        }

                        // Continue Learning button
                        Button(action: {
                            onContinue?()
                        }) {
                            Text("Resume Lessons")
                                .font(AppTypography.bodyBold)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, AppSpacing.md)
                                .background(track.level.color)
                                .cornerRadius(AppCornerRadius.medium)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                    .padding(AppSpacing.lg)
                }

                // Level badges in a horizontal row
                HStack(spacing: 0) {
                    ForEach(InvestorLevel.allCases, id: \.rawValue) { level in
                        levelBadgeWithConnector(level: level)
                    }
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.extraLarge)
        }
        .padding(.horizontal, AppSpacing.lg)
    }

    @ViewBuilder
    private func levelBadgeWithConnector(level: InvestorLevel) -> some View {
        let isActive = level == currentLevel
        let isCompleted = level.index < currentLevel.index

        HStack(spacing: 0) {
            // Badge container
            VStack(spacing: AppSpacing.xs) {
                // Icon circle with connector overlay
                ZStack {
                    // Connector line behind the badge (if not first)
                    if level != .foundation {
                        HStack(spacing: 0) {
                            Rectangle()
                                .fill(level.index <= currentLevel.index ? level.color.opacity(0.5) : AppColors.cardBackgroundLight)
                                .frame(width: 24, height: 2)
                            Spacer()
                        }
                    }
                    
                    // Connector line after the badge (if not last)
                    if level != .master {
                        HStack(spacing: 0) {
                            Spacer()
                            Rectangle()
                                .fill(isCompleted ? level.color.opacity(0.5) : AppColors.cardBackgroundLight)
                                .frame(width: 24, height: 2)
                        }
                    }
                    
                    // Badge circle (on top of connector lines)
                    ZStack {
                        Circle()
                            .fill(isActive || isCompleted ? level.color : AppColors.cardBackgroundLight)
                            .frame(width: 44, height: 44)

                        Image(systemName: level.iconName)
                            .font(.system(size: 18, weight: .semibold))
                            .foregroundColor(isActive || isCompleted ? .white : AppColors.textMuted)
                    }
                }

                // Label
                Text(level.rawValue)
                    .font(AppTypography.caption)
                    .foregroundColor(isActive || isCompleted ? AppColors.textPrimary : AppColors.textMuted)
            }
            .frame(maxWidth: .infinity)
        }
    }
}

#Preview {
    VStack {
        InvestorJourneySection(
            currentLevel: .foundation,
            journeyTrack: JourneyTrack.sampleBeginner
        )
        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/InvestorJourneyStudyScheduleSection.swift
================================================================================

//
//  InvestorJourneyStudyScheduleSection.swift
//  ios
//
//  Organism: Study schedule section with reminder toggle and time settings
//

import SwiftUI

struct InvestorJourneyStudyScheduleSection: View {
    @Binding var schedule: StudySchedule
    var onMorningTimeTap: (() -> Void)?
    var onReviewTimeTap: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section title
            Text("Study Schedule")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)

            // Schedule card
            VStack(spacing: 0) {
                // Daily Reminder toggle
                StudyScheduleRow(
                    title: "Daily Reminder",
                    subtitle: "",
                    isEnabled: $schedule.dailyReminderEnabled
                )
                .padding(.horizontal, AppSpacing.lg)

                Divider()
                    .background(AppColors.cardBackgroundLight)
                    .padding(.horizontal, AppSpacing.lg)

                // Morning Session
                Button(action: {
                    onMorningTimeTap?()
                }) {
                    StudyScheduleRow(
                        title: "Morning Session",
                        subtitle: "Best for focus",
                        time: schedule.formattedMorningTime
                    )
                    .padding(.horizontal, AppSpacing.lg)
                }
                .buttonStyle(PlainButtonStyle())

                Divider()
                    .background(AppColors.cardBackgroundLight)
                    .padding(.horizontal, AppSpacing.lg)

                // Review Time
                Button(action: {
                    onReviewTimeTap?()
                }) {
                    StudyScheduleRow(
                        title: "Review Time",
                        subtitle: "Reinforce learning",
                        time: schedule.formattedReviewTime,
                        timeColor: AppColors.textSecondary
                    )
                    .padding(.horizontal, AppSpacing.lg)
                }
                .buttonStyle(PlainButtonStyle())
            }
            .padding(.vertical, AppSpacing.sm)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    VStack {
        InvestorJourneyStudyScheduleSection(
            schedule: .constant(.defaultSchedule)
        )
        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/KeyTakeawaysSection.swift
================================================================================

//
//  KeyTakeawaysSection.swift
//  ios
//
//  Organism: Complete key takeaways section with header and items
//

import SwiftUI

struct KeyTakeawaysSection: View {
    let takeaways: [KeyTakeaway]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Section Header
            sectionHeader

            // Takeaway Items
            VStack(alignment: .leading, spacing: AppSpacing.xl) {
                ForEach(takeaways) { takeaway in
                    KeyTakeawayRow(takeaway: takeaway)
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }

    private var sectionHeader: some View {
        HStack(spacing: AppSpacing.sm) {
            // List Icon
            Image(systemName: "list.bullet.rectangle.portrait.fill")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(AppColors.primaryBlue)

            Text("Key Takeaways")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)
        }
    }
}

#Preview {
    ScrollView {
        KeyTakeawaysSection(
            takeaways: [
                KeyTakeaway(
                    index: 1,
                    text: "Despite record Q4 results, missing expectations signals slowing growth and weaker-than-hoped execution."
                ),
                KeyTakeaway(
                    index: 2,
                    text: "A miss in a flagship quarter raises doubts about forward demand and near-term visibility."
                ),
                KeyTakeaway(
                    index: 3,
                    text: "Leadership transition at this scale introduces strategic and execution risk during a critical AI cycle."
                ),
                KeyTakeaway(
                    index: 4,
                    text: "With expectations priced for perfection, even a small miss could trigger outsized market pressure."
                )
            ]
        )
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/LearnCreditsSection.swift
================================================================================

//
//  LearnCreditsSection.swift
//  ios
//
//  Organism: Section showing credit balance in Learn tab
//

import SwiftUI

struct LearnCreditsSection: View {
    let balance: CreditBalance
    var onAddCredits: (() -> Void)?

    var body: some View {
        LearnCreditsCard(balance: balance, onAddCredits: onAddCredits)
            .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    VStack {
        LearnCreditsSection(balance: CreditBalance.mock)
        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/LearnHeader.swift
================================================================================

//
//  LearnHeader.swift
//  ios
//
//  Organism: Header for Learn screen with search and tabs
//

import SwiftUI

struct LearnHeader: View {
    @Binding var searchText: String
    @Binding var selectedTab: LearnTab
    var onSearchSubmit: (() -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Search bar
            HStack(spacing: AppSpacing.md) {
                HStack(spacing: AppSpacing.sm) {
                    Image(systemName: "magnifyingglass")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(AppColors.textMuted)

                    TextField("Search topics, books, or ask AI...", text: $searchText)
                        .font(AppTypography.body)
                        .foregroundColor(AppColors.textPrimary)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                        .onSubmit {
                            onSearchSubmit?()
                        }

                    if !searchText.isEmpty {
                        Button(action: {
                            searchText = ""
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .font(.system(size: 16))
                                .foregroundColor(AppColors.textMuted)
                        }
                    }
                }
                .padding(.horizontal, AppSpacing.md)
                .padding(.vertical, AppSpacing.md)
                .background(AppColors.cardBackground)
                .cornerRadius(AppCornerRadius.large)

                // Profile button
                Button(action: {
                    // Profile action
                }) {
                    Circle()
                        .fill(AppColors.cardBackground)
                        .frame(width: 44, height: 44)
                        .overlay(
                            Image(systemName: "person.fill")
                                .font(.system(size: 18, weight: .medium))
                                .foregroundColor(AppColors.textSecondary)
                        )
                }
            }

            // Tab control
            LearnTabControl(selectedTab: $selectedTab)
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.md)
        .padding(.bottom, AppSpacing.sm)
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var searchText = ""
        @State private var selectedTab = LearnTab.learn

        var body: some View {
            VStack {
                LearnHeader(searchText: $searchText, selectedTab: $selectedTab)
                Spacer()
            }
            .background(AppColors.background)
        }
    }

    return PreviewWrapper()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/LessonTopicCardView.swift
================================================================================

//
//  LessonTopicCardView.swift
//  ios
//
//  Organism: Full-screen lesson story card view with swipeable cards,
//  AI voice orb, and progress tracking (Instagram Stories style)
//  Includes text-to-speech with word-by-word highlighting
//

import SwiftUI

struct LessonTopicCardView: View {
    let storyContent: LessonStoryContent
    var onDismiss: (() -> Void)?
    var onCTATapped: ((LessonCTADestination) -> Void)?

    @StateObject private var voiceManager = AIVoiceManager.shared
    @State private var currentIndex: Int = 0
    @State private var cardProgress: CGFloat = 0
    @State private var dragOffset: CGFloat = 0

    // Timer for auto-advance after voice finishes
    @State private var autoAdvanceTimer: Timer?

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Background
                AppColors.background
                    .ignoresSafeArea()

                VStack(spacing: 0) {
                    // Header with lesson label and close button
                    headerView
                        .padding(.top, AppSpacing.sm)
                        .zIndex(100) // Ensure header stays on top

                    // Progress bar
                    LessonStoryProgressBar(
                        currentIndex: currentIndex,
                        totalCount: storyContent.totalCards,
                        currentProgress: cardProgress
                    )
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.top, AppSpacing.md)
                    .zIndex(99)

                    // Card content with tap zones overlay
                    ZStack {
                        cardContentView
                        
                        // Tap zones for navigation (only over content area)
                        HStack(spacing: 0) {
                            // Left tap zone - go back
                            Color.clear
                                .contentShape(Rectangle())
                                .onTapGesture {
                                    goToPrevious()
                                }
                                .frame(width: geometry.size.width * 0.3)

                            Spacer()

                            // Right tap zone - go forward
                            Color.clear
                                .contentShape(Rectangle())
                                .onTapGesture {
                                    goToNext()
                                }
                                .frame(width: geometry.size.width * 0.3)
                        }
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)

                    // Bottom section with orb and controls (not on completion card)
                    if !isCompletionCard {
                        bottomControlsView
                            .padding(.bottom, AppSpacing.xxxl)
                            .zIndex(98)
                    }
                }
            }
            .gesture(
                DragGesture()
                    .onChanged { value in
                        dragOffset = value.translation.width
                    }
                    .onEnded { value in
                        handleDragEnd(value: value)
                    }
            )
        }
        .onAppear {
            startReadingCurrentCard()
        }
        .onDisappear {
            voiceManager.stop()
            stopAutoAdvanceTimer()
        }
        .onChange(of: currentIndex) { _, _ in
            startReadingCurrentCard()
        }
        .onChange(of: voiceManager.progress) { _, newProgress in
            // Sync card progress with voice progress
            if !isCompletionCard {
                cardProgress = newProgress
            }
        }
    }

    // MARK: - Computed Properties

    private var currentCard: LessonTopicCard {
        storyContent.cards[currentIndex]
    }

    private var isCompletionCard: Bool {
        currentCard.cardType == .completion
    }

    /// Get the text to read for the current card
    private var currentAudioText: String {
        if let audioText = currentCard.audioText {
            return audioText
        }

        // Fall back to constructing from segments
        switch currentCard.cardType {
        case .title:
            return currentCard.subtitleSegments?.map { $0.text }.joined() ?? ""
        case .content:
            return currentCard.contentSegments?.map { $0.text }.joined() ?? ""
        case .completion:
            return ""
        }
    }

    // MARK: - Subviews

    private var headerView: some View {
        HStack {
            Text(storyContent.lessonLabel)
                .font(.system(size: 13, weight: .semibold))
                .foregroundColor(AppColors.textSecondary)
                .tracking(0.5)

            Spacer()

            Button(action: {
                handleClose()
            }) {
                Image(systemName: "xmark")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(AppColors.textSecondary)
                    .frame(width: 32, height: 32)
                    .contentShape(Rectangle())
            }
            .buttonStyle(.plain) // Ensure no interference from default button style
        }
        .padding(.horizontal, AppSpacing.lg)
        .allowsHitTesting(true)
    }

    @ViewBuilder
    private var cardContentView: some View {
        switch currentCard.cardType {
        case .title:
            LessonTitleCard(
                title: currentCard.title ?? "",
                subtitleSegments: currentCard.subtitleSegments ?? [],
                currentWordRange: voiceManager.currentWordRange,
                isReading: voiceManager.isPlaying
            )
            .transition(.opacity.combined(with: .scale(scale: 0.95)))

        case .content:
            LessonContentCard(
                imageName: currentCard.imageName,
                contentSegments: currentCard.contentSegments ?? [],
                currentWordRange: voiceManager.currentWordRange,
                isReading: voiceManager.isPlaying
            )
            .transition(.opacity.combined(with: .scale(scale: 0.95)))

        case .completion:
            LessonCompletionCard(
                title: currentCard.completionTitle ?? "You're ready.",
                subtitle: currentCard.completionSubtitle ?? "",
                lessonNumber: storyContent.lessonNumber,
                totalLessons: storyContent.totalLessonsInLevel,
                estimatedMinutes: storyContent.estimatedMinutes,
                ctaButtonTitle: currentCard.ctaButtonTitle ?? "Continue",
                onCTATapped: {
                    if let destination = currentCard.ctaDestination {
                        onCTATapped?(destination)
                    }
                },
                onCloseTapped: {
                    onDismiss?()
                }
            )
            .transition(.opacity.combined(with: .move(edge: .bottom)))
        }
    }

    private var bottomControlsView: some View {
        VStack(spacing: AppSpacing.xl) {
            // AI Voice Orb - animated when speaking
            AIVoiceOrb(isAnimating: voiceManager.isPlaying, size: 100)

            // Play/Pause button
            Button(action: {
                togglePlayPause()
            }) {
                ZStack {
                    Circle()
                        .fill(Color.white.opacity(0.1))
                        .frame(width: 44, height: 44)

                    Image(systemName: voiceManager.isPlaying ? "pause.fill" : "play.fill")
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                }
            }
        }
    }

    // MARK: - Voice Reading

    private func handleClose() {
        // Stop all ongoing activities
        voiceManager.stop()
        stopAutoAdvanceTimer()
        
        // Dismiss the view
        onDismiss?()
    }

    private func startReadingCurrentCard() {
        stopAutoAdvanceTimer()

        guard !isCompletionCard else {
            // No voice for completion card
            cardProgress = 1.0
            return
        }

        let textToRead = currentAudioText
        guard !textToRead.isEmpty else {
            cardProgress = 1.0
            scheduleAutoAdvance(delay: 2.0)
            return
        }

        cardProgress = 0

        // Start speaking with completion handler
        voiceManager.speak(textToRead) { [self] in
            // Voice finished, wait a moment then auto-advance
            scheduleAutoAdvance(delay: 1.5)
        }
    }

    private func scheduleAutoAdvance(delay: TimeInterval) {
        stopAutoAdvanceTimer()

        autoAdvanceTimer = Timer.scheduledTimer(withTimeInterval: delay, repeats: false) { _ in
            Task { @MainActor in
                if currentIndex < storyContent.totalCards - 1 {
                    goToNext()
                }
            }
        }
    }

    private func stopAutoAdvanceTimer() {
        autoAdvanceTimer?.invalidate()
        autoAdvanceTimer = nil
    }

    // MARK: - Navigation

    private func goToNext() {
        guard currentIndex < storyContent.totalCards - 1 else {
            return
        }

        voiceManager.stop()
        stopAutoAdvanceTimer()

        withAnimation(.easeInOut(duration: 0.3)) {
            currentIndex += 1
            cardProgress = 0
        }
    }

    private func goToPrevious() {
        voiceManager.stop()
        stopAutoAdvanceTimer()

        guard currentIndex > 0 else {
            // Restart current card
            cardProgress = 0
            startReadingCurrentCard()
            return
        }

        withAnimation(.easeInOut(duration: 0.3)) {
            currentIndex -= 1
            cardProgress = 0
        }
    }

    private func handleDragEnd(value: DragGesture.Value) {
        let threshold: CGFloat = 50

        if value.translation.width < -threshold {
            goToNext()
        } else if value.translation.width > threshold {
            goToPrevious()
        }

        dragOffset = 0
    }

    private func togglePlayPause() {
        if voiceManager.isPlaying {
            voiceManager.pause()
            stopAutoAdvanceTimer()
        } else {
            voiceManager.resume()
        }
    }
}

#Preview {
    LessonTopicCardView(
        storyContent: .buffettWaySample,
        onDismiss: {
            print("Dismissed")
        },
        onCTATapped: { destination in
            print("CTA tapped: \(destination)")
        }
    )
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/LiveNewsTimeline.swift
================================================================================

//
//  LiveNewsTimeline.swift
//  ios
//
//  Organism: Live news timeline content with sticky section headers
//

import SwiftUI

struct LiveNewsTimeline: View {
    let groupedNews: [GroupedNews]
    var onArticleTapped: ((NewsArticle) -> Void)?

    var body: some View {
        LazyVStack(spacing: 0, pinnedViews: [.sectionHeaders]) {
            ForEach(groupedNews) { group in
                Section {
                    NewsGroupContent(
                        articles: group.articles,
                        onArticleTapped: onArticleTapped
                    )
                } header: {
                    NewsSectionHeader(title: group.sectionTitle)
                }
            }
        }
    }
}

// MARK: - News Group Content (without header)
struct NewsGroupContent: View {
    let articles: [NewsArticle]
    var onArticleTapped: ((NewsArticle) -> Void)?

    var body: some View {
        VStack(spacing: 0) {
            ForEach(Array(articles.enumerated()), id: \.element.id) { index, article in
                TimelineRow(
                    article: article,
                    isFirst: index == 0,
                    isLast: index == articles.count - 1,
                    onTapped: {
                        onArticleTapped?(article)
                    }
                )
                .padding(.horizontal, AppSpacing.lg)
            }
        }
    }
}

#Preview {
    ScrollView {
        LiveNewsTimeline(
            groupedNews: [
                GroupedNews(
                    sectionTitle: "TODAY",
                    articles: [
                        NewsArticle(
                            headline: "Oil prices stabilize as OPEC + members agreed to maintain current production levels.",
                            summary: nil,
                            source: NewsSource(name: "Reuters", iconName: nil),
                            sentiment: .neutral,
                            publishedAt: Date(),
                            thumbnailName: nil,
                            relatedTickers: []
                        ),
                        NewsArticle(
                            headline: "NVIDIA Announces Record Q4 Earnings, Missed Expectations and CEO step down",
                            summary: nil,
                            source: NewsSource(name: "CNBC", iconName: nil),
                            sentiment: .negative,
                            publishedAt: Date(),
                            thumbnailName: nil,
                            relatedTickers: []
                        )
                    ]
                ),
                GroupedNews(
                    sectionTitle: "YESTERDAY",
                    articles: [
                        NewsArticle(
                            headline: "Apple Unveils Revolutionary AI Features in iOS 18 Beta",
                            summary: nil,
                            source: NewsSource(name: "Zacks", iconName: nil),
                            sentiment: .positive,
                            publishedAt: Calendar.current.date(byAdding: .day, value: -1, to: Date())!,
                            thumbnailName: nil,
                            relatedTickers: []
                        )
                    ]
                )
            ]
        )
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/MarketInsightsCard.swift
================================================================================

//
//  MarketInsightsCard.swift
//  ios
//
//  Organism: Market insights card with headline and bullet points
//

import SwiftUI

struct MarketInsightsCard: View {
    let insight: MarketInsight
    var onSeeAllTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header
            HStack {
                HStack(spacing: AppSpacing.sm) {
                    Image(systemName: "bolt.fill")
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundColor(AppColors.neutral)

                    Text("Market Insights")
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)
                }

                Spacer()

                Button(action: {
                    onSeeAllTapped?()
                }) {
                    Text("See All")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
            }

            // Headline
            Text(insight.headline)
                .font(AppTypography.title2)
                .foregroundColor(AppColors.textPrimary)
                .fixedSize(horizontal: false, vertical: true)

            // Bullet Points
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                ForEach(insight.bulletPoints, id: \.self) { point in
                    HStack(alignment: .top, spacing: AppSpacing.sm) {
                        Circle()
                            .fill(AppColors.textSecondary)
                            .frame(width: 5, height: 5)
                            .padding(.top, 6)

                        Text(point)
                            .font(AppTypography.callout)
                            .foregroundColor(AppColors.textSecondary)
                            .fixedSize(horizontal: false, vertical: true)
                    }
                }
            }

            // Footer
            HStack {
                SentimentBadge(sentiment: insight.sentiment)

                Spacer()

                Text("Updated \(insight.timeAgo)")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    MarketInsightsCard(insight: MarketInsight(
        headline: "Tech Stocks Rally on Strong AI Earnings",
        bulletPoints: [
            "Major technology companies posted impressive Q4 results driven by AI infrastructure investments.",
            "Cloud computing revenue exceeded expectations, with Microsoft and Google leading the charge. Market sentiment remains bullish heading into 2024."
        ],
        sentiment: .bullish,
        updatedAt: Date().addingTimeInterval(-3600)
    ))
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/MarketTickersRow.swift
================================================================================

//
//  MarketTickersRow.swift
//  ios
//
//  Organism: Horizontal scrollable row of market tickers
//

import SwiftUI

struct MarketTickersRow: View {
    let tickers: [MarketTicker]

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: AppSpacing.md) {
                ForEach(tickers) { ticker in
                    TickerCard(ticker: ticker)
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    MarketTickersRow(tickers: [
        MarketTicker(name: "S&P 500", price: 6783.45, changePercent: 0.85, sparklineData: [100, 102, 98, 105, 103, 108, 110, 107, 112, 115]),
        MarketTicker(name: "Nasdaq", price: 23293.23, changePercent: 0.85, sparklineData: [100, 102, 98, 105, 103, 108, 110, 107, 112, 115]),
        MarketTicker(name: "Bitcoin", price: 89394.43, changePercent: -2.34, sparklineData: [115, 112, 108, 105, 110, 103, 100, 98, 95, 92]),
        MarketTicker(name: "Gold", price: 4322.43, changePercent: -1.34, sparklineData: [115, 112, 108, 105, 110, 103, 100, 98, 95, 92])
    ])
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/MoneyMoveArticleCommentsSection.swift
================================================================================

//
//  MoneyMoveArticleCommentsSection.swift
//  ios
//
//  Organism: Comments section with comment cards and input
//

import SwiftUI

struct MoneyMoveArticleCommentsSection: View {
    let comments: [ArticleComment]
    let totalCount: Int
    var onAddCommentTapped: (() -> Void)?
    var onViewAllTapped: (() -> Void)?
    var onCommentLiked: ((ArticleComment) -> Void)?
    var onCommentReplied: ((ArticleComment) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            HStack {
                HStack(spacing: AppSpacing.sm) {
                    Image(systemName: "bubble.left.and.bubble.right.fill")
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(AppColors.primaryBlue)

                    Text("Comments")
                        .font(AppTypography.title3)
                        .foregroundColor(AppColors.textPrimary)

                    Text("(\(totalCount))")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                // View all button
                if comments.count < totalCount {
                    Button(action: { onViewAllTapped?() }) {
                        Text("View all")
                            .font(AppTypography.calloutBold)
                            .foregroundColor(AppColors.primaryBlue)
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }

            // Add comment button
            Button(action: { onAddCommentTapped?() }) {
                HStack(spacing: AppSpacing.md) {
                    // Avatar placeholder
                    Circle()
                        .fill(AppColors.cardBackgroundLight)
                        .frame(width: 36, height: 36)
                        .overlay(
                            Image(systemName: "person.fill")
                                .font(.system(size: 14))
                                .foregroundColor(AppColors.textMuted)
                        )

                    Text("Add a comment...")
                        .font(AppTypography.body)
                        .foregroundColor(AppColors.textMuted)

                    Spacer()

                    Image(systemName: "paperplane")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(AppColors.textMuted)
                }
                .padding(AppSpacing.md)
                .background(AppColors.cardBackground)
                .cornerRadius(AppCornerRadius.large)
            }
            .buttonStyle(PlainButtonStyle())

            // Comment cards
            VStack(spacing: AppSpacing.md) {
                ForEach(comments) { comment in
                    ArticleCommentCard(
                        comment: comment,
                        onLikeTapped: { onCommentLiked?(comment) },
                        onReplyTapped: { onCommentReplied?(comment) }
                    )
                }
            }

            // Load more button
            if comments.count < totalCount {
                Button(action: { onViewAllTapped?() }) {
                    HStack {
                        Text("Load more comments")
                            .font(AppTypography.bodyBold)
                            .foregroundColor(AppColors.primaryBlue)

                        Image(systemName: "chevron.down")
                            .font(.system(size: 12, weight: .semibold))
                            .foregroundColor(AppColors.primaryBlue)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, AppSpacing.md)
                    .background(AppColors.cardBackground)
                    .cornerRadius(AppCornerRadius.large)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
    }
}

#Preview {
    ScrollView {
        MoneyMoveArticleCommentsSection(
            comments: [
                ArticleComment(
                    authorName: "Alex Johnson",
                    authorAvatar: nil,
                    content: "Excellent breakdown of the current DeFi landscape! The data on portfolio fragility suggests wealth creation through early adoption needs more critical analysis.",
                    postedAt: Calendar.current.date(byAdding: .hour, value: -5, to: Date())!,
                    likeCount: 47,
                    replyCount: 8,
                    isVerified: false
                ),
                ArticleComment(
                    authorName: "Maya Patel",
                    authorAvatar: nil,
                    content: "As a traditional banker transitioning to fintech, this article perfectly captures the challenges we face.",
                    postedAt: Calendar.current.date(byAdding: .hour, value: -12, to: Date())!,
                    likeCount: 32,
                    replyCount: 3,
                    isVerified: true
                )
            ],
            totalCount: 124
        )
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/MoneyMoveArticleContent.swift
================================================================================

//
//  MoneyMoveArticleContent.swift
//  ios
//
//  Organism: Main article content containing all sections
//

import SwiftUI

struct MoneyMoveArticleContent: View {
    let article: MoneyMoveArticle

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xxl) {
            // Key highlights
            if !article.keyHighlights.isEmpty {
                MoneyMoveArticleKeyHighlights(highlights: article.keyHighlights)
                    .padding(.horizontal, AppSpacing.lg)
            }

            // Article sections
            VStack(spacing: AppSpacing.lg) {
                ForEach(article.sections) { section in
                    MoneyMoveArticleSectionContent(section: section)
                }
            }

            // Comments section
            if !article.comments.isEmpty {
                MoneyMoveArticleCommentsSection(
                    comments: Array(article.comments.prefix(2)),
                    totalCount: article.commentCount
                )
                .padding(.horizontal, AppSpacing.lg)
            }

            // Related articles
            if !article.relatedArticles.isEmpty {
                MoneyMoveRelatedArticlesSection(articles: article.relatedArticles)
            }

            // Bottom padding
            Color.clear
                .frame(height: AppSpacing.xxxl)
        }
    }
}

#Preview {
    ScrollView {
        MoneyMoveArticleContent(article: MoneyMoveArticle.sampleDigitalFinance)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/MoneyMoveArticleHeroHeader.swift
================================================================================

//
//  MoneyMoveArticleHeroHeader.swift
//  ios
//
//  Organism: Hero header section for money move article with gradient background
//  Integrates with AudioManager for audio playback
//

import SwiftUI

struct MoneyMoveArticleHeroHeader: View {
    @EnvironmentObject private var audioManager: AudioManager

    let article: MoneyMoveArticle
    var audioEpisode: AudioEpisode?
    var onBackTapped: (() -> Void)?
    var onShareTapped: (() -> Void)?
    var isBookmarked: Bool = false
    var onBookmarkTapped: (() -> Void)?
    var onMoreTapped: (() -> Void)?

    private var gradientColors: [Color] {
        article.heroGradientColors.map { Color(hex: $0) }
    }

    private var isCurrentlyPlaying: Bool {
        guard let episode = audioEpisode else { return false }
        return audioManager.currentEpisode?.id == episode.id && audioManager.isPlaying
    }

    var body: some View {
        ZStack(alignment: .top) {
            // Background gradient with effects
            ZStack {
                // Base gradient
                LinearGradient(
                    colors: gradientColors,
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )

                // Animated glow orbs
                GeometryReader { geometry in
                    Circle()
                        .fill(
                            RadialGradient(
                                colors: [
                                    Color(hex: "3B82F6").opacity(0.15),
                                    Color.clear
                                ],
                                center: .center,
                                startRadius: 0,
                                endRadius: geometry.size.width * 0.4
                            )
                        )
                        .frame(width: geometry.size.width * 0.6)
                        .offset(x: -geometry.size.width * 0.1, y: geometry.size.height * 0.2)

                    Circle()
                        .fill(
                            RadialGradient(
                                colors: [
                                    Color(hex: "8B5CF6").opacity(0.12),
                                    Color.clear
                                ],
                                center: .center,
                                startRadius: 0,
                                endRadius: geometry.size.width * 0.35
                            )
                        )
                        .frame(width: geometry.size.width * 0.5)
                        .offset(x: geometry.size.width * 0.5, y: geometry.size.height * 0.5)
                }

                // Grain texture
                GrainyTextureOverlay()

                // Bottom fade
                VStack {
                    Spacer()
                    LinearGradient(
                        colors: [
                            Color.clear,
                            AppColors.background.opacity(0.8),
                            AppColors.background
                        ],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                    .frame(height: 100)
                }
            }

            // Content
            VStack(alignment: .leading, spacing: 0) {
                // Navigation bar
                HStack {
                    Button(action: { onBackTapped?() }) {
                        HStack(spacing: AppSpacing.xs) {
                            Image(systemName: "chevron.left")
                                .font(.system(size: 16, weight: .semibold))
                            Text("Back")
                                .font(AppTypography.body)
                        }
                        .foregroundColor(.white)
                        .padding(.horizontal, AppSpacing.md)
                        .padding(.vertical, AppSpacing.sm)
                        .background(
                            Capsule()
                                .fill(Color.white.opacity(0.15))
                        )
                    }
                    .buttonStyle(PlainButtonStyle())

                    Spacer()

                    // Action buttons
                    HStack(spacing: AppSpacing.sm) {
                        // Share button
                        Button(action: { onShareTapped?() }) {
                            Image(systemName: "square.and.arrow.up")
                                .font(.system(size: 16, weight: .semibold))
                                .foregroundColor(.white)
                                .frame(width: 36, height: 36)
                                .background(
                                    Circle()
                                        .fill(Color.white.opacity(0.15))
                                )
                        }
                        .buttonStyle(PlainButtonStyle())

                        // Bookmark button
                        Button(action: { onBookmarkTapped?() }) {
                            Image(systemName: isBookmarked ? "bookmark.fill" : "bookmark")
                                .font(.system(size: 16, weight: .semibold))
                                .foregroundColor(.white)
                                .frame(width: 36, height: 36)
                                .background(
                                    Circle()
                                        .fill(Color.white.opacity(0.15))
                                )
                        }
                        .buttonStyle(PlainButtonStyle())

                        // More button
                        Button(action: { onMoreTapped?() }) {
                            Image(systemName: "ellipsis")
                                .font(.system(size: 16, weight: .semibold))
                                .foregroundColor(.white)
                                .frame(width: 36, height: 36)
                                .background(
                                    Circle()
                                        .fill(Color.white.opacity(0.15))
                                )
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
                .padding(.top, AppSpacing.md)

                Spacer()

                // Title and meta
                VStack(alignment: .leading, spacing: AppSpacing.md) {
                    // Category (or "FEATURED DEEP DIVE" for featured articles)
                    Text(article.isFeatured ? "FEATURED DEEP DIVE" : article.category.rawValue.uppercased())
                        .font(AppTypography.captionBold)
                        .foregroundColor(.white.opacity(0.7))
                        .tracking(1.2)

                    // Title
                    Text(article.title)
                        .font(.system(size: 28, weight: .bold))
                        .foregroundColor(.white)
                        .lineSpacing(4)

                    // Subtitle
                    Text(article.subtitle)
                        .font(AppTypography.body)
                        .foregroundColor(.white.opacity(0.85))
                        .lineSpacing(4)
                        .fixedSize(horizontal: false, vertical: true)

                    // Meta row and Play button
                    HStack(spacing: AppSpacing.lg) {
                        // Play button (if audio available)
                        if article.hasAudioVersion, let episode = audioEpisode {
                            LargePlayButton(episode: episode, showLabel: true)
                        }

                        Spacer()

                        // Meta info
                        VStack(alignment: .trailing, spacing: AppSpacing.xs) {
                            HStack(spacing: AppSpacing.md) {
                                // Read time
                                HStack(spacing: AppSpacing.xs) {
                                    Image(systemName: "clock")
                                        .font(.system(size: 11, weight: .medium))
                                    Text(article.formattedReadTime)
                                        .font(AppTypography.caption)
                                }

                                // Views
                                HStack(spacing: AppSpacing.xs) {
                                    Image(systemName: "eye")
                                        .font(.system(size: 11, weight: .medium))
                                    Text(article.viewCount)
                                        .font(AppTypography.caption)
                                }
                            }
                            .foregroundColor(.white.opacity(0.7))

                            // Date
                            Text(article.formattedDate)
                                .font(AppTypography.caption)
                                .foregroundColor(.white.opacity(0.6))
                        }
                    }

                    // Now playing indicator
                    if isCurrentlyPlaying {
                        HStack(spacing: AppSpacing.sm) {
                            NowPlayingBars()
                            Text("Now Playing")
                                .font(AppTypography.captionBold)
                                .foregroundColor(.white)
                        }
                        .padding(.top, AppSpacing.xs)
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
                .padding(.bottom, AppSpacing.xl)
            }
        }
        .frame(height: article.hasAudioVersion ? 380 : 340)
    }
}

// MARK: - Now Playing Animation Bars
struct NowPlayingBars: View {
    @State private var isAnimating = false

    var body: some View {
        HStack(spacing: 2) {
            ForEach(0..<4) { index in
                RoundedRectangle(cornerRadius: 1)
                    .fill(Color.white)
                    .frame(width: 3, height: isAnimating ? CGFloat.random(in: 8...16) : 4)
                    .animation(
                        .easeInOut(duration: 0.4)
                            .repeatForever()
                            .delay(Double(index) * 0.1),
                        value: isAnimating
                    )
            }
        }
        .frame(height: 16)
        .onAppear {
            isAnimating = true
        }
    }
}

// MARK: - Grainy Texture Overlay
struct GrainyTextureOverlay: View {
    var body: some View {
        Canvas { context, size in
            for _ in 0..<Int(size.width * size.height / 50) {
                let x = CGFloat.random(in: 0..<size.width)
                let y = CGFloat.random(in: 0..<size.height)
                let opacity = Double.random(in: 0.02...0.08)

                context.fill(
                    Path(ellipseIn: CGRect(x: x, y: y, width: 1, height: 1)),
                    with: .color(.white.opacity(opacity))
                )
            }
        }
    }
}

#Preview {
    ScrollView {
        MoneyMoveArticleHeroHeader(
            article: MoneyMoveArticle.sampleDigitalFinance,
            audioEpisode: .sampleMoneyMoves,
            isBookmarked: false
        )

        Text("Content goes here")
            .foregroundColor(.white)
            .padding()
    }
    .background(AppColors.background)
    .ignoresSafeArea()
    .environmentObject(AudioManager.shared)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/MoneyMoveArticleKeyHighlights.swift
================================================================================

//
//  MoneyMoveArticleKeyHighlights.swift
//  ios
//
//  Organism: Key highlights section with highlight cards
//

import SwiftUI

struct MoneyMoveArticleKeyHighlights: View {
    let highlights: [ArticleHighlight]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Section header
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "sparkles")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(AppColors.neutral)

                Text("Key Highlights")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)
            }

            // Highlight cards
            VStack(spacing: AppSpacing.md) {
                ForEach(highlights) { highlight in
                    ArticleHighlightCard(highlight: highlight)
                }
            }
        }
    }
}

#Preview {
    ScrollView {
        MoneyMoveArticleKeyHighlights(
            highlights: [
                ArticleHighlight(
                    icon: "building.columns.fill",
                    title: "The Alpha",
                    description: "As technology becomes ubiquitous, decentralized finance (DeFi) is reshaping how we invest."
                ),
                ArticleHighlight(
                    icon: "chart.line.uptrend.xyaxis",
                    title: "Key Trends",
                    description: "The pace of banking innovation has never been faster."
                ),
                ArticleHighlight(
                    icon: "shield.checkered",
                    title: "Risk Factors",
                    description: "Despite strong prospects, regulatory challenges and market volatility remain key concerns."
                )
            ]
        )
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/MoneyMoveArticleSectionContent.swift
================================================================================

//
//  MoneyMoveArticleSectionContent.swift
//  ios
//
//  Organism: Article section with title, icon, and content blocks
//

import SwiftUI
import Charts

struct MoneyMoveArticleSectionContent: View {
    let section: ArticleSection

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Section header
            HStack(spacing: AppSpacing.md) {
                if let icon = section.icon {
                    ArticleSectionIcon(icon: icon)
                }

                Text(section.title)
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)
            }

            // Content blocks
            VStack(alignment: .leading, spacing: AppSpacing.lg) {
                ForEach(section.content) { content in
                    renderContent(content)
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(Color(hex: "171B26"))
    }

    @ViewBuilder
    private func renderContent(_ content: ArticleSectionContent) -> some View {
        switch content {
        case .paragraph(let text):
            Text(text)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textPrimary)
                .lineSpacing(6)
                .fixedSize(horizontal: false, vertical: true)

        case .bulletList(let items):
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                ForEach(items, id: \.self) { item in
                    HStack(alignment: .top, spacing: AppSpacing.md) {
                        Circle()
                            .fill(AppColors.primaryBlue)
                            .frame(width: 6, height: 6)
                            .padding(.top, 7)

                        Text(item)
                            .font(AppTypography.body)
                            .foregroundColor(AppColors.textPrimary)
                            .fixedSize(horizontal: false, vertical: true)
                    }
                }
            }
            .padding(.leading, AppSpacing.sm)

        case .subheading(let text):
            Text(text)
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)
                .padding(.top, AppSpacing.sm)

        case .quote(let text, let attribution):
            ArticleQuoteBlock(text: text, attribution: attribution)

        case .callout(let icon, let text, let style):
            ArticleCalloutBox(icon: icon, text: text, style: style)

        case .chart(let data):
            ArticleChartView(chartData: data)
        }
    }
}

// MARK: - Article Chart View
struct ArticleChartView: View {
    let chartData: ChartData

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text(chartData.title)
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textSecondary)

            Chart {
                ForEach(chartData.dataPoints) { point in
                    switch chartData.type {
                    case .bar:
                        BarMark(
                            x: .value("Label", point.label),
                            y: .value("Value", point.value)
                        )
                        .foregroundStyle(point.color ?? AppColors.primaryBlue)

                    case .line:
                        LineMark(
                            x: .value("Label", point.label),
                            y: .value("Value", point.value)
                        )
                        .foregroundStyle(point.color ?? AppColors.primaryBlue)

                    case .area:
                        AreaMark(
                            x: .value("Label", point.label),
                            y: .value("Value", point.value)
                        )
                        .foregroundStyle(
                            LinearGradient(
                                colors: [
                                    (point.color ?? AppColors.primaryBlue).opacity(0.5),
                                    (point.color ?? AppColors.primaryBlue).opacity(0.1)
                                ],
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                    }
                }
            }
            .chartXAxis {
                AxisMarks(values: .automatic) { _ in
                    AxisValueLabel()
                        .foregroundStyle(AppColors.textSecondary)
                }
            }
            .chartYAxis {
                AxisMarks(values: .automatic) { _ in
                    AxisValueLabel()
                        .foregroundStyle(AppColors.textSecondary)
                    AxisGridLine()
                        .foregroundStyle(AppColors.cardBackgroundLight)
                }
            }
            .frame(height: 200)
        }
        .padding(AppSpacing.md)
        .background(AppColors.cardBackgroundLight)
        .cornerRadius(AppCornerRadius.medium)
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.lg) {
            MoneyMoveArticleSectionContent(
                section: ArticleSection(
                    title: "The Rise of Decentralized Finance",
                    icon: "chart.bar.fill",
                    content: [
                        .paragraph("Decentralized finance, or DeFi, represents a fundamental shift in how financial services are delivered."),
                        .callout(
                            icon: "lightbulb.fill",
                            text: "DeFi protocols have processed over $180B in total value locked.",
                            style: .highlight
                        ),
                        .bulletList([
                            "Permissionless lending and borrowing",
                            "Automated market makers (AMMs)",
                            "Yield farming and liquidity mining"
                        ])
                    ],
                    hasGlowEffect: true
                )
            )

            MoneyMoveArticleSectionContent(
                section: ArticleSection(
                    title: "AI in Banking",
                    icon: "cpu.fill",
                    content: [
                        .paragraph("Traditional banks are not standing still."),
                        .subheading("Enhanced Security"),
                        .paragraph("Biometric authentication has reduced fraud rates by 45%."),
                        .quote(
                            text: "The future of finance isn't about going to the bank.",
                            attribution: "Industry Analyst"
                        )
                    ]
                )
            )
        }
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/MoneyMoveRelatedArticlesSection.swift
================================================================================

//
//  MoneyMoveRelatedArticlesSection.swift
//  ios
//
//  Organism: Related articles horizontal scroll section
//

import SwiftUI

struct MoneyMoveRelatedArticlesSection: View {
    let articles: [RelatedArticle]
    var onArticleTapped: ((RelatedArticle) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "newspaper.fill")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(AppColors.accentCyan)

                Text("Related Articles")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)
            }
            .padding(.horizontal, AppSpacing.lg)

            // Horizontal scroll
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.md) {
                    ForEach(articles) { article in
                        RelatedMoneyMoveCard(
                            article: article,
                            onTap: { onArticleTapped?(article) }
                        )
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }
        }
    }
}

#Preview {
    MoneyMoveRelatedArticlesSection(
        articles: [
            RelatedArticle(
                title: "The FTX Collapse",
                subtitle: "What the failure of crypto's top exchange tells us.",
                category: .valueTraps,
                readTimeMinutes: 14,
                viewCount: "2.8M",
                gradientColors: ["DC2626", "991B1B"]
            ),
            RelatedArticle(
                title: "How Amazon Built Its Moat",
                subtitle: "The strategy behind unstoppable dominance.",
                category: .blueprints,
                readTimeMinutes: 12,
                viewCount: "3.1M",
                gradientColors: ["059669", "047857"]
            ),
            RelatedArticle(
                title: "How AI Is Revolutionizing Stock Market",
                subtitle: "From pattern recognition to predictive analytics.",
                category: .blueprints,
                readTimeMinutes: 16,
                viewCount: "1.9M",
                gradientColors: ["7C3AED", "5B21B6"]
            )
        ]
    )
    .padding(.vertical)
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/MoneyMovesSection.swift
================================================================================

//
//  MoneyMovesSection.swift
//  ios
//
//  Organism: Horizontal scrolling section of money moves
//

import SwiftUI

struct MoneyMovesSection: View {
    let concepts: [MoneyMove]
    var onSeeAll: (() -> Void)?
    var onConceptTap: ((MoneyMove) -> Void)?
    var onBookmark: ((MoneyMove) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            HStack {
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text("Money Moves")
                        .font(AppTypography.title3)
                        .foregroundColor(AppColors.textPrimary)

                    Text("Most Read")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                Button(action: {
                    onSeeAll?()
                }) {
                    Text("See All")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
            }
            .padding(.horizontal, AppSpacing.lg)

            // Horizontal scroll of money move cards
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.md) {
                    ForEach(concepts) { moneyMove in
                        MoneyMoveCard(
                            moneyMove: moneyMove,
                            onTap: { onConceptTap?(moneyMove) },
                            onBookmark: { onBookmark?(moneyMove) }
                        )
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }
        }
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.xxl) {
            MoneyMovesSection(concepts: MoneyMove.sampleData)
            Spacer()
        }
        .padding(.top, AppSpacing.md)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/NewAnalysisButton.swift
================================================================================

//
//  NewAnalysisButton.swift
//  ios
//
//  Organism: Floating action button for new analysis
//

import SwiftUI

struct NewAnalysisButton: View {
    var onTap: (() -> Void)?

    var body: some View {
        Button(action: {
            onTap?()
        }) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "sparkles")
                    .font(.system(size: 16, weight: .semibold))

                Text("New Analysis")
                    .font(AppTypography.bodyBold)
            }
            .foregroundColor(.white)
            .padding(.horizontal, AppSpacing.xxl)
            .padding(.vertical, AppSpacing.md)
            .frame(maxWidth: .infinity)
            .background(
                LinearGradient(
                    colors: [AppColors.primaryBlue, AppColors.accentCyan],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .cornerRadius(AppCornerRadius.extraLarge)
//            .shadow(color: AppColors.primaryBlue.opacity(0.4), radius: 8, x: 0, y: 4)
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    VStack {
        Spacer()
        NewAnalysisButton()
    }
    .padding()
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/NewsDetailContent.swift
================================================================================

//
//  NewsDetailContent.swift
//  ios
//
//  Organism: Main content area for news detail screen
//

import SwiftUI

struct NewsDetailContent: View {
    let article: NewsArticleDetail
    var onTickerTapped: ((String) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xl) {
            // Headline
            Text(article.headline)
                .font(AppTypography.title)
                .foregroundColor(AppColors.textPrimary)
                .fixedSize(horizontal: false, vertical: true)
                .lineSpacing(4)

            // Meta Row (Date, Read Time, Sentiment)
            NewsDetailMetaRow(
                date: article.formattedDate,
                readTimeMinutes: article.readTimeMinutes,
                sentiment: article.sentiment
            )

            // Hero Image
            NewsDetailHeroImage(imageName: article.heroImageName)

            // Related Tickers
            if !article.relatedTickers.isEmpty {
                RelatedTickersRow(
                    tickers: article.relatedTickers,
                    onTickerTapped: onTickerTapped
                )
            }

            // Key Takeaways
            if !article.keyTakeaways.isEmpty {
                KeyTakeawaysSection(takeaways: article.keyTakeaways)
            }
        }
    }
}

#Preview {
    ScrollView {
        NewsDetailContent(
            article: NewsArticleDetail(
                headline: "NVIDIA Announces Record Q4 Earnings, Missed Expectations and CEO step down",
                source: NewsSource(name: "CNBC", iconName: nil),
                sentiment: .negative,
                publishedAt: Date(),
                readTimeMinutes: 4,
                heroImageName: nil,
                relatedTickers: ["APPL", "ORCL", "TSLA"],
                keyTakeaways: [
                    KeyTakeaway(index: 1, text: "Despite record Q4 results, missing expectations signals slowing growth and weaker-than-hoped execution."),
                    KeyTakeaway(index: 2, text: "A miss in a flagship quarter raises doubts about forward demand and near-term visibility."),
                    KeyTakeaway(index: 3, text: "Leadership transition at this scale introduces strategic and execution risk during a critical AI cycle."),
                    KeyTakeaway(index: 4, text: "With expectations priced for perfection, even a small miss could trigger outsized market pressure.")
                ],
                articleURL: nil
            ),
            onTickerTapped: { ticker in
                print("Tapped ticker: \(ticker)")
            }
        )
        .padding()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/NextLessonSection.swift
================================================================================

//
//  NextLessonSection.swift
//  ios
//
//  Organism: Section showing the next lesson to take
//

import SwiftUI

struct NextLessonSection: View {
    let lesson: NextLesson
    var onTap: (() -> Void)?

    var body: some View {
        NextLessonCard(lesson: lesson, onTap: onTap)
            .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    VStack {
        NextLessonSection(lesson: NextLesson.sampleData)
        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/PersonaSelectionSection.swift
================================================================================

//
//  PersonaSelectionSection.swift
//  ios
//
//  Organism: Horizontal scrollable persona selection with description
//

import SwiftUI

struct PersonaSelectionSection: View {
    let personas: [AnalysisPersona]
    @Binding var selectedPersona: AnalysisPersona
    var onViewAllTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Section header
            HStack {
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text("Select Analysis Persona:")
                        .font(AppTypography.title3)
                        .foregroundColor(AppColors.textPrimary)

                    Text("Choose your investment style")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                Button(action: {
                    onViewAllTapped?()
                }) {
                    Text("View All")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
            }
            .padding(.horizontal, AppSpacing.lg)

            // Horizontal scroll of persona cards
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.md) {
                    ForEach(personas) { persona in
                        PersonaCard(
                            persona: persona,
                            isSelected: selectedPersona == persona
                        ) {
                            withAnimation(.easeInOut(duration: 0.2)) {
                                selectedPersona = persona
                            }
                        }
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }

            // Analysis description card
            AnalysisDescriptionCard(persona: selectedPersona)
                .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    ScrollView {
        PersonaSelectionSection(
            personas: AnalysisPersona.allCases,
            selectedPersona: .constant(.warrenBuffett)
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/PortfolioInsightsSection.swift
================================================================================

//
//  PortfolioInsightsSection.swift
//  ios
//
//  Organism: Portfolio Insights section with diversification score
//

import SwiftUI

struct PortfolioInsightsSection: View {
    let score: DiversificationScore?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section Header
            Text("Portfolio Insights")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)

            // Diversification Card
            if let score = score {
                DiversificationCard(score: score)
                    .padding(.horizontal, AppSpacing.lg)
            } else {
                // Empty State
                VStack(spacing: AppSpacing.md) {
                    Image(systemName: "chart.pie")
                        .font(.system(size: 32))
                        .foregroundColor(AppColors.textMuted)

                    Text("Add more assets to see insights")
                        .font(AppTypography.body)
                        .foregroundColor(AppColors.textSecondary)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, AppSpacing.xxl)
                .background(AppColors.cardBackground)
                .cornerRadius(AppCornerRadius.large)
                .padding(.horizontal, AppSpacing.lg)
            }
        }
    }
}

#Preview {
    VStack(spacing: AppSpacing.xxl) {
        PortfolioInsightsSection(score: DiversificationScore.sampleData)
        PortfolioInsightsSection(score: nil)
    }
    .padding(.vertical)
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ProfitPowerSectionCard.swift
================================================================================

//
//  ProfitPowerSectionCard.swift
//  ios
//
//  Organism: Complete Profit Power Section card for the Financial tab
//  Displays multiple profit margin metrics over time with sector comparison
//

import SwiftUI

struct ProfitPowerSectionCard: View {
    // MARK: - Properties

    let profitPowerData: ProfitPowerSectionData
    let onDetailTapped: () -> Void

    // MARK: - State

    @State private var selectedPeriod: ProfitPowerPeriodType = .annual
    @State private var showInfoSheet: Bool = false
    @State private var selectedDataPoint: ProfitPowerDataPoint? = nil

    // MARK: - Computed Properties

    private var currentDataPoints: [ProfitPowerDataPoint] {
        profitPowerData.dataPoints(for: selectedPeriod)
    }

    // MARK: - Body

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header with title, info icon, and detail link
            headerSection

            // Period toggle (Annual / Quarterly)
            ProfitPowerPeriodToggle(selectedPeriod: $selectedPeriod)
                .padding(.leading, AppSpacing.xs)

            // Main chart
            ProfitPowerChartView(
                dataPoints: currentDataPoints,
                selectedDataPoint: $selectedDataPoint
            )
            .padding(.top, AppSpacing.sm)

            // Legend
            ProfitPowerLegendView()
                .frame(maxWidth: .infinity)
                .padding(.top, AppSpacing.md)
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
        .sheet(isPresented: $showInfoSheet) {
            ProfitPowerInfoSheet()
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        HStack {
            HStack(spacing: AppSpacing.sm) {
                Text("Profit Power")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                ProfitPowerInfoIcon {
                    showInfoSheet = true
                }
            }

            Spacer()

            Button(action: onDetailTapped) {
                Text("Detail")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.primaryBlue)
            }
            .buttonStyle(.plain)
        }
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            ProfitPowerSectionCard(
                profitPowerData: ProfitPowerSectionData.sampleData,
                onDetailTapped: {}
            )
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/RecentActivitiesSection.swift
================================================================================

//
//  RecentActivitiesSection.swift
//  ios
//
//  Organism: Complete Recent Activities section card
//  Displays recent institutional or insider trading activities with flow bar and activity list
//

import SwiftUI

struct RecentActivitiesSection: View {
    // MARK: - Properties

    let data: RecentActivitiesData

    // MARK: - State

    @State private var selectedTab: RecentActivitiesTab = .institutions
    @State private var selectedSort: RecentActivitiesSortOption = .byValue
    @State private var selectedFilter: InsiderActivityFilterOption = .all
    @State private var showInfoSheet: Bool = false

    // MARK: - Computed Properties

    private var sortedInstitutionalActivities: [InstitutionalActivity] {
        data.sortedInstitutionalActivities(by: selectedSort)
    }

    private var sortedInsiderActivities: [InsiderActivity] {
        // Always sort by date (most recent first) for both All and Informative tabs
        return data.insiderActivities.sortedActivities(by: .byDate, filter: selectedFilter)
    }

    // MARK: - Body

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header with title and info icon
            headerSection

            // Tab selector (Institutions / Insiders)
            RecentActivitiesTabSelector(
                selectedTab: $selectedTab,
                disabledTabs: []  // Both tabs enabled
            )

            // Content based on selected tab
            if selectedTab == .institutions {
                institutionsContent
            } else {
                insidersContent
            }
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
        .sheet(isPresented: $showInfoSheet) {
            RecentActivitiesInfoSheet()
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        HStack {
            HStack(spacing: AppSpacing.sm) {
                Text("Recent Activities")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                RecentActivitiesInfoIcon {
                    showInfoSheet = true
                }
            }

            Spacer()
        }
    }

    // MARK: - Institutions Content

    private var institutionsContent: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Period label
            Text("Latest Filings (\(data.institutionalFlowSummary.periodDescription))")
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textMuted)
                .padding(.top, AppSpacing.xs)

            // Flow bar
            RecentActivitiesFlowBar(
                inFlowPercent: data.institutionalFlowSummary.inFlowPercent,
                formattedInFlow: data.institutionalFlowSummary.formattedInFlow,
                formattedOutFlow: data.institutionalFlowSummary.formattedOutFlow
            )

            // Legend
            RecentActivitiesFlowLegend()

            // Net flow badge
            RecentActivitiesNetFlowBadge(summary: data.institutionalFlowSummary)

            // Sort selector
            RecentActivitiesSortSelector(selectedSort: $selectedSort)

            // Activity list
            LazyVStack(spacing: AppSpacing.sm) {
                ForEach(sortedInstitutionalActivities) { activity in
                    InstitutionalActivityRow(activity: activity)
                }
            }
            .animation(.easeInOut(duration: 0.2), value: selectedSort)
        }
    }

    // MARK: - Insiders Content

    private var insidersContent: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Period label
            Text(data.insiderActivities.summary.periodDescription)
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textMuted)
                .padding(.top, AppSpacing.xs)

            // Informative Buys vs Sells summary card
            InsiderFlowSummaryCard(summary: data.insiderActivities.summary)

            // Net informative flow
            InsiderNetFlowBadge(summary: data.insiderActivities.summary)

            // Filter selector (All / Informative)
            InsiderFilterSelector(selectedFilter: $selectedFilter)

            // Activity list
            LazyVStack(spacing: AppSpacing.sm) {
                ForEach(sortedInsiderActivities) { activity in
                    InsiderActivityRow(activity: activity)
                }
            }
            .animation(.easeInOut(duration: 0.2), value: selectedFilter)
            .animation(.easeInOut(duration: 0.2), value: selectedSort)
        }
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            RecentActivitiesSection(
                data: RecentActivitiesData.sampleData
            )
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/RecentResearchSection.swift
================================================================================

//
//  RecentResearchSection.swift
//  ios
//
//  Organism: Recent research carousel section
//

import SwiftUI

struct RecentResearchSection: View {
    let reports: [ResearchReport]
    var onSeeAllTapped: (() -> Void)?
    var onReportTapped: ((ResearchReport) -> Void)?
    var onAskOrReadTapped: ((ResearchReport) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section Header
            SectionHeader(title: "Recent Research", showSeeAll: true) {
                onSeeAllTapped?()
            }
            .padding(.horizontal, AppSpacing.lg)

            // Research Cards Carousel
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.lg) {
                    ForEach(reports) { report in
                        ResearchCard(report: report) {
                            onReportTapped?(report)
                        } onAskOrRead: {
                            onAskOrReadTapped?(report)
                        }
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }
        }
    }
}

#Preview {
    RecentResearchSection(reports: [
        ResearchReport(
            stockTicker: "MSFT",
            stockName: "Microsoft",
            companyLogoName: "icon_microsoft",
            persona: .warrenBuffett,
            headline: "Microsoft: The AI Moat Deepens",
            summary: "Azure's AI services and UX Pilot AI partnership position MSFT as a dominant force in enterprise AI. Q4 cloud growth of 28% YoY signals strong market demand.",
            rating: 4.6,
            targetPrice: 425,
            createdAt: Date().addingTimeInterval(-10800),
            gradientColors: ["0078D4", "00BCF2"]
        ),
        ResearchReport(
            stockTicker: "GOOGL",
            stockName: "Google",
            companyLogoName: "icon_google",
            persona: .peterLynch,
            headline: "Google: Gemini's Market Impact",
            summary: "Gemini AI integration across products shows promise. Search market share stable while cloud business accelerates with 26% growth.",
            rating: 4.2,
            targetPrice: 155,
            createdAt: Date().addingTimeInterval(-345600),
            gradientColors: ["4285F4", "34A853"]
        ),
        ResearchReport(
            stockTicker: "AMD",
            stockName: "AMD",
            companyLogoName: "icon_amd",
            persona: .cathieWood,
            headline: "AMD: AI Chip Wars Heat Up",
            summary: "MI300 series gaining traction in data centers. While trailing NVIDIA, AMD's competitive pricing and supply availability create opportunities.",
            rating: 3.3,
            targetPrice: 23,
            createdAt: Date().addingTimeInterval(-432000),
            gradientColors: ["ED1C24", "FF6B6B"]
        )
    ])
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/RecentSearchesSection.swift
================================================================================

//
//  RecentSearchesSection.swift
//  ios
//
//  Organism: Section displaying recent search items
//

import SwiftUI

struct RecentSearchesSection: View {
    let items: [SearchResultItem]
    var onClearAll: (() -> Void)?
    var onItemTapped: ((SearchResultItem) -> Void)?
    var onFollowTapped: ((SearchResultItem) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header
            HStack {
                Text("Recent Searches")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                if !items.isEmpty {
                    ClearAllButton {
                        onClearAll?()
                    }
                }
            }
            .padding(.horizontal, AppSpacing.lg)

            // Search results list
            if items.isEmpty {
                emptyStateView
            } else {
                VStack(spacing: 0) {
                    ForEach(items) { item in
                        SearchResultRow(
                            item: item,
                            onTap: { onItemTapped?(item) },
                            onFollowTap: { onFollowTapped?(item) }
                        )

                        if item.id != items.last?.id {
                            Divider()
                                .background(AppColors.cardBackgroundLight.opacity(0.5))
                        }
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }
        }
    }

    private var emptyStateView: some View {
        VStack(spacing: AppSpacing.md) {
            Image(systemName: "clock.arrow.circlepath")
                .font(.system(size: 32))
                .foregroundColor(AppColors.textMuted)

            Text("No recent searches")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, AppSpacing.xxl)
    }
}

#Preview {
    ScrollView {
        VStack(spacing: AppSpacing.xl) {
            RecentSearchesSection(items: SearchResultItem.sampleData)

            RecentSearchesSection(items: [])
        }
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportCoreThesisSection.swift
================================================================================

//
//  ReportCoreThesisSection.swift
//  ios
//
//  Organism: Core Thesis section combining Bull and Bear cases
//

import SwiftUI

struct ReportCoreThesisSection: View {
    let thesis: ReportCoreThesis

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("The Core Thesis")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            ReportCoreThesisCard(isBullCase: true, bullets: thesis.bullCase)

            ReportCoreThesisCard(isBullCase: false, bullets: thesis.bearCase)
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    ReportCoreThesisSection(thesis: TickerReportData.sampleOracle.coreThesis)
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportCriticalFactorsSection.swift
================================================================================

//
//  ReportCriticalFactorsSection.swift
//  ios
//
//  Organism: Critical Factors to Watch section with all warning items
//

import SwiftUI

struct ReportCriticalFactorsSection: View {
    let factors: [CriticalFactor]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("Critical Factors to Watch")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            // Combined card with dividers
            VStack(spacing: 0) {
                ForEach(Array(factors.enumerated()), id: \.element.id) { index, factor in
                    ReportCriticalFactorRow(factor: factor)
                    
                    // Add divider between items (but not after the last one)
                    if index < factors.count - 1 {
                        Divider()
                            .background(AppColors.textMuted.opacity(0.2))
                            .padding(.horizontal, AppSpacing.md)
                    }
                }
            }
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                    .fill(AppColors.cardBackground)
            )
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    ReportCriticalFactorsSection(factors: TickerReportData.sampleOracle.criticalFactors)
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportDeepDiveSection.swift
================================================================================

//
//  ReportDeepDiveSection.swift
//  ios
//
//  Organism: Collapsible deep dive module container
//

import SwiftUI

struct ReportDeepDiveSection<Content: View>: View {
    let module: DeepDiveModule
    let isExpanded: Bool
    let onToggle: () -> Void
    @ViewBuilder let content: () -> Content

    var body: some View {
        VStack(spacing: 0) {
            // Header row (tappable)
            Button(action: onToggle) {
                HStack(spacing: AppSpacing.md) {
                    Image(systemName: module.iconName)
                        .font(.system(size: module.iconName == "dollarsign.circle" ? 22 : 16))
                        .foregroundColor(AppColors.primaryBlue)
                        .frame(width: module.iconName == "dollarsign.circle" ? 36 : 28, alignment: module.iconName == "dollarsign.circle" ? .leading : .center)

                    Text(module.title)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.textPrimary)
                        .offset(x: module.iconName == "dollarsign.circle" ? -8 : 0)

                    Spacer()

                    Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                        .font(.system(size: 12, weight: .semibold))
                        .foregroundColor(AppColors.textMuted)
                }
                .padding(.horizontal, AppSpacing.lg)
                .padding(.vertical, AppSpacing.lg)
            }
            .buttonStyle(PlainButtonStyle())

            // Expanded content - only built when visible
            if isExpanded {
                content()
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.bottom, AppSpacing.lg)
                    .transition(.opacity.combined(with: .move(edge: .top)))
            }

            Divider()
                .background(AppColors.textMuted.opacity(0.15))
        }
        .background(AppColors.cardBackground)
        .animation(.easeInOut(duration: 0.25), value: isExpanded)
    }
}

#Preview {
    VStack(spacing: 0) {
        ReportDeepDiveSection(
            module: DeepDiveModule(
                title: "Fundamentals & Growth",
                iconName: "chart.bar.fill",
                type: .fundamentalsGrowth
            ),
            isExpanded: true,
            onToggle: {}
        ) {
            Text("Content goes here")
                .foregroundColor(AppColors.textSecondary)
        }
        ReportDeepDiveSection(
            module: DeepDiveModule(
                title: "Recent Price Movement",
                iconName: "chart.xyaxis.line",
                type: .recentPriceMovement
            ),
            isExpanded: false,
            onToggle: {}
        ) {
            EmptyView()
        }
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportFundamentalsSection.swift
================================================================================

//
//  ReportFundamentalsSection.swift
//  ios
//
//  Organism: Fundamentals & Growth deep dive content with 2x2 metric grid + assessment
//

import SwiftUI

struct ReportFundamentalsSection: View {
    let metrics: [DeepDiveMetricCard]
    let assessment: ReportOverallAssessment

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // 2x2 metric grid
            LazyVGrid(
                columns: [
                    GridItem(.flexible(), spacing: AppSpacing.md),
                    GridItem(.flexible(), spacing: AppSpacing.md)
                ],
                spacing: AppSpacing.md
            ) {
                ForEach(metrics) { metric in
                    ReportDeepDiveMetricCard(data: metric)
                }
            }

            // Overall Assessment
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                HStack(spacing: AppSpacing.xs) {
                    Image(systemName: "sparkles.2")
                        .foregroundStyle(
                            LinearGradient(
                                colors: [.indigo],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .font(.system(size: 16, weight: .semibold))

                    Text("Insight")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundStyle(LinearGradient(
                            colors: [.indigo, .cyan],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ))
                }

                Text(assessment.text)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textSecondary)
                    .lineSpacing(3)
            }
            .padding(AppSpacing.md)
        }
    }
}

#Preview {
    ReportFundamentalsSection(
        metrics: TickerReportData.sampleOracle.fundamentalMetrics,
        assessment: TickerReportData.sampleOracle.overallAssessment
    )
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportFutureForecastSection.swift
================================================================================

//
//  ReportFutureForecastSection.swift
//  ios
//
//  Organism: Future Forecast deep dive content with revenue chart and management guidance
//

import SwiftUI

struct ReportFutureForecastSection: View {
    let forecast: ReportRevenueForecast

    var body: some View {
        ReportForecastChart(forecast: forecast)
    }
}

#Preview {
    ReportFutureForecastSection(forecast: TickerReportData.sampleOracle.revenueForecast)
        .padding()
        .background(AppColors.cardBackground)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportInsiderSection.swift
================================================================================

//
//  ReportInsiderSection.swift
//  ios
//
//  Organism: Insider & Management deep dive content combining activity table and management info
//

import SwiftUI

struct ReportInsiderSection: View {
    let insiderData: ReportInsiderData
    let management: ReportKeyManagement

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xxl) {
            // Insider Activity
            ReportInsiderActivityTable(insiderData: insiderData)

            // Key Management
            ReportKeyManagementTable(management: management)
        }
    }
}

#Preview {
    ReportInsiderSection(
        insiderData: TickerReportData.sampleOracle.insiderData,
        management: TickerReportData.sampleOracle.keyManagement
    )
    .padding()
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportKeyVitalsSection.swift
================================================================================

//
//  ReportKeyVitalsSection.swift
//  ios
//
//  Organism: Horizontal scrolling Key Vitals section with 3 vital cards
//

import SwiftUI

struct ReportKeyVitalsSection: View {
    let vitals: ReportKeyVitals

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("Key Vitals")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)

            ScrollView(.horizontal, showsIndicators: false) {
                HStack(alignment: .top, spacing: AppSpacing.md) {
                    ReportValuationVitalCard(data: vitals.valuation)
                        .frame(width: 185)

                    ReportMoatVitalCard(data: vitals.moat)
                        .frame(width: 185)

                    ReportFinancialHealthVitalCard(data: vitals.financialHealth)
                        .frame(width: 185)
                }
                .padding(.horizontal, AppSpacing.lg)
            }
        }
    }
}

#Preview {
    ReportKeyVitalsSection(vitals: TickerReportData.sampleOracle.keyVitals)
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportMacroGeopoliticalSection.swift
================================================================================

//
//  ReportMacroGeopoliticalSection.swift
//  ios
//
//  Organism: Macro-Economic & Geopolitical deep dive content.
//  Intelligence briefing design: DEFCON-style threat level bar,
//  2-column risk gauge grid, and classified-style AI intelligence brief.
//

import SwiftUI

struct ReportMacroGeopoliticalSection: View {
    let data: ReportMacroData

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xxl) {
            // Threat Level Bar
            threatLevelSection

            // Intelligence Brief
            intelligenceBriefSection
        }
    }

    // MARK: - Threat Level

    private var threatLevelSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            ReportThreatLevelBar(level: data.overallThreatLevel)

            // Headline
            Text(data.headline)
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textPrimary)
                .lineSpacing(2)
        }
        .padding(AppSpacing.md)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackgroundLight)
                .overlay(
                    RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                        .stroke(data.overallThreatLevel.color.opacity(0.2), lineWidth: 1)
                )
        )
    }

    // MARK: - Intelligence Brief

    private var intelligenceBriefSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.xs) {
                Image(systemName: "sparkles.2")
                    .foregroundStyle(
                        LinearGradient(
                            colors: [.indigo],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .font(.system(size: 16, weight: .semibold))

                Text("Insight")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundStyle(LinearGradient(
                        colors: [.indigo, .cyan],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ))
            }

            Text(data.intelligenceBrief)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(3)
        }
        .padding(AppSpacing.md)
    }
}

#Preview {
    ScrollView {
        ReportMacroGeopoliticalSection(
            data: TickerReportData.sampleOracle.macroData
        )
        .padding()
    }
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportMoatCompetitionSection.swift
================================================================================

//
//  ReportMoatCompetitionSection.swift
//  ios
//
//  Organism: Industry & Competitive Moat deep dive content.
//  Market dynamics overview + Pentagon radar chart for competitive dimensions + peer comparison bars + moat rating.
//

import SwiftUI

struct ReportMoatCompetitionSection: View {
    let data: ReportMoatCompetitionData

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            // Market Dynamics Section
            marketDynamicsSection

            Divider()
                .background(AppColors.cardBackgroundLight)
                .padding(.vertical, AppSpacing.sm)

            // Moat Rating + Legend
            moatRatingHeader

            // Radar Chart
            radarChartSection

            // Durability Insight
            durabilityInsight

            // Peer Comparison
            peerComparisonSection
        }
    }

    // MARK: - Market Dynamics Section

    private var marketDynamicsSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section Title
            Text("Market Dynamics")
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textPrimary)

            // Industry and Concentration row
            HStack(spacing: AppSpacing.lg) {
                // Industry
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text("Industry")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)

                    Text(data.marketDynamics.industry)
                        .font(AppTypography.subheadline)
                        .fontWeight(.semibold)
                        .foregroundColor(AppColors.textPrimary)
                }

                Spacer()

                // Concentration
                VStack(alignment: .trailing, spacing: AppSpacing.xs) {
                    Text("Concentration")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)

                    Text(data.marketDynamics.concentration.rawValue)
                        .font(.system(size: 11, weight: .bold))
                        .foregroundColor(data.marketDynamics.concentration.color)
                        .padding(.horizontal, AppSpacing.sm)
                        .padding(.vertical, AppSpacing.xs)
                        .background(
                            Capsule()
                                .fill(data.marketDynamics.concentration.backgroundColor)
                        )
                }
                .alignmentGuide(.firstTextBaseline) { d in d[.top] }
            }
            .padding(.top, AppSpacing.xs)

            // 3-column metrics
            HStack(spacing: AppSpacing.sm) {
                // Column 1: CAGR
                marketMetricColumn(
                    label: "CAGR (5Yr)",
                    value: data.marketDynamics.formattedCAGR,
                    valueColor: data.marketDynamics.cagr5Yr >= 0 ? AppColors.bullish : AppColors.bearish,
                    subtitle: nil
                )
                .frame(maxWidth: 75)

                Divider()
                    .frame(height: 40)
                    .background(AppColors.cardBackgroundLight)

                // Column 2: Market Size (TAM)
                VStack(alignment: .center, spacing: AppSpacing.xxs) {
                    Text("Market Size (TAM)")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)

                    HStack(spacing: AppSpacing.xxs) {
                        Text(data.marketDynamics.formattedCurrentTAM)
                            .font(.system(size: 14, weight: .bold))
                            .foregroundColor(AppColors.textPrimary)

                        Text("â†’")
                            .font(.system(size: 14, weight: .semibold))
                            .foregroundColor(AppColors.textSecondary)

                        Text(data.marketDynamics.formattedFutureTAM)
                            .font(.system(size: 14, weight: .bold))
                            .foregroundColor(AppColors.textPrimary)
                    }

                    HStack(spacing: AppSpacing.xxs) {
                        Text("(\(data.marketDynamics.currentYear))")
                            .font(.system(size: 9))
                            .foregroundColor(AppColors.textMuted)

                        Spacer()
                            .frame(width: 14)

                        Text("(\(data.marketDynamics.futureYear))")
                            .font(.system(size: 9))
                            .foregroundColor(AppColors.textMuted)
                    }
                }
                .frame(maxWidth: .infinity)

                Divider()
                    .frame(height: 40)
                    .background(AppColors.cardBackgroundLight)

                // Column 3: Lifecycle Phase
                marketMetricColumn(
                    label: "Lifecycle Phase",
                    value: data.marketDynamics.lifecyclePhase.rawValue,
                    valueColor: AppColors.textPrimary,
                    subtitle: nil,
                    isBadge: false
                )
                .frame(maxWidth: 105)
            }
            .padding(.top, AppSpacing.sm)
        }
    }

    private func marketMetricColumn(
        label: String,
        value: String,
        valueColor: Color,
        subtitle: String?,
        isBadge: Bool = false
    ) -> some View {
        VStack(alignment: .center, spacing: AppSpacing.xxs) {
            Text(label)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            if isBadge {
                Text(value)
                    .font(.system(size: 11, weight: .bold))
                    .foregroundColor(valueColor)
                    .padding(.horizontal, AppSpacing.sm)
                    .padding(.vertical, AppSpacing.xs)
                    .background(
                        Capsule()
                            .fill(valueColor.opacity(0.15))
                    )
                    .lineLimit(1)
                    .minimumScaleFactor(0.8)
            } else {
                Text(value)
                    .font(.system(size: 12, weight: .bold))
                    .foregroundColor(valueColor)
            }

            if let subtitle = subtitle {
                Text(subtitle)
                    .font(.system(size: 9))
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .frame(maxWidth: .infinity)
    }

    // MARK: - Moat Rating Header

    private var moatRatingHeader: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            // Top row: Badge + Legend
            HStack(spacing: AppSpacing.md) {
                // Moat badge (styled like RISING SEGMENT)
                Text(data.overallRating.rawValue.uppercased())
                    .font(.system(size: 11, weight: .bold))
                    .foregroundColor(data.overallRating.color)
                    .padding(.horizontal, AppSpacing.sm)
                    .padding(.vertical, AppSpacing.xs)
                    .background(
                        Capsule()
                            .fill(data.overallRating.backgroundColor)
                    )

                Spacer()

                // Legend
                VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                    legendItem(color: AppColors.primaryBlue, label: "Company")
                    legendItem(color: AppColors.textMuted, label: "Peer Avg")
                }
            }

            // Primary Driver & Meaning
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                HStack(spacing: AppSpacing.xs) {
                    Text("Primary Driver:")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)

                    Text(data.primaryDriverName)
                        .font(AppTypography.caption)
                        .fontWeight(.semibold)
                        .foregroundColor(AppColors.textPrimary)

                    if let driver = data.primaryDriver {
                        Text("(\(String(format: "%.1f", driver.score))/10)")
                            .font(AppTypography.caption)
                            .foregroundColor(data.overallRating.color)
                    }
                }

                Text(data.overallRating.meaning)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .italic()
            }
        }
    }

    private func legendItem(color: Color, label: String) -> some View {
        HStack(spacing: AppSpacing.xs) {
            RoundedRectangle(cornerRadius: 1)
                .fill(color)
                .frame(width: 12, height: 3)
            Text(label)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
                .frame(minWidth: 55, alignment: .leading)
        }
    }

    // MARK: - Radar Chart

    private var radarChartSection: some View {
        ReportMoatRadarChart(dimensions: data.dimensions)
            .frame(maxWidth: .infinity)
    }

    // MARK: - Durability Insight

    private var durabilityInsight: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.xs) {
                Image(systemName: "sparkles.2")
                    .foregroundStyle(
                        LinearGradient(
                            colors: [.indigo],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .font(.system(size: 16, weight: .semibold))

                Text("Insight")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundStyle(LinearGradient(
                        colors: [.indigo, .cyan],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ))
            }

            Text(data.durabilityNote)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(3)
        }
        .padding(AppSpacing.md)
    }

    // MARK: - Peer Comparison

    private var peerComparisonSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            Text("Competitive Landscape")
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textPrimary)

            ForEach(data.competitors) { competitor in
                ReportPeerComparisonRow(competitor: competitor)
            }
        }
    }

    // MARK: - Competitive Insight

    private var competitiveInsightSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.xs) {
                Image(systemName: "sparkles.2")
                    .foregroundStyle(
                        LinearGradient(
                            colors: [.indigo],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .font(.system(size: 16, weight: .semibold))

                Text("Insight")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundStyle(LinearGradient(
                        colors: [.indigo, .cyan],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ))
            }

            Text(data.competitiveInsight)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(3)
        }
        .padding(AppSpacing.md)
    }
}

#Preview {
    ScrollView {
        ReportMoatCompetitionSection(
            data: TickerReportData.sampleOracle.moatCompetition
        )
        .padding()
    }
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportPriceMovementSection.swift
================================================================================

//
//  ReportPriceMovementSection.swift
//  ios
//
//  Organism: Recent Price Movement deep dive content.
//  Shows the "why" behind recent price action: catalyst badge,
//  percentage change with smart time label, sparkline with event dot,
//  and narrative explanation box.
//

import SwiftUI

struct ReportPriceMovementSection: View {
    @StateObject private var viewModel: PriceActionViewModel

    init(data: PriceActionData) {
        _viewModel = StateObject(wrappedValue: PriceActionViewModel(data: data))
    }
    
    var body: some View {
        let ctx = viewModel.context

        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Badge capsule: tag + %
            PriceActionBadge(
                tag: ctx.tag,
                percentage: ctx.displayPercentage,
                isPositive: ctx.isPositive
            )

            // Percentage text + time label
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(ctx.displayPercentage)
                    .font(.system(size: 22, weight: .bold, design: .rounded))
                    .foregroundColor(ctx.trendColor)

                Text(ctx.timeLabel)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textSecondary)
            }

            // Sparkline with event dot
            PriceActionSparkline(
                data: ctx.chartData,
                eventIndex: ctx.eventIndex,
                trendColor: ctx.trendColor
            )

            // Narrative box with header and explanation
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                // Header: sparkles icon + "Insight"
                HStack(spacing: AppSpacing.xs) {
                    Image(systemName: "sparkles.2")
                        .foregroundStyle(
                            LinearGradient(
                                colors: [.indigo],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .font(.system(size: 16, weight: .semibold))
                    
                    Text("Insight")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundStyle(LinearGradient(
                            colors: [.indigo, .cyan],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ))
                }
                
                // Narrative text
                Text(ctx.narrative)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textSecondary)
                    .lineSpacing(3)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
    }
}

#Preview {
    ScrollView {
        ReportPriceMovementSection(
            data: TickerReportData.sampleOracle.priceAction
        )
        .padding()
    }
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportRevenueEngineSection.swift
================================================================================

//
//  ReportRevenueEngineSection.swift
//  ios
//
//  Organism: Revenue Engine deep dive content.
//  Shows revenue segment breakdown with automatic role assignment,
//  growth metrics, and visual indicators for each segment.
//

import SwiftUI

struct ReportRevenueEngineSection: View {
    let data: ReportRevenueEngineData

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header: Total Revenue & Period
            headerSection

            // Segments List
            VStack(spacing: AppSpacing.md) {
                ForEach(data.segments) { segment in
                    segmentCard(segment)
                }
            }

            // Analysis Note (if available)
            if let note = data.analysisNote {
                analysisNoteSection(note)
            }
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xs) {
            Text("Total Revenue")
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)

            HStack(alignment: .firstTextBaseline, spacing: AppSpacing.xs) {
                Text(data.formattedTotalRevenue)
                    .font(.system(size: 18, weight: .bold, design: .rounded))
                    .foregroundColor(AppColors.textPrimary)

                Text(data.period)
                    .font(AppTypography.subheadline)
                    .foregroundColor(AppColors.textMuted)
            }
        }
    }

    // MARK: - Segment Card

    private func segmentCard(_ segment: RevenueSegment) -> some View {
        let role = data.roleForSegment(segment)

        return VStack(alignment: .leading, spacing: AppSpacing.sm) {
            // Top row: Role badge + Revenue
            HStack(alignment: .center) {
                // Role badge
                HStack(spacing: AppSpacing.xs) {
                    Text(role.rawValue.uppercased())
                        .font(.system(size: 9, weight: .bold))
                        .foregroundColor(role.color)
                }
                .padding(.horizontal, AppSpacing.sm)
                .padding(.vertical, AppSpacing.xs)
                .background(
                    Capsule()
                        .fill(role.backgroundColor)
                )

                Spacer()

                // Revenue amount
                Text(segment.formattedRevenue)
                    .font(.system(size: 12, weight: .semibold))
                    .foregroundColor(AppColors.textPrimary)
            }

            // Segment name
            Text(segment.name)
                .font(.system(size: 12, weight: .semibold))
                .foregroundColor(AppColors.textPrimary)
                .lineLimit(2)

            // Bottom row: Percentage + Growth
            HStack(spacing: AppSpacing.lg) {
                // Percentage of total
                HStack(spacing: AppSpacing.xs) {
                    Image(systemName: "chart.pie.fill")
                        .font(.system(size: 9))
                        .foregroundColor(AppColors.textSecondary)

                    Text(segment.formattedPercentage)
                        .font(.system(size: 11))
                        .foregroundColor(AppColors.textSecondary)

                    Text("of total")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }

                // Growth indicator
                HStack(spacing: AppSpacing.xs) {
                    Image(systemName: segment.growth >= 0 ? "arrow.up.right" : "arrow.down.right")
                        .font(.system(size: 7, weight: .semibold))
                        .foregroundColor(segment.growthColor)

                    Text(segment.formattedGrowth)
                        .font(.system(size: 11))
                        .foregroundColor(segment.growthColor)
                }
            }
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(AppColors.cardBackgroundLight)
        )
    }

    // MARK: - Analysis Note Section

    private func analysisNoteSection(_ note: String) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            HStack(spacing: AppSpacing.xs) {
                Image(systemName: "sparkles.2")
                    .foregroundStyle(
                        LinearGradient(
                            colors: [.indigo],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .font(.system(size: 16, weight: .semibold))

                Text("Insight")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundStyle(LinearGradient(
                        colors: [.indigo, .cyan],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ))
            }

            Text(note)
                .font(AppTypography.subheadline)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(3)
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

// MARK: - Preview

#Preview {
    ScrollView {
        ReportRevenueEngineSection(
            data: ReportRevenueEngineData.sampleOracle
        )
        .padding()
    }
    .background(AppColors.cardBackground)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportWallStreetSection.swift
================================================================================

//
//  ReportWallStreetSection.swift
//  ios
//
//  Organism: Wall Street Consensus deep dive content
//

import SwiftUI

struct ReportWallStreetSection: View {
    let consensus: ReportWallStreetConsensus

    var body: some View {
        ReportConsensusBar(consensus: consensus)
    }
}

#Preview {
    ReportWallStreetSection(consensus: TickerReportData.sampleOracle.wallStreetConsensus)
        .padding()
        .background(AppColors.cardBackground)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ReportsListSection.swift
================================================================================

//
//  ReportsListSection.swift
//  ios
//
//  Organism: List of analysis reports with sort option
//

import SwiftUI

struct ReportsListSection: View {
    let reports: [AnalysisReport]
    @Binding var sortOption: ReportSortOption
    var onReportTapped: ((AnalysisReport) -> Void)?
    var onRetryTapped: ((AnalysisReport) -> Void)?

    @State private var showSortMenu = false

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Sort header
            Button(action: {
                showSortMenu = true
            }) {
                HStack(spacing: AppSpacing.xxs) {
                    Text("Sort")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)

                    Image(systemName: "arrow.up.arrow.down")
                        .font(.system(size: 10, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                }
                .padding(.horizontal, AppSpacing.sm)
                .padding(.vertical, AppSpacing.xs)
                .background(
                    Capsule()
                        .fill(AppColors.cardBackgroundLight)
                )
            }
            .buttonStyle(PlainButtonStyle())
            .confirmationDialog("Sort Reports", isPresented: $showSortMenu) {
                ForEach(ReportSortOption.allCases, id: \.rawValue) { option in
                    Button(option.rawValue) {
                        sortOption = option
                    }
                }
                Button("Cancel", role: .cancel) {}
            }

            // Reports list
            VStack(spacing: AppSpacing.md) {
                ForEach(reports) { report in
                    ReportCard(
                        report: report,
                        onTap: {
                            onReportTapped?(report)
                        },
                        onRetry: {
                            onRetryTapped?(report)
                        }
                    )
                }
            }
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    ScrollView {
        ReportsListSection(
            reports: AnalysisReport.mockReports,
            sortOption: .constant(.dateNewest)
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ResearchHeader.swift
================================================================================

//
//  ResearchHeader.swift
//  ios
//
//  Organism: Research screen header with logo, title, and tab selector
//

import SwiftUI

struct ResearchHeader: View {
    @Binding var selectedTab: ResearchTab
    var onProfileTapped: (() -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Top bar with centered title using ZStack
            ZStack {
                // Centered title (ignores side elements)
                HStack(spacing: AppSpacing.sm) {
                    Image(systemName: "sparkles")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(AppColors.primaryBlue)

                    Text("AI Research Analysis")
                        .font(AppTypography.headline)
                        .foregroundColor(AppColors.textPrimary)
                }
                .padding(.horizontal, AppSpacing.md)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    Capsule()
                        .fill(AppColors.cardBackground)
                )

                // Side elements
                HStack {
                    // Logo placeholder
                    Circle()
                        .fill(AppColors.cardBackgroundLight)
                        .frame(width: 32, height: 32)
                        .overlay(
                            Text("L")
                                .font(AppTypography.footnoteBold)
                                .foregroundColor(AppColors.textSecondary)
                        )

                    Spacer()

                    // Profile button
                    Button(action: {
                        onProfileTapped?()
                    }) {
                        Circle()
                            .fill(AppColors.cardBackgroundLight)
                            .frame(width: 36, height: 36)
                            .overlay(
                                Image(systemName: "person.fill")
                                    .font(.system(size: 14))
                                    .foregroundColor(AppColors.textSecondary)
                            )
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }

            // Tab selector - stretched to full width
            HStack(spacing: 0) {
                ForEach(ResearchTab.allCases, id: \.rawValue) { tab in
                    Button(action: {
                        withAnimation(.easeInOut(duration: 0.2)) {
                            selectedTab = tab
                        }
                    }) {
                        Text(tab.rawValue)
                            .font(AppTypography.callout)
                            .fontWeight(selectedTab == tab ? .semibold : .regular)
                            .foregroundColor(selectedTab == tab ? AppColors.textPrimary : AppColors.textSecondary)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, AppSpacing.sm)
                            .background(
                                Group {
                                    if selectedTab == tab {
                                        RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                                            .fill(AppColors.cardBackgroundLight)
                                    }
                                }
                            )
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .padding(AppSpacing.xs)
            .background(
                RoundedRectangle(cornerRadius: AppCornerRadius.large)
                    .fill(AppColors.cardBackground)
            )
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
    }
}

#Preview {
    VStack {
        ResearchHeader(selectedTab: .constant(.research))
        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/RevenueBreakdownSectionCard.swift
================================================================================

//
//  RevenueBreakdownSectionCard.swift
//  ios
//
//  Organism: "How [TICKER] Makes Money" section card for the Financial tab
//

import SwiftUI

struct RevenueBreakdownSectionCard: View {
    // MARK: - Properties

    let data: RevenueBreakdownData
    let onDetailTapped: () -> Void

    // MARK: - State

    @State private var showInfoSheet: Bool = false

    // MARK: - Body

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            headerSection

            // Chart
            RevenueBreakdownChartView(data: data)

            // Legend
            RevenueBreakdownLegendView(data: data)
                .padding(.top, AppSpacing.md)
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
        .sheet(isPresented: $showInfoSheet) {
            RevenueBreakdownInfoSheet()
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        HStack {
            HStack(spacing: AppSpacing.sm) {
                Text("How \(data.tickerSymbol) Makes Money")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                GrowthInfoIcon {
                    showInfoSheet = true
                }
            }

            Spacer()

            Button(action: onDetailTapped) {
                Text("Detail")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.primaryBlue)
            }
            .buttonStyle(.plain)
        }
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            VStack(spacing: AppSpacing.lg) {
                RevenueBreakdownSectionCard(
                    data: RevenueBreakdownData.sampleApple,
                    onDetailTapped: {}
                )

                RevenueBreakdownSectionCard(
                    data: RevenueBreakdownData.sampleLossCompany,
                    onDetailTapped: {}
                )
            }
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/SearchBooksSection.swift
================================================================================

//
//  SearchBooksSection.swift
//  ios
//
//  Organism: Section displaying AI-enabled books in search
//

import SwiftUI

struct SearchBooksSection: View {
    let books: [SearchBookItem]
    var onChatWithBook: ((SearchBookItem) -> Void)?
    var onReadKeyIdeas: ((SearchBookItem) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header
            Text("AI-Enabled Books")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)

            // Book cards
            VStack(spacing: AppSpacing.md) {
                ForEach(books) { book in
                    SearchBookCard(
                        book: book,
                        onChatWithBook: { onChatWithBook?(book) },
                        onReadKeyIdeas: { onReadKeyIdeas?(book) }
                    )
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    ScrollView {
        SearchBooksSection(books: SearchBookItem.sampleData)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/SearchHeader.swift
================================================================================

//
//  SearchHeader.swift
//  ios
//
//  Organism: Header for search screen with back button, search bar, and suggestion chips
//

import SwiftUI

struct SearchHeader: View {
    @Binding var searchText: String
    let suggestions: [SearchQuerySuggestion]
    var onBackTapped: (() -> Void)?
    var onSearchSubmit: (() -> Void)?
    var onSuggestionTapped: ((SearchQuerySuggestion) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Search bar row
            HStack(spacing: AppSpacing.md) {
                // Back button
                Button(action: {
                    onBackTapped?()
                }) {
                    Image(systemName: "chevron.down")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                        .frame(width: 32, height: 32)
                }
                .buttonStyle(PlainButtonStyle())

                // Search bar
                HStack(spacing: AppSpacing.sm) {
                    Image(systemName: "sparkles")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(AppColors.primaryBlue)

                    TextField("", text: $searchText, prompt: Text("Search or ask Caudex AI...")
                        .foregroundColor(AppColors.textMuted))
                        .font(AppTypography.body)
                        .foregroundColor(AppColors.textPrimary)
                        .autocorrectionDisabled()
                        .textInputAutocapitalization(.never)
                        .onSubmit {
                            onSearchSubmit?()
                        }
                }
                .padding(.horizontal, AppSpacing.md)
                .padding(.vertical, AppSpacing.md)
                .background(AppColors.cardBackground)
                .cornerRadius(AppCornerRadius.large)
            }
            .padding(.horizontal, AppSpacing.lg)

            // Suggestion chips
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.sm) {
                    ForEach(suggestions) { suggestion in
                        SearchQueryChip(suggestion: suggestion) {
                            onSuggestionTapped?(suggestion)
                        }
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }
        }
        .padding(.top, AppSpacing.sm)
        .padding(.bottom, AppSpacing.md)
    }
}

#Preview {
    VStack {
        SearchHeader(
            searchText: .constant(""),
            suggestions: SearchQuerySuggestion.sampleData
        )

        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/SearchLatestNewsSection.swift
================================================================================

//
//  SearchLatestNewsSection.swift
//  ios
//
//  Organism: Section displaying latest news in search
//

import SwiftUI

struct SearchLatestNewsSection: View {
    let items: [SearchNewsItem]
    var onItemTapped: ((SearchNewsItem) -> Void)?
    var onReadMore: ((SearchNewsItem) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header
            Text("Latest News")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)

            // News cards
            VStack(spacing: AppSpacing.md) {
                ForEach(items) { item in
                    SearchNewsCard(
                        item: item,
                        onTap: { onItemTapped?(item) },
                        onReadMore: { onReadMore?(item) }
                    )
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

#Preview {
    ScrollView {
        SearchLatestNewsSection(items: SearchNewsItem.sampleData)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/SentimentAnalysisSection.swift
================================================================================

//
//  SentimentAnalysisSection.swift
//  ios
//
//  Complete Sentiment Analysis section for the Analysis tab
//

import SwiftUI

struct SentimentAnalysisSection: View {
    let sentimentData: SentimentAnalysisData
    @Binding var selectedTimeframe: SentimentTimeframe
    var onMoreTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            AnalysisSectionHeader(
                title: "Sentiment Analysis",
                onAction: { onMoreTapped?() }
            )

            // Market Mood Meter
            HStack {
                Spacer()
                MarketMoodMeter(
                    sentimentData: sentimentData,
                    selectedTimeframe: $selectedTimeframe
                )
                Spacer()
            }

            // Metrics row
            SentimentMetricsRow(sentimentData: sentimentData)

            // Disclaimer
            AnalysisDisclaimerText()
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        SentimentAnalysisSection(
            sentimentData: SentimentAnalysisData.sampleData,
            selectedTimeframe: .constant(.last24h),
            onMoreTapped: {}
        )
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/ShareholderBreakdownSection.swift
================================================================================

//
//  ShareholderBreakdownSection.swift
//  ios
//
//  Organism: Complete Shareholder Breakdown section card
//  Displays ownership distribution with bar chart and legend
//

import SwiftUI

struct ShareholderBreakdownSection: View {
    // MARK: - Properties

    let breakdownData: ShareholderBreakdown

    // MARK: - State

    @State private var showInfoSheet: Bool = false
    @State private var showTop10Sheet: Bool = false

    // MARK: - Body

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header with title, info icon, and Top 10 link
            headerSection

            // Horizontal stacked bar chart
            ShareholderBreakdownBar(
                insidersPercent: breakdownData.insidersPercent,
                institutionsPercent: breakdownData.institutionsPercent,
                publicOtherPercent: breakdownData.publicOtherPercent
            )
            .padding(.vertical, AppSpacing.sm)

            // Legend with percentages
            legendSection
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
        .sheet(isPresented: $showInfoSheet) {
            ShareholderBreakdownInfoSheet()
        }
        .sheet(isPresented: $showTop10Sheet) {
            Top10OwnersSheet(data: breakdownData.top10Owners)
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        HStack {
            HStack(spacing: AppSpacing.sm) {
                Text("Shareholder Breakdown")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                ShareholderBreakdownInfoIcon {
                    showInfoSheet = true
                }
            }

            Spacer()

            Button(action: { showTop10Sheet = true }) {
                Text("Top 10")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.primaryBlue)
            }
            .buttonStyle(.plain)
        }
    }

    // MARK: - Legend Section

    private var legendSection: some View {
        VStack(spacing: AppSpacing.md) {
            HolderBreakdownLegendItem(
                color: HoldersColors.insiders,
                label: "Insiders",
                percentage: breakdownData.formattedInsiders
            )

            HolderBreakdownLegendItem(
                color: HoldersColors.institutions,
                label: "Institutions",
                percentage: breakdownData.formattedInstitutions
            )

            HolderBreakdownLegendItem(
                color: HoldersColors.publicOther,
                label: "Public/Other",
                percentage: breakdownData.formattedPublicOther
            )
        }
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            ShareholderBreakdownSection(
                breakdownData: ShareholderBreakdown.sampleData
            )
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/SignalOfConfidenceSectionCard.swift
================================================================================

//
//  SignalOfConfidenceSectionCard.swift
//  ios
//
//  Organism: Complete Signal of Confidence Section card for the Financial tab
//  Displays dividends, buybacks, and shares outstanding over time
//

import SwiftUI

struct SignalOfConfidenceSectionCard: View {
    // MARK: - Properties

    let signalData: SignalOfConfidenceSectionData
    let onDetailTapped: () -> Void

    // MARK: - State

    @State private var selectedView: SignalOfConfidenceViewType = .yield
    @State private var showInfoSheet: Bool = false

    // MARK: - Body

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header with title, info icon, and detail link
            headerSection

            // View toggle (Yield % / Capital $)
            SignalOfConfidenceViewToggle(selectedView: $selectedView)
                .padding(.leading, AppSpacing.xs)

            // Main chart
            SignalOfConfidenceChartView(
                dataPoints: signalData.dataPoints,
                viewType: selectedView
            )
            .padding(.top, AppSpacing.sm)

            // Legend
            SignalOfConfidenceLegendView()
                .frame(maxWidth: .infinity)
                .padding(.top, AppSpacing.sm)

            // Summary text
            SignalOfConfidenceSummaryView(summary: signalData.summary)
                .padding(.top, AppSpacing.sm)

            // Dividend Info
            if let dividendInfo = signalData.dividendInfo {
                DividendInfoCard(dividendInfo: dividendInfo)
                    .padding(.top, AppSpacing.md)
            }
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
        .sheet(isPresented: $showInfoSheet) {
            SignalOfConfidenceInfoSheet()
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        HStack {
            HStack(spacing: AppSpacing.sm) {
                Text("Signal of Confidence")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                SignalOfConfidenceInfoIcon {
                    showInfoSheet = true
                }
            }

            Spacer()

            Button(action: onDetailTapped) {
                Text("Detail")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.primaryBlue)
            }
            .buttonStyle(.plain)
        }
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            SignalOfConfidenceSectionCard(
                signalData: SignalOfConfidenceSectionData.sampleData,
                onDetailTapped: {}
            )
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/SmartMoneySection.swift
================================================================================

//
//  SmartMoneySection.swift
//  ios
//
//  Organism: Complete Smart Money section card
//  Displays insider/hedge fund/congress trading activity with flow chart
//

import SwiftUI

struct SmartMoneySection: View {
    // MARK: - Properties

    let holdersData: HoldersData

    // MARK: - State

    @State private var selectedTab: SmartMoneyTab = .insider
    @State private var showInfoSheet: Bool = false

    // MARK: - Computed Properties

    private var currentData: SmartMoneyData {
        holdersData.smartMoneyData(for: selectedTab)
    }

    // MARK: - Body

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header with title and info icon
            headerSection

            // Tab selector (Insider / Hedge Funds / Congress)
            SmartMoneyTabSelector(selectedTab: $selectedTab)

            // Period label
            Text("\(currentData.summary.periodDescription) Flow")
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textMuted)
                .padding(.top, AppSpacing.xs)

            // Flow chart (price on top, buy/sell volume below)
            SmartMoneyFlowChart(
                priceData: currentData.priceData,
                flowData: currentData.flowData
            )
            .id(selectedTab.rawValue)
            .animation(.easeInOut(duration: 0.3), value: selectedTab)

            // Legend
            SmartMoneyFlowLegend()
                .padding(.top, AppSpacing.sm)

            // Net flow badge
            SmartMoneyNetFlowBadge(summary: currentData.summary)
                .padding(.top, AppSpacing.sm)
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
        .sheet(isPresented: $showInfoSheet) {
            SmartMoneyInfoSheet()
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        HStack {
            HStack(spacing: AppSpacing.sm) {
                Text("Smart Money")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                SmartMoneyInfoIcon {
                    showInfoSheet = true
                }
            }

            Spacer()
        }
    }
}

// MARK: - Preview

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            SmartMoneySection(
                holdersData: HoldersData.sampleData
            )
            .padding()
        }
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TargetSelectionSection.swift
================================================================================

//
//  TargetSelectionSection.swift
//  ios
//
//  Organism: Target selection with search bar and quick ticker chips
//

import SwiftUI

struct TargetSelectionSection: View {
    @Binding var searchText: String
    let quickTickers: [QuickTicker]
    var onTickerSelected: ((QuickTicker) -> Void)?
    var onSearchSubmit: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section header
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text("Select Your Target:")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                Text("Choose a company or ticker symbol to analyze")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            // Search bar
            SearchBar(
                text: $searchText,
                placeholder: "Search stocks, ETFs, or crypto",
                onSubmit: onSearchSubmit
            )

            // Quick ticker chips
            HStack(spacing: AppSpacing.sm) {
                ForEach(quickTickers) { ticker in
                    TickerChip(
                        ticker: ticker,
                        isSelected: searchText.uppercased() == ticker.symbol
                    ) {
                        onTickerSelected?(ticker)
                    }
                }
            }
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    VStack {
        TargetSelectionSection(
            searchText: .constant(""),
            quickTickers: QuickTicker.defaults
        )
        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TechnicalAnalysisSection.swift
================================================================================

//
//  TechnicalAnalysisSection.swift
//  ios
//
//  Complete Technical Analysis section for the Analysis tab
//

import SwiftUI

struct TechnicalAnalysisSection: View {
    let technicalData: TechnicalAnalysisData
    var onDetailTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            AnalysisSectionHeader(
                title: "Technical Analysis",
                actionText: "Detail",
                onAction: { onDetailTapped?() },
                showMoreButton: false
            )

            // Technical Meter
            HStack {
                Spacer()
                TechnicalMeter(technicalData: technicalData)
                Spacer()
            }

            // Disclaimer
            AnalysisDisclaimerText()
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        TechnicalAnalysisSection(
            technicalData: TechnicalAnalysisData.sampleData,
            onDetailTapped: {}
        )
        .padding()
    }
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerAnalysisContent.swift
================================================================================

//
//  TickerAnalysisContent.swift
//  ios
//
//  Organism: Analysis tab content combining all analysis sections for Ticker Detail
//

import SwiftUI

struct TickerAnalysisContent: View {
    let analysisData: TickerAnalysisData
    @Binding var selectedMomentumPeriod: AnalystMomentumPeriod
    @Binding var selectedSentimentTimeframe: SentimentTimeframe
    var onAnalystRatingsMoreTap: (() -> Void)?
    var onAnalystActionsTap: (() -> Void)?
    var onSentimentMoreTap: (() -> Void)?
    var onTechnicalDetailTap: (() -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Analyst Ratings Section
            AnalystRatingsSection(
                ratingsData: analysisData.analystRatings,
                selectedMomentumPeriod: $selectedMomentumPeriod,
                onMoreTapped: {
                    onAnalystRatingsMoreTap?()
                },
                onActionsTapped: {
                    onAnalystActionsTap?()
                }
            )

            // Sentiment Analysis Section
            SentimentAnalysisSection(
                sentimentData: analysisData.sentimentAnalysis,
                selectedTimeframe: $selectedSentimentTimeframe,
                onMoreTapped: {
                    onSentimentMoreTap?()
                }
            )

            // Technical Analysis Section
            TechnicalAnalysisSection(
                technicalData: analysisData.technicalAnalysis,
                onDetailTapped: {
                    onTechnicalDetailTap?()
                }
            )

            // Bottom spacing for AI bar
            Spacer()
                .frame(height: 120)
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.lg)
    }
}

#Preview {
    ScrollView {
        TickerAnalysisContent(
            analysisData: TickerAnalysisData.sampleData,
            selectedMomentumPeriod: .constant(.sixMonths),
            selectedSentimentTimeframe: .constant(.last24h)
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerDetailCompanyProfileSection.swift
================================================================================

//
//  TickerDetailCompanyProfileSection.swift
//  ios
//
//  Organism: Company Profile section for Ticker Detail with expandable content
//

import SwiftUI

struct TickerDetailCompanyProfileSection: View {
    let profile: CompanyProfile
    var onWebsiteTap: (() -> Void)?
    @State private var isExpanded: Bool = false

    // Number of lines to show when collapsed
    private let collapsedLineLimit: Int = 3

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Section title inside card styling
            Text("Company Profile")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            // Profile content
            VStack(alignment: .leading, spacing: AppSpacing.md) {
                // Description with expandable text
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    Text(profile.description)
                        .font(AppTypography.footnote)
                        .foregroundColor(AppColors.textSecondary)
                        .lineSpacing(4)
                        .lineLimit(isExpanded ? nil : collapsedLineLimit)
                        .fixedSize(horizontal: false, vertical: true)

                    // More/Less button
                    Button(action: {
                        withAnimation(.easeInOut(duration: 0.2)) {
                            isExpanded.toggle()
                        }
                    }) {
                        Text(isExpanded ? "Show less" : "more")
                            .font(AppTypography.footnote)
                            .fontWeight(.semibold)
                            .foregroundColor(AppColors.primaryBlue)
                    }
                    .buttonStyle(PlainButtonStyle())
                }

                // Divider
                Rectangle()
                    .fill(AppColors.cardBackgroundLight)
                    .frame(height: 1)

                // Info rows - show basic info always
                CompanyProfileRow(label: "CEO", value: profile.ceo)
                CompanyProfileRow(label: "Founded", value: profile.founded)
                CompanyProfileRow(label: "Employees", value: profile.formattedEmployees)
                CompanyProfileRow(label: "Headquarters", value: profile.headquarters)

                // Additional info shown when expanded
                if isExpanded {
                    // Add more profile details here if available
                    // For now we show the same info, but this structure allows for expansion

                    // Divider
                    Rectangle()
                        .fill(AppColors.cardBackgroundLight)
                        .frame(height: 1)

                    // Additional company details (placeholder for future expansion)
                    if let additionalInfo = getAdditionalInfo() {
                        ForEach(additionalInfo, id: \.label) { info in
                            CompanyProfileRow(label: info.label, value: info.value)
                        }
                    }
                }

                // Divider
                Rectangle()
                    .fill(AppColors.cardBackgroundLight)
                    .frame(height: 1)

                // Website
                HStack {
                    Text("Website")
                        .font(AppTypography.footnote)
                        .foregroundColor(AppColors.textSecondary)

                    Spacer()

                    Button(action: {
                        onWebsiteTap?()
                    }) {
                        HStack(spacing: AppSpacing.xs) {
                            Text(profile.website)
                                .font(AppTypography.footnoteBold)
                                .foregroundColor(AppColors.primaryBlue)

                            Image(systemName: "arrow.up.right")
                                .font(.system(size: 10, weight: .semibold))
                                .foregroundColor(AppColors.primaryBlue)
                        }
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }

    // Helper to get additional profile info (can be extended based on available data)
    private func getAdditionalInfo() -> [(label: String, value: String)]? {
        // Return nil if no additional info available
        // This can be populated with more company data in the future
        return nil
    }
}

#Preview {
    ScrollView {
        TickerDetailCompanyProfileSection(
            profile: CompanyProfile(
                description: "Apple Inc. designs, manufactures, and markets smartphones, personal computers, tablets, wearables, and accessories worldwide. The company offers iPhone, Mac, iPad, and Wearables, Home and Accessories products. Apple was founded by Steve Jobs, Steve Wozniak, and Ronald Wayne in April 1976 to develop and sell personal computers. The company has since grown to become one of the most valuable companies in the world.",
                ceo: "Tim Cook",
                founded: "April 1, 1976",
                employees: 161000,
                headquarters: "Cupertino, CA",
                website: "www.apple.com"
            )
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerDetailKeyStatsSection.swift
================================================================================

//
//  TickerDetailKeyStatsSection.swift
//  ios
//
//  Organism: Key Statistics section with horizontally scrollable cards
//

import SwiftUI

struct TickerDetailKeyStatsSection: View {
    let statisticsGroups: [KeyStatisticsGroup]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            // Section title inside card styling
            Text("Key Statistics")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)

            // Horizontal scrolling cards
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 0) {
                    ForEach(Array(statisticsGroups.enumerated()), id: \.element.id) { index, group in
                        HStack(spacing: 0) {
                            KeyStatisticsCard(statistics: group.statistics)
                            
                            // Vertical divider between cards (except for last)
                            if index < statisticsGroups.count - 1 {
                                Rectangle()
                                    .fill(AppColors.cardBackgroundLight)
                                    .frame(width: 1)
                                    .padding(.vertical, AppSpacing.lg)
                            }
                        }
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }
        }
        .padding(.top, AppSpacing.md)
        .padding(.bottom, AppSpacing.sm)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    ScrollView {
        TickerDetailKeyStatsSection(statisticsGroups: KeyStatisticsGroup.sampleData)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerDetailOverviewContent.swift
================================================================================

//
//  TickerDetailOverviewContent.swift
//  ios
//
//  Organism: Overview tab content combining all sections for Ticker Detail
//

import SwiftUI

struct TickerDetailOverviewContent: View {
    let tickerData: TickerDetailData
    var onDeepResearchTap: (() -> Void)?
    var onWebsiteTap: (() -> Void)?
    var onRelatedTickerTap: ((RelatedTicker) -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Key Statistics
            TickerDetailKeyStatsSection(statisticsGroups: tickerData.keyStatisticsGroups)

            // Performance
            TickerDetailPerformanceSection(periods: tickerData.performancePeriods)

            // Snapshots
            TickerDetailSnapshotsSection(
                snapshots: tickerData.snapshots,
                onDeepResearchTap: onDeepResearchTap
            )

            // Sector & Industry
            TickerDetailSectorIndustrySection(info: tickerData.sectorIndustry)

            // Company Profile
            TickerDetailCompanyProfileSection(
                profile: tickerData.companyProfile,
                onWebsiteTap: onWebsiteTap
            )

            // People Also Check
            TickerDetailRelatedSection(
                relatedTickers: tickerData.relatedTickers,
                onTickerTap: onRelatedTickerTap
            )

            // Bottom spacing for AI bar
            Spacer()
                .frame(height: 120)
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.lg)
    }
}

#Preview {
    ScrollView {
        TickerDetailOverviewContent(tickerData: TickerDetailData.sampleApple)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerDetailPerformanceSection.swift
================================================================================

//
//  TickerDetailPerformanceSection.swift
//  ios
//
//  Organism: Performance section for Ticker Detail
//

import SwiftUI

struct TickerDetailPerformanceSection: View {
    let periods: [PerformancePeriod]

    // Grid columns - 3 columns layout
    private let columns = Array(repeating: GridItem(.flexible(), spacing: AppSpacing.sm), count: 3)

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Section title inside card styling
            Text("Performance")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            // Performance grid
            LazyVGrid(columns: columns, spacing: AppSpacing.sm) {
                ForEach(periods) { period in
                    PerformanceItem(period: period)
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
    }
}

#Preview {
    ScrollView {
        TickerDetailPerformanceSection(periods: PerformancePeriod.sampleData)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerDetailRelatedSection.swift
================================================================================

//
//  TickerDetailRelatedSection.swift
//  ios
//
//  Organism: People Also Check section for Ticker Detail
//

import SwiftUI

struct TickerDetailRelatedSection: View {
    let relatedTickers: [RelatedTicker]
    var onTickerTap: ((RelatedTicker) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section header
            Text("People Also Check")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)

            // Horizontal scroll of ticker cards
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.md) {
                    ForEach(relatedTickers) { ticker in
                        RelatedTickerCard(ticker: ticker) {
                            onTickerTap?(ticker)
                        }
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }
        }
    }
}

#Preview {
    TickerDetailRelatedSection(relatedTickers: RelatedTicker.sampleData)
        .padding(.vertical)
        .background(AppColors.background)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerDetailSectorIndustrySection.swift
================================================================================

//
//  TickerDetailSectorIndustrySection.swift
//  ios
//
//  Organism: Sector & Industry section for Ticker Detail
//

import SwiftUI

struct TickerDetailSectorIndustrySection: View {
    let info: SectorIndustryInfo
    @State private var showInfoSheet: Bool = false

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Section title with info button inside card styling
            HStack {
                Text("Sector & Industry")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                Button(action: {
                    showInfoSheet = true
                }) {
                    Image(systemName: "info.circle")
                        .font(.system(size: 16))
                        .foregroundColor(AppColors.textMuted)
                }
                .buttonStyle(PlainButtonStyle())

                Spacer()
            }

            // Info rows
            VStack(spacing: AppSpacing.md) {
                SectorIndustryRow(label: "Sector", value: info.sector)
                SectorIndustryRow(label: "Industry", value: info.industry)
                SectorIndustryRow(
                    label: "Sector Performance",
                    value: info.formattedPerformance,
                    valueColor: info.performanceColor
                )
                SectorIndustryRow(label: "Industry Rank", value: info.industryRank)
            }
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
        .sheet(isPresented: $showInfoSheet) {
            SectorIndustryInfoSheet()
                .presentationDetents([.medium])
                .presentationDragIndicator(.visible)
        }
    }
}

// MARK: - Sector & Industry Info Sheet
struct SectorIndustryInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xl) {
                    // Why it matters
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "lightbulb.fill")
                                .font(.system(size: 18))
                                .foregroundColor(AppColors.neutral)
                            Text("Why Sector & Industry Matters")
                                .font(AppTypography.headline)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        Text("Understanding a company's sector and industry helps you:")
                            .font(AppTypography.body)
                            .foregroundColor(AppColors.textSecondary)

                        VStack(alignment: .leading, spacing: AppSpacing.md) {
                            InfoBulletPoint(
                                icon: "chart.line.uptrend.xyaxis",
                                title: "Compare Performance",
                                description: "Benchmark the stock against similar companies and sector averages."
                            )

                            InfoBulletPoint(
                                icon: "arrow.triangle.branch",
                                title: "Understand Market Cycles",
                                description: "Different sectors perform better in different economic conditions."
                            )

                            InfoBulletPoint(
                                icon: "shield.checkerboard",
                                title: "Diversify Portfolio",
                                description: "Avoid concentration risk by spreading investments across sectors."
                            )

                            InfoBulletPoint(
                                icon: "magnifyingglass.circle",
                                title: "Identify Opportunities",
                                description: "Find undervalued stocks within high-performing industries."
                            )
                        }
                    }

                    // Metrics explained
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        Text("Key Metrics Explained")
                            .font(AppTypography.headline)
                            .foregroundColor(AppColors.textPrimary)

                        MetricExplanation(
                            term: "Sector Performance",
                            explanation: "Shows how the overall sector has performed recently, helping you understand macro trends."
                        )

                        MetricExplanation(
                            term: "Industry Rank",
                            explanation: "Indicates where this company stands among its direct competitors based on key metrics."
                        )
                    }
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("Sector & Industry")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
        .preferredColorScheme(.dark)
    }
}

// MARK: - Info Bullet Point
struct InfoBulletPoint: View {
    let icon: String
    let title: String
    let description: String

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Image(systemName: icon)
                .font(.system(size: 16))
                .foregroundColor(AppColors.primaryBlue)
                .frame(width: 24)

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.footnote)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
    }
}

// MARK: - Metric Explanation
struct MetricExplanation: View {
    let term: String
    let explanation: String

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xs) {
            Text(term)
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.primaryBlue)

            Text(explanation)
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
    }
}

#Preview {
    ScrollView {
        TickerDetailSectorIndustrySection(
            info: SectorIndustryInfo(
                sector: "Technology",
                industry: "Consumer Electronics",
                sectorPerformance: 2.87,
                industryRank: "#1 of 42"
            )
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

#Preview("Info Sheet") {
    SectorIndustryInfoSheet()
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerDetailSnapshotsSection.swift
================================================================================

//
//  TickerDetailSnapshotsSection.swift
//  ios
//
//  Organism: Snapshots section for Ticker Detail with expandable cards
//

import SwiftUI

struct TickerDetailSnapshotsSection: View {
    let snapshots: [SnapshotItem]
    var onDeepResearchTap: (() -> Void)?
    @State private var showInfoSheet: Bool = false

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Section title with info button inside card styling
            HStack {
                Text("Snapshots")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                // What's Snapshots? link
                Button(action: {
                    showInfoSheet = true
                }) {
                    Text("What's Snapshots?")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }
                .buttonStyle(PlainButtonStyle())
            }

            // Snapshot cards
            VStack(spacing: 0) {
                ForEach(snapshots) { snapshot in
                    SnapshotCard(snapshot: snapshot)
                }
            }

            // AI Deep Research button
            AIDeepResearchButton {
                onDeepResearchTap?()
            }
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
        )
        .sheet(isPresented: $showInfoSheet) {
            SnapshotsInfoSheet()
                .presentationDetents([.medium, .large])
                .presentationDragIndicator(.visible)
        }
    }
}

// MARK: - Snapshots Info Sheet
struct SnapshotsInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xl) {
                    // What are Snapshots?
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "camera.viewfinder")
                                .font(.system(size: 18))
                                .foregroundColor(AppColors.neutral)
                            Text("What are Snapshots?")
                                .font(AppTypography.headline)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        Text("Snapshots provide a quick, comprehensive view of a stock's health across multiple dimensions. Each snapshot evaluates different aspects of the company's performance, giving you an instant understanding of its strengths and weaknesses.")
                            .font(AppTypography.body)
                            .foregroundColor(AppColors.textSecondary)
                            .fixedSize(horizontal: false, vertical: true)
                    }

                    // Why Snapshots Matter
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "lightbulb.fill")
                                .font(.system(size: 18))
                                .foregroundColor(AppColors.neutral)
                            Text("Why Snapshots Matter")
                                .font(AppTypography.headline)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        Text("Instead of analyzing hundreds of metrics separately, Snapshots synthesize complex data into easy-to-understand ratings. This helps you:")
                            .font(AppTypography.body)
                            .foregroundColor(AppColors.textSecondary)
                            .fixedSize(horizontal: false, vertical: true)

                        VStack(alignment: .leading, spacing: AppSpacing.md) {
                            SnapshotBulletPoint(
                                icon: "clock.fill",
                                title: "Save Time",
                                description: "Make faster investment decisions by quickly identifying key strengths and risks."
                            )

                            SnapshotBulletPoint(
                                icon: "chart.bar.fill",
                                title: "Compare Stocks",
                                description: "Easily compare companies across standardized categories and ratings."
                            )

                            SnapshotBulletPoint(
                                icon: "target",
                                title: "Focus on What Matters",
                                description: "Identify which areas require deeper research based on ratings."
                            )

                            SnapshotBulletPoint(
                                icon: "checkmark.shield.fill",
                                title: "Reduce Risk",
                                description: "Spot potential red flags before making investment decisions."
                            )
                        }
                    }

                    // Understanding Ratings
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "star.fill")
                                .font(.system(size: 18))
                                .foregroundColor(AppColors.neutral)
                            Text("Understanding Ratings")
                                .font(AppTypography.headline)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        VStack(alignment: .leading, spacing: AppSpacing.sm) {
                            RatingExplanation(
                                rating: "High",
                                color: AppColors.bullish,
                                stars: 5,
                                description: "Outstanding performance, significantly above industry standards."
                            )

                            RatingExplanation(
                                rating: "Solid",
                                color: AppColors.bullish,
                                stars: 4,
                                description: "Strong performance, meets or exceeds most expectations."
                            )

                            RatingExplanation(
                                rating: "Moderate",
                                color: AppColors.neutral,
                                stars: 3,
                                description: "Average performance, some strengths and weaknesses."
                            )

                            RatingExplanation(
                                rating: "Soft",
                                color: AppColors.alertOrange,
                                stars: 2,
                                description: "Below-average performance, may require attention."
                            )

                            RatingExplanation(
                                rating: "Low",
                                color: AppColors.bearish,
                                stars: 1,
                                description: "Serious concerns, significant underperformance or risk."
                            )
                        }
                    }

                    // Pro Tips
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "sparkles")
                                .font(.system(size: 18))
                                .foregroundColor(AppColors.neutral)
                            Text("Pro Tips")
                                .font(AppTypography.headline)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        VStack(alignment: .leading, spacing: AppSpacing.md) {
                            ProTipCard(
                                icon: "arrow.triangle.2.circlepath",
                                tip: "Don't rely on a single snapshot. A stock with excellent growth but poor financial health may still be risky."
                            )

                            ProTipCard(
                                icon: "calendar",
                                tip: "Snapshots reflect recent data. Check the financial tab for trends over time to see if ratings are improving or declining."
                            )

                            ProTipCard(
                                icon: "building.2",
                                tip: "Compare snapshots with competitors in the same sector to understand relative performance."
                            )

                            ProTipCard(
                                icon: "book.fill",
                                tip: "Use snapshots as a starting point, not the final word. Always combine them with your own research and investment strategy."
                            )
                        }
                    }
                }
                .padding(AppSpacing.lg)
            }
            .background(AppColors.background)
            .navigationTitle("About Snapshots")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
        .preferredColorScheme(.dark)
    }
}

// MARK: - Snapshot Bullet Point
struct SnapshotBulletPoint: View {
    let icon: String
    let title: String
    let description: String

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Image(systemName: icon)
                .font(.system(size: 16))
                .foregroundColor(AppColors.primaryBlue)
                .frame(width: 24)

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.footnote)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
    }
}

// MARK: - Snapshot Usage Step
struct SnapshotUsageStep: View {
    let number: Int
    let title: String
    let description: String

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Step number circle
            ZStack {
                Circle()
                    .fill(AppColors.primaryBlue)
                    .frame(width: 28, height: 28)

                Text("\(number)")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(.white)
            }

            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(title)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(description)
                    .font(AppTypography.footnote)
                    .foregroundColor(AppColors.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
    }
}

// MARK: - Rating Explanation
struct RatingExplanation: View {
    let rating: String
    let color: Color
    let stars: Int
    let description: String

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xs) {
            // Stars
            HStack(spacing: 2) {
                ForEach(0..<stars, id: \.self) { _ in
                    Image(systemName: "star.fill")
                        .font(.system(size: 12))
                        .foregroundColor(color)
                }
                ForEach(stars..<5, id: \.self) { _ in
                    Image(systemName: "star.fill")
                        .font(.system(size: 12))
                        .foregroundColor(AppColors.textMuted.opacity(0.3))
                }
            }

            // Rating title
            Text(rating)
                .font(AppTypography.calloutBold)
                .foregroundColor(color)

            // Description
            Text(description)
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
    }
}

// MARK: - Pro Tip Card
struct ProTipCard: View {
    let icon: String
    let tip: String

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Image(systemName: icon)
                .font(.system(size: 16))
                .foregroundColor(AppColors.primaryBlue)
                .frame(width: 24)

            Text(tip)
                .font(AppTypography.footnote)
                .foregroundColor(AppColors.textSecondary)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(AppSpacing.md)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
    }
}

#Preview {
    ScrollView {
        TickerDetailSnapshotsSection(snapshots: SnapshotItem.sampleData)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}
#Preview("Info Sheet") {
    SnapshotsInfoSheet()
}


================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerFinancialsContent.swift
================================================================================

//
//  TickerFinancialsContent.swift
//  ios
//
//  Organism: Financials tab content combining all financial sections for Ticker Detail
//

import SwiftUI

struct TickerFinancialsContent: View {
    let earningsData: EarningsData
    let growthData: GrowthSectionData?
    let profitPowerData: ProfitPowerSectionData?
    let signalOfConfidenceData: SignalOfConfidenceSectionData?
    let revenueBreakdownData: RevenueBreakdownData?
    let healthCheckData: HealthCheckSectionData?
    var onEarningsDetailTap: (() -> Void)?
    var onGrowthDetailTap: (() -> Void)?
    var onProfitPowerDetailTap: (() -> Void)?
    var onSignalOfConfidenceDetailTap: (() -> Void)?
    var onRevenueBreakdownDetailTap: (() -> Void)?
    var onHealthCheckDetailTap: (() -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Earnings Section
            EarningsSectionCard(
                earningsData: earningsData,
                onDetailTap: {
                    onEarningsDetailTap?()
                }
            )

            // Growth Section
            if let growthData = growthData {
                GrowthSectionCard(
                    growthData: growthData,
                    onDetailTapped: {
                        onGrowthDetailTap?()
                    }
                )
            }

            // Revenue Breakdown Section ("How TICKER Makes Money")
            if let revenueBreakdownData = revenueBreakdownData {
                RevenueBreakdownSectionCard(
                    data: revenueBreakdownData,
                    onDetailTapped: {
                        onRevenueBreakdownDetailTap?()
                    }
                )
            }

            // Profit Power Section
            if let profitPowerData = profitPowerData {
                ProfitPowerSectionCard(
                    profitPowerData: profitPowerData,
                    onDetailTapped: {
                        onProfitPowerDetailTap?()
                    }
                )
            }

            // Health Check Section
            if let healthCheckData = healthCheckData {
                HealthCheckSectionCard(
                    healthCheckData: healthCheckData,
                    onDetailTapped: {
                        onHealthCheckDetailTap?()
                    }
                )
            }

            // Signal of Confidence Section
            if let signalOfConfidenceData = signalOfConfidenceData {
                SignalOfConfidenceSectionCard(
                    signalData: signalOfConfidenceData,
                    onDetailTapped: {
                        onSignalOfConfidenceDetailTap?()
                    }
                )
            }

            // Bottom spacing for AI bar
            Spacer()
                .frame(height: 120)
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.lg)
    }
}

#Preview {
    ScrollView {
        TickerFinancialsContent(
            earningsData: EarningsData.sampleData,
            growthData: GrowthSectionData.sampleData,
            profitPowerData: ProfitPowerSectionData.sampleData,
            signalOfConfidenceData: SignalOfConfidenceSectionData.sampleData,
            revenueBreakdownData: RevenueBreakdownData.sampleApple,
            healthCheckData: HealthCheckSectionData.sampleData
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerHoldersContent.swift
================================================================================

//
//  TickerHoldersContent.swift
//  ios
//
//  Organism: Holders tab content combining all holder-related sections for Ticker Detail
//  Includes Shareholder Breakdown, Smart Money, and Recent Activities sections
//

import SwiftUI

struct TickerHoldersContent: View {
    let holdersData: HoldersData

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Shareholder Breakdown Section
            ShareholderBreakdownSection(
                breakdownData: holdersData.shareholderBreakdown
            )

            // Smart Money Section
            SmartMoneySection(holdersData: holdersData)

            // Recent Activities Section
            RecentActivitiesSection(
                data: holdersData.recentActivities
            )

            // Bottom spacing for AI bar
            Spacer()
                .frame(height: 120)
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.lg)
    }
}

#Preview {
    ScrollView {
        TickerHoldersContent(
            holdersData: HoldersData.sampleData
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TickerNewsContent.swift
================================================================================

//
//  TickerNewsContent.swift
//  ios
//
//  Organism: News tab content for Ticker Detail screen
//

import SwiftUI

struct TickerNewsContent: View {
    let articles: [TickerNewsArticle]
    let currentTicker: String
    var onArticleTap: ((TickerNewsArticle) -> Void)?
    var onExternalLinkTap: ((TickerNewsArticle) -> Void)?
    var onRelatedTickerTap: ((String) -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.md) {
            if articles.isEmpty {
                emptyStateView
            } else {
                // News cards list
                ForEach(articles) { article in
                    TickerNewsCard(
                        article: article,
                        currentTicker: currentTicker,
                        onCardTap: {
                            onArticleTap?(article)
                        },
                        onExternalLinkTap: {
                            onExternalLinkTap?(article)
                        },
                        onTickerTap: { ticker in
                            onRelatedTickerTap?(ticker)
                        }
                    )
                }

                // Bottom spacing for AI bar
                Spacer()
                    .frame(height: 120)
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.lg)
    }

    private var emptyStateView: some View {
        VStack(spacing: AppSpacing.lg) {
            Image(systemName: "newspaper")
                .font(.system(size: 48))
                .foregroundColor(AppColors.textMuted)

            Text("No News Available")
                .font(AppTypography.title2)
                .foregroundColor(AppColors.textPrimary)

            Text("News articles for \(currentTicker) will appear here when available.")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .multilineTextAlignment(.center)

            Spacer()
                .frame(height: 150)
        }
        .frame(maxWidth: .infinity)
        .padding(.top, AppSpacing.xxxl)
    }
}

#Preview {
    ScrollView {
        TickerNewsContent(
            articles: TickerNewsArticle.sampleDataForTicker("AAPL"),
            currentTicker: "AAPL"
        )
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TrackingHeader.swift
================================================================================

//
//  TrackingHeader.swift
//  ios
//
//  Organism: Header for Tracking screen with search, tabs, and profile
//

import SwiftUI

struct TrackingHeader: View {
    @Binding var searchText: String
    @Binding var selectedTab: TrackingTab
    var onProfileTapped: (() -> Void)?
    var onSearchSubmit: (() -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Top Row: Logo, Search, Profile
            HStack(spacing: AppSpacing.md) {
                // Logo placeholder
                Circle()
                    .fill(AppColors.cardBackground)
                    .frame(width: 32, height: 32)
                    .overlay(
                        Text("logo")
                            .font(.system(size: 8))
                            .foregroundColor(AppColors.textMuted)
                    )

                // Search Bar
                SearchBar(
                    text: $searchText,
                    placeholder: "Search ticker or whale...",
                    onSubmit: onSearchSubmit
                )

                // Profile Button
                Button {
                    onProfileTapped?()
                } label: {
                    ZStack {
                        Circle()
                            .fill(AppColors.cardBackground)
                            .frame(width: 36, height: 36)

                        Image(systemName: "person.circle")
                            .font(.system(size: 22))
                            .foregroundColor(AppColors.textSecondary)
                    }
                }
                .buttonStyle(.plain)
            }
            .padding(.horizontal, AppSpacing.lg)

            // Segmented Tab Control
            SegmentedTabControl(
                tabs: TrackingTab.allCases,
                selectedTab: $selectedTab
            )
            .padding(.horizontal, AppSpacing.lg)
        }
        .padding(.top, AppSpacing.sm)
        .padding(.bottom, AppSpacing.md)
        .background(AppColors.background)
    }
}

#Preview {
    struct PreviewWrapper: View {
        @State private var searchText = ""
        @State private var selectedTab = TrackingTab.assets

        var body: some View {
            VStack {
                TrackingHeader(
                    searchText: $searchText,
                    selectedTab: $selectedTab
                )
                Spacer()
            }
            .background(AppColors.background)
        }
    }

    return PreviewWrapper()
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/TrendingAnalysesSection.swift
================================================================================

//
//  TrendingAnalysesSection.swift
//  ios
//
//  Organism: Trending analyses list with explore action
//

import SwiftUI

struct TrendingAnalysesSection: View {
    let analyses: [TrendingAnalysis]
    var onExploreTapped: (() -> Void)?
    var onAnalysisTapped: ((TrendingAnalysis) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section header
            HStack {
                Text("Trending Analyses")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button(action: {
                    onExploreTapped?()
                }) {
                    Text("Explore")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
            }

            // Trending list
            VStack(spacing: AppSpacing.sm) {
                ForEach(analyses) { analysis in
                    TrendingAnalysisRow(analysis: analysis) {
                        onAnalysisTapped?(analysis)
                    }
                }
            }
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    ScrollView {
        TrendingAnalysesSection(analyses: TrendingAnalysis.mockTrending)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/UpdatesHeader.swift
================================================================================

//
//  UpdatesHeader.swift
//  ios
//
//  Organism: Header for Updates screen with logo, title, and profile
//

import SwiftUI

struct UpdatesHeader: View {
    var onProfileTapped: (() -> Void)?

    var body: some View {
        ZStack {
            // Centered Title (ignores surrounding elements)
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "sparkles")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(AppColors.primaryBlue)

                Text("News Updates")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }
            .padding(.horizontal, AppSpacing.lg)
            .padding(.vertical, AppSpacing.sm)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.pill)

            // Left and Right buttons
            HStack {
                // Logo placeholder
                ZStack {
                    Circle()
                        .fill(AppColors.cardBackgroundLight)
                        .frame(width: 36, height: 36)

                    Text("logo")
                        .font(.system(size: 10, weight: .medium))
                        .foregroundColor(AppColors.textMuted)
                }

                Spacer()

                // Profile Button
                Button(action: { onProfileTapped?() }) {
                    ZStack {
                        Circle()
                            .stroke(AppColors.textMuted.opacity(0.5), lineWidth: 1)
                            .frame(width: 36, height: 36)

                        Image(systemName: "person.circle")
                            .font(.system(size: 24, weight: .light))
                            .foregroundColor(AppColors.textSecondary)
                    }
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
    }
}

#Preview {
    VStack {
        UpdatesHeader()
        Spacer()
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/UpdatesTabBar.swift
================================================================================

//
//  UpdatesTabBar.swift
//  ios
//
//  Organism: Tab bar for filtering news by market or ticker
//

import SwiftUI

struct UpdatesTabBar: View {
    let tabs: [NewsFilterTab]
    @Binding var selectedTab: NewsFilterTab?
    var onManageAssets: (() -> Void)?

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            // Scrollable Tabs
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.sm) {
                    ForEach(tabs) { tab in
                        UpdatesTabButton(
                            tab: tab,
                            isSelected: selectedTab?.id == tab.id
                        ) {
                            withAnimation(.easeInOut(duration: 0.2)) {
                                selectedTab = tab
                            }
                        }
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }

            // Manage Assets Button
            ManageAssetsButton {
                onManageAssets?()
            }
            .padding(.trailing, AppSpacing.lg)
        }
        .padding(.vertical, AppSpacing.sm)
    }
}

#Preview {
    VStack {
        UpdatesTabBar(
            tabs: [
                NewsFilterTab(title: "Market", ticker: nil, changePercent: nil, isMarketTab: true),
                NewsFilterTab(title: "AAPL", ticker: "AAPL", changePercent: 2.4, isMarketTab: false),
                NewsFilterTab(title: "TSLA", ticker: "TSLA", changePercent: -1.2, isMarketTab: false)
            ],
            selectedTab: .constant(NewsFilterTab(title: "Market", ticker: nil, changePercent: nil, isMarketTab: true)),
            onManageAssets: {}
        )
        Spacer()
    }
    .background(AppColors.background)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/UpgradesDowngradesSection.swift
================================================================================

//
//  UpgradesDowngradesSection.swift
//  ios
//
//  Full view displaying list of analyst upgrades and downgrades
//

import SwiftUI

struct UpgradesDowngradesSection: View {
    let actions: [AnalystAction]
    var onInfoTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            HStack {
                Text("Upgrades & Downgrades")
                    .font(AppTypography.title2)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button(action: {
                    onInfoTapped?()
                }) {
                    Image(systemName: "info.circle")
                        .font(.system(size: 18))
                        .foregroundColor(AppColors.textMuted)
                }
            }
            .padding(.horizontal, AppSpacing.lg)

            // Actions list
            LazyVStack(spacing: AppSpacing.sm) {
                ForEach(actions) { action in
                    AnalystActionCard(action: action)
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

// MARK: - Full Screen View for Modal Presentation
struct UpgradesDowngradesView: View {
    let actions: [AnalystAction]
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            VStack(spacing: 0) {
                // Navigation Header
                HStack {
                    Button(action: {
                        dismiss()
                    }) {
                        Image(systemName: "chevron.down")
                            .font(.system(size: 18, weight: .medium))
                            .foregroundColor(AppColors.textPrimary)
                    }

                    Spacer()

                    Text("Upgrades & Downgrades")
                        .font(AppTypography.headline)
                        .foregroundColor(AppColors.textPrimary)

                    Spacer()

                    Button(action: {
                        // Info action
                    }) {
                        Image(systemName: "info.circle")
                            .font(.system(size: 18))
                            .foregroundColor(AppColors.textMuted)
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
                .padding(.vertical, AppSpacing.md)
                .background(AppColors.background)

                // Divider
                Rectangle()
                    .fill(AppColors.cardBackgroundLight)
                    .frame(height: 1)

                // Scrollable content
                ScrollView(showsIndicators: false) {
                    LazyVStack(spacing: AppSpacing.sm) {
                        ForEach(actions) { action in
                            AnalystActionCard(action: action)
                        }
                    }
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.vertical, AppSpacing.lg)
                }
            }
        }
        .navigationBarHidden(true)
    }
}

#Preview("Section") {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ScrollView {
            UpgradesDowngradesSection(actions: AnalystAction.sampleData)
                .padding(.top, AppSpacing.lg)
        }
    }
}

#Preview("Full View") {
    UpgradesDowngradesView(actions: AnalystAction.sampleData)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/WhatYouGetSection.swift
================================================================================

//
//  WhatYouGetSection.swift
//  ios
//
//  Organism: Features list showing what the analysis includes
//

import SwiftUI

struct WhatYouGetSection: View {
    let features: [AnalysisFeature]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section header with info icon
            HStack {
                Text("What You'll Get")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button(action: {
                    // Show info tooltip
                }) {
                    Image(systemName: "info.circle")
                        .font(.system(size: 16))
                        .foregroundColor(AppColors.textMuted)
                }
            }

            // Features list
            VStack(spacing: AppSpacing.sm) {
                ForEach(features) { feature in
                    FeatureRow(feature: feature)
                }
            }
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    ScrollView {
        WhatYouGetSection(features: AnalysisFeature.allFeatures)
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Organisms/YourJourneySection.swift
================================================================================

//
//  YourJourneySection.swift
//  ios
//
//  Organism: Section showing current journey progress
//

import SwiftUI

struct YourJourneySection: View {
    let track: JourneyTrack
    var onContinue: (() -> Void)?
    var onItemTap: ((JourneyItem) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            Text("Your Journey")
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)

            // Progress card
            JourneyProgressCard(
                track: track,
                onContinue: onContinue,
                onItemTap: onItemTap
            )
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

#Preview {
    VStack {
        YourJourneySection(track: JourneyTrack.sampleBeginner)
        Spacer()
    }
    .background(AppColors.background)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/AllRecentTradesView.swift
================================================================================

//
//  AllRecentTradesView.swift
//  ios
//
//  All Recent Trades screen â€” shown when user taps "more" on Recent Trades
//  Displays all whale trading activity in a timeline
//

import SwiftUI

// MARK: - AllRecentTradesView
struct AllRecentTradesView: View {
    @ObservedObject var viewModel: TrackingViewModel

    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            ScrollView(showsIndicators: false) {
                LazyVStack(spacing: 0) {
                    ForEach(Array(viewModel.allWhaleTrades.enumerated()), id: \.element.id) { groupIndex, group in
                        ForEach(Array(group.activities.enumerated()), id: \.element.id) { activityIndex, activity in
                            let isFirst = groupIndex == 0 && activityIndex == 0
                            let isLast = groupIndex == viewModel.allWhaleTrades.count - 1
                                && activityIndex == group.activities.count - 1

                            WhaleTradeTimelineRow(
                                activity: activity,
                                isFirst: isFirst,
                                isLast: isLast,
                                onTapped: { viewModel.viewTradeGroupDetail(activity) }
                            )
                            .padding(.horizontal, AppSpacing.lg)
                        }
                    }

                    // Bottom spacing
                    Spacer()
                        .frame(height: 100)
                }
                .padding(.top, AppSpacing.md)
            }
        }
        .navigationTitle("Recent Trades")
        .navigationBarTitleDisplayMode(.inline)
    }
}

// MARK: - Preview
#Preview {
    NavigationStack {
        AllRecentTradesView(viewModel: TrackingViewModel())
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/AllWhalesView.swift
================================================================================

//
//  AllWhalesView.swift
//  ios
//
//  All Whales screen â€” shown when user taps "more" on Most Popular Whales
//  Horizontal category filter + categorized whale sections
//

import SwiftUI

// MARK: - Filter Option
private enum WhaleCategoryFilter: String, CaseIterable {
    case all = "All"
    case investors = "Investors"
    case institutions = "Institutions"
    case politicians = "Politicians"
    case crypto = "Crypto"

    var matchedCategory: WhaleCategory? {
        switch self {
        case .all: return nil
        case .investors: return .investors
        case .institutions: return .institutions
        case .politicians: return .politicians
        case .crypto: return .cryptoWhales
        }
    }
}

// MARK: - Sort Option (only for "All" filter)
private enum WhaleSortOption: String, CaseIterable {
    case alphabetical = "Aâ€“Z"
    case followers = "Followers"

    var icon: String {
        switch self {
        case .alphabetical: return "textformat.abc"
        case .followers: return "person.2.fill"
        }
    }
}

// MARK: - AllWhalesView
struct AllWhalesView: View {
    @ObservedObject var viewModel: TrackingViewModel
    @State private var selectedFilter: WhaleCategoryFilter = .all
    @State private var sortOption: WhaleSortOption = .followers
    @State private var isSearching: Bool = false
    @State private var searchText: String = ""
    @FocusState private var isSearchFocused: Bool

    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            VStack(spacing: 0) {
                // Expandable search bar
                if isSearching {
                    HStack(spacing: AppSpacing.sm) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "magnifyingglass")
                                .font(.system(size: 14))
                                .foregroundColor(AppColors.textMuted)

                            TextField("Search whales...", text: $searchText)
                                .font(AppTypography.body)
                                .foregroundColor(AppColors.textPrimary)
                                .focused($isSearchFocused)

                            if !searchText.isEmpty {
                                Button {
                                    searchText = ""
                                } label: {
                                    Image(systemName: "xmark.circle.fill")
                                        .font(.system(size: 14))
                                        .foregroundColor(AppColors.textMuted)
                                }
                                .buttonStyle(.plain)
                            }
                        }
                        .padding(.horizontal, AppSpacing.md)
                        .padding(.vertical, AppSpacing.sm)
                        .background(AppColors.cardBackground)
                        .cornerRadius(AppCornerRadius.pill)

                        Button {
                            withAnimation(.easeInOut(duration: 0.25)) {
                                isSearching = false
                                searchText = ""
                                isSearchFocused = false
                            }
                        } label: {
                            Text("Cancel")
                                .font(AppTypography.callout)
                                .foregroundColor(AppColors.primaryBlue)
                        }
                        .buttonStyle(.plain)
                    }
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.vertical, AppSpacing.sm)
                    .transition(.opacity.combined(with: .move(edge: .top)))
                }

                // Category filter chips (horizontal scroll) â€” hidden while searching
                if !isSearching {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: AppSpacing.sm) {
                            ForEach(WhaleCategoryFilter.allCases, id: \.self) { filter in
                                Button {
                                    withAnimation(.easeInOut(duration: 0.2)) {
                                        selectedFilter = filter
                                    }
                                } label: {
                                    Text(filter.rawValue)
                                        .font(AppTypography.calloutBold)
                                        .foregroundColor(
                                            selectedFilter == filter
                                                ? AppColors.textPrimary
                                                : AppColors.textSecondary
                                        )
                                        .padding(.horizontal, AppSpacing.lg)
                                        .padding(.vertical, AppSpacing.sm)
                                        .background(
                                            selectedFilter == filter
                                                ? AppColors.cardBackgroundLight
                                                : AppColors.cardBackground
                                        )
                                        .cornerRadius(AppCornerRadius.pill)
                                }
                                .buttonStyle(.plain)
                            }
                        }
                        .padding(.horizontal, AppSpacing.lg)
                    }
                    .padding(.top, AppSpacing.md)
                    .padding(.bottom, AppSpacing.sm)
                }

                // Sort control â€” only visible when "All" is selected and not searching
                if selectedFilter == .all && !isSearching {
                    HStack {
                        Button {
                            withAnimation(.easeInOut(duration: 0.2)) {
                                sortOption = sortOption == .alphabetical ? .followers : .alphabetical
                            }
                        } label: {
                            HStack(spacing: 4) {
                                Text("Sort by:")
                                    .font(AppTypography.caption)
                                
                                Text(sortOption == .alphabetical ? "A-Z" : "Followed")
                                    .font(AppTypography.caption)
                            }
                            .foregroundColor(AppColors.textMuted)
                            .padding(.horizontal, AppSpacing.md)
                            .padding(.vertical, AppSpacing.xs)
                            .background(AppColors.cardBackground)
                            .cornerRadius(AppCornerRadius.pill)
                        }
                        .buttonStyle(.plain)

                        Spacer()
                    }
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.bottom, AppSpacing.sm)
                }

                // Whale sections
                ScrollView(showsIndicators: false) {
                    LazyVStack(spacing: AppSpacing.xxl) {
                        if isSearching {
                            // Search results â€” flat list
                            if searchResults.isEmpty && !searchText.isEmpty {
                                VStack(spacing: AppSpacing.md) {
                                    Image(systemName: "magnifyingglass")
                                        .font(.system(size: 40))
                                        .foregroundColor(AppColors.textMuted)

                                    Text("No results for \"\(searchText)\"")
                                        .font(AppTypography.body)
                                        .foregroundColor(AppColors.textSecondary)

                                    Text("Try a different name or institution")
                                        .font(AppTypography.caption)
                                        .foregroundColor(AppColors.textMuted)
                                }
                                .frame(maxWidth: .infinity)
                                .padding(.top, AppSpacing.xxxl)
                            } else {
                                AllWhalesFlatList(
                                    whales: searchResults,
                                    onFollowToggle: { whale in viewModel.toggleFollowWhale(whale) },
                                    onWhaleTapped: { whale in viewModel.viewWhaleProfile(whale) }
                                )
                            }
                        } else if selectedFilter == .all {
                            // Flat sorted list
                            AllWhalesFlatList(
                                whales: allWhalesSorted,
                                onFollowToggle: { whale in viewModel.toggleFollowWhale(whale) },
                                onWhaleTapped: { whale in viewModel.viewWhaleProfile(whale) }
                            )
                        } else {
                            // Category-specific section
                            if let category = selectedFilter.matchedCategory {
                                AllWhalesCategorySection(
                                    title: category.rawValue,
                                    whales: whalesForCategory(category),
                                    onFollowToggle: { whale in viewModel.toggleFollowWhale(whale) },
                                    onWhaleTapped: { whale in viewModel.viewWhaleProfile(whale) }
                                )
                            }
                        }

                        // Bottom spacing
                        Spacer()
                            .frame(height: 100)
                    }
                    .padding(.top, AppSpacing.sm)
                }
            }
        }
        .navigationTitle("Popular Whales")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                if !isSearching {
                    Button {
                        withAnimation(.easeInOut(duration: 0.25)) {
                            isSearching = true
                        }
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                            isSearchFocused = true
                        }
                    } label: {
                        Image(systemName: "magnifyingglass")
                            .font(.system(size: 16, weight: .medium))
                            .foregroundColor(AppColors.textPrimary)
                    }
                }
            }
        }
    }

    // MARK: - Search

    private var searchResults: [TrendingWhale] {
        guard !searchText.isEmpty else { return syncFollowState(viewModel.allPopularWhales) }
        let query = searchText.lowercased()
        return syncFollowState(
            viewModel.allPopularWhales.filter { whale in
                whale.name.lowercased().contains(query) ||
                whale.title.lowercased().contains(query) ||
                whale.category.rawValue.lowercased().contains(query)
            }
        )
    }

    // MARK: - Data

    private var allWhalesSorted: [TrendingWhale] {
        let whales = syncFollowState(viewModel.allPopularWhales)
        switch sortOption {
        case .alphabetical:
            return whales.sorted { $0.name < $1.name }
        case .followers:
            return whales.sorted { $0.followersCount > $1.followersCount }
        }
    }

    private func whalesForCategory(_ category: WhaleCategory) -> [TrendingWhale] {
        syncFollowState(viewModel.allPopularWhales.filter { $0.category == category })
    }

    private func syncFollowState(_ whales: [TrendingWhale]) -> [TrendingWhale] {
        let trackedNames = Set(viewModel.trackedWhales.map(\.name))
        return whales.map { whale in
            if trackedNames.contains(whale.name) && !whale.isFollowing {
                return TrendingWhale(
                    name: whale.name,
                    category: whale.category,
                    avatarName: whale.avatarName,
                    followersCount: whale.followersCount,
                    isFollowing: true,
                    title: whale.title,
                    description: whale.description,
                    recentTradeCount: whale.recentTradeCount
                )
            }
            return whale
        }
    }
}

// MARK: - Flat List (for "All" with sorting)
private struct AllWhalesFlatList: View {
    let whales: [TrendingWhale]
    var onFollowToggle: ((TrendingWhale) -> Void)?
    var onWhaleTapped: ((TrendingWhale) -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.md) {
            ForEach(whales) { whale in
                WhaleCard(
                    whale: whale,
                    onFollowToggle: { onFollowToggle?(whale) },
                    onTap: { onWhaleTapped?(whale) }
                )
            }
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

// MARK: - Category Section
struct AllWhalesCategorySection: View {
    let title: String
    let whales: [TrendingWhale]
    var onFollowToggle: ((TrendingWhale) -> Void)?
    var onWhaleTapped: ((TrendingWhale) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Section Header
            Text(title)
                .font(AppTypography.title3)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)

            // Whale Cards
            VStack(spacing: AppSpacing.md) {
                ForEach(whales) { whale in
                    WhaleCard(
                        whale: whale,
                        onFollowToggle: { onFollowToggle?(whale) },
                        onTap: { onWhaleTapped?(whale) }
                    )
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

// MARK: - Preview
#Preview {
    NavigationStack {
        AllWhalesView(viewModel: TrackingViewModel())
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/BookCoreDetailView.swift
================================================================================

//
//  BookCoreDetailView.swift
//  ios
//
//  Book Core Detail View - Detailed content view for a specific core chapter
//  Displays chapter content with sections, audio playback, and AI chat
//

import SwiftUI
import Combine

// MARK: - Book Core Detail View
struct BookCoreDetailView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var audioManager: AudioManager
    @State private var scrollOffset: CGFloat = 0
    @State private var previousScrollOffset: CGFloat = 0
    @State private var inputText: String = ""
    @State private var currentContent: CoreChapterContent

    // Completion tracking
    @State private var completedCoreNumbers: Set<Int> = []
    @State private var audioCompletionCancellable: AnyCancellable?

    // Track if user initiated playback from this view or if it was already playing
    @State private var shouldShowPlayer: Bool = false

    let book: LibraryBook
    let allCores: [BookCoreChapter]
    
    init(content: CoreChapterContent, book: LibraryBook) {
        self.book = book
        self.allCores = book.coreChapters
        self._currentContent = State(initialValue: content)
    }
    
    private var currentCoreIndex: Int {
        allCores.firstIndex { $0.number == currentContent.chapterNumber } ?? 0
    }
    
    private var hasPreviousCore: Bool {
        currentCoreIndex > 0
    }
    
    private var hasNextCore: Bool {
        currentCoreIndex < allCores.count - 1
    }

    private var content: CoreChapterContent {
        currentContent
    }

    private var isCurrentCoreCompleted: Bool {
        // Check if already completed by user during this session, or previously completed (chapter <= currentChapter)
        completedCoreNumbers.contains(currentContent.chapterNumber) ||
        currentContent.chapterNumber < book.currentChapter
    }

    // Computed property for header opacity based on scroll
    private var headerOpacity: Double {
        let fadeStart: CGFloat = 60
        let fadeEnd: CGFloat = 120
        if scrollOffset < fadeStart { return 0 }
        if scrollOffset > fadeEnd { return 1 }
        return Double((scrollOffset - fadeStart) / (fadeEnd - fadeStart))
    }

    // Audio episode for the current chapter
    private var currentAudioEpisode: AudioEpisode {
        AudioEpisode(
            id: "book-\(book.id.uuidString)-core-\(content.chapterNumber)",
            title: content.chapterTitle,
            subtitle: "\(content.bookTitle) - Core \(content.chapterNumber)",
            artworkGradientColors: [book.coverGradientStart, book.coverGradientEnd],
            artworkIcon: "book.fill",
            duration: TimeInterval(content.audioDurationSeconds),
            category: .books,
            authorName: content.bookAuthor,
            sourceId: book.id.uuidString
        )
    }

    var body: some View {
        ZStack(alignment: .top) {
            // Background
            AppColors.background
                .ignoresSafeArea()

            // Main scrollable content
            ScrollView(showsIndicators: false) {
                VStack(spacing: 0) {
                    // Header spacer for back button area
                    Color.clear
                        .frame(height: 60)

                    // Chapter header
                    CoreDetailHeaderSection(
                        content: content,
                        book: book,
                        onPlayStarted: { shouldShowPlayer = true }
                    )
                    .padding(.horizontal, AppSpacing.lg)

                    // Content sections
                    LazyVStack(alignment: .leading, spacing: AppSpacing.xxl) {
                        ForEach(content.sections) { section in
                            CoreSectionView(section: section)
                        }
                    }
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.top, AppSpacing.xxl)

                    // Victory Button - Complete & Continue
                    CoreCompletionButton(
                        isCompleted: isCurrentCoreCompleted,
                        hasNextCore: hasNextCore,
                        onComplete: handleCoreCompletion
                    )
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.top, AppSpacing.xxl)

                    // Bottom padding for global audio player + AI bar
                    Color.clear.frame(height: 180)
                }
                .background(
                    GeometryReader { proxy in
                        Color.clear
                            .preference(
                                key: CoreDetailScrollOffsetKey.self,
                                value: -proxy.frame(in: .named("coreDetailScroll")).origin.y
                            )
                    }
                )
            }
            .coordinateSpace(name: "coreDetailScroll")
            .onPreferenceChange(CoreDetailScrollOffsetKey.self) { value in
                handleScrollChange(newOffset: value)
            }

            // Sticky mini header (appears on scroll)
            if headerOpacity > 0 {
                CoreDetailMiniHeader(
                    content: content,
                    hasPrevious: hasPreviousCore,
                    hasNext: hasNextCore,
                    onBackTapped: handleBackTapped,
                    onCloseTapped: handleCloseTapped,
                    onNextTapped: handleNextTapped
                )
                .opacity(headerOpacity)
                .zIndex(10)
            }

            // Navigation header (transparent)
            if headerOpacity == 0 {
                CoreDetailNavigationHeader(
                    hasPrevious: hasPreviousCore,
                    hasNext: hasNextCore,
                    onBackTapped: handleBackTapped,
                    onCloseTapped: handleCloseTapped,
                    onNextTapped: handleNextTapped
                )
                .zIndex(10)
            }

            // Bottom AI chat bar
            VStack(spacing: 0) {
                Spacer()

                // Global Mini Player (show if audio was playing or user started playback)
                if shouldShowPlayer && audioManager.hasActiveEpisode && !audioManager.isPlayerHiddenByScroll {
                    GlobalMiniPlayer()
                        .transition(.move(edge: .bottom).combined(with: .opacity))
                }

                CoreDetailAskAIBar(inputText: $inputText, onSend: handleAISend)
            }
            .animation(.spring(response: 0.3, dampingFraction: 0.85), value: audioManager.hasActiveEpisode)
            .animation(.spring(response: 0.25, dampingFraction: 0.85), value: audioManager.isPlayerHiddenByScroll)
            .animation(.spring(response: 0.3, dampingFraction: 0.85), value: shouldShowPlayer)
        }
        .navigationBarHidden(true)
        .onAppear {
            // If audio is already playing, show the player
            if audioManager.hasActiveEpisode && audioManager.isPlaying {
                shouldShowPlayer = true
            }

            // Load the audio episode when view appears (paused)
            audioManager.load(currentAudioEpisode)

            // Subscribe to audio completion events
            audioCompletionCancellable = audioManager.playbackDidComplete
                .receive(on: DispatchQueue.main)
                .sink { [self] completedEpisode in
                    // Check if the completed episode matches the current core's audio
                    if completedEpisode.id == currentAudioEpisode.id {
                        handleCoreCompletion()
                    }
                }
        }
        .onDisappear {
            // Reset scroll hiding when leaving the view
            audioManager.resetScrollHiding()
            // Cancel audio completion subscription
            audioCompletionCancellable?.cancel()
            audioCompletionCancellable = nil
        }
        .onChange(of: currentContent.chapterNumber) {
            // Load new episode when navigating between chapters (paused)
            audioManager.load(currentAudioEpisode)
        }
    }

    // MARK: - Scroll Handling
    private func handleScrollChange(newOffset: CGFloat) {
        let scrollDelta = newOffset - previousScrollOffset

        // Update global audio player visibility based on scroll direction
        // Require minimum scroll delta to avoid flickering
        if abs(scrollDelta) > 8 {
            if scrollDelta > 0 && newOffset > 50 {
                // Scrolling down - hide global audio player
                audioManager.hidePlayerByScroll()
            } else if scrollDelta < -8 {
                // Scrolling up - show global audio player
                audioManager.showPlayerAfterScroll()
            }
            previousScrollOffset = newOffset
        }

        scrollOffset = newOffset
    }

    // MARK: - Completion Handling
    private func handleCoreCompletion() {
        // Don't re-complete if already done
        guard !isCurrentCoreCompleted else { return }

        // Trigger success haptic feedback
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(.success)

        // Mark current core as completed
        _ = withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
            completedCoreNumbers.insert(currentContent.chapterNumber)
        }

        // If there's a next core, navigate to it after a delay
        if hasNextCore {
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                navigateToNextCore()
            }
        }
    }

    // MARK: - Actions
    private func handleCloseTapped() {
        print("ðŸ”´ DEBUG: Close button tapped")
        dismiss()
    }
    
    private func handleBackTapped() {
        print("ðŸ”µ DEBUG: Back button tapped")
        guard hasPreviousCore else {
            dismiss()
            return
        }
        navigateToPreviousCore()
    }
    
    private func handleNextTapped() {
        print("ðŸŸ¢ DEBUG: Next button tapped")
        guard hasNextCore else { return }
        navigateToNextCore()
    }
    
    private func navigateToPreviousCore() {
        let previousIndex = currentCoreIndex - 1
        guard previousIndex >= 0, let newContent = allCores[previousIndex].getDetailContent(for: book) else { return }
        withAnimation(.easeInOut(duration: 0.3)) {
            currentContent = newContent
        }
        // Reset scroll position and show audio player
        scrollOffset = 0
        previousScrollOffset = 0
        audioManager.resetScrollHiding()
    }

    private func navigateToNextCore() {
        let nextIndex = currentCoreIndex + 1
        guard nextIndex < allCores.count, let newContent = allCores[nextIndex].getDetailContent(for: book) else { return }
        withAnimation(.easeInOut(duration: 0.3)) {
            currentContent = newContent
        }
        // Reset scroll position and show audio player
        scrollOffset = 0
        previousScrollOffset = 0
        audioManager.resetScrollHiding()
    }
    
    private func handleAISend() {
        guard !inputText.isEmpty else { return }
        print("Ask AI about chapter: \(inputText)")
        inputText = ""
    }
}

// MARK: - Scroll Offset Preference Key
private struct CoreDetailScrollOffsetKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

// MARK: - Header Section
private struct CoreDetailHeaderSection: View {
    @EnvironmentObject private var audioManager: AudioManager
    let content: CoreChapterContent
    let book: LibraryBook
    var onPlayStarted: (() -> Void)?

    // Audio episode for this chapter
    private var audioEpisode: AudioEpisode {
        AudioEpisode(
            id: "book-\(book.id.uuidString)-core-\(content.chapterNumber)",
            title: content.chapterTitle,
            subtitle: "\(content.bookTitle) - Core \(content.chapterNumber)",
            artworkGradientColors: [book.coverGradientStart, book.coverGradientEnd],
            artworkIcon: "book.fill",
            duration: TimeInterval(content.audioDurationSeconds),
            category: .books,
            authorName: content.bookAuthor,
            sourceId: book.id.uuidString
        )
    }

    private var isThisCoreAudioPlaying: Bool {
        guard let currentEpisode = audioManager.currentEpisode else { return false }
        return currentEpisode.id == audioEpisode.id && audioManager.isPlaying
    }

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Chapter badge with play button
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "book.fill")
                    .font(.system(size: 12, weight: .semibold))
                    .foregroundColor(book.level.color)

                Text(content.formattedChapterLabel.uppercased())
                    .font(AppTypography.captionBold)
                    .foregroundColor(book.level.color)
                    .tracking(0.8)

                Spacer()

                // Direct Play button
                Button(action: handleDirectPlay) {
                    HStack(spacing: AppSpacing.xs) {
                        Image(systemName: isThisCoreAudioPlaying ? "pause.circle.fill" : "play.circle.fill")
                            .font(.system(size: 28, weight: .medium))
                            .foregroundColor(AppColors.primaryBlue)
                    }
                }
                .buttonStyle(PlainButtonStyle())
            }

            // Chapter title
            Text(content.chapterTitle)
                .font(AppTypography.largeTitle)
                .foregroundColor(AppColors.textPrimary)
                .fixedSize(horizontal: false, vertical: true)

            // Divider
            Rectangle()
                .fill(AppColors.cardBackgroundLight)
                .frame(height: 1)
                .padding(.top, AppSpacing.sm)
        }
    }

    private func handleDirectPlay() {
        if isThisCoreAudioPlaying {
            // Pause if already playing this core
            audioManager.togglePlayPause()
        } else {
            // Start playing this core's audio
            audioManager.play(audioEpisode)
            // Force show the global audio player
            audioManager.resetScrollHiding()
            // Notify parent that playback started
            onPlayStarted?()
        }
    }
}

// MARK: - Section View
private struct CoreSectionView: View {
    let section: CoreChapterSection

    var body: some View {
        switch section.content {
        case .text(let text):
            if section.type == .heading {
                CoreHeadingView(text: text)
            } else {
                CoreParagraphView(text: text)
            }

        case .richText(let attributedString):
            Text(attributedString)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(6)

        case .quote(let quote):
            CoreQuoteView(quote: quote)

        case .assetList(let assets):
            CoreAssetListView(assets: assets, title: section.title)

        case .actionPlan(let steps):
            CoreActionPlanView(steps: steps)

        case .bulletPoints(let points):
            CoreBulletPointsView(points: points, title: section.title)

        case .callout(let callout):
            CoreCalloutView(callout: callout)
        }
    }
}

// MARK: - Heading View
private struct CoreHeadingView: View {
    let text: String

    var body: some View {
        Text(text)
            .font(AppTypography.title2)
            .foregroundColor(AppColors.textPrimary)
            .padding(.top, AppSpacing.md)
    }
}

// MARK: - Paragraph View
private struct CoreParagraphView: View {
    let text: String

    var body: some View {
        Text(text)
            .font(AppTypography.body)
            .foregroundColor(AppColors.textSecondary)
            .lineSpacing(6)
            .fixedSize(horizontal: false, vertical: true)
    }
}

// MARK: - Quote View
private struct CoreQuoteView: View {
    let quote: QuoteContent

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Quote icon
            Image(systemName: "quote.opening")
                .font(.system(size: 24, weight: .bold))
                .foregroundColor(AppColors.accentCyan.opacity(0.6))

            // Quote text
            Text(quote.text)
                .font(.system(size: 16, weight: .medium, design: .serif))
                .foregroundColor(AppColors.textPrimary)
                .lineSpacing(6)
                .italic()

            // Attribution
            HStack(spacing: AppSpacing.xs) {
                Rectangle()
                    .fill(AppColors.accentCyan)
                    .frame(width: 24, height: 2)

                Text(quote.author)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.accentCyan)

                if let source = quote.source {
                    Text(",")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textMuted)

                    Text(source)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)
                        .italic()
                }
            }
        }
        .padding(AppSpacing.xl)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

// MARK: - Asset List View
private struct CoreAssetListView: View {
    let assets: [AssetCategory]
    let title: String?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            if let title = title {
                Text(title)
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            VStack(spacing: AppSpacing.md) {
                ForEach(assets) { asset in
                    CoreAssetCard(asset: asset)
                }
            }
        }
    }
}

// MARK: - Asset Card
private struct CoreAssetCard: View {
    let asset: AssetCategory

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.lg) {
            // Icon
            ZStack {
                Circle()
                    .fill(Color(hex: asset.iconColor).opacity(0.15))
                    .frame(width: 44, height: 44)

                Image(systemName: asset.icon)
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(Color(hex: asset.iconColor))
            }

            // Content
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(asset.title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(asset.description)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
                    .lineSpacing(4)
                    .fixedSize(horizontal: false, vertical: true)
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
    }
}

// MARK: - Action Plan View
private struct CoreActionPlanView: View {
    let steps: [ActionStep]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            ForEach(steps) { step in
                CoreActionStepCard(step: step)
            }
        }
    }
}

// MARK: - Action Step Card
private struct CoreActionStepCard: View {
    let step: ActionStep

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Title with indicator
            HStack(alignment: .top, spacing: AppSpacing.md) {
                // Checkbox indicator
                ZStack {
                    Circle()
                        .strokeBorder(
                            step.isCompleted ? AppColors.bullish : AppColors.primaryBlue,
                            lineWidth: 2
                        )
                        .frame(width: 24, height: 24)

                    if step.isCompleted {
                        Image(systemName: "checkmark")
                            .font(.system(size: 12, weight: .bold))
                            .foregroundColor(AppColors.bullish)
                    }
                }

                Text(step.title)
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
                    .fixedSize(horizontal: false, vertical: true)
            }

            // Description
            Text(step.description)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(4)
                .padding(.leading, 24 + AppSpacing.md)
                .fixedSize(horizontal: false, vertical: true)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

// MARK: - Bullet Points View
private struct CoreBulletPointsView: View {
    let points: [BulletPoint]
    let title: String?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            if let title = title {
                Text(title)
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            VStack(alignment: .leading, spacing: AppSpacing.md) {
                ForEach(points) { point in
                    HStack(alignment: .top, spacing: AppSpacing.md) {
                        Circle()
                            .fill(point.isHighlighted ? AppColors.accentCyan : AppColors.textMuted)
                            .frame(width: 6, height: 6)
                            .padding(.top, 6)

                        Text(point.text)
                            .font(point.isHighlighted ? AppTypography.bodyBold : AppTypography.body)
                            .foregroundColor(point.isHighlighted ? AppColors.textPrimary : AppColors.textSecondary)
                            .lineSpacing(4)
                    }
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

// MARK: - Callout View
private struct CoreCalloutView: View {
    let callout: CalloutContent

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Image(systemName: callout.style.iconName)
                .font(.system(size: 18, weight: .semibold))
                .foregroundColor(callout.style.iconColor)

            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(callout.title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(callout.text)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
                    .lineSpacing(4)
            }
        }
        .padding(AppSpacing.lg)
        .background(callout.style.backgroundColor)
        .cornerRadius(AppCornerRadius.medium)
    }
}

// MARK: - Navigation Header
private struct CoreDetailNavigationHeader: View {
    let hasPrevious: Bool
    let hasNext: Bool
    let onBackTapped: () -> Void
    let onCloseTapped: () -> Void
    let onNextTapped: () -> Void

    var body: some View {
        HStack {
            // Back button (left)
            Button(action: onBackTapped) {
                HStack(spacing: AppSpacing.sm) {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 16, weight: .semibold))

                    Text(hasPrevious ? "Prev" : "Back")
                        .font(AppTypography.bodyBold)
                }
                .foregroundColor(AppColors.textPrimary)
                .frame(height: 44)
                .contentShape(Rectangle())
            }
            .buttonStyle(PlainButtonStyle())

            Spacer()
            
            // Close button (center)
            Button(action: onCloseTapped) {
                Image(systemName: "xmark")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(AppColors.textPrimary)
                    .frame(width: 44, height: 44)
                    .contentShape(Rectangle())
            }
            .buttonStyle(PlainButtonStyle())
            
            Spacer()
            
            // Next button (right)
            if hasNext {
                Button(action: onNextTapped) {
                    HStack(spacing: AppSpacing.sm) {
                        Text("Next")
                            .font(AppTypography.bodyBold)
                        
                        Image(systemName: "chevron.right")
                            .font(.system(size: 16, weight: .semibold))
                    }
                    .foregroundColor(AppColors.textPrimary)
                    .frame(height: 44)
                    .contentShape(Rectangle())
                }
                .buttonStyle(PlainButtonStyle())
            } else {
                // Invisible spacer to balance layout
                Color.clear
                    .frame(width: 80, height: 44)
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.sm)
        .background(
            AppColors.background
                .ignoresSafeArea(edges: .top)
        )
    }
}

// MARK: - Mini Header
private struct CoreDetailMiniHeader: View {
    let content: CoreChapterContent
    let hasPrevious: Bool
    let hasNext: Bool
    let onBackTapped: () -> Void
    let onCloseTapped: () -> Void
    let onNextTapped: () -> Void

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Back button
            Button(action: onBackTapped) {
                Image(systemName: "chevron.left")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(AppColors.textPrimary)
                    .frame(width: 44, height: 44)
                    .contentShape(Rectangle())
            }
            .buttonStyle(PlainButtonStyle())

            // Chapter info
            VStack(alignment: .leading, spacing: 2) {
                Text(content.formattedChapterLabel)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)

                Text(content.chapterTitle)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)
                    .lineLimit(1)
            }

            Spacer()
            
            // Close button
            Button(action: onCloseTapped) {
                Image(systemName: "xmark")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(AppColors.textPrimary)
                    .frame(width: 44, height: 44)
                    .contentShape(Rectangle())
            }
            .buttonStyle(PlainButtonStyle())
            
            // Next button
            if hasNext {
                Button(action: onNextTapped) {
                    HStack(spacing: AppSpacing.xs) {
                        Text("Next")
                            .font(AppTypography.bodyBold)
                        Image(systemName: "chevron.right")
                            .font(.system(size: 16, weight: .semibold))
                    }
                    .foregroundColor(AppColors.textPrimary)
                    .frame(height: 44)
                    .contentShape(Rectangle())
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
        .background(
            AppColors.background
                .shadow(color: Color.black.opacity(0.2), radius: 4, y: 2)
                .ignoresSafeArea(edges: .top)
        )
    }
}

// MARK: - Ask AI Bar
private struct CoreDetailAskAIBar: View {
    @Binding var inputText: String
    let onSend: () -> Void

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // AI icon
            Image(systemName: "sparkles")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(AppColors.accentCyan)

            // Text field
            TextField("Ask Caudex AI...", text: $inputText)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textPrimary)
                .submitLabel(.send)
                .onSubmit(onSend)

            Spacer()

            // Send button
            Button(action: onSend) {
                Image(systemName: "paperplane.fill")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(inputText.isEmpty ? AppColors.textMuted : AppColors.primaryBlue)
            }
            .buttonStyle(PlainButtonStyle())
            .disabled(inputText.isEmpty)
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.extraLarge)
        .padding(.horizontal, AppSpacing.lg)
        .padding(.bottom, AppSpacing.lg)
        .background(
            LinearGradient(
                colors: [
                    AppColors.background.opacity(0),
                    AppColors.background.opacity(0.95),
                    AppColors.background
                ],
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()
        )
    }
}

// MARK: - Completion Button
private struct CoreCompletionButton: View {
    let isCompleted: Bool
    let hasNextCore: Bool
    let onComplete: () -> Void

    var body: some View {
        Button(action: {
            if !isCompleted {
                onComplete()
            }
        }) {
            HStack(spacing: AppSpacing.md) {
                Text(isCompleted ? "Review Again" : "Complete & Continue")
                    .font(AppTypography.bodyBold)

                Image(systemName: isCompleted ? "arrow.counterclockwise" : "arrow.right")
                    .font(.system(size: 14, weight: .semibold))
            }
            .foregroundColor(isCompleted ? AppColors.textSecondary : .white)
            .frame(maxWidth: .infinity)
            .frame(height: 56)
            .background(
                Group {
                    if isCompleted {
                        RoundedRectangle(cornerRadius: AppCornerRadius.large)
                            .strokeBorder(AppColors.textMuted, lineWidth: 1.5)
                    } else {
                        RoundedRectangle(cornerRadius: AppCornerRadius.large)
                            .fill(AppColors.primaryBlue)
                    }
                }
            )
        }
        .buttonStyle(PlainButtonStyle())
        .animation(.easeInOut(duration: 0.25), value: isCompleted)
    }
}

// MARK: - Preview
#Preview {
    @Previewable @StateObject var audioManager = AudioManager.shared

    BookCoreDetailView(
        content: .sampleFinancialScorecard,
        book: LibraryBook.sampleData[0]
    )
    .environmentObject(audioManager)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/BookDetailView.swift
================================================================================

//
//  BookDetailView.swift
//  ios
//
//  Book Detail View - Detailed view for each book in the library
//  Displays book information, audio playback, and content tabs
//

import SwiftUI

// MARK: - Book Detail Tab
enum BookDetailTab: String, CaseIterable {
    case core = "Core"
    case about = "About"
}

// MARK: - Book Detail View
struct BookDetailView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var audioManager: AudioManager
    @State private var selectedTab: BookDetailTab = .core
    @State private var isBookmarked: Bool = false
    @State private var showShareSheet: Bool = false
    @State private var scrollOffset: CGFloat = 0

    let book: LibraryBook

    // Computed property for header opacity based on scroll
    private var headerOpacity: Double {
        let fadeStart: CGFloat = 280
        let fadeEnd: CGFloat = 360
        if scrollOffset < fadeStart { return 0 }
        if scrollOffset > fadeEnd { return 1 }
        return Double((scrollOffset - fadeStart) / (fadeEnd - fadeStart))
    }

    var body: some View {
        ZStack(alignment: .top) {
            // Background
            AppColors.background
                .ignoresSafeArea()
                .frame(maxWidth: .infinity, maxHeight: .infinity)

            // Main scrollable content
            ScrollView(showsIndicators: false) {
                VStack(spacing: 0) {
                    // Hero section with book cover and info
                    BookDetailHeroSection(
                        book: book,
                        onBackTapped: { dismiss() },
                        isBookmarked: isBookmarked,
                        onBookmarkTapped: { isBookmarked.toggle() },
                        onShareTapped: { showShareSheet = true }
                    )

                    // Tab selector and content
                    VStack(spacing: 0) {
                        // Tab selector
                        BookDetailTabSelector(selectedTab: $selectedTab)
                            .padding(.top, AppSpacing.lg)

                        // Tab content
                        switch selectedTab {
                        case .about:
                            BookDetailAboutContent(book: book)
                        case .core:
                            BookDetailCoreContent(book: book)
                        }
                    }

                    // Bottom padding for Ask AI bar
                    Color.clear.frame(height: 100)
                }
                .background(
                    GeometryReader { proxy in
                        Color.clear
                            .preference(
                                key: BookDetailScrollOffsetKey.self,
                                value: -proxy.frame(in: .named("bookDetailScroll")).origin.y
                            )
                    }
                )
            }
            .coordinateSpace(name: "bookDetailScroll")
            .onPreferenceChange(BookDetailScrollOffsetKey.self) { value in
                scrollOffset = value
            }

            // Sticky mini header (appears on scroll)
            if headerOpacity > 0 {
                BookDetailMiniHeader(
                    book: book,
                    isBookmarked: isBookmarked,
                    onBackTapped: { dismiss() },
                    onBookmarkTapped: { isBookmarked.toggle() },
                    onShareTapped: { showShareSheet = true }
                )
                .opacity(headerOpacity)
            }

            // Bottom Ask AI bar
            VStack {
                Spacer()

                // Global Mini Player (for fullScreenCover presentation)
                if audioManager.hasActiveEpisode {
                    GlobalMiniPlayer()
                        .transition(.move(edge: .bottom).combined(with: .opacity))
                }

                BookDetailAskAIBar()
            }
            .animation(.spring(response: 0.3, dampingFraction: 0.85), value: audioManager.hasActiveEpisode)
        }
        .navigationBarHidden(true)
        .sheet(isPresented: $showShareSheet) {
            if let url = URL(string: "https://app.example.com/book/\(book.id)") {
                ShareSheet(items: [book.title, "by \(book.author)", url])
            }
        }
        .onDisappear {
            // Reset scroll hiding when leaving to ensure main screen player shows
            audioManager.resetScrollHiding()
        }
    }
}

// MARK: - Scroll Offset Preference Key
private struct BookDetailScrollOffsetKey: PreferenceKey {
    static var defaultValue: CGFloat = 0

    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

// MARK: - Hero Section
private struct BookDetailHeroSection: View {
    @EnvironmentObject private var audioManager: AudioManager
    let book: LibraryBook
    let onBackTapped: () -> Void
    let isBookmarked: Bool
    let onBookmarkTapped: () -> Void
    let onShareTapped: () -> Void

    var body: some View {
        VStack(spacing: 0) {
            // Navigation header
            HStack {
                Button(action: onBackTapped) {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                        .frame(width: 44, height: 44)
                }

                Spacer()

                HStack(spacing: AppSpacing.md) {
                    Button(action: onBookmarkTapped) {
                        Image(systemName: isBookmarked ? "bookmark.fill" : "bookmark")
                            .font(.system(size: 18, weight: .medium))
                            .foregroundColor(isBookmarked ? AppColors.primaryBlue : AppColors.textPrimary)
                            .frame(width: 44, height: 44)
                    }

                    Button(action: onShareTapped) {
                        Image(systemName: "square.and.arrow.up")
                            .font(.system(size: 18, weight: .medium))
                            .foregroundColor(AppColors.textPrimary)
                            .frame(width: 44, height: 44)
                    }
                }
            }
            .padding(.horizontal, AppSpacing.md)
            .padding(.top, AppSpacing.sm)

            // Book cover
            BookDetailCoverImage(book: book)
                .padding(.top, AppSpacing.xl)
                .padding(.bottom, AppSpacing.xxl)

            // Title and author
            VStack(spacing: AppSpacing.sm) {
                Text(book.title)
                    .font(AppTypography.title)
                    .foregroundColor(AppColors.textPrimary)
                    .multilineTextAlignment(.center)
                    .lineLimit(2)

                Text(book.author)
                    .font(AppTypography.body)
                    .foregroundColor(AppColors.textSecondary)
            }
            .padding(.horizontal, AppSpacing.lg)

            // Category badges
            BookDetailBadgeRow(book: book)
                .padding(.top, AppSpacing.lg)

            // Listen Now row
            BookDetailListenRow(book: book)
                .padding(.top, AppSpacing.xl)
                .padding(.horizontal, AppSpacing.lg)
        }
    }
}

// MARK: - Book Cover Image
private struct BookDetailCoverImage: View {
    let book: LibraryBook

    var body: some View {
        ZStack {
            // Shadow layer
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(
                    LinearGradient(
                        colors: [
                            Color(hex: book.coverGradientStart),
                            Color(hex: book.coverGradientEnd)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 160, height: 220)
                .shadow(color: Color(hex: book.coverGradientStart).opacity(0.4), radius: 20, y: 10)

            // Book cover
            ZStack {
                RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                    .fill(
                        LinearGradient(
                            colors: [
                                Color(hex: book.coverGradientStart),
                                Color(hex: book.coverGradientEnd)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )

                // Book spine effect
                HStack(spacing: 0) {
                    Rectangle()
                        .fill(Color.black.opacity(0.15))
                        .frame(width: 4)
                    Spacer()
                }

                // Book title on cover
                VStack(spacing: AppSpacing.sm) {
                    Text(book.title.uppercased())
                        .font(.system(size: 14, weight: .bold))
                        .foregroundColor(.white)
                        .multilineTextAlignment(.center)
                        .lineLimit(4)
                        .padding(.horizontal, AppSpacing.lg)

                    Rectangle()
                        .fill(Color.white.opacity(0.3))
                        .frame(width: 40, height: 1)

                    Text(book.author.uppercased())
                        .font(.system(size: 8, weight: .medium))
                        .foregroundColor(.white.opacity(0.8))
                        .tracking(1)
                }
            }
            .frame(width: 160, height: 220)
        }
    }
}

// MARK: - Badge Row
private struct BookDetailBadgeRow: View {
    let book: LibraryBook

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Level badge
            BookDetailBadge(
                text: book.level.rawValue,
                color: book.level.color
            )

            // Separator
            Text("|")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            // Chapters badge
            BookDetailBadge(
                text: book.formattedChapters,
                color: AppColors.accentCyan
            )

            // Separator
            Text("|")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)

            // Primary category tag
            if let firstTag = book.categoryTags.first {
                BookDetailBadge(
                    text: firstTag.rawValue,
                    color: AppColors.accentCyan
                )
            }
        }
    }
}

// MARK: - Badge Component
private struct BookDetailBadge: View {
    let text: String
    let color: Color

    var body: some View {
        Text(text)
            .font(AppTypography.calloutBold)
            .foregroundColor(color)
    }
}

// MARK: - Listen Row
private struct BookDetailListenRow: View {
    @EnvironmentObject private var audioManager: AudioManager
    let book: LibraryBook

    // Check if this is the current book being played (any core)
    private var isCurrentBookPlaying: Bool {
        guard let currentEpisode = audioManager.currentEpisode else { return false }
        return currentEpisode.sourceId == book.id.uuidString && audioManager.isPlaying
    }

    // Check if the specific core we would resume is playing
    private var isResumeCorePlaying: Bool {
        guard let currentEpisode = audioManager.currentEpisode else { return false }
        return currentEpisode.id == resumeCoreAudioEpisode.id && audioManager.isPlaying
    }

    // User has progress if currentChapter > 1 (they've completed at least core 1)
    private var hasProgress: Bool {
        book.currentChapter > 1
    }

    // The core to resume from (currentChapter is the one they're working on)
    private var resumeCoreNumber: Int {
        book.currentChapter
    }

    // Get the audio episode for the resume core
    private var resumeCoreAudioEpisode: AudioEpisode {
        let coreChapter = book.coreChapters[safe: resumeCoreNumber - 1] ?? book.coreChapters[0]
        return AudioEpisode(
            id: "book-\(book.id.uuidString)-core-\(resumeCoreNumber)",
            title: coreChapter.title,
            subtitle: "\(book.title) - Core \(resumeCoreNumber)",
            artworkGradientColors: [book.coverGradientStart, book.coverGradientEnd],
            artworkIcon: "book.fill",
            duration: TimeInterval(book.audioDurationSeconds / book.coreChapters.count),
            category: .books,
            authorName: book.author,
            sourceId: book.id.uuidString
        )
    }

    // Button label based on state
    private var buttonLabel: String {
        if isResumeCorePlaying {
            return "Now Playing"
        } else if hasProgress {
            return "Continue Core \(resumeCoreNumber)"
        } else {
            return "Listen Now"
        }
    }

    var body: some View {
        HStack(spacing: 0) {
            // Play button
            Button(action: handlePlayTapped) {
                HStack(spacing: AppSpacing.md) {
                    ZStack {
                        Circle()
                            .fill(AppColors.textPrimary)
                            .frame(width: 48, height: 48)

                        Image(systemName: isResumeCorePlaying ? "pause.fill" : "play.fill")
                            .font(.system(size: 18, weight: .bold))
                            .foregroundColor(AppColors.background)
                            .offset(x: isResumeCorePlaying ? 0 : 2)
                    }

                    VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                        Text(buttonLabel)
                            .font(AppTypography.bodyBold)
                            .foregroundColor(AppColors.textPrimary)

                        Text(book.formattedAudioDuration)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)
                    }
                }
            }
            .buttonStyle(PlainButtonStyle())

            Spacer()

            // Stats
            VStack(alignment: .trailing, spacing: AppSpacing.xs) {
                HStack(spacing: AppSpacing.md) {
                    // Read time
                    HStack(spacing: AppSpacing.xs) {
                        Image(systemName: "clock")
                            .font(.system(size: 11, weight: .medium))
                            .foregroundColor(AppColors.textMuted)

                        Text(book.formattedReadTime)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)
                    }

                    // Views
                    HStack(spacing: AppSpacing.xs) {
                        Image(systemName: "eye")
                            .font(.system(size: 11, weight: .medium))
                            .foregroundColor(AppColors.textMuted)

                        Text(book.formattedViewCount)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)
                    }
                }

                // Date
                Text(book.formattedLastUpdated)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }

    private func handlePlayTapped() {
        if isResumeCorePlaying {
            audioManager.togglePlayPause()
        } else {
            // Play the resume core (or Core 1 for new users)
            audioManager.play(resumeCoreAudioEpisode)
        }
    }
}

// MARK: - Tab Selector
private struct BookDetailTabSelector: View {
    @Binding var selectedTab: BookDetailTab

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            ForEach(BookDetailTab.allCases, id: \.self) { tab in
                Button(action: {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedTab = tab
                    }
                }) {
                    Text(tab.rawValue)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(selectedTab == tab ? AppColors.textPrimary : AppColors.textMuted)
                        .padding(.horizontal, AppSpacing.lg)
                        .padding(.vertical, AppSpacing.sm)
                        .background(
                            selectedTab == tab
                                ? AppColors.cardBackgroundLight
                                : Color.clear
                        )
                        .cornerRadius(AppCornerRadius.pill)
                }
                .buttonStyle(PlainButtonStyle())
            }

            Spacer()
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

// MARK: - About Content
private struct BookDetailAboutContent: View {
    let book: LibraryBook

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xxl) {
            // Why this book section
            VStack(alignment: .leading, spacing: AppSpacing.md) {
                Text("Why this book?")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                Text(book.whyThisBook)
                    .font(AppTypography.body)
                    .foregroundColor(AppColors.textSecondary)
                    .lineSpacing(4)
            }

            // Author section
            VStack(alignment: .leading, spacing: AppSpacing.md) {
                Text("The Author")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                BookDetailAuthorCard(author: book.authorDetail)
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.xl)
    }
}

// MARK: - Author Card
private struct BookDetailAuthorCard: View {
    let author: BookAuthor

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Author header
            HStack(spacing: AppSpacing.md) {
                // Avatar
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: author.avatarGradientColors.map { Color(hex: $0) },
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 56, height: 56)

                    Text(author.name.prefix(1))
                        .font(.system(size: 22, weight: .bold))
                        .foregroundColor(.white)
                }

                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text(author.name)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text(author.title)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }
            }

            // Bio
            Text(author.bio)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(3)
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

// MARK: - Core Content
private struct BookDetailCoreContent: View {
    let book: LibraryBook
    @State private var selectedChapter: BookCoreChapter?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.xxl) {
            // Core Chapters Section (with progress tracking)
            CoreChaptersSection(
                chapters: book.coreChapters,
                currentChapter: book.currentChapter,
                onChapterTapped: { chapter in
                    selectedChapter = chapter
                }
            )

            // Discussion Section
            DiscussionSection(discussions: book.discussions)
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.xl)
        .fullScreenCover(item: $selectedChapter) { chapter in
            if let content = chapter.getDetailContent(for: book) {
                BookCoreDetailView(content: content, book: book)
                    .environmentObject(AudioManager.shared)
            }
        }
    }
}

// MARK: - Key Highlights Section
private struct KeyHighlightsSection: View {
    let highlights: [BookKeyHighlight]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            Text("Key Highlights")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            VStack(spacing: AppSpacing.md) {
                ForEach(highlights) { highlight in
                    KeyHighlightCard(highlight: highlight)
                }
            }
        }
    }
}

// MARK: - Key Highlight Card
private struct KeyHighlightCard: View {
    let highlight: BookKeyHighlight

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Icon
            ZStack {
                Circle()
                    .fill(Color(hex: highlight.iconColor).opacity(0.15))
                    .frame(width: 40, height: 40)

                Image(systemName: highlight.iconName)
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(Color(hex: highlight.iconColor))
            }

            // Content
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(highlight.title)
                    .font(AppTypography.bodyBold)
                    .foregroundColor(AppColors.textPrimary)

                Text(highlight.description)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .lineSpacing(2)
            }

            Spacer(minLength: 0)
        }
        .padding(AppSpacing.md)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.medium)
    }
}

// MARK: - Core Chapters Section (Timeline Style)
private struct CoreChaptersSection: View {
    let chapters: [BookCoreChapter]
    let currentChapter: Int
    var onChapterTapped: ((BookCoreChapter) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Timeline layout
            VStack(spacing: 0) {
                ForEach(Array(chapters.enumerated()), id: \.element.id) { index, chapter in
                    CoreChapterTimelineRow(
                        chapter: chapter,
                        isLast: index == chapters.count - 1,
                        isCompleted: chapter.number <= currentChapter,
                        onTapped: {
                            onChapterTapped?(chapter)
                        }
                    )
                }
            }
        }
    }
}

// MARK: - Core Chapter Timeline Row
private struct CoreChapterTimelineRow: View {
    let chapter: BookCoreChapter
    let isLast: Bool
    let isCompleted: Bool
    var onTapped: (() -> Void)?

    private let completedColor = Color(hex: "14B8A6") // Teal color for completed
    private let uncompletedColor = Color(hex: "2DD4BF").opacity(0.5) // Muted color for outline
    private let lineColor = Color(hex: "2DD4BF").opacity(0.5) // Subtle dark line
    private let badgeSize: CGFloat = 32

    var body: some View {
        Button(action: { onTapped?() }) {
            HStack(alignment: .top, spacing: AppSpacing.lg) {
                // Timeline column with badge and connecting line
                ZStack(alignment: .top) {
                    // Connecting line (starts from bottom edge of badge)
                    if !isLast {
                        VStack(spacing: 0) {
                            // Spacer for badge height
                            Color.clear
                                .frame(width: 2, height: 32)

                            // Actual line
                            Rectangle()
                                .fill(lineColor)
                                .frame(width: 1)
                        }
                    }

                    // Number badge - filled or outline based on completion
                    HStack {
                        Spacer(minLength: 0)

                        ZStack {
                            if isCompleted {
                                // Filled badge for completed/current chapters
                                Circle()
                                    .fill(completedColor)
                                    .frame(width: 32, height: 32)
                            } else {
                                // Outline-only badge for unread chapters
                                Circle()
                                    .strokeBorder(uncompletedColor, lineWidth: 1)
                                    .frame(width: 32, height: 32)
                            }

                            Text("\(chapter.number)")
                                .font(.system(size: 13, weight: .bold))
                                .foregroundColor(isCompleted ? .white : uncompletedColor)
                        }
                        .frame(width: 32, height: 32)

                        Spacer(minLength: 0)
                    }
                    .frame(width: 32)
                }
                .frame(width: 32)

                // Content column
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    HStack {
                        Text(chapter.title)
                            .font(AppTypography.bodyBold)
                            .foregroundColor(AppColors.textPrimary)

                        Spacer()

                        // Chevron indicator
                        Image(systemName: "chevron.right")
                            .font(.system(size: 12, weight: .semibold))
                            .foregroundColor(AppColors.textMuted)
                    }

                    Text(chapter.description)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)
                        .lineSpacing(4)
                        .fixedSize(horizontal: false, vertical: true)
                        .multilineTextAlignment(.leading)
                }
                .padding(.bottom, isLast ? 0 : AppSpacing.xxl)
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
}

// MARK: - Discussion Section
private struct DiscussionSection: View {
    let discussions: [BookDiscussion]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            HStack {
                Text("Discussion")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button(action: {}) {
                    Text("See All")
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.accentCyan)
                }
                .buttonStyle(PlainButtonStyle())
            }

            // Discussion cards
            VStack(spacing: AppSpacing.md) {
                ForEach(discussions) { discussion in
                    DiscussionCard(discussion: discussion)
                }
            }
        }
    }
}

// MARK: - Discussion Card
private struct DiscussionCard: View {
    let discussion: BookDiscussion

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header with avatar, name, date, and rating
            HStack(spacing: AppSpacing.md) {
                // Avatar
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: discussion.authorAvatarGradient.map { Color(hex: $0) },
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 36, height: 36)

                    Text(discussion.authorName.prefix(1))
                        .font(.system(size: 14, weight: .bold))
                        .foregroundColor(.white)
                }

                // Name and date
                VStack(alignment: .leading, spacing: 2) {
                    Text(discussion.authorName)
                        .font(AppTypography.calloutBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text(discussion.formattedDate)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }

                Spacer()

                // Star rating
                HStack(spacing: 2) {
                    ForEach(1...5, id: \.self) { star in
                        Image(systemName: star <= discussion.rating ? "star.fill" : "star")
                            .font(.system(size: 10))
                            .foregroundColor(star <= discussion.rating ? Color(hex: "F59E0B") : AppColors.textMuted)
                    }
                }
            }

            // Content
            Text(discussion.content)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(3)
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

// MARK: - Mini Header
private struct BookDetailMiniHeader: View {
    let book: LibraryBook
    let isBookmarked: Bool
    let onBackTapped: () -> Void
    let onBookmarkTapped: () -> Void
    let onShareTapped: () -> Void

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Back button
            Button(action: onBackTapped) {
                Image(systemName: "chevron.left")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(AppColors.textPrimary)
            }
            .buttonStyle(PlainButtonStyle())

            // Title
            Text(book.title)
                .font(AppTypography.bodyBold)
                .foregroundColor(AppColors.textPrimary)
                .lineLimit(1)

            Spacer()

            // Actions
            HStack(spacing: AppSpacing.lg) {
                Button(action: onBookmarkTapped) {
                    Image(systemName: isBookmarked ? "bookmark.fill" : "bookmark")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(isBookmarked ? AppColors.primaryBlue : AppColors.textSecondary)
                }
                .buttonStyle(PlainButtonStyle())

                Button(action: onShareTapped) {
                    Image(systemName: "square.and.arrow.up")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
        .background(
            AppColors.background
                .shadow(color: Color.black.opacity(0.2), radius: 4, y: 2)
        )
    }
}

// MARK: - Ask AI Bar
private struct BookDetailAskAIBar: View {
    @State private var inputText: String = ""

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // AI icon
            Image(systemName: "sparkles")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(AppColors.accentCyan)

            // Text field
            TextField("Ask Caudex AI...", text: $inputText)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textPrimary)

            Spacer()

            // Send button
            Button(action: handleSend) {
                Image(systemName: "paperplane.fill")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(inputText.isEmpty ? AppColors.textMuted : AppColors.primaryBlue)
            }
            .buttonStyle(PlainButtonStyle())
            .disabled(inputText.isEmpty)
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.extraLarge)
        .padding(.horizontal, AppSpacing.lg)
        .padding(.bottom, AppSpacing.lg)
        .background(
            LinearGradient(
                colors: [
                    AppColors.background.opacity(0),
                    AppColors.background.opacity(0.9),
                    AppColors.background
                ],
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()
        )
    }

    private func handleSend() {
        guard !inputText.isEmpty else { return }
        print("Ask AI: \(inputText)")
        inputText = ""
    }
}

// MARK: - Safe Array Subscript
private extension Array {
    subscript(safe index: Int) -> Element? {
        indices.contains(index) ? self[index] : nil
    }
}

// MARK: - Preview
#Preview {
    @Previewable @StateObject var audioManager = AudioManager.shared

    BookDetailView(book: LibraryBook.sampleData[0])
        .environmentObject(audioManager)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/BookLibraryView.swift
================================================================================

//
//  BookLibraryView.swift
//  ios
//
//  Book Library View - Gamified Curriculum with progress tracking
//

import SwiftUI

struct BookLibraryView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var audioManager: AudioManager
    @State private var searchText = ""
    @State private var books: [LibraryBook] = []
    @State private var selectedBook: LibraryBook?

    private var filteredBooks: [LibraryBook] {
        if searchText.isEmpty {
            return books.sorted { $0.curriculumOrder < $1.curriculumOrder }
        }
        return books.filter { book in
            book.title.localizedCaseInsensitiveContains(searchText) ||
            book.author.localizedCaseInsensitiveContains(searchText)
        }.sorted { $0.curriculumOrder < $1.curriculumOrder }
    }

    private var masteredCount: Int {
        books.filter { $0.isMastered }.count
    }

    private var totalCount: Int {
        books.count
    }

    private var progressPercentage: Double {
        guard totalCount > 0 else { return 0 }
        return Double(masteredCount) / Double(totalCount)
    }

    var body: some View {
        ZStack {
            // Background
            AppColors.background
                .ignoresSafeArea()

            // Main content
            VStack(spacing: 0) {
                // Header with back button and title
                BookLibraryHeader(onBackTapped: {
                    dismiss()
                })

                // Sticky search bar
                BookLibrarySearchBar(searchText: $searchText)
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.bottom, AppSpacing.md)

                // Scrollable content
                ScrollView(showsIndicators: false) {
                    LazyVStack(spacing: AppSpacing.lg) {
                        // Hero Progress Card
                        ProgressDashboardCard(
                            masteredCount: masteredCount,
                            totalCount: totalCount,
                            progressPercentage: progressPercentage
                        )
                        .padding(.horizontal, AppSpacing.lg)
                        .padding(.top, AppSpacing.sm)

                        // Curriculum Label
                        HStack {
                            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                                Text("Your Curriculum")
                                    .font(AppTypography.title3)
                                    .foregroundColor(AppColors.textPrimary)

                                Text("Complete in order for maximum learning")
                                    .font(AppTypography.caption)
                                    .foregroundColor(AppColors.textSecondary)
                            }
                            Spacer()
                        }
                        .padding(.horizontal, AppSpacing.lg)
                        .padding(.top, AppSpacing.md)

                        // Book List
                        ForEach(filteredBooks) { book in
                            LibraryBookCard(
                                book: book,
                                onChatWithBook: { handleChatWithBook(book) },
                                onReadKeyIdeas: { handleReadKeyIdeas(book) },
                                onReview: { handleReview(book) }
                            )
                            .padding(.horizontal, AppSpacing.lg)
                            .onTapGesture {
                                selectedBook = book
                            }
                        }

                        // Bottom padding for safe area
                        Color.clear.frame(height: AppSpacing.xxxl)
                    }
                }
            }
        }
        .navigationBarHidden(true)
        .onAppear {
            loadBooks()
        }
        .fullScreenCover(item: $selectedBook) { book in
            BookDetailView(book: book)
                .environmentObject(audioManager)
        }
    }

    private func loadBooks() {
        books = LibraryBook.sampleData
    }

    private func handleChatWithBook(_ book: LibraryBook) {
        print("Chat with book: \(book.title)")
    }

    private func handleReadKeyIdeas(_ book: LibraryBook) {
        print("Read key ideas: \(book.title)")
    }

    private func handleReview(_ book: LibraryBook) {
        print("Review book: \(book.title)")
    }
}

// MARK: - Header
private struct BookLibraryHeader: View {
    var onBackTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Navigation bar
            HStack {
                Button(action: {
                    onBackTapped?()
                }) {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                }

                Spacer()
            }

            // Title section
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text("Book Library")
                    .font(AppTypography.largeTitle)
                    .foregroundColor(AppColors.textPrimary)

                Text("10 essential books to master value investing")
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.sm)
        .padding(.bottom, AppSpacing.lg)
    }
}

// MARK: - Search Bar
private struct BookLibrarySearchBar: View {
    @Binding var searchText: String

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            Image(systemName: "magnifyingglass")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(AppColors.textMuted)

            TextField("Search by title or author...", text: $searchText)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textPrimary)
                .autocapitalization(.none)
                .disableAutocorrection(true)

            if !searchText.isEmpty {
                Button(action: {
                    searchText = ""
                }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.system(size: 16))
                        .foregroundColor(AppColors.textMuted)
                }
            }
        }
        .padding(.horizontal, AppSpacing.md)
        .padding(.vertical, AppSpacing.md)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

// MARK: - Progress Dashboard Hero Card
private struct ProgressDashboardCard: View {
    let masteredCount: Int
    let totalCount: Int
    let progressPercentage: Double

    var body: some View {
        ZStack(alignment: .topTrailing) {
            // Background with gradient
            ZStack {
                // Base gradient (#11998E â†’ #38EF7D)
                LinearGradient(
                    colors: [
                        Color(hex: "11998E"),
                        Color(hex: "38EF7D")
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )

                // Grainy texture overlay
                ProgressCardGrainyOverlay()

                // Subtle dark overlay for depth
                LinearGradient(
                    colors: [
                        Color.black.opacity(0.05),
                        Color.black.opacity(0.2)
                    ],
                    startPoint: .top,
                    endPoint: .bottom
                )
            }

            // Content
            HStack(alignment: .center, spacing: AppSpacing.xl) {
                // Left: Text content
                VStack(alignment: .leading, spacing: AppSpacing.md) {
                    // Label
                    Text("YOUR PROGRESS")
                        .font(AppTypography.captionBold)
                        .foregroundColor(.white.opacity(0.8))
                        .tracking(1.2)

                    // Main stat
                    VStack(alignment: .leading, spacing: AppSpacing.xs) {
                        Text("\(masteredCount) of \(totalCount)")
                            .font(.system(size: 32, weight: .bold))
                            .foregroundColor(.white)

                        Text("Books Mastered")
                            .font(AppTypography.headline)
                            .foregroundColor(.white.opacity(0.9))
                    }

                    // Motivational message
                    Text(motivationalMessage)
                        .font(AppTypography.callout)
                        .foregroundColor(.white.opacity(0.85))
                        .lineLimit(2)
                }

                Spacer()

                // Right: Progress ring
                ProgressRingView(progress: progressPercentage)
                    .frame(width: 90, height: 90)
            }
            .padding(.horizontal, AppSpacing.xl)
            .padding(.vertical, AppSpacing.xl)

            // Trophy badge
            if masteredCount > 0 {
                ProgressBadgePill(count: masteredCount)
                    .padding(AppSpacing.lg)
            }
        }
        .aspectRatio(16/9, contentMode: .fit)
        .clipShape(RoundedRectangle(cornerRadius: AppCornerRadius.extraLarge))
    }

    private var motivationalMessage: String {
        switch masteredCount {
        case 0:
            return "Start your journey to financial wisdom"
        case 1...2:
            return "Great start! Keep the momentum going"
        case 3...5:
            return "You're building a solid foundation"
        case 6...8:
            return "Almost there! You're becoming an expert"
        case 9:
            return "One more book to complete mastery!"
        case 10:
            return "Congratulations! You've mastered all books"
        default:
            return "Keep learning and growing"
        }
    }
}

// MARK: - Progress Ring View
private struct ProgressRingView: View {
    let progress: Double

    var body: some View {
        ZStack {
            // Background ring
            Circle()
                .stroke(
                    Color.white.opacity(0.3),
                    lineWidth: 8
                )

            // Progress ring
            Circle()
                .trim(from: 0, to: progress)
                .stroke(
                    Color.white,
                    style: StrokeStyle(
                        lineWidth: 8,
                        lineCap: .round
                    )
                )
                .rotationEffect(.degrees(-90))
                .animation(.easeInOut(duration: 0.5), value: progress)

            // Percentage text
            VStack(spacing: 0) {
                Text("\(Int(progress * 100))%")
                    .font(.system(size: 22, weight: .bold))
                    .foregroundColor(.white)

                Text("Complete")
                    .font(.system(size: 9, weight: .medium))
                    .foregroundColor(.white.opacity(0.8))
            }
        }
    }
}

// MARK: - Progress Badge Pill
private struct ProgressBadgePill: View {
    let count: Int

    var body: some View {
        HStack(spacing: AppSpacing.xs) {
            Image(systemName: "trophy.fill")
                .font(.system(size: 10, weight: .semibold))

            Text("\(count) MASTERED")
                .font(AppTypography.captionBold)
        }
        .foregroundColor(.white)
        .padding(.horizontal, AppSpacing.md)
        .padding(.vertical, AppSpacing.xs)
        .background(
            Capsule()
                .fill(Color.black.opacity(0.3))
                .overlay(
                    Capsule()
                        .strokeBorder(Color.white.opacity(0.3), lineWidth: 1)
                )
        )
    }
}

// MARK: - Grainy Texture Overlay for Progress Card
private struct ProgressCardGrainyOverlay: View {
    var body: some View {
        Canvas { context, size in
            for _ in 0..<Int(size.width * size.height / 50) {
                let x = CGFloat.random(in: 0..<size.width)
                let y = CGFloat.random(in: 0..<size.height)
                let opacity = Double.random(in: 0.02...0.08)

                context.fill(
                    Path(ellipseIn: CGRect(x: x, y: y, width: 1, height: 1)),
                    with: .color(.white.opacity(opacity))
                )
            }
        }
    }
}

#Preview {
    BookLibraryView()
        .environmentObject(AudioManager.shared)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/ChatConversationView.swift
================================================================================

//
//  ChatConversationView.swift
//  ios
//
//  Chat conversation view with messages and input
//

import SwiftUI

struct ChatConversationView: View {
    @State private var messages: [RichChatMessage]
    @State private var inputText: String = ""
    @State private var isLoading: Bool = false

    init(messages: [RichChatMessage] = RichChatMessage.sampleConversation) {
        _messages = State(initialValue: messages)
    }

    var body: some View {
        VStack(spacing: 0) {
            // Messages list
            ChatMessagesList(messages: messages)

            // Page indicator (for multi-page responses)
            PageIndicatorDots(currentPage: 0, totalPages: 3)
                .padding(.vertical, AppSpacing.sm)

            // Input section
            ChatInputSection(
                inputText: $inputText,
                onAttachmentTap: handleAttachmentTap,
                onSend: handleSend,
                onVoiceTap: handleVoiceTap,
                onImageTap: handleImageTap
            )
        }
    }

    // MARK: - Action Handlers
    private func handleAttachmentTap() {
        print("Attachment tapped")
    }

    private func handleSend() {
        guard !inputText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }

        // Add user message
        let userMessage = RichChatMessage(
            role: .user,
            content: [.text(inputText)],
            timestamp: Date()
        )
        messages.append(userMessage)

        let query = inputText
        inputText = ""
        isLoading = true

        // Simulate AI response (in real app, this would call your backend)
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
            let aiResponse = generateMockResponse(for: query)
            messages.append(aiResponse)
            isLoading = false
        }
    }

    private func handleVoiceTap() {
        print("Voice input tapped")
    }

    private func handleImageTap() {
        print("Image input tapped")
    }

    // MARK: - Mock Response Generator
    private func generateMockResponse(for query: String) -> RichChatMessage {
        let lowercased = query.lowercased()

        if lowercased.contains("sentiment") || lowercased.contains("feeling") {
            return RichChatMessage(
                role: .assistant,
                content: [
                    .text("Based on the latest market data and social sentiment analysis, here's what I found:"),
                    .sentimentAnalysis(SentimentAnalysis(
                        overallSentiment: .bullish,
                        percentage: 68,
                        bulletPoints: [
                            ChatBulletPoint(text: "Strong delivery numbers exceeded expectations", indicatorType: .success),
                            ChatBulletPoint(text: "Production ramping up successfully", indicatorType: .success),
                            ChatBulletPoint(text: "Competition intensifying in the market", indicatorType: .warning),
                            ChatBulletPoint(text: "Analyst price targets vary widely", indicatorType: .info)
                        ],
                        dataUpdatedText: "Data updated just now"
                    ))
                ],
                timestamp: Date()
            )
        } else if lowercased.contains("price") || lowercased.contains("performance") || lowercased.contains("stock") {
            return RichChatMessage(
                role: .assistant,
                content: [
                    .text("Here's the stock performance over the past month:"),
                    .stockPerformance(StockPerformance(
                        currentPrice: 242.84,
                        changePercent: 8.7,
                        period: "1 Month",
                        dayHigh: 245.12,
                        dayLow: 238.45,
                        volume: "124.5M",
                        avgVolume: "98.2M",
                        chartData: [220, 225, 218, 230, 235, 228, 240, 238, 245, 242],
                        followUpQuestion: "Would you like me to analyze any specific timeframe or technical indicators?"
                    ))
                ],
                timestamp: Date()
            )
        } else if lowercased.contains("risk") {
            return RichChatMessage(
                role: .assistant,
                content: [
                    .text("Here are the major risk factors to monitor:"),
                    .riskFactors(RiskFactorsData(
                        introText: "",
                        factors: [
                            RiskFactor(
                                iconName: "exclamationmark.triangle.fill",
                                iconColor: AppColors.bearish,
                                title: "Market Competition",
                                description: "Intensifying competition from established players and new entrants",
                                impactLevel: .high
                            ),
                            RiskFactor(
                                iconName: "doc.text.fill",
                                iconColor: AppColors.neutral,
                                title: "Regulatory Changes",
                                description: "Potential changes in subsidies and regulations",
                                impactLevel: .medium
                            )
                        ]
                    )),
                    .tip(TipData(
                        title: "RISK MITIGATION TIP",
                        content: "Consider diversifying your portfolio to manage risk exposure."
                    ))
                ],
                timestamp: Date()
            )
        } else {
            return RichChatMessage(
                role: .assistant,
                content: [
                    .text("I understand you're asking about \"\(query)\". Let me help you with that.\n\nBased on my analysis, here are some key points to consider:\n\nâ€¢ Market conditions remain favorable\nâ€¢ Technical indicators suggest stability\nâ€¢ Fundamental analysis shows strong fundamentals\n\nWould you like me to dive deeper into any specific aspect?")
                ],
                timestamp: Date()
            )
        }
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ChatConversationView()
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/ChatHistoryView.swift
================================================================================

//
//  ChatHistoryView.swift
//  ios
//
//  Chat history view showing all past conversations
//

import SwiftUI

struct ChatHistoryView: View {
    @State private var historyGroups: [ChatHistoryGroup] = ChatHistoryItem.sampleGroups
    var onItemTap: ((ChatHistoryItem) -> Void)?
    var onDismiss: (() -> Void)?

    var body: some View {
        VStack(spacing: 0) {
            // History list
            ChatHistoryList(
                groups: historyGroups,
                onItemTap: handleItemTap,
                onItemMoreOptions: handleItemMoreOptions,
                onSectionTap: handleSectionTap
            )
        }
    }

    // MARK: - Action Handlers
    private func handleItemTap(_ item: ChatHistoryItem) {
        print("Open chat history: \(item.title)")
        onItemTap?(item)
    }

    private func handleItemMoreOptions(_ item: ChatHistoryItem) {
        print("More options for: \(item.title)")
    }

    private func handleSectionTap(_ section: ChatHistorySection) {
        print("Section tapped: \(section.rawValue)")
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ChatHistoryView()
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/ChatTabView.swift
================================================================================

//
//  ChatTabView.swift
//  ios
//
//  Chat tab content view within the Learn/Wiser section
//

import SwiftUI

struct ChatTabView: View {
    @EnvironmentObject private var audioManager: AudioManager
    @State private var inputText: String = ""
    @State private var suggestions: [SuggestionChip] = SuggestionChip.sampleData
    @State private var conversationMessages: [RichChatMessage] = []
    @State private var showingHistory: Bool = false
    @State private var isInConversation: Bool = false
    @State private var dragOffset: CGFloat = 0

    var onHistoryTap: (() -> Void)?

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Chat content (slides right when history is shown)
                chatContent
                    .offset(x: showingHistory ? geometry.size.width * 0.85 : 0)

                // History panel (slides in from left)
                if showingHistory {
                    historyPanel(width: geometry.size.width)
                        .offset(x: dragOffset)
                        .transition(.move(edge: .leading))
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                                    // Only allow dragging left (negative)
                                    if value.translation.width < 0 {
                                        dragOffset = value.translation.width
                                    }
                                }
                                .onEnded { value in
                                    // If dragged more than 100 points left, close the panel
                                    if value.translation.width < -100 {
                                        withAnimation(.easeInOut(duration: 0.15)) {
                                            showingHistory = false
                                            dragOffset = 0
                                        }
                                    } else {
                                        // Snap back
                                        withAnimation(.easeInOut(duration: 0.15)) {
                                            dragOffset = 0
                                        }
                                    }
                                }
                        )
                }
            }
            .animation(.easeInOut(duration: 0.15), value: showingHistory)
        }
        .onAppear {
            // Move audio player to Dynamic Island when entering chat
            audioManager.enterCompactMode()
        }
        .onDisappear {
            // Move audio player back to bottom when leaving chat
            audioManager.exitCompactMode()
        }
    }

    // MARK: - Chat Content
    private var chatContent: some View {
        VStack(spacing: 0) {
            // History button header
            ChatHistoryHeader(
                showingHistory: showingHistory,
                onHistoryTap: {
                    handleHistoryTap()
                },
                onChevronTap: {
                    handleHistoryTap()
                }
            )

            // Main content area (empty state for now)
            Spacer()

            // Suggestions section
            ChatSuggestionsSection(suggestions: suggestions) { chip in
                handleSuggestionTap(chip)
            }
            .padding(.bottom, AppSpacing.lg)

            // Input section
            ChatInputSection(
                inputText: $inputText,
                onAttachmentTap: handleAttachmentTap,
                onSend: handleSend,
                onVoiceTap: handleVoiceTap,
                onImageTap: handleImageTap,
                onFocusChange: handleInputFocusChange
            )
        }
    }

    // MARK: - History Panel
    private func historyPanel(width: CGFloat) -> some View {
        HStack(spacing: 0) {
            // History content
            VStack(spacing: 0) {
                // Header with chevron to close
                HStack {
                    Text("History")
                        .font(AppTypography.headline)
                        .foregroundColor(AppColors.textPrimary)

                    Spacer()

                    Button {
                        handleHistoryTap()
                    } label: {
                        Image(systemName: "chevron.right")
                            .font(.system(size: 16, weight: .semibold))
                            .foregroundColor(AppColors.textSecondary)
                    }
                    .buttonStyle(.plain)
                }
                .padding(.horizontal, AppSpacing.lg)
                .padding(.vertical, AppSpacing.md)

                // History list
                ChatHistoryView(
                    onItemTap: { item in
                        showingHistory = false
                        print("Selected conversation: \(item.title)")
                    },
                    onDismiss: {
                        showingHistory = false
                    }
                )
            }
            .frame(width: width * 0.85)
            .background(AppColors.background)

            Spacer()
        }
    }

    // MARK: - Action Handlers
    private func handleHistoryTap() {
        withAnimation(.easeInOut(duration: 0.15)) {
            showingHistory.toggle()
        }
        onHistoryTap?()
    }

    private func handleSuggestionTap(_ chip: SuggestionChip) {
        inputText = chip.text
        // Auto-send the suggestion
        handleSend()
    }

    private func handleAttachmentTap() {
        print("Attachment tapped")
    }

    private func handleSend() {
        guard !inputText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }

        // Create user message
        let userMessage = RichChatMessage(
            role: .user,
            content: [.text(inputText)],
            timestamp: Date()
        )

        // Start conversation with user message
        conversationMessages = [userMessage]
        let query = inputText
        inputText = ""

        // Enter conversation mode
        withAnimation(.easeInOut(duration: 0.2)) {
            isInConversation = true
        }

        // Simulate AI response
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            let aiResponse = generateMockResponse(for: query)
            conversationMessages.append(aiResponse)
        }
    }

    private func handleVoiceTap() {
        print("Voice input tapped")
    }

    private func handleImageTap() {
        print("Image input tapped")
    }

    private func handleInputFocusChange(_ isFocused: Bool) {
        // Enter/exit compact mode for audio player when chat keyboard is active
        if isFocused {
            audioManager.enterCompactMode()
        } else {
            audioManager.exitCompactMode()
        }
    }

    // MARK: - Helper Methods
    private func generateMockResponse(for query: String) -> RichChatMessage {
        let responseText = "This is a mock response to: \"\(query)\". In a real implementation, this would connect to your AI service."
        return RichChatMessage(
            role: .assistant,
            content: [.text(responseText)],
            timestamp: Date()
        )
    }
}

#Preview {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ChatTabView()
    }
    .environmentObject(AudioManager.shared)
    .preferredColorScheme(.dark)
}

#Preview("Chat View") {
    ZStack {
        AppColors.background
            .ignoresSafeArea()

        ChatTabView()
            .onAppear {
                // This preview shows history by default
            }
    }
    .environmentObject(AudioManager.shared)
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/FullScreenAudioPlayer.swift
================================================================================

//
//  FullScreenAudioPlayer.swift
//  ios
//
//  Full screen audio player with complete playback controls
//  Expanded from mini player, dismissible via swipe down gesture
//

import SwiftUI

struct FullScreenAudioPlayer: View {
    @EnvironmentObject private var audioManager: AudioManager
    @State private var dragOffset: CGFloat = 0
    @State private var showSpeedPicker: Bool = false
    @State private var showSleepTimer: Bool = false
    @State private var showQueue: Bool = false

    private let dismissThreshold: CGFloat = 150

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Background gradient
                backgroundGradient
                    .ignoresSafeArea()

                // Main content
                VStack(spacing: 0) {
                    // Drag indicator and header
                    headerSection

                    Spacer()

                    // Artwork
                    artworkSection

                    Spacer()

                    // Title and info
                    titleSection

                    // Progress bar
                    progressSection
                        .padding(.top, AppSpacing.xxl)

                    // Main controls
                    controlsSection
                        .padding(.top, AppSpacing.xl)

                    // Secondary controls
                    secondaryControlsSection
                        .padding(.top, AppSpacing.xxl)

                    Spacer()
                        .frame(height: geometry.safeAreaInsets.bottom + AppSpacing.xl)
                }
                .padding(.leading, AppSpacing.sm)
                .padding(.trailing, AppSpacing.xxxl)
            }
            .offset(y: dragOffset)
            .gesture(
                DragGesture()
                    .onChanged { value in
                        // Only allow downward drag
                        if value.translation.height > 0 {
                            dragOffset = value.translation.height
                        }
                    }
                    .onEnded { value in
                        if value.translation.height > dismissThreshold ||
                            value.predictedEndTranslation.height > dismissThreshold * 2 {
                            audioManager.collapsePlayer()
                        }
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            dragOffset = 0
                        }
                    }
            )
        }
        .sheet(isPresented: $showSpeedPicker) {
            PlaybackSpeedSheet()
                .environmentObject(audioManager)
                .presentationDetents([.height(320)])
        }
        .sheet(isPresented: $showSleepTimer) {
            SleepTimerSheet()
                .environmentObject(audioManager)
                .presentationDetents([.height(400)])
        }
        .sheet(isPresented: $showQueue) {
            AudioQueueSheet()
                .environmentObject(audioManager)
                .presentationDetents([.medium, .large])
        }
    }

    // MARK: - Background Gradient
    private var backgroundGradient: some View {
        ZStack {
            // Base dark background
            AppColors.background

            // Dynamic gradient from artwork colors
            if let episode = audioManager.currentEpisode {
                LinearGradient(
                    colors: [
                        episode.artworkColors.first?.opacity(0.6) ?? .clear,
                        episode.artworkColors.first?.opacity(0.3) ?? .clear,
                        AppColors.background
                    ],
                    startPoint: .top,
                    endPoint: .bottom
                )
            }
        }
    }

    // MARK: - Header Section
    private var headerSection: some View {
        VStack(spacing: AppSpacing.lg) {
            // Drag indicator
            Capsule()
                .fill(Color.white.opacity(0.3))
                .frame(width: 36, height: 5)
                .padding(.top, AppSpacing.md)

            // Header row
            HStack {
                // Collapse button
                Button(action: {
                    audioManager.collapsePlayer()
                }) {
                    Image(systemName: "chevron.down")
                        .font(.system(size: 20, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                        .frame(width: 44, height: 44)
                }

                Spacer()

                // Category label
                if let episode = audioManager.currentEpisode {
                    HStack(spacing: AppSpacing.xs) {
                        Image(systemName: episode.category.icon)
                            .font(.system(size: 12, weight: .medium))
                        Text(episode.category.rawValue.uppercased())
                            .font(AppTypography.captionBold)
                            .tracking(0.8)
                    }
                    .foregroundColor(episode.category.accentColor)
                    .frame(maxWidth: .infinity)
                }

                Spacer()

                // More options
                Button(action: {
                    // Show more options menu
                }) {
                    Image(systemName: "ellipsis")
                        .font(.system(size: 20, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                        .frame(width: 44, height: 44)
                }
                .offset(x: -7)
            }
        }
    }

    // MARK: - Artwork Section
    private var artworkSection: some View {
        Group {
            if let episode = audioManager.currentEpisode {
                AudioArtworkLarge(episode: episode, size: 280)
                    .scaleEffect(audioManager.isPlaying ? 1.0 : 0.95)
                    .animation(.spring(response: 0.4), value: audioManager.isPlaying)
            }
        }
    }

    // MARK: - Title Section
    private var titleSection: some View {
        VStack(spacing: AppSpacing.sm) {
            if let episode = audioManager.currentEpisode {
                Text(episode.title)
                    .font(AppTypography.title2)
                    .foregroundColor(AppColors.textPrimary)
                    .multilineTextAlignment(.center)
                    .lineLimit(2)

                Text(episode.authorName)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
        .padding(.horizontal, AppSpacing.lg)
    }

    // MARK: - Progress Section
    private var progressSection: some View {
        VStack(spacing: AppSpacing.sm) {
            // Progress slider
            AudioProgressSlider(
                progress: audioManager.progress,
                onSeek: { progress in
                    audioManager.seekToProgress(progress)
                }
            )
            .padding(.horizontal, AppSpacing.xl)

            // Time labels
            HStack {
                Text(audioManager.formattedCurrentTime)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .monospacedDigit()

                Spacer()

                Text(audioManager.formattedRemainingTime)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
                    .monospacedDigit()
            }
            .padding(.horizontal, AppSpacing.xl)
        }
    }

    // MARK: - Main Controls Section
    private var controlsSection: some View {
        HStack(spacing: AppSpacing.xxxl) {
            // Skip backward 15s
            Button(action: {
                audioManager.skipBackward()
            }) {
                ZStack {
                    Image(systemName: "gobackward.15")
                        .font(.system(size: 28, weight: .medium))
                        .foregroundColor(AppColors.textPrimary)
                }
                .frame(width: 56, height: 56)
            }
            .buttonStyle(PlainButtonStyle())

            // Play/Pause
            Button(action: {
                audioManager.togglePlayPause()
            }) {
                ZStack {
                    Circle()
                        .fill(AppColors.textPrimary)
                        .frame(width: 72, height: 72)

                    Image(systemName: audioManager.isPlaying ? "pause.fill" : "play.fill")
                        .font(.system(size: 28, weight: .bold))
                        .foregroundColor(AppColors.background)
                        .offset(x: audioManager.isPlaying ? 0 : 2)
                }
            }
            .buttonStyle(PlainButtonStyle())

            // Skip forward 15s
            Button(action: {
                audioManager.skipForward()
            }) {
                ZStack {
                    Image(systemName: "goforward.15")
                        .font(.system(size: 28, weight: .medium))
                        .foregroundColor(AppColors.textPrimary)
                }
                .frame(width: 56, height: 56)
            }
            .buttonStyle(PlainButtonStyle())
        }
    }

    // MARK: - Secondary Controls
    private var secondaryControlsSection: some View {
        HStack {
            // Playback speed
            Button(action: { showSpeedPicker = true }) {
                VStack(spacing: AppSpacing.xxs) {
                    Text(audioManager.playbackSpeed.label)
                        .font(AppTypography.captionBold)
                        .foregroundColor(AppColors.textPrimary)
                    Text("Speed")
                        .font(.system(size: 9, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                }
                .frame(width: 56)
            }
            .buttonStyle(PlainButtonStyle())

            Spacer()

            // Sleep timer
            Button(action: { showSleepTimer = true }) {
                VStack(spacing: AppSpacing.xxs) {
                    Image(systemName: audioManager.sleepTimer == .off ? "moon" : "moon.fill")
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(audioManager.sleepTimer == .off ? AppColors.textPrimary : AppColors.primaryBlue)
                    Text("Sleep")
                        .font(.system(size: 9, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                }
                .frame(width: 56)
            }
            .buttonStyle(PlainButtonStyle())

            Spacer()

            // Queue
            Button(action: { showQueue = true }) {
                VStack(spacing: AppSpacing.xxs) {
                    Image(systemName: "list.bullet")
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(AppColors.textPrimary)
                    Text("Queue")
                        .font(.system(size: 9, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                }
                .frame(width: 56)
            }
            .buttonStyle(PlainButtonStyle())

            Spacer()

            // Share
            Button(action: {
                // Share action
            }) {
                VStack(spacing: AppSpacing.xxs) {
                    Image(systemName: "square.and.arrow.up")
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(AppColors.textPrimary)
                    Text("Share")
                        .font(.system(size: 9, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                }
                .frame(width: 56)
            }
            .buttonStyle(PlainButtonStyle())
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

// MARK: - Audio Progress Slider
struct AudioProgressSlider: View {
    let progress: Double
    var onSeek: ((Double) -> Void)?

    @State private var isDragging: Bool = false
    @State private var dragProgress: Double = 0

    private var displayProgress: Double {
        isDragging ? dragProgress : progress
    }

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Track background
                Capsule()
                    .fill(Color.white.opacity(0.2))
                    .frame(height: 3)

                // Progress fill
                Capsule()
                    .fill(AppColors.textPrimary)
                    .frame(width: geometry.size.width * displayProgress, height: 3)

                // Thumb (visible on drag)
                if isDragging {
                    Circle()
                        .fill(AppColors.textPrimary)
                        .frame(width: 14, height: 14)
                        .offset(x: (geometry.size.width * displayProgress) - 7)
                }
            }
            .frame(height: 20)
            .contentShape(Rectangle())
            .gesture(
                DragGesture(minimumDistance: 0)
                    .onChanged { value in
                        isDragging = true
                        let newProgress = max(0, min(1, value.location.x / geometry.size.width))
                        dragProgress = newProgress
                    }
                    .onEnded { value in
                        let finalProgress = max(0, min(1, value.location.x / geometry.size.width))
                        onSeek?(finalProgress)
                        isDragging = false
                    }
            )
        }
        .frame(height: 20)
    }
}

// MARK: - Playback Speed Sheet
struct PlaybackSpeedSheet: View {
    @EnvironmentObject private var audioManager: AudioManager
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            List {
                ForEach(PlaybackSpeed.allCases) { speed in
                    Button(action: {
                        audioManager.playbackSpeed = speed
                        dismiss()
                    }) {
                        HStack {
                            Text(speed.label)
                                .font(AppTypography.body)
                                .foregroundColor(AppColors.textPrimary)

                            Spacer()

                            if audioManager.playbackSpeed == speed {
                                Image(systemName: "checkmark")
                                    .font(.system(size: 14, weight: .semibold))
                                    .foregroundColor(AppColors.primaryBlue)
                            }
                        }
                        .padding(.vertical, AppSpacing.xs)
                    }
                }
            }
            .listStyle(.plain)
            .navigationTitle("Playback Speed")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") { dismiss() }
                }
            }
        }
        .presentationDragIndicator(.visible)
        .preferredColorScheme(.dark)
    }
}

// MARK: - Sleep Timer Sheet
struct SleepTimerSheet: View {
    @EnvironmentObject private var audioManager: AudioManager
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            List {
                ForEach(SleepTimerOption.allCases) { option in
                    Button(action: {
                        audioManager.sleepTimer = option
                        dismiss()
                    }) {
                        HStack {
                            Text(option.label)
                                .font(AppTypography.body)
                                .foregroundColor(AppColors.textPrimary)

                            Spacer()

                            if audioManager.sleepTimer == option {
                                Image(systemName: "checkmark")
                                    .font(.system(size: 14, weight: .semibold))
                                    .foregroundColor(AppColors.primaryBlue)
                            }
                        }
                        .padding(.vertical, AppSpacing.xs)
                    }
                }
            }
            .listStyle(.plain)
            .navigationTitle("Sleep Timer")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") { dismiss() }
                }
            }
        }
        .presentationDragIndicator(.visible)
        .preferredColorScheme(.dark)
    }
}

// MARK: - Audio Queue Sheet
struct AudioQueueSheet: View {
    @EnvironmentObject private var audioManager: AudioManager
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            VStack {
                if audioManager.queue.isEmpty {
                    emptyQueueView
                } else {
                    queueList
                }
            }
            .navigationTitle("Up Next")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    if !audioManager.queue.isEmpty {
                        Button("Clear") {
                            audioManager.clearQueue()
                        }
                        .foregroundColor(AppColors.bearish)
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") { dismiss() }
                }
            }
        }
        .presentationDragIndicator(.visible)
        .preferredColorScheme(.dark)
    }

    private var emptyQueueView: some View {
        VStack(spacing: AppSpacing.lg) {
            Image(systemName: "list.bullet")
                .font(.system(size: 48, weight: .light))
                .foregroundColor(AppColors.textMuted)

            Text("Your queue is empty")
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)

            Text("Add episodes from Money Moves or Books")
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    private var queueList: some View {
        List {
            ForEach(Array(audioManager.queue.enumerated()), id: \.element.id) { index, item in
                HStack(spacing: AppSpacing.md) {
                    AudioArtworkThumbnail(episode: item.episode, size: 48)

                    VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                        Text(item.episode.title)
                            .font(AppTypography.bodyBold)
                            .foregroundColor(AppColors.textPrimary)
                            .lineLimit(1)

                        Text(item.episode.authorName)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)
                    }

                    Spacer()

                    Text(item.episode.formattedDuration)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }
                .swipeActions(edge: .trailing) {
                    Button(role: .destructive) {
                        audioManager.removeFromQueue(at: index)
                    } label: {
                        Label("Remove", systemImage: "trash")
                    }
                }
            }
            .onMove { from, to in
                // Handle reordering
            }
        }
        .listStyle(.plain)
    }
}

// MARK: - Preview
#Preview {
    FullScreenAudioPlayer()
        .environmentObject(AudioManager.shared)
        .onAppear {
            AudioManager.shared.play(.sampleMoneyMoves)
        }
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/HomeView.swift
================================================================================

//
//  HomeView.swift
//  ios
//
//  Main Home screen combining all organisms
//

import SwiftUI

// MARK: - HomeContentView (Used in TabView)
struct HomeContentView: View {
    @StateObject private var viewModel = HomeViewModel()
    @State private var showingSearch = false
    @State private var selectedNewsArticle: NewsArticle?

    var body: some View {
        NavigationStack {
            ZStack {
                // Background
                AppColors.background
                    .ignoresSafeArea()

                // Main Content
                VStack(spacing: 0) {
                    // Header
                    HomeHeader(
                        onProfileTapped: handleProfileTapped,
                        onSearchTapped: handleSearchTapped
                    )

                    // Scrollable Content with proper bounce behavior
                    ScrollView(showsIndicators: false) {
                        LazyVStack(spacing: AppSpacing.xl) {
                            // Market Tickers Row
                            MarketTickersRow(tickers: viewModel.marketTickers)
                                .padding(.top, AppSpacing.sm)

                            // Market Insights Card
                            if let insight = viewModel.marketInsight {
                                MarketInsightsCard(insight: insight) {
                                    handleSeeAllInsights()
                                }
                                .padding(.horizontal, AppSpacing.lg)
                            }

                            // Daily Briefing Section
                            DailyBriefingSection(
                                items: viewModel.dailyBriefings,
                                onItemTapped: handleBriefingItemTapped
                            )

                            // Recent Research Section
                            RecentResearchSection(
                                reports: viewModel.recentResearch,
                                onSeeAllTapped: handleSeeAllResearch,
                                onReportTapped: handleReportTapped,
                                onAskOrReadTapped: handleAskOrRead
                            )

                            // New Analysis Button
                            NewAnalysisButton {
                                handleNewAnalysis()
                            }
                            .padding(.bottom, AppSpacing.lg)
                        }
                    }
                    .refreshable {
                        await viewModel.refresh()
                    }
                }

                // Loading overlay
                if viewModel.isLoading {
                    LoadingOverlay()
                }
            }
            .navigationBarHidden(true)
            .fullScreenCover(isPresented: $showingSearch) {
                SearchView()
            }
            .fullScreenCover(item: $selectedNewsArticle) { article in
                NewsDetailView(article: article)
                    .preferredColorScheme(.dark)
            }
        }
    }

    // MARK: - Action Handlers
    private func handleProfileTapped() {
        print("Profile tapped")
    }

    private func handleSearchTapped() {
        showingSearch = true
    }

    private func handleSeeAllInsights() {
        print("See all insights tapped")
    }

    private func handleBriefingItemTapped(_ item: DailyBriefingItem) {
        // Convert DailyBriefingItem to NewsArticle and show detail
        selectedNewsArticle = NewsArticle(
            headline: item.title,
            summary: item.subtitle,
            source: NewsSource(name: "Market Alert", iconName: nil),
            sentiment: .neutral,
            publishedAt: item.date ?? Date(),
            thumbnailName: nil,
            relatedTickers: []
        )
    }

    private func handleSeeAllResearch() {
        print("See all research tapped")
    }

    private func handleReportTapped(_ report: ResearchReport) {
        print("Report tapped: \(report.headline)")
    }

    private func handleAskOrRead(_ report: ResearchReport) {
        print("Ask or Read tapped for: \(report.stockTicker)")
    }

    private func handleNewAnalysis() {
        print("New analysis tapped")
    }
}

// MARK: - Legacy HomeView (for backward compatibility)
struct HomeView: View {
    var body: some View {
        MainTabView()
    }
}

// MARK: - Loading Overlay
struct LoadingOverlay: View {
    var body: some View {
        ZStack {
            Color.black.opacity(0.3)
                .ignoresSafeArea()

            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                .scaleEffect(1.5)
        }
    }
}

#Preview {
    HomeView()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/InvestorJourneyView.swift
================================================================================

//
//  InvestorJourneyView.swift
//  ios
//
//  The Investor Journey - Full learning journey screen from Novice to Master
//

import SwiftUI

struct InvestorJourneyView: View {
    @StateObject private var viewModel = InvestorJourneyViewModel()
    @Environment(\.dismiss) private var dismiss
    var scrollToNextLesson: Bool = false
    @Namespace private var lessonNamespace

    var body: some View {
        ZStack {
            // Background
            AppColors.background
                .ignoresSafeArea()

            // Main content
            VStack(spacing: 0) {
                // Header
                InvestorJourneyHeader(
                    completedLessons: viewModel.totalLessonsCompleted,
                    totalLessons: viewModel.totalLessons,
                    onBackTapped: {
                        dismiss()
                    }
                )

                // Scrollable content
                ScrollViewReader { proxy in
                    ScrollView(showsIndicators: false) {
                        LazyVStack(spacing: AppSpacing.xxl) {
                            // Level 1: Foundation
                            if let foundationLevel = viewModel.getLevelProgress(for: .foundation) {
                                InvestorJourneyLevelSection(
                                    levelProgress: foundationLevel,
                                    onLessonTap: { lesson in
                                        viewModel.selectLesson(lesson)
                                    }
                                )
                                .id(foundationLevel.id)
                            }

                            // Level 2: Analysis
                            if let analysisLevel = viewModel.getLevelProgress(for: .analysis) {
                                InvestorJourneyLevelSection(
                                    levelProgress: analysisLevel,
                                    onLessonTap: { lesson in
                                        viewModel.selectLesson(lesson)
                                    }
                                )
                                .id(analysisLevel.id)
                            }

                            // Chat with book prompt (between Level 2 and 3)
                            ChatWithBookPromptCard {
                                viewModel.openChatWithBook()
                            }
                            .padding(.horizontal, AppSpacing.lg)

                            // Level 3: Strategies
                            if let strategiesLevel = viewModel.getLevelProgress(for: .strategies) {
                                InvestorJourneyLevelSection(
                                    levelProgress: strategiesLevel,
                                    onLessonTap: { lesson in
                                        viewModel.selectLesson(lesson)
                                    }
                                )
                                .id(strategiesLevel.id)
                            }

                            // Level 4: Mastery
                            if let masteryLevel = viewModel.getLevelProgress(for: .mastery) {
                                InvestorJourneyLevelSection(
                                    levelProgress: masteryLevel,
                                    onLessonTap: { lesson in
                                        viewModel.selectLesson(lesson)
                                    }
                                )
                                .id(masteryLevel.id)
                            }

                            // Study Schedule section
                            InvestorJourneyStudyScheduleSection(
                                schedule: $viewModel.studySchedule,
                                onMorningTimeTap: {
                                    // Show time picker for morning session
                                },
                                onReviewTimeTap: {
                                    // Show time picker for review time
                                }
                            )

                            // Inspirational quote
                            InvestorQuoteCard(quote: viewModel.quote)
                                .padding(.horizontal, AppSpacing.lg)

                            // Bottom padding for safe area
                            Color.clear.frame(height: AppSpacing.xxxl)
                        }
                        .padding(.top, AppSpacing.md)
                    }
                    .refreshable {
                        await viewModel.refresh()
                    }
                    .onAppear {
                        if scrollToNextLesson, let nextLevelId = viewModel.nextLessonLevelId {
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                                withAnimation {
                                    proxy.scrollTo(nextLevelId, anchor: .top)
                                }
                            }
                        }
                    }
                }
            }

            // Loading overlay
            if viewModel.isLoading {
                LoadingOverlay()
            }
        }
        .navigationBarHidden(true)
        .fullScreenCover(isPresented: $viewModel.showLessonStory) {
            if let lesson = viewModel.selectedLesson {
                LessonTopicCardView(
                    storyContent: viewModel.getStoryContent(for: lesson),
                    onDismiss: {
                        viewModel.dismissLessonStory()
                    },
                    onCTATapped: { destination in
                        viewModel.dismissLessonStory()
                        // Handle CTA navigation based on destination
                        handleCTANavigation(destination)
                    }
                )
            }
        }
    }

    private func handleCTANavigation(_ destination: LessonCTADestination) {
        switch destination {
        case .analyzeStock:
            // Navigate to stock analysis - implement based on your navigation
            print("Navigate to stock analysis")
        case .viewPortfolio:
            // Navigate to portfolio
            print("Navigate to portfolio")
        case .readArticle(let articleId):
            print("Navigate to article: \(articleId)")
        case .watchVideo(let videoId):
            print("Navigate to video: \(videoId)")
        case .practiceQuiz:
            print("Navigate to quiz")
        case .custom(let action):
            print("Custom action: \(action)")
        }
    }
}

#Preview {
    InvestorJourneyView()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/LearnView.swift
================================================================================

//
//  LearnView.swift
//  ios
//
//  Main Learn (Wiser) screen combining all organisms
//

import SwiftUI

// MARK: - LearnContentView (Used in TabView)
struct LearnContentView: View {
    @EnvironmentObject private var audioManager: AudioManager
    @StateObject private var viewModel = LearnViewModel()
    @State private var showingInvestorJourney = false
    @State private var shouldScrollToNextLesson = false
    @State private var showingMoneyMovesDetail = false
    @State private var showingBookLibrary = false

    var body: some View {
        NavigationStack {
        ZStack {
            // Background
            AppColors.background
                .ignoresSafeArea()

            // Main Content
            VStack(spacing: 0) {
                // Header with search and tabs
                LearnHeader(
                    searchText: $viewModel.searchText,
                    selectedTab: $viewModel.selectedTab,
                    onSearchSubmit: handleSearchSubmit
                )

                // Tab content - no swipe gesture between tabs
                Group {
                    switch viewModel.selectedTab {
                    case .learn:
                        learnTabContent
                    case .chat:
                        chatTabContent
                    }
                }
                .animation(.easeInOut(duration: 0.2), value: viewModel.selectedTab)
            }

            // Loading overlay
            if viewModel.isLoading {
                LoadingOverlay()
            }
        }
        .navigationDestination(isPresented: $showingInvestorJourney) {
            InvestorJourneyView(scrollToNextLesson: shouldScrollToNextLesson)
                .environmentObject(audioManager)
        }
        .navigationDestination(isPresented: $showingMoneyMovesDetail) {
            MoneyMovesDetailView()
                .environmentObject(audioManager)
        }
        .navigationDestination(isPresented: $showingBookLibrary) {
            BookLibraryView()
                .environmentObject(audioManager)
        }
        .navigationBarHidden(true)
        }
    }

    // MARK: - Learn Tab Content
    private var learnTabContent: some View {
        ScrollView(showsIndicators: false) {
            LazyVStack(spacing: AppSpacing.xxl) {
                // Investor Journey Section (includes journey progress)
                InvestorJourneySection(
                    currentLevel: viewModel.currentLevel,
                    journeyTrack: viewModel.journeyTrack,
                    onSeeAll: handleSeeAllJourney,
                    onContinue: handleContinueJourney,
                    onItemTap: handleJourneyItemTap
                )
                .padding(.top, AppSpacing.md)

                // Money Moves Section
                if !viewModel.moneyMoves.isEmpty {
                    MoneyMovesSection(
                        concepts: viewModel.moneyMoves,
                        onSeeAll: handleSeeAllMoneyMoves,
                        onConceptTap: handleMoneyMoveTap,
                        onBookmark: handleBookmarkMoneyMove
                    )
                }

                // AI-Enabled Books Section
                if !viewModel.books.isEmpty {
                    AIBooksSection(
                        books: viewModel.books,
                        onSeeAll: handleSeeAllBooks,
                        onChatWithBook: handleChatWithBook,
                        onReadKeyIdeas: handleReadKeyIdeas
                    )
                }

                // Community Discussions Section
                if !viewModel.discussions.isEmpty {
                    CommunityDiscussionsSection(
                        discussions: viewModel.discussions,
                        onSeeAll: handleSeeAllDiscussions,
                        onDiscussionTap: handleDiscussionTap
                    )
                }

                // Credits Balance Section
                if let balance = viewModel.creditBalance {
                    LearnCreditsSection(
                        balance: balance,
                        onAddCredits: handleAddCredits
                    )
                }

                // Bottom padding for tab bar
                Color.clear.frame(height: AppSpacing.xxxl)
            }
        }
        .refreshable {
            await viewModel.refresh()
        }
    }

    // MARK: - Chat Tab Content
    private var chatTabContent: some View {
        ChatTabView {
            handleHistoryTap()
        }
    }

    private func handleHistoryTap() {
        print("Chat history tapped")
    }

    // MARK: - Action Handlers
    private func handleSearchSubmit() {
        print("Search submitted: \(viewModel.searchText)")
    }

    private func handleSeeAllJourney() {
        shouldScrollToNextLesson = false
        showingInvestorJourney = true
    }

    private func handleContinueJourney() {
        shouldScrollToNextLesson = true
        showingInvestorJourney = true
    }

    private func handleJourneyItemTap(_ item: JourneyItem) {
        print("Journey item tapped: \(item.title)")
    }

    private func handleSeeAllMoneyMoves() {
        showingMoneyMovesDetail = true
    }

    private func handleMoneyMoveTap(_ moneyMove: MoneyMove) {
        viewModel.openMoneyMove(moneyMove)
    }

    private func handleBookmarkMoneyMove(_ moneyMove: MoneyMove) {
        viewModel.toggleBookmark(for: moneyMove)
    }

    private func handleSeeAllBooks() {
        showingBookLibrary = true
    }

    private func handleChatWithBook(_ book: EducationBook) {
        viewModel.chatWithBook(book)
    }

    private func handleReadKeyIdeas(_ book: EducationBook) {
        viewModel.readKeyIdeas(book)
    }

    private func handleSeeAllDiscussions() {
        print("See all discussions")
    }

    private func handleDiscussionTap(_ discussion: CommunityDiscussion) {
        viewModel.openDiscussion(discussion)
    }

    private func handleAddCredits() {
        viewModel.addCredits()
    }
}

// MARK: - Legacy LearnView (for backward compatibility)
struct LearnView: View {
    var body: some View {
        LearnContentView()
    }
}

#Preview {
    LearnView()
        .environmentObject(AudioManager.shared)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/MainTabView.swift
================================================================================

//
//  MainTabView.swift
//  ios
//
//  Main navigation using native SwiftUI TabView
//  Works with RootContainerView for global audio player support
//

import SwiftUI

struct MainTabView: View {
    @State private var selectedTab: HomeTab = .home
    @Environment(\.miniPlayerVisible) private var miniPlayerVisible

    init() {
        // Configure tab bar appearance
        let appearance = UITabBarAppearance()
        appearance.configureWithOpaqueBackground()
        appearance.backgroundColor = UIColor(AppColors.tabBarBackground)

        // Normal state
        appearance.stackedLayoutAppearance.normal.iconColor = UIColor(AppColors.tabBarUnselected)
        appearance.stackedLayoutAppearance.normal.titleTextAttributes = [
            .foregroundColor: UIColor(AppColors.tabBarUnselected)
        ]

        // Selected state
        appearance.stackedLayoutAppearance.selected.iconColor = UIColor(AppColors.tabBarSelected)
        appearance.stackedLayoutAppearance.selected.titleTextAttributes = [
            .foregroundColor: UIColor(AppColors.tabBarSelected)
        ]

        UITabBar.appearance().standardAppearance = appearance
        UITabBar.appearance().scrollEdgeAppearance = appearance
    }

    var body: some View {
        TabView(selection: $selectedTab) {
            HomeContentView()
                .miniPlayerSafeArea()
                .tabItem {
                    Image(systemName: "house.fill")
                    Text("Home")
                }
                .tag(HomeTab.home)

            UpdatesViewForTabView(selectedTab: $selectedTab)
                .miniPlayerSafeArea()
                .tabItem {
                    Image(systemName: "chart.bar.doc.horizontal")
                    Text("Updates")
                }
                .tag(HomeTab.updates)

            ResearchContentView()
                .miniPlayerSafeArea()
                .tabItem {
                    Image(systemName: "magnifyingglass")
                    Text("Research")
                }
                .tag(HomeTab.research)

            TrackingContentView()
                .miniPlayerSafeArea()
                .tabItem {
                    Image(systemName: "star.fill")
                    Text("Tracking")
                }
                .tag(HomeTab.tracking)

            LearnContentView()
                .miniPlayerSafeArea()
                .tabItem {
                    Image(systemName: "lightbulb.fill")
                    Text("Wiser")
                }
                .tag(HomeTab.wiser)
        }
        .tint(AppColors.tabBarSelected)
    }
}

// MARK: - UpdatesView wrapper for TabView (hides custom tab bar)
struct UpdatesViewForTabView: View {
    @StateObject private var viewModel = UpdatesViewModel()
    @Binding var selectedTab: HomeTab
    @State private var showManageAssetsSheet = false
    @State private var selectedNewsArticle: NewsArticle?

    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            VStack(spacing: 0) {
                UpdatesHeader(
                    onProfileTapped: {}
                )

                UpdatesTabBar(
                    tabs: viewModel.filterTabs,
                    selectedTab: $viewModel.selectedTab,
                    onManageAssets: { showManageAssetsSheet = true }
                )

                LiveNewsHeader(onFilterTapped: { viewModel.openFilterOptions() })

                ScrollView(showsIndicators: false) {
                    if let summary = viewModel.insightSummary {
                        InsightsSummaryCard(summary: summary)
                            .padding(.horizontal, AppSpacing.lg)
                            .padding(.vertical, AppSpacing.sm)
                    }

                    LiveNewsTimeline(
                        groupedNews: viewModel.groupedNews,
                        onArticleTapped: { article in
                            selectedNewsArticle = article
                        }
                    )

                    Spacer()
                        .frame(height: 100)
                }
                .refreshable {
                    await viewModel.refresh()
                }
            }

            if viewModel.isLoading {
                LoadingOverlay()
            }
        }
        .sheet(isPresented: $viewModel.showFilterSheet) {
            NewsFilterSheet(
                filterOptions: $viewModel.filterOptions,
                onApply: { viewModel.showFilterSheet = false }
            )
        }
        .sheet(isPresented: $showManageAssetsSheet) {
            ManageAssetsSheet(
                tickers: viewModel.filterTabs.filter { !$0.isMarketTab },
                onDismiss: { showManageAssetsSheet = false }
            )
        }
        .fullScreenCover(item: $selectedNewsArticle) { article in
            NewsDetailView(article: article)
                .preferredColorScheme(.dark)
        }
    }
}

// MARK: - Placeholder View for other tabs
struct PlaceholderView: View {
    let title: String

    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            Text(title)
                .font(AppTypography.title)
                .foregroundColor(AppColors.textPrimary)
        }
    }
}

#Preview {
    MainTabView()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/MoneyMoveArticleDetailView.swift
================================================================================

//
//  MoneyMoveArticleDetailView.swift
//  ios
//
//  Full article detail screen for Money Move articles
//  Displays hero header, content sections, statistics, comments, and related articles
//  Integrates with AudioManager for audio playback
//

import SwiftUI

struct MoneyMoveArticleDetailView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var audioManager: AudioManager
    @State private var isBookmarked: Bool = false
    @State private var isFollowing: Bool = false
    @State private var showShareSheet: Bool = false
    @State private var showMoreOptions: Bool = false
    @State private var scrollOffset: CGFloat = 0

    let article: MoneyMoveArticle

    /// Convert article to AudioEpisode for playback
    private var audioEpisode: AudioEpisode {
        AudioEpisode(
            id: "article-\(article.id)",
            title: article.title,
            subtitle: article.subtitle,
            artworkGradientColors: article.heroGradientColors,
            artworkIcon: article.category.iconName,
            duration: TimeInterval(article.readTimeMinutes * 60),
            category: .moneyMoves,
            authorName: article.author.name,
            sourceId: article.id.uuidString
        )
    }

    // Computed property for header opacity based on scroll
    private var headerOpacity: Double {
        let fadeStart: CGFloat = 200
        let fadeEnd: CGFloat = 280
        if scrollOffset < fadeStart { return 0 }
        if scrollOffset > fadeEnd { return 1 }
        return Double((scrollOffset - fadeStart) / (fadeEnd - fadeStart))
    }

    var body: some View {
        ZStack {
            // Main content layer
            ZStack(alignment: .top) {
                // Background
                AppColors.background
                    .ignoresSafeArea()

                // Main scrollable content
                ScrollView(showsIndicators: false) {
                    VStack(spacing: 0) {
                        // Hero header
                        MoneyMoveArticleHeroHeader(
                            article: article,
                            audioEpisode: audioEpisode,
                            onBackTapped: handleBackTapped,
                            onShareTapped: handleShareTapped,
                            isBookmarked: isBookmarked,
                            onBookmarkTapped: handleBookmarkTapped,
                            onMoreTapped: handleMoreTapped
                        )

                        // Content
                        MoneyMoveArticleContent(article: article)
                        .padding(.top, AppSpacing.lg)

                        // Bottom padding (extra space for mini player)
                        Color.clear
                            .frame(height: audioManager.hasActiveEpisode ? 120 : 40)
                    }
                    .background(
                        GeometryReader { proxy in
                            Color.clear
                                .preference(
                                    key: ScrollOffsetPreferenceKey.self,
                                    value: -proxy.frame(in: .named("scroll")).origin.y
                                )
                        }
                    )
                }
                .coordinateSpace(name: "scroll")
                .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
                    scrollOffset = value
                }

                // Sticky mini header (appears on scroll)
                if headerOpacity > 0 {
                    miniHeader
                        .opacity(headerOpacity)
                }
            }

            // Global Mini Player (floating at bottom)
            if audioManager.hasActiveEpisode && !audioManager.showFullScreenPlayer {
                VStack {
                    Spacer()
                    GlobalMiniPlayer()
                        .padding(.bottom, AppSpacing.lg)
                }
                .transition(.move(edge: .bottom).combined(with: .opacity))
            }

            // Full Screen Player (modal overlay)
            if audioManager.showFullScreenPlayer {
                FullScreenAudioPlayer()
                    .transition(.move(edge: .bottom))
                    .zIndex(100)
            }
        }
        .navigationBarHidden(true)
        .preferredColorScheme(.dark)
        .animation(.spring(response: 0.35, dampingFraction: 0.85), value: audioManager.hasActiveEpisode)
        .animation(.spring(response: 0.4, dampingFraction: 0.85), value: audioManager.showFullScreenPlayer)
        .onAppear {
            isBookmarked = article.isBookmarked
        }
        .confirmationDialog("Options", isPresented: $showMoreOptions) {
            Button("Share Article") { handleShareTapped() }
            Button(isBookmarked ? "Remove Bookmark" : "Save Article") { handleBookmarkTapped() }
            if article.hasAudioVersion {
                Button("Add to Queue") {
                    audioManager.addToQueue(audioEpisode)
                }
            }
            Button("Report Issue") { handleReportTapped() }
            Button("Cancel", role: .cancel) {}
        }
        .sheet(isPresented: $showShareSheet) {
            ShareSheet(items: [article.title, article.subtitle])
        }
    }

    // MARK: - Mini Header

    private var miniHeader: some View {
        HStack(spacing: AppSpacing.md) {
            // Back button
            Button(action: handleBackTapped) {
                Image(systemName: "chevron.left")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(AppColors.textPrimary)
            }
            .buttonStyle(PlainButtonStyle())

            // Title
            Text(article.title)
                .font(AppTypography.bodyBold)
                .foregroundColor(AppColors.textPrimary)
                .lineLimit(1)

            Spacer()

            // Actions
            HStack(spacing: AppSpacing.lg) {
                // Mini play button
                if article.hasAudioVersion {
                    PlayAudioButton(
                        episode: audioEpisode,
                        style: .minimal,
                        size: .small
                    )
                }

                Button(action: handleShareTapped) {
                    Image(systemName: "square.and.arrow.up")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(AppColors.textSecondary)
                }
                .buttonStyle(PlainButtonStyle())

                Button(action: handleBookmarkTapped) {
                    Image(systemName: isBookmarked ? "bookmark.fill" : "bookmark")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(isBookmarked ? AppColors.primaryBlue : AppColors.textSecondary)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.vertical, AppSpacing.md)
        .background(
            AppColors.background
                .shadow(color: Color.black.opacity(0.2), radius: 4, y: 2)
        )
    }

    // MARK: - Action Handlers

    private func handleBackTapped() {
        dismiss()
    }

    private func handleShareTapped() {
        showShareSheet = true
    }

    private func handleBookmarkTapped() {
        withAnimation(.spring(response: 0.3)) {
            isBookmarked.toggle()
        }
    }

    private func handleFollowTapped() {
        withAnimation(.spring(response: 0.3)) {
            isFollowing.toggle()
        }
    }

    private func handleAuthorTapped() {
        print("Navigate to author profile: \(article.author.name)")
    }

    private func handleMoreTapped() {
        showMoreOptions = true
    }

    private func handleReportTapped() {
        print("Report article")
    }
}

// MARK: - Scroll Offset Preference Key

private struct ScrollOffsetPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0

    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

// MARK: - Preview

#Preview {
    MoneyMoveArticleDetailView(article: MoneyMoveArticle.sampleDigitalFinance)
        .environmentObject(AudioManager.shared)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/MoneyMovesDetailView.swift
================================================================================

//
//  MoneyMovesDetailView.swift
//  ios
//
//  Money Moves Detail View - Full screen with hero card and categorized case studies
//  Serves as the main listing view for all Money Move articles
//

import SwiftUI

struct MoneyMovesDetailView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var audioManager: AudioManager
    @State private var blueprints: [MoneyMove] = []
    @State private var valueTraps: [MoneyMove] = []
    @State private var battles: [MoneyMove] = []
    @State private var selectedArticle: MoneyMoveArticle?

    var body: some View {
        ZStack {
            // Background
            AppColors.background
                .ignoresSafeArea()

            // Main content
            VStack(spacing: 0) {
                // Header
                MoneyMovesDetailHeader(onBackTapped: {
                    dismiss()
                })

                // Scrollable content
                ScrollView(showsIndicators: false) {
                    LazyVStack(spacing: AppSpacing.xxl) {
                        // Hero Card - Featured Deep Dive
                        FeaturedDeepDiveHeroCard(
                            article: MoneyMoveArticle.sampleDigitalFinance,
                            onTap: {
                                // Create a special version with featured flag for the orange gradient
                                selectedArticle = MoneyMoveArticle.featuredDigitalFinance
                            }
                        )
                        .padding(.horizontal, AppSpacing.lg)
                        .padding(.top, AppSpacing.md)

                        // Section 1: The Blueprints
                        MoneyMovesCategorySection(
                            category: .blueprints,
                            moves: blueprints,
                            onMoveTap: handleMoveTap,
                            onBookmark: handleBookmark
                        )

                        // Section 2: Value Traps
                        MoneyMovesCategorySection(
                            category: .valueTraps,
                            moves: valueTraps,
                            onMoveTap: handleMoveTap,
                            onBookmark: handleBookmark
                        )

                        // Section 3: Battles
                        MoneyMovesCategorySection(
                            category: .battles,
                            moves: battles,
                            onMoveTap: handleMoveTap,
                            onBookmark: handleBookmark
                        )

                        // Bottom padding for safe area
                        Color.clear.frame(height: AppSpacing.xxxl)
                    }
                }
            }
        }
        .navigationBarHidden(true)
        .fullScreenCover(item: $selectedArticle) { article in
            MoneyMoveArticleDetailView(article: article)
                .environmentObject(audioManager)
        }
        .onAppear {
            loadSampleData()
        }
        // Prevent accidental navigation gestures
        .interactiveDismissDisabled(false)
    }

    private func loadSampleData() {
        // Filter sample data by category
        let allMoves = MoneyMove.sampleData
        blueprints = allMoves.filter { $0.category == .blueprints }
        valueTraps = allMoves.filter { $0.category == .valueTraps }
        battles = allMoves.filter { $0.category == .battles }

        // Add more sample data for each category
        blueprints.append(contentsOf: [
            MoneyMove(
                title: "Apple's Services Revolution",
                subtitle: "How Apple transformed from hardware to ecosystem.",
                category: .blueprints,
                estimatedMinutes: 14,
                learnerCount: "1.6k",
                isBookmarked: false
            ),
            MoneyMove(
                title: "Costco's Membership Magic",
                subtitle: "The power of customer loyalty economics.",
                category: .blueprints,
                estimatedMinutes: 9,
                learnerCount: "1.2k",
                isBookmarked: true
            )
        ])

        valueTraps.append(contentsOf: [
            MoneyMove(
                title: "The FTX Collapse",
                subtitle: "Crypto's biggest fraud unraveled.",
                category: .valueTraps,
                estimatedMinutes: 18,
                learnerCount: "3.2k",
                isBookmarked: false
            ),
            MoneyMove(
                title: "Theranos: Blood & Lies",
                subtitle: "The $9 billion medical fraud.",
                category: .valueTraps,
                estimatedMinutes: 16,
                learnerCount: "2.8k",
                isBookmarked: false
            )
        ])

        battles.append(contentsOf: [
            MoneyMove(
                title: "Visa vs. Mastercard",
                subtitle: "The payment network duopoly.",
                category: .battles,
                estimatedMinutes: 12,
                learnerCount: "1.7k",
                isBookmarked: false
            ),
            MoneyMove(
                title: "Google vs. Microsoft: AI Wars",
                subtitle: "The battle for AI supremacy.",
                category: .battles,
                estimatedMinutes: 15,
                learnerCount: "2.5k",
                isBookmarked: true
            )
        ])
    }

    private func handleMoveTap(_ move: MoneyMove) {
        // Create article from move and show detail
        selectedArticle = createArticleFromMove(move)
    }

    private func handleBookmark(_ move: MoneyMove) {
        print("Bookmark toggled for: \(move.title)")
    }

    /// Creates a full MoneyMoveArticle from a MoneyMove card data
    private func createArticleFromMove(_ move: MoneyMove) -> MoneyMoveArticle {
        // Generate gradient colors based on category
        let gradientColors: [String]
        switch move.category {
        case .blueprints:
            gradientColors = ["059669", "047857", "064E3B"]
        case .valueTraps:
            gradientColors = ["DC2626", "991B1B", "7F1D1D"]
        case .battles:
            gradientColors = ["7C3AED", "5B21B6", "4C1D95"]
        }

        return MoneyMoveArticle(
            title: move.title,
            subtitle: move.subtitle,
            category: move.category,
            author: ArticleAuthor(
                name: "The Alpha",
                avatarName: nil,
                title: "Investment Research",
                isVerified: true,
                followerCount: "45.2k"
            ),
            publishedAt: Date(),
            readTimeMinutes: move.estimatedMinutes,
            viewCount: move.learnerCount,
            commentCount: Int.random(in: 20...200),
            isBookmarked: move.isBookmarked,
            hasAudioVersion: true,
            heroGradientColors: gradientColors,
            tagLabel: move.category == .blueprints ? "BLUEPRINT" : (move.category == .valueTraps ? "CASE STUDY" : "VS"),
            isFeatured: false,
            keyHighlights: [
                ArticleHighlight(
                    icon: "lightbulb.fill",
                    title: "Key Insight",
                    description: "Understanding the core principles behind this investment case study."
                ),
                ArticleHighlight(
                    icon: "chart.line.uptrend.xyaxis",
                    title: "Market Impact",
                    description: "How this story influenced market dynamics and investor behavior."
                ),
                ArticleHighlight(
                    icon: "exclamationmark.triangle.fill",
                    title: "Lessons Learned",
                    description: "Critical takeaways for modern investors and portfolio managers."
                )
            ],
            sections: [
                ArticleSection(
                    title: "Overview",
                    icon: "doc.text.fill",
                    content: [
                        .paragraph("This case study explores the key factors that led to this notable investment story. Understanding these dynamics is crucial for making informed investment decisions in today's complex market environment."),
                        .paragraph("By analyzing the events, decisions, and market reactions, we can extract valuable lessons applicable to future investment opportunities and risk management strategies.")
                    ],
                    hasGlowEffect: true
                ),
                ArticleSection(
                    title: "Background & Context",
                    icon: "clock.fill",
                    content: [
                        .paragraph("To fully appreciate this case study, we must understand the market conditions and competitive landscape that shaped its trajectory."),
                        .callout(
                            icon: "info.circle.fill",
                            text: "The events discussed here occurred during a period of significant market transformation, making them particularly relevant for today's investors.",
                            style: .info
                        ),
                        .bulletList([
                            "Market conditions at the time",
                            "Key players and their motivations",
                            "Regulatory environment",
                            "Technological factors"
                        ])
                    ]
                ),
                ArticleSection(
                    title: "Key Takeaways",
                    icon: "star.fill",
                    content: [
                        .subheading("For Value Investors"),
                        .bulletList([
                            "Understanding market dynamics is essential for long-term success",
                            "Due diligence prevents costly mistakes and protects capital",
                            "Long-term thinking creates lasting value for shareholders",
                            "Risk management is non-negotiable in volatile markets"
                        ]),
                        .subheading("Practical Applications"),
                        .paragraph("These lessons can be directly applied to your investment process. Consider how each principle might have changed outcomes in your own portfolio decisions.")
                    ]
                ),
                ArticleSection(
                    title: "Conclusion",
                    icon: "checkmark.seal.fill",
                    content: [
                        .paragraph("This case study demonstrates the importance of fundamental analysis, proper due diligence, and maintaining a long-term perspective in investing."),
                        .callout(
                            icon: "quote.opening",
                            text: "The best investment you can make is in your own education and understanding of what drives business value.",
                            style: .highlight
                        )
                    ]
                )
            ],
            statistics: [
                ArticleStatistic(value: move.learnerCount, label: "Investors Learning", trend: .up, trendValue: "12%"),
                ArticleStatistic(value: "\(move.estimatedMinutes)m", label: "Read Time"),
                ArticleStatistic(value: "4.8", label: "Rating", trend: .up, trendValue: "0.3")
            ],
            comments: [
                ArticleComment(
                    authorName: "Michael Chen",
                    authorAvatar: nil,
                    content: "Excellent analysis! This really helped me understand the key factors at play.",
                    postedAt: Calendar.current.date(byAdding: .hour, value: -3, to: Date())!,
                    likeCount: 24,
                    replyCount: 5,
                    isVerified: false
                ),
                ArticleComment(
                    authorName: "Sarah Williams",
                    authorAvatar: nil,
                    content: "The section on risk management was particularly valuable. Would love to see more case studies like this.",
                    postedAt: Calendar.current.date(byAdding: .hour, value: -8, to: Date())!,
                    likeCount: 18,
                    replyCount: 2,
                    isVerified: true
                )
            ],
            relatedArticles: MoneyMoveArticle.sampleDigitalFinance.relatedArticles
        )
    }
}

// MARK: - Header
private struct MoneyMovesDetailHeader: View {
    var onBackTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Navigation bar
            HStack {
                Button(action: {
                    onBackTapped?()
                }) {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                }

                Spacer()
            }

            // Title section
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text("Money Moves")
                    .font(AppTypography.largeTitle)
                    .foregroundColor(AppColors.textPrimary)

                Text("Real-world case studies & deep dives")
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.sm)
        .padding(.bottom, AppSpacing.lg)
    }
}

// MARK: - Featured Deep Dive Hero Card
private struct FeaturedDeepDiveHeroCard: View {
    let article: MoneyMoveArticle
    var onTap: (() -> Void)?

    private var gradientColors: [Color] {
        // Always use orange gradient based on EA580C
        [
            Color(hex: "F97316"),
            Color(hex: "EA580C"),
            Color(hex: "C2410C")
        ]
    }

    var body: some View {
        ZStack(alignment: .topTrailing) {
            ZStack(alignment: .topTrailing) {
                // Background with gradient and effects
                ZStack {
                    // Base gradient
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )

                    // Animated glow orbs
                    GeometryReader { geometry in
                        Circle()
                            .fill(
                                RadialGradient(
                                    colors: [
                                        Color(hex: "3B82F6").opacity(0.3),
                                        Color.clear
                                    ],
                                    center: .center,
                                    startRadius: 0,
                                    endRadius: geometry.size.width * 0.35
                                )
                            )
                            .frame(width: geometry.size.width * 0.5)
                            .offset(x: -geometry.size.width * 0.15, y: geometry.size.height * 0.3)

                        Circle()
                            .fill(
                                RadialGradient(
                                    colors: [
                                        Color(hex: "8B5CF6").opacity(0.25),
                                        Color.clear
                                    ],
                                    center: .center,
                                    startRadius: 0,
                                    endRadius: geometry.size.width * 0.3
                                )
                            )
                            .frame(width: geometry.size.width * 0.4)
                            .offset(x: geometry.size.width * 0.6, y: geometry.size.height * 0.1)
                    }

                    // Grainy texture overlay
                    GrainyTextureOverlay()

                    // Dark overlay for text readability
                    LinearGradient(
                        colors: [
                            Color.black.opacity(0.1),
                            Color.black.opacity(0.5)
                        ],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                }

                // Content overlay
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    Spacer()

                    // Category label
                    Text("FEATURED DEEP DIVE")
                        .font(AppTypography.captionBold)
                        .foregroundColor(.white.opacity(0.8))
                        .tracking(1.2)

                    // Title
                    Text(article.title)
                        .font(.system(size: 28, weight: .bold))
                        .foregroundColor(.white)
                        .minimumScaleFactor(0.8)
                        .lineLimit(2)

                    // Description
                    Text(article.subtitle)
                        .font(AppTypography.callout)
                        .foregroundColor(.white.opacity(0.9))
                        .lineLimit(nil)
                        .fixedSize(horizontal: false, vertical: true)

                    // Meta info
                    HStack(spacing: AppSpacing.lg) {
                        HStack(spacing: AppSpacing.xs) {
                            Image(systemName: "clock")
                                .font(.system(size: 12, weight: .medium))
                            Text("\(article.readTimeMinutes) min")
                                .font(AppTypography.caption)
                        }
                        .foregroundColor(.white.opacity(0.8))

                        HStack(spacing: AppSpacing.xs) {
                            Image(systemName: "person.2.fill")
                                .font(.system(size: 12, weight: .medium))
                            Text("\(article.viewCount) investors")
                                .font(AppTypography.caption)

                            if article.hasAudioVersion {
                                Image(systemName: "headphones")
                                    .font(.system(size: 12, weight: .medium))
                                    .padding(.leading, AppSpacing.md)
                            }
                        }
                        .foregroundColor(.white.opacity(0.8))
                    }
                    .padding(.top, AppSpacing.xs)
                }
                .padding(AppSpacing.xl)
                .frame(maxWidth: .infinity, alignment: .leading)

                // Tag pill
                if let tagLabel = article.tagLabel {
                    ArticleTagPill(text: tagLabel)
                        .padding(AppSpacing.lg)
                }
            }
            .aspectRatio(16/9, contentMode: .fit)
            .clipShape(RoundedRectangle(cornerRadius: AppCornerRadius.extraLarge))
        }
        .onTapGesture {
            onTap?()
        }
    }
}

// MARK: - Category Section
private struct MoneyMovesCategorySection: View {
    let category: MoneyMoveCategory
    let moves: [MoneyMove]
    var onMoveTap: ((MoneyMove) -> Void)?
    var onBookmark: ((MoneyMove) -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header
            MoneyMovesCategorySectionHeader(category: category)
                .padding(.horizontal, AppSpacing.lg)

            // Horizontal scroll of cards
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: AppSpacing.md) {
                    ForEach(moves) { move in
                        MoneyMoveCard(
                            moneyMove: move,
                            showIcon: false,
                            onTap: { onMoveTap?(move) },
                            onBookmark: { onBookmark?(move) }
                        )
                    }
                }
                .padding(.horizontal, AppSpacing.lg)
            }
        }
    }
}

// MARK: - Category Section Header
private struct MoneyMovesCategorySectionHeader: View {
    let category: MoneyMoveCategory

    var body: some View {
        HStack(spacing: AppSpacing.md) {
            // Icon with colored background
            ZStack {
                RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                    .fill(category.iconBackgroundColor)
                    .frame(width: 36, height: 36)

                Image(systemName: category.iconName)
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(.white)
            }

            // Title and subtitle
            VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                Text(category.rawValue)
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                Text(category.tagline)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textSecondary)
            }

            Spacer()
        }
    }
}



#Preview {
    MoneyMovesDetailView()
        .environmentObject(AudioManager.shared)
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/NewsDetailView.swift
================================================================================

//
//  NewsDetailView.swift
//  ios
//
//  Main News Detail screen displaying full article information
//

import SwiftUI

struct NewsDetailView: View {
    @StateObject private var viewModel: NewsDetailViewModel
    @Environment(\.dismiss) private var dismiss
    @State private var showShareSheet = false
    @State private var showMoreOptions = false

    let article: NewsArticle

    init(article: NewsArticle) {
        self.article = article
        self._viewModel = StateObject(wrappedValue: NewsDetailViewModel(article: article))
    }

    var body: some View {
        ZStack(alignment: .bottom) {
            // Background
            AppColors.background
                .ignoresSafeArea()

            // Main Content
            VStack(spacing: 0) {
                // Header
                NewsDetailHeader(
                    source: article.source,
                    onBackTapped: handleBackTapped,
                    onMoreTapped: handleMoreTapped
                )

                // Divider
                Rectangle()
                    .fill(AppColors.cardBackgroundLight)
                    .frame(height: 1)

                // Scrollable Content
                ScrollView(showsIndicators: false) {
                    if let articleDetail = viewModel.articleDetail {
                        NewsDetailContent(
                            article: articleDetail,
                            onTickerTapped: handleTickerTapped
                        )
                        .padding(.horizontal, AppSpacing.lg)
                        .padding(.top, AppSpacing.lg)
                    } else {
                        // Loading placeholder
                        loadingPlaceholder
                    }

                    // Bottom spacing for button
                    Spacer()
                        .frame(height: 100)
                }
                .refreshable {
                    await viewModel.refresh()
                }
            }

            // Read Full Story Button (Fixed at bottom)
            if viewModel.articleDetail != nil {
                readFullStoryButton
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.bottom, AppSpacing.xxl)
            }

            // Loading overlay
            if viewModel.isLoading {
                LoadingOverlay()
            }
        }
        .preferredColorScheme(.dark)
        .navigationBarHidden(true)
        .task {
            viewModel.loadArticleDetail()
        }
        .gesture(
            DragGesture()
                .onEnded { value in
                    // Swipe right to dismiss
                    if value.translation.width > 100 {
                        handleBackTapped()
                    }
                }
        )
        .confirmationDialog("Options", isPresented: $showMoreOptions) {
            Button("Share Article") {
                showShareSheet = true
            }
            Button("Save Article") {
                handleSaveArticle()
            }
            Button("Report Issue") {
                handleReportIssue()
            }
            Button("Cancel", role: .cancel) {}
        }
        .sheet(isPresented: $showShareSheet) {
            if let url = viewModel.articleDetail?.articleURL {
                ShareSheet(items: [url])
            }
        }
    }

    // MARK: - Subviews

    private var readFullStoryButton: some View {
        Button(action: handleReadFullStory) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "arrow.up.right.square")
                    .font(.system(size: 16, weight: .semibold))

                Text("Read full story")
                    .font(AppTypography.bodyBold)
            }
            .foregroundColor(AppColors.textPrimary)
            .frame(maxWidth: .infinity)
            .padding(.vertical, AppSpacing.lg)
            .background(AppColors.primaryBlue)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(PlainButtonStyle())
    }

    private var loadingPlaceholder: some View {
        VStack(spacing: AppSpacing.lg) {
            // Headline placeholder
            RoundedRectangle(cornerRadius: AppCornerRadius.small)
                .fill(AppColors.cardBackgroundLight)
                .frame(height: 60)

            // Meta row placeholder
            HStack {
                RoundedRectangle(cornerRadius: AppCornerRadius.small)
                    .fill(AppColors.cardBackgroundLight)
                    .frame(width: 100, height: 20)
                Spacer()
            }

            // Image placeholder
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackgroundLight)
                .frame(height: 220)

            // Takeaways placeholder
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackgroundLight)
                .frame(height: 300)
        }
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.lg)
        .shimmer()
    }

    // MARK: - Action Handlers

    private func handleBackTapped() {
        dismiss()
    }

    private func handleMoreTapped() {
        showMoreOptions = true
    }

    private func handleTickerTapped(_ ticker: String) {
        print("Navigate to ticker: \(ticker)")
        // TODO: Navigate to ticker detail screen
    }

    private func handleReadFullStory() {
        viewModel.openFullStory()
    }

    private func handleSaveArticle() {
        print("Save article")
        // TODO: Implement save functionality
    }

    private func handleReportIssue() {
        print("Report issue")
        // TODO: Implement report functionality
    }
}

// MARK: - Shimmer Effect
extension View {
    func shimmer() -> some View {
        self.modifier(ShimmerModifier())
    }
}

struct ShimmerModifier: ViewModifier {
    @State private var phase: CGFloat = 0

    func body(content: Content) -> some View {
        content
            .overlay(
                GeometryReader { geometry in
                    LinearGradient(
                        gradient: Gradient(colors: [
                            Color.clear,
                            Color.white.opacity(0.1),
                            Color.clear
                        ]),
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                    .frame(width: geometry.size.width * 2)
                    .offset(x: -geometry.size.width + phase * geometry.size.width * 2)
                    .onAppear {
                        withAnimation(
                            Animation.linear(duration: 1.5)
                                .repeatForever(autoreverses: false)
                        ) {
                            phase = 1
                        }
                    }
                }
            )
            .clipped()
    }
}

// MARK: - Preview
struct NewsDetailViewStandalone: View {
    var body: some View {
        NewsDetailView(
            article: NewsArticle(
                headline: "NVIDIA Announces Record Q4 Earnings, Missed Expectations and CEO step down",
                summary: nil,
                source: NewsSource(name: "CNBC", iconName: nil),
                sentiment: .negative,
                publishedAt: Date(),
                thumbnailName: nil,
                relatedTickers: ["APPL", "ORCL", "TSLA"]
            )
        )
    }
}

#Preview {
    NewsDetailViewStandalone()
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/ResearchView.swift
================================================================================

//
//  ResearchView.swift
//  ios
//
//  Main Research screen combining all organisms
//

import SwiftUI

struct ResearchContentView: View {
    @StateObject private var viewModel: ResearchViewModel
    @State private var navigationPath = NavigationPath()
    
    init(prefilledTicker: String? = nil) {
        _viewModel = StateObject(wrappedValue: ResearchViewModel(prefilledTicker: prefilledTicker))
    }

    var body: some View {
        NavigationStack(path: $navigationPath) {
            ZStack {
                // Background
                AppColors.background
                    .ignoresSafeArea()

                // Main Content
                VStack(spacing: 0) {
                    // Header
                    ResearchHeader(
                        selectedTab: $viewModel.selectedTab,
                        onProfileTapped: handleProfileTapped
                    )

                    // Tab Content
                    if viewModel.selectedTab == .research {
                        researchTabContent
                    } else {
                        reportsTabContent
                    }
                }

                // Loading overlay
                if viewModel.isLoading {
                    LoadingOverlay()
                }
            }
            .navigationDestination(for: String.self) { ticker in
                TickerReportView(ticker: ticker)
            }
        }
    }

    // MARK: - Research Tab Content
    private var researchTabContent: some View {
        ScrollView(showsIndicators: false) {
            LazyVStack(spacing: AppSpacing.xxl) {
                // Target Selection Section
                TargetSelectionSection(
                    searchText: $viewModel.searchText,
                    quickTickers: viewModel.quickTickers,
                    onTickerSelected: handleTickerSelected,
                    onSearchSubmit: handleSearchSubmit
                )
                .padding(.top, AppSpacing.sm)

                // Persona Selection Section
                PersonaSelectionSection(
                    personas: viewModel.personas,
                    selectedPersona: $viewModel.selectedPersona,
                    onViewAllTapped: handleViewAllPersonas
                )

                // Generate Analysis Section
                GenerateAnalysisSection(
                    cost: viewModel.analysisCost,
                    remainingCredits: viewModel.creditBalance.credits,
                    isEnabled: viewModel.canGenerateAnalysis,
                    isLoading: viewModel.isGeneratingAnalysis,
                    onGenerate: handleGenerateAnalysis
                )

                // What You'll Get Section
                WhatYouGetSection(features: viewModel.features)

                // Credits Balance Card
                CreditsBalanceCard(
                    balance: viewModel.creditBalance,
                    onAddCredits: handleAddCredits
                )
                .padding(.horizontal, AppSpacing.lg)

                // Trending Analyses Section
                TrendingAnalysesSection(
                    analyses: viewModel.trendingAnalyses,
                    onExploreTapped: handleExploreTrending,
                    onAnalysisTapped: handleTrendingAnalysisTapped
                )

                // Bottom padding for tab bar
                Spacer()
                    .frame(height: AppSpacing.xxxl)
            }
        }
        .refreshable {
            await viewModel.refresh()
        }
    }

    // MARK: - Reports Tab Content
    private var reportsTabContent: some View {
        ScrollView(showsIndicators: false) {
            LazyVStack(spacing: AppSpacing.xxl) {
                // Reports List Section
                ReportsListSection(
                    reports: viewModel.reports,
                    sortOption: $viewModel.reportSortOption,
                    onReportTapped: handleReportTapped,
                    onRetryTapped: handleRetryTapped
                )
                .padding(.top, AppSpacing.sm)

                // Community Insights Section
                CommunityInsightsSection(
                    insights: viewModel.communityInsights,
                    onJoinDiscussion: handleJoinDiscussion,
                    onLike: handleLikeInsight,
                    onComment: handleCommentInsight,
                    onShare: handleShareInsight
                )

                // Bottom padding for tab bar
                Spacer()
                    .frame(height: AppSpacing.xxxl)
            }
        }
        .refreshable {
            await viewModel.refresh()
        }
    }

    // MARK: - Research Tab Action Handlers
    private func handleProfileTapped() {
        print("Profile tapped")
    }

    private func handleTickerSelected(_ ticker: QuickTicker) {
        viewModel.selectQuickTicker(ticker)
    }

    private func handleSearchSubmit() {
        print("Search submitted: \(viewModel.searchText)")
    }

    private func handleViewAllPersonas() {
        viewModel.viewAllPersonas()
    }

    private func handleGenerateAnalysis() {
        viewModel.generateAnalysis()
    }

    private func handleAddCredits() {
        viewModel.addMoreCredits()
    }

    private func handleExploreTrending() {
        viewModel.exploreTrending()
    }

    private func handleTrendingAnalysisTapped(_ analysis: TrendingAnalysis) {
        viewModel.selectTrendingAnalysis(analysis)
    }

    // MARK: - Reports Tab Action Handlers
    private func handleReportTapped(_ report: AnalysisReport) {
        guard report.status == .ready else { return }
        navigationPath.append(report.ticker)
    }

    private func handleRetryTapped(_ report: AnalysisReport) {
        viewModel.retryReport(report)
    }

    private func handleJoinDiscussion() {
        viewModel.joinDiscussion()
    }

    private func handleLikeInsight(_ insight: CommunityInsight) {
        viewModel.likeInsight(insight)
    }

    private func handleCommentInsight(_ insight: CommunityInsight) {
        viewModel.commentOnInsight(insight)
    }

    private func handleShareInsight(_ insight: CommunityInsight) {
        viewModel.shareInsight(insight)
    }
}

// MARK: - Preview
#Preview {
    ResearchContentView()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/RootContainerView.swift
================================================================================

//
//  RootContainerView.swift
//  ios
//
//  Root container view with layered architecture for global audio player
//  Manages the tab navigation, mini player overlay, and full screen player
//

import SwiftUI

struct RootContainerView: View {
    @StateObject private var audioManager = AudioManager.shared

    var body: some View {
        ZStack {
            // Layer 1: Main Tab Navigation
            MainTabView()
                .environment(\.miniPlayerVisible, audioManager.hasActiveEpisode && !audioManager.isCompactMode)

            // Layer 2: Audio Player States
            // Note: isPlayerHiddenByScroll is only used within detail views (BookCoreDetailView),
            // not at the root level. The main screen always shows the player when active.
            if audioManager.hasActiveEpisode && !audioManager.showFullScreenPlayer {
                if audioManager.isCompactMode {
                    // State B: Status Island (top, minimal pill near Dynamic Island)
                    VStack {
                        AudioStatusIsland()
                            .padding(.top, 8) // Below Dynamic Island
                        Spacer()
                    }
                    .transition(.asymmetric(
                        insertion: .move(edge: .top).combined(with: .opacity),
                        removal: .move(edge: .top).combined(with: .opacity)
                    ))
                } else {
                    // State A: Full Mini Player (bottom, floating above tab bar)
                    VStack {
                        Spacer()
                        GlobalMiniPlayer()
                            .padding(.bottom, 49) // Tab bar height
                    }
                    .transition(.asymmetric(
                        insertion: .move(edge: .bottom).combined(with: .opacity),
                        removal: .move(edge: .bottom).combined(with: .opacity)
                    ))
                }
            }

            // Layer 3: Full Screen Player (modal overlay)
            if audioManager.showFullScreenPlayer {
                FullScreenAudioPlayer()
                    .transition(.move(edge: .bottom))
                    .zIndex(100)
            }
        }
        .environmentObject(audioManager)
        .animation(.spring(response: 0.35, dampingFraction: 0.85), value: audioManager.hasActiveEpisode)
        .animation(.spring(response: 0.3, dampingFraction: 0.85), value: audioManager.isCompactMode)
        .animation(.spring(response: 0.4, dampingFraction: 0.85), value: audioManager.showFullScreenPlayer)
        .preferredColorScheme(.dark)
    }
}

// MARK: - Mini Player Visibility Environment Key
struct MiniPlayerVisibleKey: EnvironmentKey {
    static let defaultValue: Bool = false
}

extension EnvironmentValues {
    var miniPlayerVisible: Bool {
        get { self[MiniPlayerVisibleKey.self] }
        set { self[MiniPlayerVisibleKey.self] = newValue }
    }
}

// MARK: - Mini Player Safe Area Modifier
/// Adds extra bottom padding to scrollable content when mini player is visible
struct MiniPlayerSafeAreaModifier: ViewModifier {
    @Environment(\.miniPlayerVisible) private var miniPlayerVisible

    // Mini player height (72) + padding (8) + extra spacing (8)
    private let miniPlayerHeight: CGFloat = 88

    func body(content: Content) -> some View {
        content
            .safeAreaInset(edge: .bottom) {
                if miniPlayerVisible {
                    Color.clear
                        .frame(height: miniPlayerHeight)
                }
            }
    }
}

extension View {
    /// Adds extra bottom safe area when mini player is visible
    /// Apply this to ScrollViews and Lists to prevent content being hidden
    func miniPlayerSafeArea() -> some View {
        modifier(MiniPlayerSafeAreaModifier())
    }
}

// MARK: - Alternative: Content Inset Modifier
/// For ScrollViews that need contentInsets instead of safeAreaInset
struct MiniPlayerContentInsetModifier: ViewModifier {
    @Environment(\.miniPlayerVisible) private var miniPlayerVisible

    private let miniPlayerHeight: CGFloat = 88

    func body(content: Content) -> some View {
        content
            .padding(.bottom, miniPlayerVisible ? miniPlayerHeight : 0)
    }
}

extension View {
    /// Adds bottom padding when mini player is visible
    /// Use this for content that doesn't support safeAreaInset
    func miniPlayerContentInset() -> some View {
        modifier(MiniPlayerContentInsetModifier())
    }
}

// MARK: - Preview
#Preview {
    RootContainerView()
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/SearchView.swift
================================================================================

//
//  SearchView.swift
//  ios
//
//  Search screen combining all search-related organisms
//

import SwiftUI

struct SearchView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel = SearchViewModel()
    @State private var selectedNewsArticle: NewsArticle?

    var body: some View {
        ZStack {
            // Background
            AppColors.background
                .ignoresSafeArea()

            // Main Content
            VStack(spacing: 0) {
                // Header with search bar
                SearchHeader(
                    searchText: $viewModel.searchText,
                    suggestions: viewModel.querySuggestions,
                    onBackTapped: handleBackTapped,
                    onSearchSubmit: handleSearchSubmit,
                    onSuggestionTapped: handleSuggestionTapped
                )

                // Scrollable Content
                ScrollView(showsIndicators: false) {
                    LazyVStack(spacing: AppSpacing.xxl) {
                        // Recent Searches Section
                        RecentSearchesSection(
                            items: viewModel.recentSearches,
                            onClearAll: handleClearAll,
                            onItemTapped: handleSearchItemTapped,
                            onFollowTapped: handleFollowTapped
                        )

                        // Latest News Section
                        SearchLatestNewsSection(
                            items: viewModel.latestNews,
                            onItemTapped: handleNewsItemTapped,
                            onReadMore: handleNewsReadMore
                        )

                        // AI-Enabled Books Section
                        SearchBooksSection(
                            books: viewModel.books,
                            onChatWithBook: handleChatWithBook,
                            onReadKeyIdeas: handleReadKeyIdeas
                        )

                        // Bottom spacing for safe area
                        Spacer()
                            .frame(height: AppSpacing.xxxl)
                    }
                    .padding(.top, AppSpacing.md)
                }
                .refreshable {
                    await viewModel.refresh()
                }
            }

            // Loading overlay
            if viewModel.isLoading {
                LoadingOverlay()
            }
        }
        .navigationBarHidden(true)
        .gesture(
            DragGesture()
                .onEnded { gesture in
                    // Swipe right to go back
                    if gesture.translation.width > 100 {
                        handleBackTapped()
                    }
                }
        )
        .fullScreenCover(item: $selectedNewsArticle) { article in
            NewsDetailView(article: article)
                .preferredColorScheme(.dark)
        }
    }

    // MARK: - Action Handlers
    private func handleBackTapped() {
        dismiss()
    }

    private func handleSearchSubmit() {
        viewModel.performSearch()
    }

    private func handleSuggestionTapped(_ suggestion: SearchQuerySuggestion) {
        viewModel.selectSuggestion(suggestion)
    }

    private func handleClearAll() {
        viewModel.clearAllRecentSearches()
    }

    private func handleSearchItemTapped(_ item: SearchResultItem) {
        viewModel.selectSearchResult(item)
    }

    private func handleFollowTapped(_ item: SearchResultItem) {
        viewModel.toggleFollow(for: item)
    }

    private func handleNewsItemTapped(_ item: SearchNewsItem) {
        // Convert SearchNewsItem to NewsArticle and show detail
        selectedNewsArticle = NewsArticle(
            headline: item.headline,
            summary: item.summary,
            source: NewsSource(name: item.source, iconName: nil),
            sentiment: .neutral,
            publishedAt: Date(),
            thumbnailName: item.imageName,
            relatedTickers: []
        )
    }

    private func handleNewsReadMore(_ item: SearchNewsItem) {
        handleNewsItemTapped(item)
    }

    private func handleChatWithBook(_ book: SearchBookItem) {
        viewModel.chatWithBook(book)
    }

    private func handleReadKeyIdeas(_ book: SearchBookItem) {
        viewModel.readKeyIdeas(book)
    }
}

// MARK: - SearchContentView (For use in NavigationStack)
struct SearchContentView: View {
    @StateObject private var viewModel = SearchViewModel()
    @State private var selectedNewsArticle: NewsArticle?
    var onDismiss: (() -> Void)?

    var body: some View {
        ZStack {
            // Background
            AppColors.background
                .ignoresSafeArea()

            // Main Content
            VStack(spacing: 0) {
                // Header with search bar
                SearchHeader(
                    searchText: $viewModel.searchText,
                    suggestions: viewModel.querySuggestions,
                    onBackTapped: { onDismiss?() },
                    onSearchSubmit: { viewModel.performSearch() },
                    onSuggestionTapped: { viewModel.selectSuggestion($0) }
                )

                // Scrollable Content
                ScrollView(showsIndicators: false) {
                    LazyVStack(spacing: AppSpacing.xxl) {
                        // Recent Searches Section
                        RecentSearchesSection(
                            items: viewModel.recentSearches,
                            onClearAll: { viewModel.clearAllRecentSearches() },
                            onItemTapped: { viewModel.selectSearchResult($0) },
                            onFollowTapped: { viewModel.toggleFollow(for: $0) }
                        )

                        // Latest News Section
                        SearchLatestNewsSection(
                            items: viewModel.latestNews,
                            onItemTapped: { item in
                                selectedNewsArticle = NewsArticle(
                                    headline: item.headline,
                                    summary: item.summary,
                                    source: NewsSource(name: item.source, iconName: nil),
                                    sentiment: .neutral,
                                    publishedAt: Date(),
                                    thumbnailName: item.imageName,
                                    relatedTickers: []
                                )
                            },
                            onReadMore: { item in
                                selectedNewsArticle = NewsArticle(
                                    headline: item.headline,
                                    summary: item.summary,
                                    source: NewsSource(name: item.source, iconName: nil),
                                    sentiment: .neutral,
                                    publishedAt: Date(),
                                    thumbnailName: item.imageName,
                                    relatedTickers: []
                                )
                            }
                        )

                        // AI-Enabled Books Section
                        SearchBooksSection(
                            books: viewModel.books,
                            onChatWithBook: { viewModel.chatWithBook($0) },
                            onReadKeyIdeas: { viewModel.readKeyIdeas($0) }
                        )

                        // Bottom spacing
                        Spacer()
                            .frame(height: AppSpacing.xxxl)
                    }
                    .padding(.top, AppSpacing.md)
                }
                .refreshable {
                    await viewModel.refresh()
                }
            }

            // Loading overlay
            if viewModel.isLoading {
                LoadingOverlay()
            }
        }
        .gesture(
            DragGesture()
                .onEnded { gesture in
                    if gesture.translation.width > 100 {
                        onDismiss?()
                    }
                }
        )
        .fullScreenCover(item: $selectedNewsArticle) { article in
            NewsDetailView(article: article)
                .preferredColorScheme(.dark)
        }
    }
}

#Preview {
    SearchView()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/TechnicalAnalysisDetailView.swift
================================================================================

//
//  TechnicalAnalysisDetailView.swift
//  ios
//
//  Full Technical Analysis detail screen
//

import SwiftUI

struct TechnicalAnalysisDetailView: View {
    let detailData: TechnicalAnalysisDetailData
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            VStack(spacing: 0) {
                // Navigation Header
                TechnicalDetailHeader(
                    symbol: detailData.symbol,
                    onBackTapped: { dismiss() },
                    onInfoTapped: { /* Info action */ }
                )

                // Scrollable content
                ScrollView(showsIndicators: false) {
                    VStack(spacing: AppSpacing.lg) {
                        // Moving Averages
                        MovingAveragesSection(
                            indicators: detailData.movingAverages,
                            summary: detailData.movingAveragesSummary
                        )

                        // Oscillators
                        OscillatorsSection(
                            indicators: detailData.oscillators,
                            summary: detailData.oscillatorsSummary
                        )

                        // Pivot Points
                        PivotPointsSection(pivotData: detailData.pivotPoints)

                        // Volume Analysis
                        VolumeAnalysisSection(volumeData: detailData.volumeAnalysis)

                        // Fibonacci Retracement
                        FibonacciRetracementSection(fibData: detailData.fibonacciRetracement)

                        // Key Support & Resistance
                        SupportResistanceSection(srData: detailData.supportResistance)

                        // Disclaimer
                        AnalysisDisclaimerText()
                            .padding(.horizontal, AppSpacing.lg)

                        // Bottom spacing
                        Spacer()
                            .frame(height: AppSpacing.xxxl)
                    }
                    .padding(.horizontal, AppSpacing.lg)
                    .padding(.top, AppSpacing.lg)
                }
            }
        }
        .navigationBarHidden(true)
    }
}

// MARK: - Technical Detail Header
struct TechnicalDetailHeader: View {
    let symbol: String
    let onBackTapped: () -> Void
    let onInfoTapped: () -> Void

    var body: some View {
        HStack {
            Button(action: onBackTapped) {
                Image(systemName: "chevron.left")
                    .font(.system(size: 18, weight: .medium))
                    .foregroundColor(AppColors.textPrimary)
            }
            .frame(width: 44, height: 44)

            Spacer()

            Text("\(symbol) Technical Analysis")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)

            Spacer()

            Button(action: onInfoTapped) {
                Image(systemName: "info.circle")
                    .font(.system(size: 18))
                    .foregroundColor(AppColors.textMuted)
            }
            .frame(width: 44, height: 44)
        }
        .padding(.horizontal, AppSpacing.sm)
        .padding(.vertical, AppSpacing.sm)
        .background(AppColors.background)
    }
}

#Preview {
    TechnicalAnalysisDetailView(detailData: TechnicalAnalysisDetailData.sampleData)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/TickerDetailView.swift
================================================================================

//
//  TickerDetailView.swift
//  ios
//
//  Main Ticker Detail screen displaying stock information
//

import SwiftUI

struct TickerDetailView: View {
    @StateObject private var viewModel: TickerDetailViewModel
    @Environment(\.dismiss) private var dismiss
    @State private var showMoreOptions = false
    @State private var showUpgradesDowngrades = false
    @State private var showTechnicalAnalysisDetail = false
    @State private var isTabBarPinned: Bool = false
    @State private var scrollOffset: CGFloat = 0

    let tickerSymbol: String
    var onNavigateToResearch: (() -> Void)?

    init(tickerSymbol: String, onNavigateToResearch: (() -> Void)? = nil) {
        self.tickerSymbol = tickerSymbol
        self.onNavigateToResearch = onNavigateToResearch
        self._viewModel = StateObject(wrappedValue: TickerDetailViewModel(tickerSymbol: tickerSymbol))
    }

    var body: some View {
        ZStack(alignment: .bottom) {
            // Background
            AppColors.background
                .ignoresSafeArea()

            // Main Content
            VStack(spacing: 0) {
                // Navigation Header (always visible - back, bell, star, more buttons)
                // Shows ticker symbol and price when tab bar is pinned
                TickerDetailHeader(
                    onBackTapped: handleBackTapped,
                    onNotificationTapped: viewModel.handleNotificationTap,
                    onFavoriteTapped: viewModel.toggleFavorite,
                    onMoreTapped: handleMoreTapped,
                    isFavorite: viewModel.isFavorite,
                    tickerSymbol: isTabBarPinned ? viewModel.tickerData?.symbol : nil,
                    tickerPrice: isTabBarPinned ? viewModel.tickerData?.formattedPrice : nil
                )

                // Scrollable Content with pinned tab bar
                ScrollView(showsIndicators: false) {
                    LazyVStack(spacing: 0, pinnedViews: [.sectionHeaders]) {
                        // Content above tab bar (scrolls away)
                        if let tickerData = viewModel.tickerData {
                            // Full Ticker Price Header
                            TickerPriceHeader(
                                companyName: tickerData.companyName,
                                symbol: tickerData.symbol,
                                price: tickerData.formattedPrice,
                                priceChange: tickerData.formattedChange,
                                priceChangePercent: tickerData.formattedChangePercent,
                                isPositive: tickerData.isPositive,
                                marketStatus: tickerData.marketStatus
                            )
                            .padding(.top, AppSpacing.sm)

                            // Chart
                            TickerChartView(
                                chartData: tickerData.chartData,
                                isPositive: tickerData.isPositive,
                                selectedRange: $viewModel.selectedChartRange
                            )
                            .padding(.top, AppSpacing.lg)
                        }

                        // Section with pinned tab bar header
                        Section {
                            // Tab Content
                            tabContent
                        } header: {
                            // Tab Bar - this will stick at the top when scrolling
                            VStack(spacing: 0) {
                                TickerDetailTabBar(selectedTab: $viewModel.selectedTab)
                                    .padding(.top, AppSpacing.lg)

                                // Divider
                                Rectangle()
                                    .fill(AppColors.cardBackgroundLight)
                                    .frame(height: 1)
                            }
                            .background(AppColors.background)
                            .background(
                                GeometryReader { geometry in
                                    Color.clear
                                        .preference(
                                            key: TabBarPositionPreferenceKey.self,
                                            value: geometry.frame(in: .named("scroll")).minY
                                        )
                                }
                            )
                        }
                    }
                }
                .coordinateSpace(name: "scroll")
                .onPreferenceChange(TabBarPositionPreferenceKey.self) { position in
                    // Tab bar is pinned when it reaches the top
                    let shouldPin = position <= 0
                    if shouldPin != isTabBarPinned {
                        isTabBarPinned = shouldPin
                    }
                }
                .refreshable {
                    await viewModel.refresh()
                }
            }

            // Bottom AI Chat Bar (always visible)
            TickerDetailAIBar(
                inputText: $viewModel.aiInputText,
                tickerSymbol: tickerSymbol,
                suggestions: viewModel.aiSuggestions,
                onSuggestionTap: viewModel.handleSuggestionTap,
                onSend: viewModel.handleAISend
            )

            // Loading overlay
            if viewModel.isLoading {
                LoadingOverlay()
            }
        }
        .preferredColorScheme(.dark)
        .navigationBarHidden(true)
        .task {
            viewModel.loadTickerData()
        }
        .gesture(
            DragGesture()
                .onEnded { value in
                    // Swipe right to dismiss
                    if value.translation.width > 100 {
                        handleBackTapped()
                    }
                }
        )
        .confirmationDialog("Options", isPresented: $showMoreOptions) {
            Button("Share") {
                handleShare()
            }
            Button("Add to Watchlist") {
                handleAddToWatchlist()
            }
            Button("Set Price Alert") {
                handleSetPriceAlert()
            }
            Button("Compare") {
                handleCompare()
            }
            Button("Cancel", role: .cancel) {}
        }
        .sheet(isPresented: $showUpgradesDowngrades) {
            if let analysisData = viewModel.analysisData {
                UpgradesDowngradesView(actions: analysisData.analystRatings.actions)
            }
        }
        .sheet(isPresented: $showTechnicalAnalysisDetail) {
            TechnicalAnalysisDetailView(
                detailData: TechnicalAnalysisDetailData.sampleData
            )
        }
    }

    // MARK: - Tab Content

    @ViewBuilder
    private var tabContent: some View {
        switch viewModel.selectedTab {
        case .overview:
            if let tickerData = viewModel.tickerData {
                TickerDetailOverviewContent(
                    tickerData: tickerData,
                    onDeepResearchTap: {
                        handleDeepResearchTap()
                    },
                    onWebsiteTap: viewModel.handleWebsiteTap,
                    onRelatedTickerTap: viewModel.handleRelatedTickerTap
                )
            }
        case .news:
            TickerNewsContent(
                articles: viewModel.newsArticles,
                currentTicker: tickerSymbol,
                onArticleTap: viewModel.handleNewsArticleTap,
                onExternalLinkTap: viewModel.handleNewsExternalLink,
                onRelatedTickerTap: viewModel.handleNewsTickerTap
            )
        case .analysis:
            if let analysisData = viewModel.analysisData {
                TickerAnalysisContent(
                    analysisData: analysisData,
                    selectedMomentumPeriod: $viewModel.selectedMomentumPeriod,
                    selectedSentimentTimeframe: $viewModel.selectedSentimentTimeframe,
                    onAnalystRatingsMoreTap: viewModel.handleAnalystRatingsMore,
                    onAnalystActionsTap: {
                        showUpgradesDowngrades = true
                    },
                    onSentimentMoreTap: viewModel.handleSentimentMore,
                    onTechnicalDetailTap: {
                        showTechnicalAnalysisDetail = true
                    }
                )
            } else {
                placeholderContent(title: "Analysis", description: "Loading analysis data...")
            }
        case .financials:
            if let earningsData = viewModel.earningsData {
                TickerFinancialsContent(
                    earningsData: earningsData,
                    growthData: viewModel.growthData,
                    profitPowerData: viewModel.profitPowerData,
                    signalOfConfidenceData: viewModel.signalOfConfidenceData,
                    revenueBreakdownData: viewModel.revenueBreakdownData,
                    healthCheckData: viewModel.healthCheckData,
                    onEarningsDetailTap: viewModel.handleEarningsDetail,
                    onGrowthDetailTap: viewModel.handleGrowthDetail,
                    onProfitPowerDetailTap: viewModel.handleProfitPowerDetail,
                    onSignalOfConfidenceDetailTap: viewModel.handleSignalOfConfidenceDetail,
                    onRevenueBreakdownDetailTap: viewModel.handleRevenueBreakdownDetail,
                    onHealthCheckDetailTap: viewModel.handleHealthCheckDetail
                )
            } else {
                placeholderContent(title: "Financials", description: "Loading financial data...")
            }
        case .holders:
            if let holdersData = viewModel.holdersData {
                TickerHoldersContent(
                    holdersData: holdersData
                )
            } else {
                placeholderContent(title: "Holders", description: "Loading holders data...")
            }
        }
    }

    private func placeholderContent(title: String, description: String) -> some View {
        VStack(spacing: AppSpacing.lg) {
            Image(systemName: "chart.bar.doc.horizontal")
                .font(.system(size: 48))
                .foregroundColor(AppColors.textMuted)

            Text(title)
                .font(AppTypography.title2)
                .foregroundColor(AppColors.textPrimary)

            Text(description)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .multilineTextAlignment(.center)

            Spacer()
                .frame(height: 150)
        }
        .frame(maxWidth: .infinity)
        .padding(.top, AppSpacing.xxxl)
        .padding(.horizontal, AppSpacing.lg)
    }

    // MARK: - Action Handlers

    private func handleBackTapped() {
        dismiss()
    }

    private func handleDeepResearchTap() {
        if let onNavigateToResearch = onNavigateToResearch {
            dismiss()
            onNavigateToResearch()
        }
    }

    private func handleMoreTapped() {
        showMoreOptions = true
    }

    private func handleShare() {
        print("Share \(tickerSymbol)")
    }

    private func handleAddToWatchlist() {
        print("Add \(tickerSymbol) to watchlist")
    }

    private func handleSetPriceAlert() {
        print("Set price alert for \(tickerSymbol)")
    }

    private func handleCompare() {
        print("Compare \(tickerSymbol)")
    }
}

// MARK: - Tab Bar Position Preference Key
struct TabBarPositionPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = .infinity
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

// MARK: - Preview
#Preview {
    TickerDetailView(tickerSymbol: "AAPL")
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/TickerReportView.swift
================================================================================

//
//  TickerReportView.swift
//  ios
//
//  Screen: Full stock report view (Buffett Agent style analysis)
//  Combines all report organisms into a scrollable report layout
//

import SwiftUI

struct TickerReportView: View {
    @StateObject private var viewModel: TickerReportViewModel
    @Environment(\.dismiss) private var dismiss

    init(ticker: String) {
        _viewModel = StateObject(wrappedValue: TickerReportViewModel(ticker: ticker))
    }

    var body: some View {
        ZStack {
            // Background
            AppColors.background    
                .ignoresSafeArea()

            if viewModel.isLoading {
                loadingView
            } else if let report = viewModel.reportData {
                reportContent(report)
            }
        }
        .navigationBarHidden(true)
    }

    // MARK: - Loading View

    private var loadingView: some View {
        VStack(spacing: AppSpacing.lg) {
            ProgressView()
                .tint(AppColors.primaryBlue)
                .scaleEffect(1.2)
            Text("Loading report...")
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
        }
    }

    // MARK: - Report Content

    private func reportContent(_ report: TickerReportData) -> some View {
        ZStack(alignment: .bottom) {
            ScrollView(showsIndicators: false) {
                LazyVStack(spacing: AppSpacing.xxl) {
                    // Header
                    headerSection(report)

                    // Agent Badge + Score
                    agentScoreSection(report)

                    // Executive Summary
                    ReportExecutiveSummaryCard(
                        summaryText: report.executiveSummaryText,
                        bullets: report.executiveSummaryBullets
                    )
                    .padding(.horizontal, AppSpacing.lg)

                    // Key Vitals
                    ReportKeyVitalsSection(vitals: report.keyVitals)

                    // Core Thesis
                    ReportCoreThesisSection(thesis: report.coreThesis)

                    // Deep Dive Modules
                    deepDiveModulesSection(report)

                    // Critical Factors
                    ReportCriticalFactorsSection(factors: report.criticalFactors)

                    // View Detailed Analysis button
                    detailedAnalysisButton

                    // Disclaimer
                    disclaimerSection(report)

                    // Bottom padding for chat bar
                    Spacer()
                        .frame(height: 80)
                }
                .padding(.top, AppSpacing.sm)
            }
            .refreshable {
                await viewModel.refresh()
            }

            // Floating chat bar
            ReportChatBar(onTapped: viewModel.chatWithReport)
                .padding(.horizontal, AppSpacing.lg)
                .padding(.bottom, AppSpacing.sm)
        }
    }

    // MARK: - Header Section

    private func headerSection(_ report: TickerReportData) -> some View {
        VStack(spacing: AppSpacing.xs) {
            ReportHeaderBar(
                companyName: report.companyName,
                ticker: report.symbol,
                exchange: report.exchange,
                onBack: { dismiss() },
                onShare: viewModel.shareTapped
            )

            Text(report.liveDate)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.horizontal, AppSpacing.lg)
        }
    }

    // MARK: - Agent + Score Section

    private func agentScoreSection(_ report: TickerReportData) -> some View {
        VStack(spacing: AppSpacing.lg) {
            ReportAgentBadge(agent: report.agent)

            ReportScoreGauge(
                score: report.qualityRating.score,
                maxScore: report.qualityRating.maxScore,
                label: report.qualityRating.label
            )
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, AppSpacing.sm)
    }

    // MARK: - Deep Dive Modules

    private func deepDiveModulesSection(_ report: TickerReportData) -> some View {
        VStack(alignment: .leading, spacing: 0) {
            Text("Deep Dive Modules")
                .font(AppTypography.headline)
                .foregroundColor(AppColors.textPrimary)
                .padding(.horizontal, AppSpacing.lg)
                .padding(.bottom, AppSpacing.md)

            VStack(spacing: 0) {
                ForEach(viewModel.deepDiveModules) { module in
                    ReportDeepDiveSection(
                        module: module,
                        isExpanded: viewModel.isSectionExpanded(module.type),
                        onToggle: { viewModel.toggleSection(module.type) }
                    ) {
                        deepDiveContent(for: module.type, report: report)
                    }
                }
            }
            .clipShape(RoundedRectangle(cornerRadius: AppCornerRadius.large))
            .padding(.horizontal, AppSpacing.lg)
        }
    }

    // MARK: - Deep Dive Content Router

    @ViewBuilder
    private func deepDiveContent(for type: DeepDiveModuleType, report: TickerReportData) -> some View {
        switch type {
        case .recentPriceMovement:
            ReportPriceMovementSection(data: report.priceAction)
        case .revenueEngine:
            ReportRevenueEngineSection(data: report.revenueEngine)
        case .fundamentalsGrowth:
            ReportFundamentalsSection(
                metrics: report.fundamentalMetrics,
                assessment: report.overallAssessment
            )
        case .futureForecast:
            ReportFutureForecastSection(forecast: report.revenueForecast)
        case .insiderManagement:
            ReportInsiderSection(
                insiderData: report.insiderData,
                management: report.keyManagement
            )
        case .moatCompetition:
            ReportMoatCompetitionSection(data: report.moatCompetition)
        case .macroGeopolitical:
            ReportMacroGeopoliticalSection(data: report.macroData)
        case .wallStreetConsensus:
            ReportWallStreetSection(consensus: report.wallStreetConsensus)
        }
    }

    // MARK: - View Detailed Analysis Button

    private var detailedAnalysisButton: some View {
        Button(action: viewModel.viewDetailedAnalysis) {
            HStack(spacing: AppSpacing.sm) {
                Text("View Detailed Analysis")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.primaryBlue)

                Image(systemName: "arrow.right")
                    .font(.system(size: 12, weight: .semibold))
                    .foregroundColor(AppColors.primaryBlue)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, AppSpacing.lg)
        }
        .padding(.horizontal, AppSpacing.lg)
    }

    // MARK: - Disclaimer

    private func disclaimerSection(_ report: TickerReportData) -> some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            Text("Disclaimer")
                .font(AppTypography.footnoteBold)
                .foregroundColor(AppColors.textSecondary)

            Text(report.disclaimerText)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
                .lineSpacing(3)
        }
        .padding(.horizontal, AppSpacing.lg)
    }
}

// MARK: - Preview

#Preview {
    NavigationStack {
        TickerReportView(ticker: "ORCL")
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/TrackingView.swift
================================================================================

//
//  TrackingView.swift
//  ios
//
//  Main Tracking screen with Assets and Whales tabs
//

import SwiftUI

// MARK: - Navigation Models
/// Wrapper for trade group navigation to conform to Hashable
struct TradeGroupNavigation: Identifiable, Hashable {
    let id: String
    let tradeGroup: WhaleTradeGroup
    let whaleName: String
    
    init(tradeGroup: WhaleTradeGroup, whaleName: String) {
        self.id = tradeGroup.id
        self.tradeGroup = tradeGroup
        self.whaleName = whaleName
    }
    
    static func == (lhs: TradeGroupNavigation, rhs: TradeGroupNavigation) -> Bool {
        lhs.id == rhs.id
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}

// MARK: - TrackingContentView (Used in TabView)
struct TrackingContentView: View {
    @StateObject private var viewModel = TrackingViewModel()

    var body: some View {
        NavigationStack {
            ZStack {
                // Background
                AppColors.background
                    .ignoresSafeArea()

                // Main Content
                VStack(spacing: 0) {
                    // Header with Search and Tab Control
                    TrackingHeader(
                        searchText: $viewModel.searchText,
                        selectedTab: $viewModel.selectedTab,
                        onProfileTapped: handleProfileTapped,
                        onSearchSubmit: handleSearchSubmit
                    )

                    // Tab Content
                    TabView(selection: $viewModel.selectedTab) {
                        // Assets Tab
                        AssetsTabContent(viewModel: viewModel)
                            .tag(TrackingTab.assets)

                        // Whales Tab
                        WhalesTabContent(viewModel: viewModel)
                            .tag(TrackingTab.whales)
                    }
                    .tabViewStyle(.page(indexDisplayMode: .never))
                    .animation(.easeInOut(duration: 0.2), value: viewModel.selectedTab)
                }

                // Loading overlay
                if viewModel.isLoading {
                    LoadingOverlay()
                }
            }
            .sheet(isPresented: $viewModel.showAddAssetSheet) {
                AddAssetSheet(onDismiss: {
                    viewModel.showAddAssetSheet = false
                })
            }
            .sheet(isPresented: $viewModel.showSortSheet) {
                SortOptionsSheet(
                    selectedOption: viewModel.sortOption,
                    onSelect: { option in
                        viewModel.selectSortOption(option)
                    },
                    onDismiss: {
                        viewModel.showSortSheet = false
                    }
                )
            }
            .navigationDestination(item: $viewModel.selectedTickerSymbol) { ticker in
                TickerDetailView(tickerSymbol: ticker)
            }
            .navigationDestination(item: $viewModel.selectedWhaleId) { whaleId in
                WhaleProfileView(whaleId: whaleId)
            }
            .navigationDestination(item: $viewModel.selectedTradeGroup) { tradeData in
                TradeGroupDetailView(
                    tradeGroup: tradeData.tradeGroup,
                    whaleName: tradeData.whaleName
                )
            }
        }
    }

    // MARK: - Action Handlers
    private func handleProfileTapped() {
        print("Profile tapped")
    }

    private func handleSearchSubmit() {
        print("Search submitted: \(viewModel.searchText)")
    }
}

// MARK: - TrackingContentViewWithBinding (Used when tab navigation needed)
struct TrackingContentViewWithBinding: View {
    @StateObject private var viewModel = TrackingViewModel()
    @Binding var selectedTab: HomeTab
    @Binding var researchTickerSymbol: String?

    var body: some View {
        NavigationStack {
            ZStack {
                // Background
                AppColors.background
                    .ignoresSafeArea()

                // Main Content
                VStack(spacing: 0) {
                    // Header with Search and Tab Control
                    TrackingHeader(
                        searchText: $viewModel.searchText,
                        selectedTab: $viewModel.selectedTab,
                        onProfileTapped: handleProfileTapped,
                        onSearchSubmit: handleSearchSubmit
                    )

                    // Tab Content
                    TabView(selection: $viewModel.selectedTab) {
                        // Assets Tab
                        AssetsTabContent(viewModel: viewModel)
                            .tag(TrackingTab.assets)

                        // Whales Tab
                        WhalesTabContent(viewModel: viewModel)
                            .tag(TrackingTab.whales)
                    }
                    .tabViewStyle(.page(indexDisplayMode: .never))
                    .animation(.easeInOut(duration: 0.2), value: viewModel.selectedTab)
                }

                // Loading overlay
                if viewModel.isLoading {
                    LoadingOverlay()
                }
            }
            .sheet(isPresented: $viewModel.showAddAssetSheet) {
                AddAssetSheet(onDismiss: {
                    viewModel.showAddAssetSheet = false
                })
            }
            .sheet(isPresented: $viewModel.showSortSheet) {
                SortOptionsSheet(
                    selectedOption: viewModel.sortOption,
                    onSelect: { option in
                        viewModel.selectSortOption(option)
                    },
                    onDismiss: {
                        viewModel.showSortSheet = false
                    }
                )
            }
            .navigationDestination(item: $viewModel.selectedTickerSymbol) { ticker in
                TickerDetailView(tickerSymbol: ticker, onNavigateToResearch: {
                    researchTickerSymbol = ticker
                    selectedTab = .research
                })
            }
            .navigationDestination(item: $viewModel.selectedWhaleId) { whaleId in
                WhaleProfileView(whaleId: whaleId)
            }
            .navigationDestination(item: $viewModel.selectedTradeGroup) { tradeData in
                TradeGroupDetailView(
                    tradeGroup: tradeData.tradeGroup,
                    whaleName: tradeData.whaleName
                )
            }
        }
    }

    // MARK: - Action Handlers
    private func handleProfileTapped() {
        print("Profile tapped")
    }

    private func handleSearchSubmit() {
        print("Search submitted: \(viewModel.searchText)")
    }
}

// MARK: - Assets Tab Content
struct AssetsTabContent: View {
    @ObservedObject var viewModel: TrackingViewModel

    var body: some View {
        ScrollView(showsIndicators: false) {
            LazyVStack(spacing: AppSpacing.xxl) {
                // Assets List Section
                AssetsListSection(
                    assets: viewModel.filteredAssets,
                    onSortTapped: { viewModel.openSortOptions() },
                    onAddTapped: { viewModel.addNewAsset() },
                    onAssetTapped: { asset in viewModel.viewAssetDetail(asset) }
                )
                .padding(.top, AppSpacing.sm)

                // Alerts & Upcoming Events Section
                AlertsEventsSection(
                    alerts: viewModel.alertEvents,
                    smartMoneyAlert: viewModel.smartMoneyAlert,
                    onAlertTapped: { alert in viewModel.viewAlertDetail(alert) },
                    onSmartMoneyTapped: { print("Smart money tapped") }
                )

                // Portfolio Insights Section
                PortfolioInsightsSection(score: viewModel.diversificationScore)

                // Bottom spacing for tab bar
                Spacer()
                    .frame(height: 100)
            }
        }
        .refreshable {
            await viewModel.refresh()
        }
    }
}

// MARK: - Whales Tab Content
struct WhalesTabContent: View {
    @ObservedObject var viewModel: TrackingViewModel

    var body: some View {
        ScrollView(showsIndicators: false) {
            LazyVStack(spacing: AppSpacing.xl) {
                // 1. Followed Whale Profiles (horizontal scroll)
                if !viewModel.trackedWhales.isEmpty {
                    FollowedWhalesRow(
                        whales: viewModel.trackedWhales,
                        onWhaleTapped: { whale in viewModel.viewWhaleProfile(whale) }
                    )
                    .padding(.top, AppSpacing.sm)
                }

                // 2. Recent Trades Timeline
                if !viewModel.groupedWhaleTrades.isEmpty {
                    WhaleTradesTimelineSection(
                        groupedTrades: viewModel.groupedWhaleTrades,
                        onActivityTapped: { activity in viewModel.viewTradeGroupDetail(activity) },
                        onMoreTapped: { viewModel.viewMoreRecentTrades() }
                    )
                }

                // 3. Whale Alert Banner
                if let alert = viewModel.whaleAlertBanner {
                    WhaleAlertBannerCard(
                        alert: alert,
                        onViewAlert: { viewModel.viewWhaleAlert() }
                    )
                    .padding(.horizontal, AppSpacing.lg)
                }

                // 4. Most Popular Whales (unchanged)
                MostPopularWhalesSection(
                    heroWhales: viewModel.heroWhales,
                    whales: viewModel.popularWhales,
                    onFollowToggle: { whale in viewModel.toggleFollowWhale(whale) },
                    onWhaleTapped: { whale in viewModel.viewWhaleProfile(whale) },
                    onMoreTapped: { viewModel.viewMorePopularWhales() }
                )

                // Bottom spacing
                Spacer()
                    .frame(height: 100)
            }
        }
        .refreshable {
            await viewModel.refresh()
        }
        .navigationDestination(isPresented: $viewModel.showAllWhales) {
            AllWhalesView(viewModel: viewModel)
        }
        .navigationDestination(isPresented: $viewModel.showAllTrades) {
            AllRecentTradesView(viewModel: viewModel)
        }
    }
}

// MARK: - Followed Whales Row (Horizontal Scroll)
struct FollowedWhalesRow: View {
    let whales: [TrendingWhale]
    var onWhaleTapped: ((TrendingWhale) -> Void)?

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: AppSpacing.lg) {
                ForEach(whales) { whale in
                    Button {
                        onWhaleTapped?(whale)
                    } label: {
                        VStack(spacing: AppSpacing.sm) {
                            // Avatar
                            Circle()
                                .fill(AppColors.cardBackgroundLight)
                                .frame(width: 64, height: 64)
                                .overlay(
                                    Image(systemName: "person.fill")
                                        .font(.system(size: 28))
                                        .foregroundColor(AppColors.textMuted)
                                )

                            // Name
                            Text(whale.name.components(separatedBy: " ").last ?? whale.name)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textPrimary)
                                .lineLimit(1)

                            // Trade count
                            Text(whale.formattedTradeCount)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textMuted)
                        }
                        .frame(width: 72)
                    }
                    .buttonStyle(.plain)
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

// MARK: - Whale Trades Timeline Section
struct WhaleTradesTimelineSection: View {
    let groupedTrades: [GroupedWhaleTrades]
    var onActivityTapped: ((WhaleTradeGroupActivity) -> Void)?
    var onMoreTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Section Header with "more" button
            HStack {
                Text("Recent Trades")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button {
                    onMoreTapped?()
                } label: {
                    Text("more")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
                .buttonStyle(.plain)
            }
            .padding(.horizontal, AppSpacing.lg)
            .padding(.bottom, AppSpacing.md)

            // Timeline
            VStack(spacing: 0) {
                ForEach(Array(groupedTrades.enumerated()), id: \.element.id) { groupIndex, group in
                    ForEach(Array(group.activities.enumerated()), id: \.element.id) { activityIndex, activity in
                        let isFirst = groupIndex == 0 && activityIndex == 0
                        let isLast = groupIndex == groupedTrades.count - 1
                            && activityIndex == group.activities.count - 1

                        WhaleTradeTimelineRow(
                            activity: activity,
                            isFirst: isFirst,
                            isLast: isLast,
                            onTapped: { onActivityTapped?(activity) }
                        )
                        .padding(.horizontal, AppSpacing.lg)
                    }
                }
            }
        }
    }
}

// MARK: - Whale Trade Timeline Row
struct WhaleTradeTimelineRow: View {
    let activity: WhaleTradeGroupActivity
    let isFirst: Bool
    let isLast: Bool
    var onTapped: (() -> Void)?

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            // Timeline Column
            ZStack(alignment: .top) {
                // Background connector line (full height)
                if !isLast {
                    VStack(spacing: 0) {
                        Spacer()
                            .frame(height: 4) // Half of dot size to start from center
                        Rectangle()
                            .fill(AppColors.textMuted.opacity(0.3))
                            .frame(width: 1)
                    }
                }
                
                // Dot on top
                VStack(spacing: 0) {
                    if !isFirst {
                        Spacer()
                            .frame(height: 0)
                    }
                    TimelineDot()
                    Spacer()
                }
            }
            .frame(width: 20)

            // Content Column
            VStack(alignment: .leading, spacing: AppSpacing.sm) {
                // Date label
                Text(activity.formattedDate)
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)

                // Trade Card
                WhaleTradeCard(activity: activity, onTapped: onTapped)
            }
            .padding(.bottom, AppSpacing.md)
        }
    }
}

// MARK: - Whale Trade Card
struct WhaleTradeCard: View {
    let activity: WhaleTradeGroupActivity
    var onTapped: (() -> Void)?

    var body: some View {
        Button {
            onTapped?()
        } label: {
            HStack(spacing: AppSpacing.md) {
                // Avatar
                Circle()
                    .fill(AppColors.cardBackgroundLight)
                    .frame(width: 48, height: 48)
                    .overlay(
                        Image(systemName: "person.fill")
                            .font(.system(size: 22))
                            .foregroundColor(AppColors.textMuted)
                    )

                // Info
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    HStack {
                        // Name and trade count
                        VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                            Text(activity.entityName)
                                .font(AppTypography.bodyBold)
                                .foregroundColor(AppColors.textPrimary)

                            Text(activity.formattedTradeCount)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textSecondary)
                        }

                        Spacer()

                        // Amount + Action badge
                        VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                            Text(activity.formattedAmount)
                                .font(AppTypography.calloutBold)
                                .foregroundColor(activity.action.color)

                            Text(activity.action.rawValue)
                                .font(.system(size: 10, weight: .bold))
                                .foregroundColor(activity.action.color)
                        }
                    }

                    // Summary (if available)
                    if let summary = activity.summary {
                        Text(summary)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textSecondary)
                            .lineLimit(2)
                    }
                }

                // Chevron
                Image(systemName: "chevron.right")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(AppColors.textMuted)
            }
            .padding(AppSpacing.lg)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Whale Alert Banner Card
struct WhaleAlertBannerCard: View {
    let alert: WhaleAlertBanner
    var onViewAlert: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            HStack(spacing: AppSpacing.md) {
                // Bell icon
                Circle()
                    .fill(AppColors.alertOrange.opacity(0.2))
                    .frame(width: 44, height: 44)
                    .overlay(
                        Image(systemName: "bell.fill")
                            .font(.system(size: 20))
                            .foregroundColor(AppColors.alertOrange)
                    )

                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text(alert.title)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text(alert.description)
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.textSecondary)
                        .lineLimit(2)
                }
            }

            // View Full Alert button
            Button {
                onViewAlert?()
            } label: {
                Text(alert.actionTitle)
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.alertOrange)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, AppSpacing.sm)
                    .background(
                        RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                            .stroke(AppColors.alertOrange.opacity(0.5), lineWidth: 1)
                    )
            }
            .buttonStyle(.plain)
        }
        .padding(AppSpacing.lg)
        .background(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .fill(AppColors.cardBackground)
                .overlay(
                    RoundedRectangle(cornerRadius: AppCornerRadius.large)
                        .stroke(AppColors.alertOrange.opacity(0.3), lineWidth: 1)
                )
        )
    }
}

// MARK: - Most Popular Whales Section
struct MostPopularWhalesSection: View {
    let heroWhales: [TrendingWhale]
    let whales: [TrendingWhale]
    var onFollowToggle: ((TrendingWhale) -> Void)?
    var onWhaleTapped: ((TrendingWhale) -> Void)?
    var onMoreTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.lg) {
            // Header with "more" button
            HStack {
                Text("Most Popular")
                    .font(AppTypography.title3)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button {
                    onMoreTapped?()
                } label: {
                    Text("more")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
                .buttonStyle(.plain)
            }
            .padding(.horizontal, AppSpacing.lg)

            // Hero Carousel
            if !heroWhales.isEmpty {
                WhaleHeroCarousel(
                    whales: heroWhales,
                    onWhaleTapped: onWhaleTapped
                )
            }

            // List below hero
            VStack(spacing: AppSpacing.md) {
                ForEach(whales) { whale in
                    WhaleCard(
                        whale: whale,
                        onFollowToggle: { onFollowToggle?(whale) },
                        onTap: { onWhaleTapped?(whale) }
                    )
                }
            }
            .padding(.horizontal, AppSpacing.lg)
        }
    }
}

// MARK: - Whale Hero Carousel
struct WhaleHeroCarousel: View {
    let whales: [TrendingWhale]
    var onWhaleTapped: ((TrendingWhale) -> Void)?
    @State private var currentIndex: Int = 0

    var body: some View {
        VStack(spacing: AppSpacing.md) {
            TabView(selection: $currentIndex) {
                ForEach(Array(whales.enumerated()), id: \.element.id) { index, whale in
                    WhaleHeroCard(whale: whale) {
                        onWhaleTapped?(whale)
                    }
                    .tag(index)
                }
            }
            .tabViewStyle(.page(indexDisplayMode: .never))
            .frame(height: 200)

            // Page indicators
            HStack(spacing: AppSpacing.sm) {
                ForEach(0..<whales.count, id: \.self) { index in
                    Circle()
                        .fill(currentIndex == index ? AppColors.primaryBlue : AppColors.textMuted.opacity(0.4))
                        .frame(width: 7, height: 7)
                        .animation(.easeInOut(duration: 0.2), value: currentIndex)
                }
            }
        }
    }
}

// MARK: - Whale Hero Card
struct WhaleHeroCard: View {
    let whale: TrendingWhale
    var onTap: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            ZStack(alignment: .bottomLeading) {
                // Background gradient
                LinearGradient(
                    colors: [
                        AppColors.primaryBlue.opacity(0.6),
                        AppColors.cardBackground
                    ],
                    startPoint: .topTrailing,
                    endPoint: .bottomLeading
                )

                // Content
                HStack(spacing: AppSpacing.lg) {
                    // Left side - text info
                    VStack(alignment: .leading, spacing: AppSpacing.sm) {
                        Spacer()

                        Text(whale.name)
                            .font(AppTypography.title2)
                            .foregroundColor(AppColors.textPrimary)

                        if !whale.title.isEmpty {
                            Text(whale.title)
                                .font(AppTypography.callout)
                                .foregroundColor(AppColors.accentCyan)
                        }

                        if !whale.description.isEmpty {
                            Text(whale.description)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textSecondary)
                                .lineLimit(2)
                        }

                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "person.2.fill")
                                .font(.system(size: 11))
                                .foregroundColor(AppColors.textMuted)

                            Text(whale.formattedFollowers)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textMuted)
                        }
                        .padding(.top, AppSpacing.xs)
                    }
                    .padding(AppSpacing.lg)

                    Spacer()

                    // Right side - avatar
                    VStack {
                        Spacer()
                        Circle()
                            .fill(AppColors.cardBackgroundLight)
                            .frame(width: 80, height: 80)
                            .overlay(
                                Image(systemName: "person.fill")
                                    .font(.system(size: 36))
                                    .foregroundColor(AppColors.textMuted)
                            )
                            .shadow(color: Color.black.opacity(0.3), radius: 8, x: 0, y: 4)
                        Spacer()
                    }
                    .padding(.trailing, AppSpacing.xl)
                }
            }
            .cornerRadius(AppCornerRadius.extraLarge)
            .padding(.horizontal, AppSpacing.lg)
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Whale Card
struct WhaleCard: View {
    let whale: TrendingWhale
    var onFollowToggle: (() -> Void)?
    var onTap: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            HStack(spacing: AppSpacing.md) {
                // Avatar
                Circle()
                    .fill(AppColors.cardBackgroundLight)
                    .frame(width: 44, height: 44)
                    .overlay(
                        Image(systemName: "person.fill")
                            .font(.system(size: 20))
                            .foregroundColor(AppColors.textMuted)
                    )

                // Info
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text(whale.name)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text(whale.formattedFollowers)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                // Follow Button
                Button {
                    onFollowToggle?()
                } label: {
                    Text(whale.isFollowing ? "Following" : "Follow")
                        .font(AppTypography.calloutBold)
                        .foregroundColor(whale.isFollowing ? AppColors.textSecondary : .white)
                        .padding(.horizontal, AppSpacing.lg)
                        .padding(.vertical, AppSpacing.sm)
                        .background(whale.isFollowing ? AppColors.cardBackgroundLight : AppColors.primaryBlue)
                        .cornerRadius(AppCornerRadius.pill)
                }
                .buttonStyle(.plain)
            }
            .padding(AppSpacing.lg)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Add Asset Sheet
struct AddAssetSheet: View {
    @State private var searchText = ""
    var onDismiss: (() -> Void)?

    var body: some View {
        NavigationView {
            ZStack {
                AppColors.background
                    .ignoresSafeArea()

                VStack(spacing: AppSpacing.lg) {
                    SearchBar(
                        text: $searchText,
                        placeholder: "Search ticker symbol..."
                    )
                    .padding(.horizontal, AppSpacing.lg)

                    // Search Results (placeholder)
                    if searchText.isEmpty {
                        VStack(spacing: AppSpacing.md) {
                            Image(systemName: "magnifyingglass")
                                .font(.system(size: 48))
                                .foregroundColor(AppColors.textMuted)

                            Text("Search for a stock to add to your watchlist")
                                .font(AppTypography.body)
                                .foregroundColor(AppColors.textSecondary)
                                .multilineTextAlignment(.center)
                        }
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                    } else {
                        // Results would go here
                        Text("Searching for \"\(searchText)\"...")
                            .foregroundColor(AppColors.textSecondary)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                    }

                    Spacer()
                }
                .padding(.top, AppSpacing.lg)
            }
            .navigationTitle("Add Asset")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        onDismiss?()
                    }
                }
            }
        }
        .presentationDetents([.medium, .large])
    }
}

// MARK: - Sort Options Sheet
struct SortOptionsSheet: View {
    let selectedOption: AssetSortOption
    var onSelect: ((AssetSortOption) -> Void)?
    var onDismiss: (() -> Void)?

    var body: some View {
        NavigationView {
            List {
                ForEach(AssetSortOption.allCases, id: \.self) { option in
                    Button {
                        onSelect?(option)
                    } label: {
                        HStack {
                            Text(option.displayName)
                                .font(AppTypography.body)
                                .foregroundColor(AppColors.textPrimary)

                            Spacer()

                            if selectedOption == option {
                                Image(systemName: "checkmark")
                                    .foregroundColor(AppColors.primaryBlue)
                            }
                        }
                    }
                }
            }
            .listStyle(InsetGroupedListStyle())
            .navigationTitle("Sort By")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") {
                        onDismiss?()
                    }
                    .fontWeight(.semibold)
                }
            }
        }
        .presentationDetents([.medium])
    }
}

// MARK: - Preview
#Preview {
    TrackingContentView()
        .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/TradeGroupDetailView.swift
================================================================================

//
//  TradeGroupDetailView.swift
//  ios
//
//  Detail screen for a whale's trade group batch showing
//  individual trades with filter tabs and insights.
//

import SwiftUI

// MARK: - Trade Group Detail View
struct TradeGroupDetailView: View {
    @StateObject private var viewModel: TradeGroupDetailViewModel
    @Environment(\.dismiss) private var dismiss

    init(tradeGroup: WhaleTradeGroup, whaleName: String) {
        _viewModel = StateObject(wrappedValue: TradeGroupDetailViewModel(
            tradeGroup: tradeGroup,
            whaleName: whaleName
        ))
    }

    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            ScrollView(showsIndicators: false) {
                VStack(spacing: AppSpacing.xl) {
                    // Whale Name
                    Text(viewModel.whaleName)
                        .font(AppTypography.title)
                        .foregroundColor(AppColors.textPrimary)
                        .frame(maxWidth: .infinity)
                        .padding(.top, AppSpacing.lg)

                    // Filter Tabs
                    TradeFilterTabBar(
                        selectedFilter: viewModel.selectedFilter,
                        filterCounts: viewModel.filterCounts,
                        onSelect: { viewModel.selectFilter($0) }
                    )

                    // Insights Card
                    if !viewModel.tradeGroup.insights.isEmpty {
                        TradeGroupInsightsCard(insights: viewModel.tradeGroup.insights)
                    }

                    // Trade Cards
                    VStack(spacing: AppSpacing.md) {
                        ForEach(viewModel.filteredTrades) { trade in
                            TradeDetailCard(
                                trade: trade,
                                onTap: { viewModel.viewTrade(trade) }
                            )
                        }
                    }

                    // Empty state
                    if viewModel.filteredTrades.isEmpty {
                        VStack(spacing: AppSpacing.md) {
                            Image(systemName: "tray")
                                .font(.system(size: 36))
                                .foregroundColor(AppColors.textMuted)

                            Text("No trades in this category")
                                .font(AppTypography.body)
                                .foregroundColor(AppColors.textSecondary)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, AppSpacing.xxl)
                    }

                    Spacer().frame(height: 40)
                }
                .padding(.horizontal, AppSpacing.lg)
            }
        }
        .navigationBarBackButtonHidden(true)
        .toolbar {
            ToolbarItem(placement: .navigationBarLeading) {
                Button {
                    dismiss()
                } label: {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(AppColors.textPrimary)
                }
            }

            ToolbarItem(placement: .principal) {
                Text(viewModel.tradeGroup.formattedDateFull)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
            }
        }
        .navigationDestination(item: $viewModel.selectedTickerSymbol) { ticker in
            TickerDetailView(tickerSymbol: ticker)
        }
    }
}

// MARK: - Filter Tab Bar
struct TradeFilterTabBar: View {
    let selectedFilter: TradeFilterTab
    let filterCounts: [TradeFilterTab: Int]
    var onSelect: ((TradeFilterTab) -> Void)?

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: AppSpacing.sm) {
                ForEach(TradeFilterTab.allCases, id: \.self) { tab in
                    TradeFilterPill(
                        tab: tab,
                        isSelected: selectedFilter == tab,
                        count: filterCounts[tab] ?? 0,
                        onTap: { onSelect?(tab) }
                    )
                }
            }
        }
    }
}

// MARK: - Filter Pill
struct TradeFilterPill: View {
    let tab: TradeFilterTab
    let isSelected: Bool
    let count: Int
    var onTap: (() -> Void)?

    // Hide tabs with zero trades (except "All Trades")
    private var shouldShow: Bool {
        tab == .all || count > 0
    }

    var body: some View {
        if shouldShow {
            Button {
                onTap?()
            } label: {
                HStack(spacing: AppSpacing.xs) {
                    if let iconName = tab.iconName {
                        Image(systemName: iconName)
                            .font(.system(size: 11, weight: .semibold))
                            .foregroundColor(isSelected ? .white : tab.iconColor)
                    }

                    Text(tab.rawValue)
                        .font(AppTypography.captionBold)
                }
                .foregroundColor(isSelected ? .white : AppColors.textSecondary)
                .padding(.horizontal, AppSpacing.md)
                .padding(.vertical, AppSpacing.sm)
                .background(
                    isSelected
                        ? AppColors.primaryBlue
                        : AppColors.cardBackgroundLight
                )
                .cornerRadius(AppCornerRadius.pill)
            }
            .buttonStyle(.plain)
        }
    }
}

// MARK: - Insights Card
struct TradeGroupInsightsCard: View {
    let insights: [String]

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            ForEach(Array(insights.enumerated()), id: \.offset) { _, insight in
                HStack(alignment: .top, spacing: AppSpacing.sm) {
                    Circle()
                        .fill(AppColors.primaryBlue)
                        .frame(width: 6, height: 6)
                        .padding(.top, 6)

                    Text(insight)
                        .font(AppTypography.body)
                        .foregroundColor(AppColors.textSecondary)
                        .lineSpacing(2)
                }
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

// MARK: - Trade Detail Card
struct TradeDetailCard: View {
    let trade: WhaleTrade
    var onTap: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            HStack(spacing: AppSpacing.md) {
                // Logo placeholder
                TradeTickerLogo(ticker: trade.ticker)

                // Ticker + allocation change
                VStack(alignment: .leading, spacing: AppSpacing.xs) {
                    Text(trade.ticker)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    AllocationChangeText(allocationChange: trade.formattedAllocationChange)
                }

                Spacer()

                // Action badge + amount
                VStack(alignment: .trailing, spacing: AppSpacing.xs) {
                    TradeActionBadge(action: trade.action)

                    Text(trade.formattedAmount)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)
                }
            }
            .padding(AppSpacing.lg)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Allocation Change Text
struct AllocationChangeText: View {
    let allocationChange: String
    
    var body: some View {
        // Parse the allocation change string (e.g., "0% â†’ 1.5%")
        let components = allocationChange.components(separatedBy: "â†’")
        
        if components.count == 2 {
            HStack(spacing: 2) {
                Text(components[0].trimmingCharacters(in: .whitespaces))
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                
                Text("â†’")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
                
                Text(components[1].trimmingCharacters(in: .whitespaces))
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textPrimary)
            }
        } else {
            // Fallback if format doesn't match
            Text(allocationChange)
                .font(AppTypography.caption)
                .foregroundColor(AppColors.textMuted)
        }
    }
}

// MARK: - Trade Ticker Logo
struct TradeTickerLogo: View {
    let ticker: String

    private var backgroundColor: Color {
        let colors: [Color] = [
            AppColors.primaryBlue,
            AppColors.bullish,
            AppColors.alertOrange,
            AppColors.alertPurple,
            AppColors.accentCyan
        ]
        let index = abs(ticker.hashValue) % colors.count
        return colors[index]
    }

    var body: some View {
        RoundedRectangle(cornerRadius: AppCornerRadius.medium)
            .fill(backgroundColor.opacity(0.15))
            .frame(width: 48, height: 48)
            .overlay(
                Text("Logo")
                    .font(.system(size: 11, weight: .medium))
                    .foregroundColor(AppColors.textMuted)
            )
    }
}

// MARK: - Trade Action Badge
struct TradeActionBadge: View {
    let action: WhaleTradeAction

    var body: some View {
        Text(action.rawValue)
            .font(.system(size: 11, weight: .bold))
            .foregroundColor(.white)
            .padding(.horizontal, AppSpacing.md)
            .padding(.vertical, AppSpacing.xs)
            .background(action.color)
            .cornerRadius(AppCornerRadius.small)
    }
}

// MARK: - Preview
#Preview {
    NavigationStack {
        TradeGroupDetailView(
            tradeGroup: WhaleProfile.warrenBuffett.recentTradeGroups.first!,
            whaleName: "Warren Buffett")
    
    }
 
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/UpdatesView.swift
================================================================================

//
//  UpdatesView.swift
//  ios
//
//  Main Updates/News screen combining all organisms
//

import SwiftUI

struct UpdatesView: View {
    @StateObject private var viewModel = UpdatesViewModel()
    @Binding var selectedTab: HomeTab
    @State private var showManageAssetsSheet = false
    @State private var selectedNewsArticle: NewsArticle?

    var body: some View {
        NavigationStack {
            ZStack(alignment: .bottom) {
                // Background
                AppColors.background
                    .ignoresSafeArea()

                // Main Content
                VStack(spacing: 0) {
                    // Header
                    UpdatesHeader(
                        onProfileTapped: handleProfileTapped
                    )

                    // Tab Bar with tickers
                    UpdatesTabBar(
                        tabs: viewModel.filterTabs,
                        selectedTab: $viewModel.selectedTab,
                        onManageAssets: handleManageAssets
                    )

                    // Static "Live News" Header (non-scrolling, stays at top)
                    LiveNewsHeader(onFilterTapped: handleFilterTapped)

                    // Scrollable Content with sticky section headers
                    ScrollView(showsIndicators: false) {
                        // Insights Summary Card (scrollable)
                        if let summary = viewModel.insightSummary {
                            InsightsSummaryCard(summary: summary)
                                .padding(.horizontal, AppSpacing.lg)
                                .padding(.vertical, AppSpacing.sm)
                        }

                        LiveNewsTimeline(
                            groupedNews: viewModel.groupedNews,
                            onArticleTapped: handleArticleTapped
                        )

                        // Bottom spacing for tab bar
                        Spacer()
                            .frame(height: 100)
                    }
                    .refreshable {
                        await viewModel.refresh()
                    }

                    // Tab Bar
                    CustomTabBar(selectedTab: $selectedTab)
                }

                // Loading overlay
                if viewModel.isLoading {
                    LoadingOverlay()
                }
            }
            .navigationBarHidden(true)
            .navigationDestination(item: $selectedNewsArticle) { article in
                NewsDetailView(article: article)
            }
            .onChange(of: viewModel.selectedTab) { oldValue, newValue in
                if let newTab = newValue {
                    viewModel.selectTab(newTab)
                }
            }
            .sheet(isPresented: $viewModel.showFilterSheet) {
                NewsFilterSheet(
                    filterOptions: $viewModel.filterOptions,
                    onApply: {
                        viewModel.showFilterSheet = false
                    }
                )
            }
            .sheet(isPresented: $showManageAssetsSheet) {
                ManageAssetsSheet(
                    tickers: viewModel.filterTabs.filter { !$0.isMarketTab },
                    onDismiss: { showManageAssetsSheet = false }
                )
            }
        }
    }

    // MARK: - Action Handlers
    private func handleProfileTapped() {
        print("Profile tapped")
    }

    private func handleAddTicker() {
        print("Add ticker tapped")
    }

    private func handleManageAssets() {
        showManageAssetsSheet = true
    }

    private func handleFilterTapped() {
        viewModel.openFilterOptions()
    }

    private func handleArticleTapped(_ article: NewsArticle) {
        selectedNewsArticle = article
    }
}

// MARK: - Manage Assets Sheet
struct ManageAssetsSheet: View {
    let tickers: [NewsFilterTab]
    var onDismiss: (() -> Void)?

    var body: some View {
        NavigationView {
            List {
                Section("Your Tickers") {
                    ForEach(tickers) { ticker in
                        HStack {
                            Text(ticker.title)
                                .font(AppTypography.body)
                                .foregroundColor(AppColors.textPrimary)

                            Spacer()

                            if let change = ticker.formattedChange {
                                Text(change)
                                    .font(AppTypography.callout)
                                    .foregroundColor(ticker.isPositive ? AppColors.bullish : AppColors.bearish)
                            }
                        }
                    }
                    .onDelete { _ in
                        // Handle delete
                        print("Delete ticker")
                    }
                }

                Section {
                    Text("Swipe left to remove a ticker from your watchlist.")
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textMuted)
                }
            }
            .listStyle(InsetGroupedListStyle())
            .navigationTitle("Manage Assets")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") {
                        onDismiss?()
                    }
                    .fontWeight(.semibold)
                }
            }
        }
        .presentationDetents([.medium])
    }
}

// MARK: - News Filter Sheet
struct NewsFilterSheet: View {
    @Binding var filterOptions: NewsFilterOptions
    var onApply: (() -> Void)?

    @State private var selectedSources: Set<String> = []
    @State private var selectedSentiments: Set<NewsSentiment> = []

    private let availableSources = ["Reuters", "CNBC", "Bloomberg", "WSJ", "Zacks", "MarketWatch"]

    var body: some View {
        NavigationView {
            List {
                // Sources Section
                Section("Sources") {
                    ForEach(availableSources, id: \.self) { source in
                        HStack {
                            Text(source)
                                .font(AppTypography.body)
                                .foregroundColor(AppColors.textPrimary)

                            Spacer()

                            if selectedSources.contains(source) {
                                Image(systemName: "checkmark")
                                    .foregroundColor(AppColors.primaryBlue)
                            }
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            if selectedSources.contains(source) {
                                selectedSources.remove(source)
                            } else {
                                selectedSources.insert(source)
                            }
                        }
                    }
                }

                // Sentiment Section
                Section("Sentiment") {
                    ForEach(NewsSentiment.allCases, id: \.self) { sentiment in
                        HStack {
                            Text(sentiment.displayName)
                                .font(AppTypography.body)
                                .foregroundColor(AppColors.textPrimary)

                            Spacer()

                            if selectedSentiments.contains(sentiment) {
                                Image(systemName: "checkmark")
                                    .foregroundColor(AppColors.primaryBlue)
                            }
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            if selectedSentiments.contains(sentiment) {
                                selectedSentiments.remove(sentiment)
                            } else {
                                selectedSentiments.insert(sentiment)
                            }
                        }
                    }
                }

                // Reset Section
                Section {
                    Button("Reset Filters") {
                        selectedSources.removeAll()
                        selectedSentiments.removeAll()
                    }
                    .foregroundColor(AppColors.bearish)
                }
            }
            .listStyle(InsetGroupedListStyle())
            .navigationTitle("Filters")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        onApply?()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Apply") {
                        filterOptions.sources = Array(selectedSources)
                        filterOptions.sentiments = Array(selectedSentiments)
                        onApply?()
                    }
                    .fontWeight(.semibold)
                }
            }
        }
        .presentationDetents([.medium, .large])
        .onAppear {
            selectedSources = Set(filterOptions.sources)
            selectedSentiments = Set(filterOptions.sentiments)
        }
    }
}

// MARK: - Standalone Preview
struct UpdatesViewStandalone: View {
    @State private var selectedTab: HomeTab = .updates

    var body: some View {
        UpdatesView(selectedTab: $selectedTab)
    }
}

#Preview {
    UpdatesViewStandalone()
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/WhaleProfileView.swift
================================================================================

//
//  WhaleProfileView.swift
//  ios
//
//  Whale Profile screen showing detailed investor information,
//  holdings, trades, and sentiment analysis.
//

import SwiftUI

// MARK: - Whale Profile View
struct WhaleProfileView: View {
    @StateObject private var viewModel: WhaleProfileViewModel
    @Environment(\.dismiss) private var dismiss

    init(whaleId: String) {
        _viewModel = StateObject(wrappedValue: WhaleProfileViewModel(whaleId: whaleId))
    }

    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            if viewModel.isLoading {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle(tint: AppColors.primaryBlue))
                    .scaleEffect(1.2)
            } else if let profile = viewModel.profile {
                ScrollView(showsIndicators: false) {
                    LazyVStack(spacing: AppSpacing.xl) {
                        // Profile Header
                        WhaleProfileHeader(
                            profile: profile,
                            onFollowToggle: { viewModel.toggleFollow() }
                        )

                        // Portfolio Stats
                        WhalePortfolioStats(profile: profile)

                        // Sector Exposure
                        WhaleSectorExposureSection(sectors: profile.sectorExposure)

                        // Current Picks
                        WhaleCurrentPicksSection(
                            holdings: viewModel.displayedHoldings,
                            behaviorSummary: profile.behaviorSummary,
                            onHoldingTapped: { viewModel.viewHolding($0) },
                            onTopTenTapped: { viewModel.viewMoreHoldings() }
                        )

                        // Recent Trades
                        WhaleRecentTradesSection(
                            tradeGroups: viewModel.displayedTradeGroups,
                            onTradeGroupTapped: { viewModel.viewTradeGroup($0) },
                            onInfoTapped: { viewModel.showRecentTradesInfo = true }
                        )

                        // Sentiment Summary
                        WhaleSentimentSummary(summary: profile.sentimentSummary)

                        // Pro Upgrade Footer
                        WhaleProUpgradeFooter()

                        // Bottom spacing
                        Spacer().frame(height: 40)
                    }
                    .padding(.horizontal, AppSpacing.lg)
                }
                .refreshable {
                    await viewModel.refresh()
                }
            }
        }
        .navigationBarBackButtonHidden(true)
        .toolbar {
            ToolbarItem(placement: .navigationBarLeading) {
                Button {
                    dismiss()
                } label: {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(AppColors.textPrimary)
                }
            }

            ToolbarItem(placement: .navigationBarTrailing) {
                if let profile = viewModel.profile {
                    Button {
                        viewModel.toggleFollow()
                    } label: {
                        Text(profile.isFollowing ? "Following" : "Follow")
                            .font(.system(size: 15, weight: .semibold))
                            .foregroundColor(AppColors.primaryBlue)
                    }
                }
            }
        }
        .navigationDestination(item: $viewModel.selectedTickerSymbol) { ticker in
            TickerDetailView(tickerSymbol: ticker)
        }
        .navigationDestination(item: $viewModel.selectedTradeGroupId) { groupId in
            if let group = viewModel.tradeGroup(for: groupId) {
                TradeGroupDetailView(
                    tradeGroup: group,
                    whaleName: viewModel.profile?.name ?? ""
                )
            }
        }
    }
}

// MARK: - Profile Header
struct WhaleProfileHeader: View {
    let profile: WhaleProfile
    var onFollowToggle: (() -> Void)?

    var body: some View {
        VStack(spacing: AppSpacing.lg) {
            // Avatar
            WhaleAvatarView(
                avatarURL: profile.avatarURL,
                size: 80
            )

            // Name and Title
            VStack(spacing: AppSpacing.xs) {
                Text(profile.name)
                    .font(AppTypography.title)
                    .foregroundColor(AppColors.textPrimary)

                Text(profile.title)
                    .font(AppTypography.callout)
                    .foregroundColor(AppColors.textSecondary)
            }

            // Risk Profile Badge
            WhaleRiskBadge(riskProfile: profile.riskProfile)

            // Description
            WhaleDescriptionSection(description: profile.description)
        }
        .padding(.top, AppSpacing.md)
    }
}

// MARK: - Whale Avatar View
struct WhaleAvatarView: View {
    let avatarURL: String?
    let size: CGFloat

    var body: some View {
        if let url = avatarURL, let imageURL = URL(string: url) {
            AsyncImage(url: imageURL) { phase in
                switch phase {
                case .success(let image):
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: size, height: size)
                        .clipShape(Circle())
                case .failure, .empty:
                    placeholderAvatar
                @unknown default:
                    placeholderAvatar
                }
            }
        } else {
            placeholderAvatar
        }
    }

    private var placeholderAvatar: some View {
        Circle()
            .fill(
                LinearGradient(
                    colors: [AppColors.cardBackgroundLight, AppColors.cardBackground],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .frame(width: size, height: size)
            .overlay(
                Image(systemName: "person.fill")
                    .font(.system(size: size * 0.4))
                    .foregroundColor(AppColors.textMuted)
            )
    }
}

// MARK: - Risk Badge
struct WhaleRiskBadge: View {
    let riskProfile: WhaleRiskProfile

    var body: some View {
        HStack(spacing: AppSpacing.sm) {
            Image(systemName: riskProfile.iconName)
                .font(.system(size: 12, weight: .medium))

            Text(riskProfile.rawValue)
                .font(AppTypography.captionBold)
        }
        .foregroundColor(riskProfile.color)
        .padding(.horizontal, AppSpacing.md)
        .padding(.vertical, AppSpacing.sm)
        .background(riskProfile.color.opacity(0.15))
        .cornerRadius(AppCornerRadius.pill)
    }
}

// MARK: - Description Section
struct WhaleDescriptionSection: View {
    let description: String
    @State private var isExpanded: Bool = false
    
    private let lineLimit: Int = 3
    
    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            Text(description)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(4)
                .lineLimit(isExpanded ? nil : lineLimit)
                .animation(.easeInOut(duration: 0.2), value: isExpanded)
            
            Button {
                withAnimation(.easeInOut(duration: 0.2)) {
                    isExpanded.toggle()
                }
            } label: {
                Text(isExpanded ? "Show Less" : "Show More")
                    .font(AppTypography.calloutBold)
                    .foregroundColor(AppColors.primaryBlue)
            }
            .buttonStyle(.plain)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(.horizontal, AppSpacing.lg)
        .padding(.top, AppSpacing.md)
    }
}

// MARK: - Portfolio Stats
struct WhalePortfolioStats: View {
    let profile: WhaleProfile

    var body: some View {
        HStack {
            // Portfolio Value
            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                Text(profile.formattedPortfolioValue)
                    .font(.system(size: 28, weight: .bold))
                    .foregroundColor(AppColors.textPrimary)

                Text("Portfolio Value")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }

            Spacer()

            // Annual Return
            VStack(alignment: .trailing, spacing: AppSpacing.xs) {
                Text(profile.formattedYTDReturn)
                    .font(.system(size: 28, weight: .bold))
                    .foregroundColor(profile.isPositiveReturn ? AppColors.bullish : AppColors.bearish)

                Text("Annual Return")
                    .font(AppTypography.caption)
                    .foregroundColor(AppColors.textMuted)
            }
        }
        .padding(AppSpacing.lg)
    }
}

// MARK: - Sector Exposure Section
struct WhaleSectorExposureSection: View {
    let sectors: [WhaleSectorAllocation]
    @State private var showInfoSheet: Bool = false

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            HStack {
                Text("Sector Exposure")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button {
                    showInfoSheet = true
                } label: {
                    Image(systemName: "info.circle")
                        .font(.system(size: 16))
                        .foregroundColor(AppColors.textMuted)
                }
                .buttonStyle(.plain)
            }

            DonutChartView(
                segments: sectors.map { sector in
                    DonutChartSegment(
                        id: sector.id,
                        value: sector.percentage,
                        color: sector.color,
                        label: sector.name
                    )
                },
                lineWidth: 20
            )
            .padding(.vertical, AppSpacing.sm)
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
        .sheet(isPresented: $showInfoSheet) {
            SectorExposureInfoSheet()
                .presentationDetents([.medium])
                .presentationDragIndicator(.visible)
        }
    }
}

// MARK: - Sector Exposure Info Sheet
struct SectorExposureInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xl) {
                    // What is Sector Exposure
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "chart.pie.fill")
                                .font(.system(size: 20))
                                .foregroundColor(AppColors.primaryBlue)

                            Text("What is Sector Exposure?")
                                .font(AppTypography.title3)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        Text("Sector exposure shows how an investor's portfolio is distributed across different market sectors. It reveals their investment strategy and risk preferences.")
                            .font(AppTypography.body)
                            .foregroundColor(AppColors.textSecondary)
                            .lineSpacing(4)
                    }

                    Divider()
                        .background(AppColors.cardBackgroundLight)

                    // Why it Matters
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "lightbulb.fill")
                                .font(.system(size: 20))
                                .foregroundColor(AppColors.alertOrange)

                            Text("Why It Matters")
                                .font(AppTypography.title3)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        VStack(alignment: .leading, spacing: AppSpacing.md) {
                            WhaleBulletPoint(
                                icon: "target",
                                text: "Understand the investor's focus areas and conviction sectors"
                            )
                            WhaleBulletPoint(
                                icon: "arrow.triangle.branch",
                                text: "See how diversified or concentrated their portfolio is"
                            )
                            WhaleBulletPoint(
                                icon: "chart.line.uptrend.xyaxis",
                                text: "Track shifts in sector allocation over time"
                            )
                            WhaleBulletPoint(
                                icon: "exclamationmark.triangle",
                                text: "Identify potential risks from sector concentration"
                            )
                        }
                    }

                    Divider()
                        .background(AppColors.cardBackgroundLight)

                    // How to Use
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "hand.tap.fill")
                                .font(.system(size: 20))
                                .foregroundColor(AppColors.bullish)

                            Text("How to Use This")
                                .font(AppTypography.title3)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        Text("Compare the whale's sector exposure to your own portfolio. If you want to follow their strategy, consider similar sector weightings. Use this to identify sectors they're bullish on.")
                            .font(AppTypography.body)
                            .foregroundColor(AppColors.textSecondary)
                            .lineSpacing(4)
                    }

                    Spacer().frame(height: AppSpacing.xl)
                }
                .padding(AppSpacing.xl)
            }
            .background(AppColors.background)
            .navigationTitle("Sector Exposure")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
    }
}

// MARK: - Recent Trades Info Sheet
struct RecentTradesInfoSheet: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: AppSpacing.xl) {
                    // What are Recent Trades
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "arrow.left.arrow.right")
                                .font(.system(size: 20))
                                .foregroundColor(AppColors.primaryBlue)

                            Text("What are Recent Trades?")
                                .font(AppTypography.title3)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        VStack(alignment: .leading, spacing: AppSpacing.md) {
                            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                                Text("The Definition:")
                                    .font(AppTypography.bodyBold)
                                    .foregroundColor(AppColors.textPrimary)
                                
                                Text("\"Recent Trades\" captures the latest buy and sell transactions disclosed by institutional investors (Whales) or politicians.")
                                    .font(AppTypography.body)
                                    .foregroundColor(AppColors.textSecondary)
                                    .lineSpacing(4)
                            }
                            
                            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                                Text("The Data Source:")
                                    .font(AppTypography.bodyBold)
                                    .foregroundColor(AppColors.textPrimary)
                                
                                Text("This information is sourced from mandatory legal filings, such as SEC 13F Filings (for hedge funds) and Congressional Disclosures (for politicians).")
                                    .font(AppTypography.body)
                                    .foregroundColor(AppColors.textSecondary)
                                    .lineSpacing(4)
                            }
                            
                            VStack(alignment: .leading, spacing: AppSpacing.xs) {
                                Text("The \"Lag\" Factor:")
                                    .font(AppTypography.bodyBold)
                                    .foregroundColor(AppColors.textPrimary)
                                
                                Text("Note that these trades are often reported with a delay (e.g., 45 days for 13F filings), meaning they represent a snapshot of past activity rather than real-time moves.")
                                    .font(AppTypography.body)
                                    .foregroundColor(AppColors.textSecondary)
                                    .lineSpacing(4)
                            }
                        }
                    }

                    Divider()
                        .background(AppColors.cardBackgroundLight)

                    // Why it Matters
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "lightbulb.fill")
                                .font(.system(size: 20))
                                .foregroundColor(AppColors.alertOrange)

                            Text("Why It Matters")
                                .font(AppTypography.title3)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        VStack(alignment: .leading, spacing: AppSpacing.md) {
                            WhaleBulletPoint(
                                icon: "chart.line.uptrend.xyaxis",
                                text: "Identify emerging trends and conviction changes"
                            )
                            WhaleBulletPoint(
                                icon: "sparkles",
                                text: "Discover new opportunities they're exploring"
                            )
                            WhaleBulletPoint(
                                icon: "exclamationmark.triangle",
                                text: "Spot positions they're reducing or exiting"
                            )
                        }
                    }

                    Divider()
                        .background(AppColors.cardBackgroundLight)

                    // How to Use
                    VStack(alignment: .leading, spacing: AppSpacing.md) {
                        HStack(spacing: AppSpacing.sm) {
                            Image(systemName: "hand.tap.fill")
                                .font(.system(size: 20))
                                .foregroundColor(AppColors.bullish)

                            Text("How to Use This")
                                .font(AppTypography.title3)
                                .foregroundColor(AppColors.textPrimary)
                        }

                        Text("Pay attention to the size and direction of trades. Large buys signal high conviction, while sells may indicate risk concerns or profit-taking. Tap on any trade group to see detailed transaction information.")
                            .font(AppTypography.body)
                            .foregroundColor(AppColors.textSecondary)
                            .lineSpacing(4)
                    }

                    Spacer().frame(height: AppSpacing.xl)
                }
                .padding(AppSpacing.xl)
            }
            .background(AppColors.background)
            .navigationTitle("Recent Trades")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.primaryBlue)
                }
            }
        }
    }
}

// MARK: - Whale Bullet Point
struct WhaleBulletPoint: View {
    let icon: String
    let text: String

    var body: some View {
        HStack(alignment: .top, spacing: AppSpacing.md) {
            Image(systemName: icon)
                .font(.system(size: 14))
                .foregroundColor(AppColors.primaryBlue)
                .frame(width: 20)

            Text(text)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(2)
        }
    }
}

// MARK: - Current Picks Section
struct WhaleCurrentPicksSection: View {
    let holdings: [WhaleHolding]
    let behaviorSummary: WhaleBehaviorSummary
    var onHoldingTapped: ((WhaleHolding) -> Void)?
    var onTopTenTapped: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header
            HStack {
                Text("Current Picks")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button {
                    onTopTenTapped?()
                } label: {
                    Text("Top 10")
                        .font(AppTypography.callout)
                        .foregroundColor(AppColors.primaryBlue)
                }
                .buttonStyle(.plain)
            }

            // Behavior Summary Card
            WhaleBehaviorSummaryCard(behaviorSummary: behaviorSummary)

            // Holdings List
            VStack(spacing: 0) {
                ForEach(holdings) { holding in
                    WhaleHoldingRow(
                        holding: holding,
                        onTap: { onHoldingTapped?(holding) }
                    )

                    if holding.id != holdings.last?.id {
                        Divider()
                            .background(AppColors.cardBackgroundLight)
                    }
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
    }
}

// MARK: - Behavior Summary Card
struct WhaleBehaviorSummaryCard: View {
    let behaviorSummary: WhaleBehaviorSummary

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.sm) {
            Text("Behavior Summary:")
                .font(AppTypography.calloutBold)
                .foregroundColor(AppColors.textSecondary)

            Text(behaviorSummary.formattedSummary)
                .font(AppTypography.body)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(2)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(AppSpacing.lg)
        .background(Color.clear)
        .cornerRadius(AppCornerRadius.medium)
        .overlay(
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .stroke(AppColors.primaryBlue.opacity(0.3), lineWidth: 1)
        )
    }
}

// MARK: - Whale Holding Row
struct WhaleHoldingRow: View {
    let holding: WhaleHolding
    var onTap: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            HStack(spacing: AppSpacing.md) {
                // Logo/Ticker Icon
                WhaleTickerIcon(ticker: holding.ticker)

                // Company Info
                VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                    Text(holding.companyName)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)
                        .lineLimit(1)

                    Text(holding.ticker)
                        .font(AppTypography.caption)
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                // Allocation and Change
                VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                    Text(holding.formattedAllocation)
                        .font(AppTypography.bodyBold)
                        .foregroundColor(AppColors.textPrimary)

                    Text(holding.formattedChange)
                        .font(AppTypography.caption)
                        .foregroundColor(
                            holding.changePercent > 0 ? AppColors.bullish :
                            holding.changePercent < 0 ? AppColors.bearish :
                            AppColors.textMuted
                        )
                }
            }
            .padding(.vertical, AppSpacing.md)
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Whale Ticker Icon
struct WhaleTickerIcon: View {
    let ticker: String

    private var backgroundColor: Color {
        // Generate consistent color based on ticker
        let colors: [Color] = [
            AppColors.primaryBlue,
            AppColors.bullish,
            AppColors.alertOrange,
            AppColors.alertPurple,
            AppColors.accentCyan
        ]
        let index = abs(ticker.hashValue) % colors.count
        return colors[index]
    }

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: AppCornerRadius.medium)
                .fill(backgroundColor.opacity(0.2))
                .frame(width: 40, height: 40)

            Text(String(ticker.prefix(1)))
                .font(.system(size: 16, weight: .bold))
                .foregroundColor(backgroundColor)
        }
    }
}

// MARK: - Recent Trades Section
struct WhaleRecentTradesSection: View {
    let tradeGroups: [WhaleTradeGroup]
    var onTradeGroupTapped: ((WhaleTradeGroup) -> Void)?
    var onInfoTapped: (() -> Void)?
    @State private var showInfoSheet: Bool = false

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            // Header
            HStack {
                Text("Recent Trades")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)

                Spacer()

                Button {
                    showInfoSheet = true
                } label: {
                    Image(systemName: "info.circle")
                        .font(.system(size: 16))
                        .foregroundColor(AppColors.textMuted)
                }
                .buttonStyle(.plain)
            }

            // Trade Groups List
            VStack(spacing: 0) {
                ForEach(tradeGroups) { group in
                    WhaleTradeGroupCard(
                        group: group,
                        onTap: { onTradeGroupTapped?(group) }
                    )

                    if group.id != tradeGroups.last?.id {
                        Divider()
                            .background(AppColors.cardBackgroundLight)
                    }
                }
            }
        }
        .padding(AppSpacing.lg)
        .background(AppColors.cardBackground)
        .cornerRadius(AppCornerRadius.large)
        .sheet(isPresented: $showInfoSheet) {
            RecentTradesInfoSheet()
                .presentationDetents([.medium])
                .presentationDragIndicator(.visible)
        }
    }
}

// MARK: - Whale Trade Group Card
struct WhaleTradeGroupCard: View {
    let group: WhaleTradeGroup
    var onTap: (() -> Void)?

    var body: some View {
        Button {
            onTap?()
        } label: {
            HStack(spacing: 0) {
                // Left content
                VStack(alignment: .leading, spacing: AppSpacing.sm) {
                    // Row 1: Date and trade count (left), Net amount (right)
                    HStack {
                        // Left side: Date and trade count stacked
                        VStack(alignment: .leading, spacing: AppSpacing.xxs) {
                            Text(group.formattedDate)
                                .font(AppTypography.bodyBold)
                                .foregroundColor(AppColors.textSecondary)
                            
                            Text(group.formattedTradeCount)
                                .font(AppTypography.caption)
                                .foregroundColor(AppColors.textSecondary)
                        }

                        Spacer()

                        // Right side: Net amount and action
                        VStack(alignment: .trailing, spacing: AppSpacing.xxs) {
                            Text(group.formattedNetAmount.replacingOccurrences(of: " BOUGHT", with: "").replacingOccurrences(of: " SOLD", with: ""))
                                .font(AppTypography.calloutBold)
                                .foregroundColor(group.netAction == .bought ? AppColors.bullish : AppColors.bearish)
                            
                            Text(group.netAction.rawValue)
                                .font(.system(size: 10, weight: .bold))
                                .foregroundColor(group.netAction == .bought ? AppColors.bullish : AppColors.bearish)
                        }
                    }

                    // Row 2: Optional summary
                    if let summary = group.summary {
                        Text(summary)
                            .font(AppTypography.caption)
                            .foregroundColor(AppColors.textMuted)
                            .lineLimit(2)
                    }
                }

                // Chevron
                Image(systemName: "chevron.right")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(AppColors.textMuted)
                    .padding(.leading, AppSpacing.md)
            }
            .padding(.vertical, AppSpacing.md)
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Sentiment Summary
struct WhaleSentimentSummary: View {
    let summary: String

    var body: some View {
        VStack(alignment: .leading, spacing: AppSpacing.md) {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "brain.head.profile")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(AppColors.primaryBlue)

                Text("Sentiment Summary")
                    .font(AppTypography.headline)
                    .foregroundColor(AppColors.textPrimary)
            }

            Text(summary)
                .font(AppTypography.callout)
                .foregroundColor(AppColors.textSecondary)
                .lineSpacing(4)
        }
        .padding(AppSpacing.lg)
        .background(
            LinearGradient(
                colors: [
                    AppColors.primaryBlue.opacity(0.15),
                    AppColors.primaryBlue.opacity(0.05)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        )
        .cornerRadius(AppCornerRadius.large)
        .overlay(
            RoundedRectangle(cornerRadius: AppCornerRadius.large)
                .stroke(AppColors.primaryBlue.opacity(0.3), lineWidth: 1)
        )
    }
}

// MARK: - Pro Upgrade Footer
struct WhaleProUpgradeFooter: View {
    var body: some View {
        Button {
            // Handle upgrade action
        } label: {
            HStack(spacing: AppSpacing.sm) {
                Image(systemName: "lock.fill")
                    .font(.system(size: 12))

                Text("See All Holdings - Upgrade to Pro")
                    .font(AppTypography.callout)
            }
            .foregroundColor(AppColors.textSecondary)
        }
        .buttonStyle(.plain)
        .padding(.vertical, AppSpacing.lg)
    }
}

// MARK: - Preview
#Preview {
    NavigationStack {
        WhaleProfileView(whaleId: "warren-buffett")
    }
    .preferredColorScheme(.dark)
}

================================================================================
FILE: frontend/ios/ios/Views/Screens/WhaleService.swift
================================================================================

//
//  WhaleService.swift
//  ios
//
//  Shared service for managing whale follow state
//

import Foundation
import Combine

@MainActor
class WhaleService: ObservableObject {
    static let shared = WhaleService()
    
    // Published set of followed whale IDs
    @Published private(set) var followedWhaleIds: Set<String> = []
    
    private init() {
        // Load followed whales from UserDefaults or your data store
        loadFollowedWhales()
    }
    
    // MARK: - Public Methods
    
    func isFollowing(_ whaleId: String) -> Bool {
        followedWhaleIds.contains(whaleId)
    }
    
    func toggleFollow(_ whaleId: String) {
        if followedWhaleIds.contains(whaleId) {
            followedWhaleIds.remove(whaleId)
        } else {
            followedWhaleIds.insert(whaleId)
        }
        saveFollowedWhales()
    }
    
    func follow(_ whaleId: String) {
        followedWhaleIds.insert(whaleId)
        saveFollowedWhales()
    }
    
    func unfollow(_ whaleId: String) {
        followedWhaleIds.remove(whaleId)
        saveFollowedWhales()
    }
    
    // MARK: - Persistence
    
    private func loadFollowedWhales() {
        if let data = UserDefaults.standard.data(forKey: "followedWhaleIds"),
           let ids = try? JSONDecoder().decode(Set<String>.self, from: data) {
            followedWhaleIds = ids
        } else {
            // Initialize with sample followed whales for demo purposes
            followedWhaleIds = ["warren-buffett", "nancy-pelosi", "bill-ackman"]
        }
    }
    
    private func saveFollowedWhales() {
        if let data = try? JSONEncoder().encode(followedWhaleIds) {
            UserDefaults.standard.set(data, forKey: "followedWhaleIds")
        }
    }
}

================================================================================
FILE: frontend/ios/ios/iosApp.swift
================================================================================

//
//  iosApp.swift
//  ios
//
//  Created by Hai Phan on 12/30/25.
//
//  App Entry Point
//
//  This is where we:
//  1. Initialize global AppState
//  2. Configure services (API client, auth)
//  3. Inject state via Environment
//

import SwiftUI

@main
struct iosApp: App {

    // MARK: - Global State

    /// Single source of truth for app-wide state
    /// Injected into all views via .environment()
    @State private var appState = AppState()

    /// Tracks if services have been configured
    @State private var isConfigured = false

    // MARK: - Initialization

    init() {
        // Configure appearance
        configureAppearance()
    }

    // MARK: - Body

    var body: some Scene {
        WindowGroup {
            RootView()
                .environment(appState)
                .preferredColorScheme(.dark)
                .task {
                    guard !isConfigured else { return }
                    isConfigured = true

                    // Get services (APIClient.shared is safe to access in async context)
                    let apiClient = APIClient.shared
                    let authService = AuthService(apiClient: apiClient)

                    // Configure AppState with services
                    appState.configure(
                        apiClient: apiClient,
                        authService: authService
                    )

                    // Restore auth token to API client
                    if let token = authService.getStoredToken() {
                        await apiClient.setAuthToken(token)
                    }
                }
        }
    }

    // MARK: - Appearance Configuration

    private func configureAppearance() {
        // Navigation bar appearance
        let navAppearance = UINavigationBarAppearance()
        navAppearance.configureWithOpaqueBackground()
        navAppearance.backgroundColor = UIColor(AppColors.background)
        navAppearance.titleTextAttributes = [.foregroundColor: UIColor.white]
        navAppearance.largeTitleTextAttributes = [.foregroundColor: UIColor.white]

        UINavigationBar.appearance().standardAppearance = navAppearance
        UINavigationBar.appearance().compactAppearance = navAppearance
        UINavigationBar.appearance().scrollEdgeAppearance = navAppearance
    }
}

// MARK: - Root View

/// Root view that handles auth state and navigation
struct RootView: View {
    @Environment(AppState.self) private var appState

    var body: some View {
        Group {
            switch appState.auth.status {
            case .unknown, .loading:
                // Loading/splash screen
                SplashView()

            case .unauthenticated:
                // For now, go straight to main app (no auth required yet)
                // Later: Show onboarding/login
                RootContainerView()

            case .authenticated:
                RootContainerView()
            }
        }
        .overlay {
            // Global error toast
            if let error = appState.currentError {
                ErrorToastView(error: error) {
                    appState.clearError()
                }
            }
        }
        .overlay {
            // Global toast messages
            if let toast = appState.toastMessage {
                ToastView(message: toast)
            }
        }
    }
}

// MARK: - Splash View

struct SplashView: View {
    var body: some View {
        ZStack {
            AppColors.background
                .ignoresSafeArea()

            VStack(spacing: 20) {
                Image(systemName: "chart.line.uptrend.xyaxis.circle.fill")
                    .font(.system(size: 80))
                    .foregroundColor(AppColors.primaryBlue)

                Text("AI Value Investor")
                    .font(AppTypography.title)
                    .foregroundColor(AppColors.textPrimary)

                ProgressView()
                    .tint(AppColors.primaryBlue)
            }
        }
    }
}

// MARK: - Error Toast View

struct ErrorToastView: View {
    let error: AppError
    let onDismiss: () -> Void

    var body: some View {
        VStack {
            Spacer()

            VStack(alignment: .leading, spacing: 8) {
                HStack {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .foregroundColor(AppColors.bearish)

                    Text(error.title)
                        .font(AppTypography.headline)
                        .foregroundColor(AppColors.textPrimary)

                    Spacer()

                    Button(action: onDismiss) {
                        Image(systemName: "xmark")
                            .foregroundColor(AppColors.textSecondary)
                    }
                }

                Text(error.message)
                    .font(AppTypography.body)
                    .foregroundColor(AppColors.textSecondary)

                if error.suggestedAction != .fixInput {
                    Button(action: onDismiss) {
                        Text(error.suggestedAction.buttonTitle)
                            .font(AppTypography.bodyBold)
                            .foregroundColor(AppColors.primaryBlue)
                    }
                }
            }
            .padding()
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.large)
            .padding(.horizontal)
            .padding(.bottom, 100) // Above tab bar
        }
        .transition(.move(edge: .bottom).combined(with: .opacity))
        .animation(.spring(), value: error.id)
    }
}

// MARK: - Toast View

struct ToastView: View {
    let message: ToastMessage

    var body: some View {
        VStack {
            Spacer()

            HStack {
                Image(systemName: iconName)
                    .foregroundColor(iconColor)

                Text(message.message)
                    .font(AppTypography.body)
                    .foregroundColor(AppColors.textPrimary)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(AppColors.cardBackground)
            .cornerRadius(AppCornerRadius.pill)
            .padding(.bottom, 100)
        }
        .transition(.move(edge: .bottom).combined(with: .opacity))
    }

    private var iconName: String {
        switch message.type {
        case .success: return "checkmark.circle.fill"
        case .error: return "exclamationmark.circle.fill"
        case .info: return "info.circle.fill"
        case .warning: return "exclamationmark.triangle.fill"
        }
    }

    private var iconColor: Color {
        switch message.type {
        case .success: return AppColors.bullish
        case .error: return AppColors.bearish
        case .info: return AppColors.primaryBlue
        case .warning: return AppColors.neutral
        }
    }
}
